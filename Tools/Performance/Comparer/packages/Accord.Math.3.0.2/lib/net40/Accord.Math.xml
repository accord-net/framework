<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Accord.Math</name>
    </assembly>
    <members>
        <member name="T:AForge.Math.ContinuousHistogram">
            <summary>
            Histogram for continuous random values.
            </summary>
            
            <remarks><para>The class wraps histogram for continuous stochastic function, which is represented
            by integer array and range of the function. Values of the integer array are treated
            as total amount of hits on the corresponding subranges, which are calculated by splitting the
            specified range into required amount of consequent ranges.</para>
            
            <para>For example, if the integer array is equal to { 1, 2, 4, 8, 16 } and the range is set
            to [0, 1], then the histogram consists of next subranges:
            <list type="bullet">
            <item>[0.0, 0.2] - 1 hit;</item>
            <item>[0.2, 0.4] - 2 hits;</item>
            <item>[0.4, 0.6] - 4 hits;</item>
            <item>[0.6, 0.8] - 8 hits;</item>
            <item>[0.8, 1.0] - 16 hits.</item>
            </list>
            </para>
            
            <para>Sample usage:</para>
            <code>
            // create histogram
            ContinuousHistogram histogram = new ContinuousHistogram(
                new int[] { 0, 0, 8, 4, 2, 4, 7, 1, 0 }, new Range( 0.0f, 1.0f ) );
            // get mean and standard deviation values
            Console.WriteLine( "mean = " + histogram.Mean + ", std.dev = " + histogram.StdDev );
            </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Math.ContinuousHistogram.#ctor(System.Int32[],AForge.Range)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Math.ContinuousHistogram"/> class.
            </summary>
            
            <param name="values">Values of the histogram.</param>
            <param name="range">Range of random values.</param>
            
            <remarks>Values of the integer array are treated as total amount of hits on the
            corresponding subranges, which are calculated by splitting the specified range into
            required amount of consequent ranges (see <see cref="T:AForge.Math.ContinuousHistogram"/> class
            description for more information).
            </remarks>
            
        </member>
        <member name="M:AForge.Math.ContinuousHistogram.GetRange(System.Single)">
            <summary>
            Get range around median containing specified percentage of values.
            </summary>
            
            <param name="percent">Values percentage around median.</param>
            
            <returns>Returns the range which containes specifies percentage of values.</returns>
            
            <remarks><para>The method calculates range of stochastic variable, which summary probability
            comprises the specified percentage of histogram's hits.</para>
            
            <para>Sample usage:</para>
            <code>
            // create histogram
            ContinuousHistogram histogram = new ContinuousHistogram(
                new int[] { 0, 0, 8, 4, 2, 4, 7, 1, 0 }, new Range( 0.0f, 1.0f ) );
            // get 50% range
            Range range = histogram.GetRange( 0.5f );
            // show the range ([0.25, 0.75])
            Console.WriteLine( "50% range = [" + range.Min + ", " + range.Max + "]" );
            </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Math.ContinuousHistogram.Update">
            <summary>
            Update statistical value of the histogram.
            </summary>
            
            <remarks>The method recalculates statistical values of the histogram, like mean,
            standard deviation, etc. The method should be called only in the case if histogram
            values were retrieved through <see cref="P:AForge.Math.ContinuousHistogram.Values"/> property and updated after that.
            </remarks>
            
        </member>
        <member name="P:AForge.Math.ContinuousHistogram.Values">
            <summary>
            Values of the histogram.
            </summary>
            
        </member>
        <member name="P:AForge.Math.ContinuousHistogram.Range">
            <summary>
            Range of random values.
            </summary>
            
        </member>
        <member name="P:AForge.Math.ContinuousHistogram.Mean">
            <summary>
            Mean value.
            </summary>
            
            <remarks><para>The property allows to retrieve mean value of the histogram.</para>
            
            <para>Sample usage:</para>
            <code>
            // create histogram
            ContinuousHistogram histogram = new ContinuousHistogram(
                new int[] { 0, 0, 8, 4, 2, 4, 7, 1, 0 }, new Range( 0.0f, 1.0f ) );
            // get mean value (= 0.505 )
            Console.WriteLine( "mean = " + histogram.Mean.ToString( "F3" ) );
            </code>
            </remarks>
            
        </member>
        <member name="P:AForge.Math.ContinuousHistogram.StdDev">
            <summary>
            Standard deviation.
            </summary>
            
            <remarks><para>The property allows to retrieve standard deviation value of the histogram.</para>
            
            <para>Sample usage:</para>
            <code>
            // create histogram
            ContinuousHistogram histogram = new ContinuousHistogram(
                new int[] { 0, 0, 8, 4, 2, 4, 7, 1, 0 }, new Range( 0.0f, 1.0f ) );
            // get std.dev. value (= 0.215)
            Console.WriteLine( "std.dev. = " + histogram.StdDev.ToString( "F3" ) );
            </code>
            </remarks>
            
        </member>
        <member name="P:AForge.Math.ContinuousHistogram.Median">
            <summary>
            Median value.
            </summary>
            
            <remarks><para>The property allows to retrieve median value of the histogram.</para>
            
            <para>Sample usage:</para>
            <code>
            // create histogram
            ContinuousHistogram histogram = new ContinuousHistogram(
                new int[] { 0, 0, 8, 4, 2, 4, 7, 1, 0 }, new Range( 0.0f, 1.0f ) );
            // get median value (= 0.500)
            Console.WriteLine( "median = " + histogram.Median.ToString( "F3" ) );
            </code>
            </remarks>
            
        </member>
        <member name="P:AForge.Math.ContinuousHistogram.Min">
            <summary>
            Minimum value.
            </summary>
            
            <remarks><para>The property allows to retrieve minimum value of the histogram with non zero
            hits count.</para>
            
            <para>Sample usage:</para>
            <code>
            // create histogram
            ContinuousHistogram histogram = new ContinuousHistogram(
                new int[] { 0, 0, 8, 4, 2, 4, 7, 1, 0 }, new Range( 0.0f, 1.0f ) );
            // get min value (= 0.250)
            Console.WriteLine( "min = " + histogram.Min.ToString( "F3" ) );
            </code>
            </remarks>
        </member>
        <member name="P:AForge.Math.ContinuousHistogram.Max">
            <summary>
            Maximum value.
            </summary>
            
            <remarks><para>The property allows to retrieve maximum value of the histogram with non zero
            hits count.</para>
            
            <para>Sample usage:</para>
            <code>
            // create histogram
            ContinuousHistogram histogram = new ContinuousHistogram(
                new int[] { 0, 0, 8, 4, 2, 4, 7, 1, 0 }, new Range( 0.0f, 1.0f ) );
            // get max value (= 0.875)
            Console.WriteLine( "max = " + histogram.Max.ToString( "F3" ) );
            </code>
            </remarks>
            
        </member>
        <member name="T:AForge.Math.FourierTransform">
            <summary>
            Fourier transformation.
            </summary>
            
            <remarks>The class implements one dimensional and two dimensional
            Discrete and Fast Fourier Transformation.</remarks>
            
        </member>
        <member name="M:AForge.Math.FourierTransform.DFT(System.Numerics.Complex[],AForge.Math.FourierTransform.Direction)">
            <summary>
            One dimensional Discrete Fourier Transform.
            </summary>
            
            <param name="data">Data to transform.</param>
            <param name="direction">Transformation direction.</param>
            
        </member>
        <member name="M:AForge.Math.FourierTransform.DFT2(System.Numerics.Complex[0:,0:],AForge.Math.FourierTransform.Direction)">
            <summary>
            Two dimensional Discrete Fourier Transform.
            </summary>
            
            <param name="data">Data to transform.</param>
            <param name="direction">Transformation direction.</param>
            
        </member>
        <member name="M:AForge.Math.FourierTransform.FFT(System.Numerics.Complex[],AForge.Math.FourierTransform.Direction)">
            <summary>
            One dimensional Fast Fourier Transform.
            </summary>
            
            <param name="data">Data to transform.</param>
            <param name="direction">Transformation direction.</param>
            
            <remarks><para><note>The method accepts <paramref name="data"/> array of 2<sup>n</sup> size
            only, where <b>n</b> may vary in the [1, 14] range.</note></para></remarks>
            
            <exception cref="T:System.ArgumentException">Incorrect data length.</exception>
            
        </member>
        <member name="M:AForge.Math.FourierTransform.FFT2(System.Numerics.Complex[0:,0:],AForge.Math.FourierTransform.Direction)">
            <summary>
            Two dimensional Fast Fourier Transform.
            </summary>
            
            <param name="data">Data to transform.</param>
            <param name="direction">Transformation direction.</param>
            
            <remarks><para><note>The method accepts <paramref name="data"/> array of 2<sup>n</sup> size
            only in each dimension, where <b>n</b> may vary in the [1, 14] range. For example, 16x16 array
            is valid, but 15x15 is not.</note></para></remarks>
            
            <exception cref="T:System.ArgumentException">Incorrect data length.</exception>
            
        </member>
        <member name="T:AForge.Math.FourierTransform.Direction">
            <summary>
            Fourier transformation direction.
            </summary>
        </member>
        <member name="F:AForge.Math.FourierTransform.Direction.Forward">
            <summary>
              Forward direction of Fourier transformation.
            </summary>
            
        </member>
        <member name="F:AForge.Math.FourierTransform.Direction.Backward">
            <summary>
              Backward direction of Fourier transformation.
            </summary>
            
        </member>
        <member name="T:AForge.Math.Gaussian">
            <summary>
            Gaussian function.
            </summary>
            
            <remarks><para>The class is used to calculate 1D and 2D Gaussian functions for
            specified <see cref="P:AForge.Math.Gaussian.Sigma"/> (s) value:</para>
            
            <code lang="none">
            1-D: f(x) = exp( x * x / ( -2 * s * s ) ) / ( s * sqrt( 2 * PI ) )
            
            2-D: f(x, y) = exp( x * x + y * y / ( -2 * s * s ) ) / ( s * s * 2 * PI )
            </code>
            
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Gaussian.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Math.Gaussian"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Math.Gaussian.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Math.Gaussian"/> class.
            </summary>
            
            <param name="sigma">Sigma value.</param>
            
        </member>
        <member name="M:AForge.Math.Gaussian.Function(System.Double)">
            <summary>
            1-D Gaussian function.
            </summary>
            
            <param name="x">x value.</param>
            
            <returns>Returns function's value at point <paramref name="x"/>.</returns>
            
            <remarks><para>The function calculates 1-D Gaussian function:</para>
            
            <code lang="none">
            f(x) = exp( x * x / ( -2 * s * s ) ) / ( s * sqrt( 2 * PI ) )
            </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Gaussian.Function2D(System.Double,System.Double)">
            <summary>
            2-D Gaussian function.
            </summary>
            
            <param name="x">x value.</param>
            <param name="y">y value.</param>
            
            <returns>Returns function's value at point (<paramref name="x"/>, <paramref name="y"/>).</returns>
            
            <remarks><para>The function calculates 2-D Gaussian function:</para>
            
            <code lang="none">
            f(x, y) = exp( x * x + y * y / ( -2 * s * s ) ) / ( s * s * 2 * PI )
            </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Gaussian.Kernel(System.Int32)">
            <summary>
            1-D Gaussian kernel.
            </summary>
            
            <param name="size">Kernel size (should be odd), [3, 101].</param>
            
            <returns>Returns 1-D Gaussian kernel of the specified size.</returns>
            
            <remarks><para>The function calculates 1-D Gaussian kernel, which is array
            of Gaussian function's values in the [-r, r] range of x value, where
            r=floor(<paramref name="size"/>/2).
            </para></remarks>
            
            <exception cref="T:System.ArgumentException">Wrong kernel size.</exception>
            
        </member>
        <member name="M:AForge.Math.Gaussian.Kernel2D(System.Int32)">
            <summary>
            2-D Gaussian kernel.
            </summary>
            
            <param name="size">Kernel size (should be odd), [3, 101].</param>
            
            <returns>Returns 2-D Gaussian kernel of specified size.</returns>
            
            <remarks><para>The function calculates 2-D Gaussian kernel, which is array
            of Gaussian function's values in the [-r, r] range of x,y values, where
            r=floor(<paramref name="size"/>/2).
            </para></remarks>
            
            <exception cref="T:System.ArgumentException">Wrong kernel size.</exception>
            
        </member>
        <member name="P:AForge.Math.Gaussian.Sigma">
            <summary>
            Sigma value.
            </summary>
            
            <remarks><para>Sigma property of Gaussian function.</para>
            
            <para>Default value is set to <b>1</b>. Minimum allowed value is <b>0.00000001</b>.</para>
            </remarks>
            
        </member>
        <member name="T:AForge.Math.Geometry.ClosePointsMergingOptimizer">
            <summary>
            Shape optimizer, which merges points within close distance to each other.
            </summary>
            
            <remarks><para>This shape optimizing algorithm checks all points of a shape
            and merges any two points which are within <see cref="P:AForge.Math.Geometry.ClosePointsMergingOptimizer.MaxDistanceToMerge">specified distance</see>
            to each other. Two close points are replaced by a single point, which has
            mean coordinates of the removed points.</para>
            
            <para><note>Because of the fact that the algorithm performs points merging
            while it goes through a shape, it may merge several points (more than 2) into a
            single point, where distance between extreme points may be bigger
            than the <see cref="P:AForge.Math.Geometry.ClosePointsMergingOptimizer.MaxDistanceToMerge">specified limit</see>. For example, suppose
            a case with 3 points, where 1st and 2nd points are close enough to be merged, but the
            3rd point is a little bit further. During merging of 1st and 2nd points, it may
            happen that the new point with mean coordinates will get closer to the 3rd point,
            so they will be merged also on next iteration of the algorithm.</note></para>
            
            <para>
            For example, the below circle shape comprised of 65 points, can be optimized to 8 points
            by setting <see cref="P:AForge.Math.Geometry.ClosePointsMergingOptimizer.MaxDistanceToMerge"/> to 28.<br/>
            <img src="img/math/close_points_merging_optimizer.png" width="268" height="238"/>
            </para>
            </remarks>
            
        </member>
        <member name="T:AForge.Math.Geometry.IShapeOptimizer">
             <summary>
             Interface for shape optimizing algorithms.
             </summary>
             
             <remarks><para>The interface defines set of methods, which should be implemented
             by shape optimizing algorithms. These algorithms take input shape, which is defined
             by a set of points (corners of convex hull, etc.), and remove some insignificant points from it,
             which has little influence on the final shape's look.</para>
             
             <para>The shape optimizing algorithms can be useful in conjunction with such algorithms
             like convex hull searching, which usually may provide many hull points, where some
             of them are insignificant and could be removed.</para>
            
             <para>For additional details about shape optimizing algorithms, documentation of
             particular algorithm should be studied.</para>
             </remarks>
             
        </member>
        <member name="M:AForge.Math.Geometry.IShapeOptimizer.OptimizeShape(System.Collections.Generic.List{AForge.IntPoint})">
            <summary>
            Optimize specified shape.
            </summary>
            
            <param name="shape">Shape to be optimized.</param>
            
            <returns>Returns final optimized shape, which may have reduced amount of points.</returns>
            
        </member>
        <member name="M:AForge.Math.Geometry.ClosePointsMergingOptimizer.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Math.Geometry.ClosePointsMergingOptimizer"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Math.Geometry.ClosePointsMergingOptimizer.#ctor(System.Single)">
             <summary>
             Initializes a new instance of the <see cref="T:AForge.Math.Geometry.ClosePointsMergingOptimizer"/> class.
             </summary>
             
             <param name="maxDistanceToMerge">Maximum allowed distance between points, which are
             merged during optimization (see <see cref="P:AForge.Math.Geometry.ClosePointsMergingOptimizer.MaxDistanceToMerge"/>).</param>
            
        </member>
        <member name="M:AForge.Math.Geometry.ClosePointsMergingOptimizer.OptimizeShape(System.Collections.Generic.List{AForge.IntPoint})">
            <summary>
            Optimize specified shape.
            </summary>
            
            <param name="shape">Shape to be optimized.</param>
            
            <returns>Returns final optimized shape, which may have reduced amount of points.</returns>
            
        </member>
        <member name="P:AForge.Math.Geometry.ClosePointsMergingOptimizer.MaxDistanceToMerge">
            <summary>
            Maximum allowed distance between points, which are merged during optimization, [0, âˆž).
            </summary>
            
            <remarks><para>The property sets maximum allowed distance between two points of
            a shape, which are replaced by single point with mean coordinates.</para>
            
            <para>Default value is set to <b>10</b>.</para></remarks>
            
        </member>
        <member name="T:AForge.Math.Geometry.CoplanarPosit">
             <summary>
             3D pose estimation algorithm (coplanar case).
             </summary>
            
             <remarks><para>The class implements an algorithm for 3D object's pose estimation from it's
             2D coordinates obtained by perspective projection, when the object is described coplanar points.
             The idea of the implemented math and algorithm is described in "Iterative Pose Estimation using
             Coplanar Feature Points" paper written by Oberkampf, Daniel DeMenthon and Larry Davis
             (the implementation of the algorithm is very close translation of the pseudo code given by the
             paper, so should be easy to follow).</para>
             
             <para><note>At this point the implementation works only with models described by 4 points, which is
             the minimum number of points enough for 3D pose estimation.</note></para>
             
             <para><note>The 4 model's point are supposed to be coplanar, i.e. supposed to reside all within
             same planer. See <see cref="T:AForge.Math.Geometry.Posit"/> for none coplanar case.</note></para>
             
             <para>Read <a href="http://www.aforgenet.com/articles/posit/">3D Pose Estimation</a> article for
             additional information and samples.</para>
             
             <para>Sample usage:</para>
             <code>
             // points of real object - model
             Vector3[] copositObject = new Vector3[4]
             { 
                 new Vector3( -56.5f, 0,  56.5f ),
                 new Vector3(  56.5f, 0,  56.5f ),
                 new Vector3(  56.5f, 0, -56.5f ),
                 new Vector3( -56.5f, 0, -56.5f ),
             };
             // focal length of camera used to capture the object
             float focalLength = 640; // depends on your camera or projection system
             // initialize CoPOSIT object
             CoplanarPosit coposit = new CoplanarPosit( copositObject, focalLength );
             
             // 2D points of te object - projection
             AForge.Point[] projectedPoints = new AForge.Point[4]
             {
                 new AForge.Point( -77,  48 ),
                 new AForge.Point(  44,  66 ),
                 new AForge.Point(  75, -36 ),
                 new AForge.Point( -61, -58 ),
             };
             // estimate pose
             Matrix3x3 rotationMatrix;
             Vector3 translationVector;
             coposit.EstimatePose( projectedPoints,
                 out rotationMatrix, out translationVector );
             </code>
             </remarks>
             
             <seealso cref="T:AForge.Math.Geometry.Posit"/>
            
        </member>
        <member name="M:AForge.Math.Geometry.CoplanarPosit.#ctor(AForge.Math.Vector3[],System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Math.Geometry.Posit"/> class.
            </summary>
            
            <param name="model">Array of vectors containing coordinates of four real model's point.</param>
            <param name="focalLength">Effective focal length of the camera used to capture the model.</param>
            
            <exception cref="T:System.ArgumentException">The model must have 4 points.</exception>
            
        </member>
        <member name="M:AForge.Math.Geometry.CoplanarPosit.EstimatePose(AForge.Point[],AForge.Math.Matrix3x3@,AForge.Math.Vector3@)">
            <summary>
            Estimate pose of a model from it's projected 2D coordinates.
            </summary>
            
            <param name="points">4 2D points of the <see cref="P:AForge.Math.Geometry.CoplanarPosit.Model">model's</see> projection.</param>
            <param name="rotation">Gets best estimation of object's rotation.</param>
            <param name="translation">Gets best estimation of object's translation.</param>
            
            <exception cref="T:System.ArgumentException">4 points must be be given for pose estimation.</exception>
            
            <remarks><para>Because of the Coplanar POSIT algorithm's nature, it provides two pose estimations,
            which are valid from the algorithm's math point of view. For each pose an error is calculated,
            which specifies how good estimation fits to the specified real 2D coordinated. The method
            provides the best estimation through its output parameters <paramref name="rotation"/> and
            <paramref name="translation"/>. This may be enough for many of the pose estimation application.
            For those, who require checking the alternate pose estimation, it can be obtained using
            <see cref="P:AForge.Math.Geometry.CoplanarPosit.AlternateEstimatedRotation"/> and <see cref="P:AForge.Math.Geometry.CoplanarPosit.AlternateEstimatedTranslation"/> properties.
            The calculated error is provided for both estimations through <see cref="P:AForge.Math.Geometry.CoplanarPosit.BestEstimationError"/> and
            <see cref="P:AForge.Math.Geometry.CoplanarPosit.AlternateEstimationError"/> properties.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Math.Geometry.CoplanarPosit.BestEstimatedRotation">
            <summary>
            Best estimated pose recently found.
            </summary>
            
            <remarks><para>The property keeps best estimated pose found by the latest call to <see cref="M:AForge.Math.Geometry.CoplanarPosit.EstimatePose(AForge.Point[],AForge.Math.Matrix3x3@,AForge.Math.Vector3@)"/>.
            The same estimated pose is provided by that method also and can be accessed through this property
            for convenience.</para>
            
            <para>See also <see cref="P:AForge.Math.Geometry.CoplanarPosit.BestEstimatedTranslation"/> and <see cref="P:AForge.Math.Geometry.CoplanarPosit.BestEstimationError"/>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Math.Geometry.CoplanarPosit.BestEstimatedTranslation">
            <summary>
            Best estimated translation recently found.
            </summary>
            
            <remarks><para>The property keeps best estimated translation found by the latest call to <see cref="M:AForge.Math.Geometry.CoplanarPosit.EstimatePose(AForge.Point[],AForge.Math.Matrix3x3@,AForge.Math.Vector3@)"/>.
            The same estimated translation is provided by that method also and can be accessed through this property
            for convenience.</para>
            
            <para>See also <see cref="P:AForge.Math.Geometry.CoplanarPosit.BestEstimatedRotation"/> and <see cref="P:AForge.Math.Geometry.CoplanarPosit.BestEstimationError"/>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Math.Geometry.CoplanarPosit.BestEstimationError">
            <summary>
            Error of the best pose estimation.
            </summary>
            
            <remarks><para>The property keeps error of the best pose estimation, which is calculated as average
            error between real angles of the specified quadrilateral and angles of the quadrilateral which
            is a projection of the best pose estimation. The error is measured degrees in (angle).</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Math.Geometry.CoplanarPosit.AlternateEstimatedRotation">
            <summary>
            Alternate estimated pose recently found.
            </summary>
            
            <remarks><para>The property keeps alternate estimated pose found by the latest call to <see cref="M:AForge.Math.Geometry.CoplanarPosit.EstimatePose(AForge.Point[],AForge.Math.Matrix3x3@,AForge.Math.Vector3@)"/>.</para>
            
            <para>See also <see cref="P:AForge.Math.Geometry.CoplanarPosit.AlternateEstimatedTranslation"/> and <see cref="P:AForge.Math.Geometry.CoplanarPosit.AlternateEstimationError"/>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Math.Geometry.CoplanarPosit.AlternateEstimatedTranslation">
            <summary>
            Alternated estimated translation recently found.
            </summary>
            
            <remarks><para>The property keeps alternate estimated translation found by the latest call to <see cref="M:AForge.Math.Geometry.CoplanarPosit.EstimatePose(AForge.Point[],AForge.Math.Matrix3x3@,AForge.Math.Vector3@)"/>.</para>
            
            <para>See also <see cref="P:AForge.Math.Geometry.CoplanarPosit.AlternateEstimatedRotation"/> and <see cref="P:AForge.Math.Geometry.CoplanarPosit.AlternateEstimationError"/>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Math.Geometry.CoplanarPosit.AlternateEstimationError">
            <summary>
            Error of the alternate pose estimation.
            </summary>
            
            <remarks><para>The property keeps error of the alternate pose estimation, which is calculated as average
            error between real angles of the specified quadrilateral and angles of the quadrilateral which
            is a projection of the alternate pose estimation. The error is measured in degrees (angle).</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Math.Geometry.CoplanarPosit.Model">
            <summary>
            Coordinates of the model points which pose should be estimated.
            </summary>
        </member>
        <member name="P:AForge.Math.Geometry.CoplanarPosit.FocalLength">
            <summary>
            Effective focal length of the camera used to capture the model.
            </summary>
        </member>
        <member name="T:AForge.Math.Geometry.FlatAnglesOptimizer">
             <summary>
             Shape optimizer, which removes obtuse angles (close to flat) from a shape.
             </summary>
             
             <remarks><para>This shape optimizing algorithm checks all adjacent edges of a shape
             and substitutes any 2 edges with a single edge if angle between them is greater than
             <see cref="P:AForge.Math.Geometry.FlatAnglesOptimizer.MaxAngleToKeep"/>. The algorithm makes sure there are not obtuse angles in
             a shape, which are very close to flat line.</para>
             
             <para>The shape optimizer does not optimize shapes to less than 3 points, so optimized
             shape always will have at least 3 points.</para>
            
             <para>
             For example, the below circle shape comprised of 65 points, can be optimized to 10 points
             by setting <see cref="P:AForge.Math.Geometry.FlatAnglesOptimizer.MaxAngleToKeep"/> to 160.<br/>
             <img src="img/math/flat_angles_optimizer.png" width="268" height="238"/>
             </para>
             </remarks>
             
        </member>
        <member name="M:AForge.Math.Geometry.FlatAnglesOptimizer.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Math.Geometry.FlatAnglesOptimizer"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Math.Geometry.FlatAnglesOptimizer.#ctor(System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Math.Geometry.FlatAnglesOptimizer"/> class.
            </summary>
            
            <param name="maxAngleToKeep">Maximum acceptable angle between two edges of a shape (see <see cref="P:AForge.Math.Geometry.FlatAnglesOptimizer.MaxAngleToKeep"/>).</param>
            
        </member>
        <member name="M:AForge.Math.Geometry.FlatAnglesOptimizer.OptimizeShape(System.Collections.Generic.List{AForge.IntPoint})">
            <summary>
            Optimize specified shape.
            </summary>
            
            <param name="shape">Shape to be optimized.</param>
            
            <returns>Returns final optimized shape, which may have reduced amount of points.</returns>
            
        </member>
        <member name="P:AForge.Math.Geometry.FlatAnglesOptimizer.MaxAngleToKeep">
            <summary>
            Maximum angle between adjacent edges to keep in a shape, [140, 180].
            </summary>
            
            <remarks><para>The property sets maximum angle between adjacent edges, which is kept
            during optimization. All edges, which have a greater angle between them, are substituted
            by a single edge.</para>
            
            <para>Default value is set to <b>160</b>.</para></remarks>
            
        </member>
        <member name="T:AForge.Math.Geometry.GeometryTools">
            <summary>
            Collection of some gemetry tool methods.
            </summary>
            
        </member>
        <member name="M:AForge.Math.Geometry.GeometryTools.GetAngleBetweenVectors(AForge.Point,AForge.Point,AForge.Point)">
            <summary>
            Calculate angle between to vectors measured in [0, 180] degrees range.
            </summary>
            
            <param name="startPoint">Starting point of both vectors.</param>
            <param name="vector1end">Ending point of the first vector.</param>
            <param name="vector2end">Ending point of the second vector.</param>
            
            <returns>Returns angle between specified vectors measured in degrees.</returns>
            
        </member>
        <member name="M:AForge.Math.Geometry.GeometryTools.GetAngleBetweenLines(AForge.Point,AForge.Point,AForge.Point,AForge.Point)">
            <summary>
            Calculate minimum angle between two lines measured in [0, 90] degrees range.
            </summary>
            
            <param name="a1">A point on the first line.</param>
            <param name="a2">Another point on the first line.</param>
            <param name="b1">A point on the second line.</param>
            <param name="b2">Another point on the second line.</param>
            
            <returns>Returns minimum angle between two lines.</returns>
            
            <remarks><para><note>It is preferred to use <see cref="M:AForge.Math.Geometry.Line.GetAngleBetweenLines(AForge.Math.Geometry.Line)"/> if it is required to calculate angle
            multiple times for one of the lines.</note></para></remarks>
            
            <exception cref="T:System.ArgumentException"><paramref name="a1"/> and <paramref name="a2"/> are the same,
            -OR- <paramref name="b1"/> and <paramref name="b2"/> are the same.</exception>
            
        </member>
        <member name="T:AForge.Math.Geometry.GrahamConvexHull">
            <summary>
            Graham scan algorithm for finding convex hull.
            </summary>
            
            <remarks><para>The class implements
            <a href="http://en.wikipedia.org/wiki/Graham_scan">Graham scan</a> algorithm for finding convex hull
            of a given set of points.</para>
            
            <para>Sample usage:</para>
            <code>
            // generate some random points
            Random rand = new Random( );
            List&lt;IntPoint&gt; points = new List&lt;IntPoint&gt;( );
            
            for ( int i = 0; i &lt; 10; i++ )
            {
                points.Add( new IntPoint(
                       rand.Next( 200 ) - 100,
                       rand.Next( 200 ) - 100 ) );
            }
            
            // find the convex hull
            IConvexHullAlgorithm hullFinder = new GrahamConvexHull( );
            List&lt;IntPoint&gt; hull = hullFinder.FindHull( points );
            </code>
            </remarks>
            
        </member>
        <member name="T:AForge.Math.Geometry.IConvexHullAlgorithm">
            <summary>
            Interface defining methods for algorithms, which search for convex hull of the specified points' set.
            </summary>
            
            <remarks><para>The interface defines a method, which should be implemented by different classes
            performing convex hull search for specified set of points.</para>
            
            <para><note>All algorithms, implementing this interface, should follow two rules for the found convex hull:
            <list type="bullet">
            <item>the first point in the returned list is the point with lowest X coordinate (and with lowest Y if
            there are several points with the same X value);</item>
            <item>points in the returned list are given in counter clockwise order
            (<a href="http://en.wikipedia.org/wiki/Cartesian_coordinate_system">Cartesian
            coordinate system</a>).</item>
            </list>
            </note></para>
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Geometry.IConvexHullAlgorithm.FindHull(System.Collections.Generic.List{AForge.IntPoint})">
            <summary>
            Find convex hull for the given set of points.
            </summary>
            
            <param name="points">Set of points to search convex hull for.</param>
            
            <returns>Returns set of points, which form a convex hull for the given <paramref name="points"/>.</returns>
            
        </member>
        <member name="M:AForge.Math.Geometry.GrahamConvexHull.FindHull(System.Collections.Generic.List{AForge.IntPoint})">
            <summary>
            Find convex hull for the given set of points.
            </summary>
            
            <param name="points">Set of points to search convex hull for.</param>
            
            <returns>Returns set of points, which form a convex hull for the given <paramref name="points"/>.
            The first point in the list is the point with lowest X coordinate (and with lowest Y if there are
            several points with the same X value). Points are provided in counter clockwise order
            (<a href="http://en.wikipedia.org/wiki/Cartesian_coordinate_system">Cartesian
            coordinate system</a>).</returns>
            
        </member>
        <member name="T:AForge.Math.Geometry.Line">
            <summary>
            The class encapsulates 2D line and provides some tool methods related to lines.
            </summary>
            
            <remarks><para>The class provides some methods which are related to lines:
            angle between lines, distance to point, finding intersection point, etc.
            </para>
            
            <para>Generally, the equation of the line is y = <see cref="P:AForge.Math.Geometry.Line.Slope"/> * x + 
            <see cref="P:AForge.Math.Geometry.Line.Intercept"/>. However, when <see cref="P:AForge.Math.Geometry.Line.Slope"/> is an Infinity,
            <see name="Intercept"/> would normally be meaningless, and it would be
            impossible to distinguish the line x = 5 from the line x = -5. Therefore,
            if <see cref="P:AForge.Math.Geometry.Line.Slope"/> is <see cref="F:System.Single.PositiveInfinity"/> or
            <see cref="F:System.Single.NegativeInfinity"/>, the line's equation is instead 
            x = <see cref="P:AForge.Math.Geometry.Line.Intercept"/>.</para>
            
            <para>Sample usage:</para>
            <code>
            // create a line
            Line line = Line.FromPoints( new Point( 0, 0 ), new Point( 3, 4 ) );
            // check if it is vertical or horizontal
            if ( line.IsVertical || line.IsHorizontal )
            {
                // ...
            }
            
            // get intersection point with another line
            Point intersection = line.GetIntersectionWith(
                Line.FromPoints( new Point( 3, 0 ), new Point( 0, 4 ) ) );
            </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Geometry.Line.FromPoints(AForge.Point,AForge.Point)">
            <summary>
            Creates a <see cref="T:AForge.Math.Geometry.Line"/>  that goes through the two specified points.
            </summary>
            
            <param name="point1">One point on the line.</param>
            <param name="point2">Another point on the line.</param>
            
            <returns>Returns a <see cref="T:AForge.Math.Geometry.Line"/> representing the line between <paramref name="point1"/>
            and <paramref name="point2"/>.</returns>
            
            <exception cref="T:System.ArgumentException">Thrown if the two points are the same.</exception>
            
        </member>
        <member name="M:AForge.Math.Geometry.Line.FromSlopeIntercept(System.Single,System.Single)">
            <summary>
            Creates a <see cref="T:AForge.Math.Geometry.Line"/> with the specified slope and intercept.
            </summary>
            
            <param name="slope">The slope of the line</param>
            <param name="intercept">The Y-intercept of the line, unless the slope is an
            infinity, in which case the line's equation is "x = intercept" instead.</param>
            
            <returns>Returns a <see cref="T:AForge.Math.Geometry.Line"/> representing the specified line.</returns>
            
            <remarks><para>The construction here follows the same rules as for the rest of this class.
            Most lines are expressed as y = slope * x + intercept. Vertical lines, however, are 
            x = intercept. This is indicated by <see cref="P:AForge.Math.Geometry.Line.IsVertical"/> being true or by 
            <see cref="P:AForge.Math.Geometry.Line.Slope"/> returning <see cref="F:System.Single.PositiveInfinity"/> or 
            <see cref="F:System.Single.NegativeInfinity"/>.</para></remarks>
            
        </member>
        <member name="M:AForge.Math.Geometry.Line.FromRTheta(System.Single,System.Single)">
            <summary>
            Constructs a <see cref="T:AForge.Math.Geometry.Line"/> from a radius and an angle (in degrees).
            </summary>
            
            <param name="radius">The minimum distance from the line to the origin.</param>
            <param name="theta">The angle of the vector from the origin to the line.</param>
            
            <returns>Returns a <see cref="T:AForge.Math.Geometry.Line"/> representing the specified line.</returns>
            
            <remarks><para><paramref name="radius"/> is the minimum distance from the origin
            to the line, and <paramref name="theta"/> is the counterclockwise rotation from
            the positive X axis to the vector through the origin and normal to the line.</para>
            <para>This means that if <paramref name="theta"/> is in [0,180), the point on the line
            closest to the origin is on the positive X or Y axes, or in quadrants I or II. Likewise,
            if <paramref name="theta"/> is in [180,360), the point on the line closest to the
            origin is on the negative X or Y axes, or in quadrants III or IV.</para></remarks>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if radius is negative.</exception>
            
        </member>
        <member name="M:AForge.Math.Geometry.Line.FromPointTheta(AForge.Point,System.Single)">
            <summary>
            Constructs a <see cref="T:AForge.Math.Geometry.Line"/> from a point and an angle (in degrees).
            </summary>
            
            <param name="point">The minimum distance from the line to the origin.</param>
            <param name="theta">The angle of the normal vector from the origin to the line.</param>
            
            <remarks><para><paramref name="theta"/> is the counterclockwise rotation from
            the positive X axis to the vector through the origin and normal to the line.</para>
            <para>This means that if <paramref name="theta"/> is in [0,180), the point on the line
            closest to the origin is on the positive X or Y axes, or in quadrants I or II. Likewise,
            if <paramref name="theta"/> is in [180,360), the point on the line closest to the
            origin is on the negative X or Y axes, or in quadrants III or IV.</para></remarks>
            
            <returns>Returns a <see cref="T:AForge.Math.Geometry.Line"/> representing the specified line.</returns>
            
        </member>
        <member name="M:AForge.Math.Geometry.Line.GetAngleBetweenLines(AForge.Math.Geometry.Line)">
            <summary>
            Calculate minimum angle between this line and the specified line measured in [0, 90] degrees range.
            </summary>
            
            <param name="secondLine">The line to find angle between.</param>
            
            <returns>Returns minimum angle between lines.</returns>
            
        </member>
        <member name="M:AForge.Math.Geometry.Line.GetIntersectionWith(AForge.Math.Geometry.Line)">
            <summary>
            Finds intersection point with the specified line.
            </summary>
            
            <param name="secondLine">Line to find intersection with.</param>
            
            <returns>Returns intersection point with the specified line, or 
            <see langword="null"/> if the lines are parallel and distinct.</returns>
            
            <exception cref="T:System.InvalidOperationException">Thrown if the specified line is the same line as this line.</exception>
            
        </member>
        <member name="M:AForge.Math.Geometry.Line.GetIntersectionWith(AForge.Math.Geometry.LineSegment)">
            <summary>
            Finds, provided it exists, the intersection point with the specified <see cref="T:AForge.Math.Geometry.LineSegment"/>.
            </summary>
            
            <param name="other"><see cref="T:AForge.Math.Geometry.LineSegment"/> to find intersection with.</param>
            
            <returns>Returns intersection point with the specified <see cref="T:AForge.Math.Geometry.LineSegment"/>, or <see langword="null"/>,
            if this line does not intersect with the segment.</returns>
            
            <remarks><para>If the line and segment do not intersect, the method returns <see langword="null"/>.
            If the line and segment share multiple points, the method throws an <see cref="T:System.InvalidOperationException"/>.
            </para></remarks>
            
            <exception cref="T:System.InvalidOperationException">Thrown if <paramref name="other"/> is a portion
            of this line.</exception>
            
        </member>
        <member name="M:AForge.Math.Geometry.Line.DistanceToPoint(AForge.Point)">
            <summary>
            Calculate Euclidean distance between a point and a line.
            </summary>
            
            <param name="point">The point to calculate distance to.</param>
            
            <returns>Returns the Euclidean distance between this line and the specified point. Unlike
            <see cref="M:AForge.Math.Geometry.LineSegment.DistanceToPoint(AForge.Point)"/>, this returns the distance from the infinite line. (0,0) is 0 units
            from the line defined by (0,5) and (0,8), but is 5 units from the segment with those endpoints.</returns>
            
        </member>
        <member name="M:AForge.Math.Geometry.Line.op_Equality(AForge.Math.Geometry.Line,AForge.Math.Geometry.Line)">
             <summary>
             Equality operator - checks if two lines have equal parameters.
             </summary>
             
             <param name="line1">First line to check.</param>
             <param name="line2">Second line to check.</param>
             
             <returns>Returns <see langword="true"/> if parameters of specified
             lines are equal.</returns>
            
        </member>
        <member name="M:AForge.Math.Geometry.Line.op_Inequality(AForge.Math.Geometry.Line,AForge.Math.Geometry.Line)">
             <summary>
             Inequality operator - checks if two lines have different parameters.
             </summary>
             
             <param name="line1">First line to check.</param>
             <param name="line2">Second line to check.</param>
             
             <returns>Returns <see langword="true"/> if parameters of specified
             lines are not equal.</returns>
            
        </member>
        <member name="M:AForge.Math.Geometry.Line.Equals(System.Object)">
            <summary>
            Check if this instance of <see cref="T:AForge.Math.Geometry.Line"/> equals to the specified one.
            </summary>
            
            <param name="obj">Another line to check equalty to.</param>
            
            <returns>Return <see langword="true"/> if objects are equal.</returns>
            
        </member>
        <member name="M:AForge.Math.Geometry.Line.GetHashCode">
            <summary>
            Get hash code for this instance.
            </summary>
            
            <returns>Returns the hash code for this instance.</returns>
            
        </member>
        <member name="M:AForge.Math.Geometry.Line.ToString">
             <summary>
             Get string representation of the class.
             </summary>
             
             <returns>Returns string, which contains values of the like in readable form.</returns>
            
        </member>
        <member name="P:AForge.Math.Geometry.Line.IsVertical">
             <summary>
             Checks if the line vertical or not.
             </summary>
            
        </member>
        <member name="P:AForge.Math.Geometry.Line.IsHorizontal">
            <summary>
            Checks if the line horizontal or not.
            </summary>
        </member>
        <member name="P:AForge.Math.Geometry.Line.Slope">
            <summary>
            Gets the slope of the line.
            </summary>
        </member>
        <member name="P:AForge.Math.Geometry.Line.Intercept">
            <summary>
            If not <see cref="P:AForge.Math.Geometry.Line.IsVertical"/>, gets the Line's Y-intercept.
            If <see cref="P:AForge.Math.Geometry.Line.IsVertical"/> gets the line's X-intercept.
            </summary>
        </member>
        <member name="T:AForge.Math.Geometry.LineSegment">
            <summary>
            The class encapsulates 2D line segment and provides some tool methods related to lines.
            </summary>
            
            <remarks><para>The class provides some methods which are related to line segments:
            distance to point, finding intersection point, etc.
            </para>
            
            <para>A line segment may be converted to a <see cref="T:AForge.Math.Geometry.Line"/>.</para>
            
            <para>Sample usage:</para>
            <code>
            // create a segment
            LineSegment segment = new LineSegment( new Point( 0, 0 ), new Point( 3, 4 ) );
            // get segment's length
            float length = segment.Length;
            
            // get intersection point with a line
            Point? intersection = segment.GetIntersectionWith(
                new Line( new Point( -3, 8 ), new Point( 0, 4 ) ) );
            </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Geometry.LineSegment.#ctor(AForge.Point,AForge.Point)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Math.Geometry.LineSegment"/> class.
            </summary>
            
            <param name="start">Segment's start point.</param>
            <param name="end">Segment's end point.</param>
            
            <exception cref="T:System.ArgumentException">Thrown if the two points are the same.</exception>
            
        </member>
        <member name="M:AForge.Math.Geometry.LineSegment.op_Explicit(AForge.Math.Geometry.LineSegment)~AForge.Math.Geometry.Line">
            <summary>
            Converts this <see cref="T:AForge.Math.Geometry.LineSegment"/> to a <see cref="T:AForge.Math.Geometry.Line"/> by discarding
            its endpoints and extending it infinitely in both directions.
            </summary>
            
            <param name="segment">The segment to convert to a <see cref="T:AForge.Math.Geometry.Line"/>.</param>
            
            <returns>Returns a <see cref="T:AForge.Math.Geometry.Line"/> that contains this <paramref name="segment"/>.</returns>
            
        </member>
        <member name="M:AForge.Math.Geometry.LineSegment.DistanceToPoint(AForge.Point)">
            <summary>
            Calculate Euclidean distance between a point and a finite line segment.
            </summary>
            
            <param name="point">The point to calculate the distance to.</param>
            
            <returns>Returns the Euclidean distance between this line segment and the specified point. Unlike
            <see cref="M:AForge.Math.Geometry.Line.DistanceToPoint(AForge.Point)"/>, this returns the distance from the finite segment. (0,0) is 5 units
            from the segment (0,5)-(0,8), but is 0 units from the line through those points.</returns>
            
        </member>
        <member name="M:AForge.Math.Geometry.LineSegment.GetIntersectionWith(AForge.Math.Geometry.LineSegment)">
            <summary>
            Finds, provided it exists, the intersection point with the specified <see cref="T:AForge.Math.Geometry.LineSegment"/>.
            </summary>
            
            <param name="other"><see cref="T:AForge.Math.Geometry.LineSegment"/> to find intersection with.</param>
            
            <returns>Returns intersection point with the specified <see cref="T:AForge.Math.Geometry.LineSegment"/>, or <see langword="null"/>, if
            the two segments do not intersect.</returns>
            
            <remarks><para>If the two segments do not intersect, the method returns <see langword="null"/>. If the two
            segments share multiple points, this throws an <see cref="T:System.InvalidOperationException"/>.
            </para></remarks>
            
            <exception cref="T:System.InvalidOperationException">Thrown if the segments overlap - if they have
            multiple points in common.</exception>
            
        </member>
        <member name="M:AForge.Math.Geometry.LineSegment.GetIntersectionWith(AForge.Math.Geometry.Line)">
            <summary>
            Finds, provided it exists, the intersection point with the specified <see cref="T:AForge.Math.Geometry.Line"/>.
            </summary>
            
            <param name="other"><see cref="T:AForge.Math.Geometry.Line"/> to find intersection with.</param>
            
            <returns>Returns intersection point with the specified <see cref="T:AForge.Math.Geometry.Line"/>, or <see langword="null"/>, if
            the line does not intersect with this segment.</returns>
            
            <remarks><para>If the line and the segment do not intersect, the method returns <see langword="null"/>. If the line
            and the segment share multiple points, the method throws an <see cref="T:System.InvalidOperationException"/>.
            </para></remarks>
            
            <exception cref="T:System.InvalidOperationException">Thrown if this segment is a portion of
            <paramref name="other"/> line.</exception>
            
        </member>
        <member name="M:AForge.Math.Geometry.LineSegment.op_Equality(AForge.Math.Geometry.LineSegment,AForge.Math.Geometry.LineSegment)">
             <summary>
             Equality operator - checks if two line segments have equal parameters.
             </summary>
             
             <param name="line1">First line segment to check.</param>
             <param name="line2">Second line segment to check.</param>
             
             <returns>Returns <see langword="true"/> if parameters of specified
             line segments are equal.</returns>
            
        </member>
        <member name="M:AForge.Math.Geometry.LineSegment.op_Inequality(AForge.Math.Geometry.LineSegment,AForge.Math.Geometry.LineSegment)">
             <summary>
             Inequality operator - checks if two lines have different parameters.
             </summary>
             
             <param name="line1">First line segment to check.</param>
             <param name="line2">Second line segment to check.</param>
             
             <returns>Returns <see langword="true"/> if parameters of specified
             line segments are not equal.</returns>
            
        </member>
        <member name="M:AForge.Math.Geometry.LineSegment.Equals(System.Object)">
            <summary>
            Check if this instance of <see cref="T:AForge.Math.Geometry.LineSegment"/> equals to the specified one.
            </summary>
            
            <param name="obj">Another line segment to check equalty to.</param>
            
            <returns>Return <see langword="true"/> if objects are equal.</returns>
            
        </member>
        <member name="M:AForge.Math.Geometry.LineSegment.GetHashCode">
            <summary>
            Get hash code for this instance.
            </summary>
            
            <returns>Returns the hash code for this instance.</returns>
            
        </member>
        <member name="M:AForge.Math.Geometry.LineSegment.ToString">
             <summary>
             Get string representation of the class.
             </summary>
             
             <returns>Returns string, which contains values of the like in readable form.</returns>
            
        </member>
        <member name="P:AForge.Math.Geometry.LineSegment.Start">
            <summary>
            Start point of the line segment.
            </summary>
        </member>
        <member name="P:AForge.Math.Geometry.LineSegment.End">
            <summary>
            End point of the line segment.
            </summary>
        </member>
        <member name="P:AForge.Math.Geometry.LineSegment.Length">
            <summary>
            Get segment's length - Euclidean distance between its <see cref="P:AForge.Math.Geometry.LineSegment.Start"/> and <see cref="P:AForge.Math.Geometry.LineSegment.End"/> points.
            </summary>
        </member>
        <member name="T:AForge.Math.Geometry.LineStraighteningOptimizer">
             <summary>
             Shape optimizer, which removes points within close range to shapes' body.
             </summary>
             
             <remarks><para>This shape optimizing algorithm checks all points of the shape and
             removes those of them, which are in a certain distance to a line connecting previous and
             the next points. In other words, it goes through all adjacent edges of a shape and checks
             what is the distance between the corner formed by these two edges and a possible edge, which
             could be used as substitution of these edges. If the distance is equal or smaller than
             the <see cref="P:AForge.Math.Geometry.LineStraighteningOptimizer.MaxDistanceToRemove">specified value</see>, then the point is removed,
             so the two edges are substituted by a single one. When optimization process is done,
             the new shape has reduced amount of points and none of the removed points are further away
             from the new shape than the specified limit.</para>
             
             <para>The shape optimizer does not optimize shapes to less than 3 points, so optimized
             shape always will have at least 3 points.</para>
            
             <para>
             For example, the below circle shape comprised of 65 points, can be optimized to 8 points
             by setting <see cref="P:AForge.Math.Geometry.LineStraighteningOptimizer.MaxDistanceToRemove"/> to 10.<br/>
             <img src="img/math/line_straightening_optimizer.png" width="268" height="238"/>
             </para>
             </remarks>
             
        </member>
        <member name="M:AForge.Math.Geometry.LineStraighteningOptimizer.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Math.Geometry.LineStraighteningOptimizer"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Math.Geometry.LineStraighteningOptimizer.#ctor(System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Math.Geometry.LineStraighteningOptimizer"/> class.
            </summary>
            
            <param name="maxDistanceToRemove">Maximum allowed distance between removed points
            and optimized shape (see <see cref="P:AForge.Math.Geometry.LineStraighteningOptimizer.MaxDistanceToRemove"/>).</param>
            
        </member>
        <member name="M:AForge.Math.Geometry.LineStraighteningOptimizer.OptimizeShape(System.Collections.Generic.List{AForge.IntPoint})">
            <summary>
            Optimize specified shape.
            </summary>
            
            <param name="shape">Shape to be optimized.</param>
            
            <returns>Returns final optimized shape, which may have reduced amount of points.</returns>
            
        </member>
        <member name="P:AForge.Math.Geometry.LineStraighteningOptimizer.MaxDistanceToRemove">
            <summary>
            Maximum allowed distance between removed points and optimized shape, [0, âˆž).
            </summary>
            
            <remarks><para>The property sets maximum allowed distance between points removed from original
            shape and optimized shape - none of the removed points are further away
            from the new shape than the specified limit.
            </para>
            
            <para>Default value is set to <b>5</b>.</para></remarks>
            
        </member>
        <member name="T:AForge.Math.Geometry.PointsCloud">
            <summary>
            Set of tools for processing collection of points in 2D space.
            </summary>
            
            <remarks><para>The static class contains set of routines, which provide different
            operations with collection of points in 2D space. For example, finding the
            furthest point from a specified point or line.</para>
            
            <para>Sample usage:</para>
            <code>
            // create points' list
            List&lt;IntPoint&gt; points = new List&lt;IntPoint&gt;( );
            points.Add( new IntPoint( 10, 10 ) );
            points.Add( new IntPoint( 20, 15 ) );
            points.Add( new IntPoint( 15, 30 ) );
            points.Add( new IntPoint( 40, 12 ) );
            points.Add( new IntPoint( 30, 20 ) );
            // get furthest point from the specified point
            IntPoint p1 = PointsCloud.GetFurthestPoint( points, new IntPoint( 15, 15 ) );
            Console.WriteLine( p1.X + ", " + p1.Y );
            // get furthest point from line
            IntPoint p2 = PointsCloud.GetFurthestPointFromLine( points,
                new IntPoint( 50, 0 ), new IntPoint( 0, 50 ) );
            Console.WriteLine( p2.X + ", " + p2.Y );
            </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Geometry.PointsCloud.Shift(System.Collections.Generic.IList{AForge.IntPoint},AForge.IntPoint)">
            <summary>
            Shift cloud by adding specified value to all points in the collection.
            </summary>
            
            <param name="cloud">Collection of points to shift their coordinates.</param>
            <param name="shift">Point to shift by.</param>
            
        </member>
        <member name="M:AForge.Math.Geometry.PointsCloud.GetBoundingRectangle(System.Collections.Generic.IEnumerable{AForge.IntPoint},AForge.IntPoint@,AForge.IntPoint@)">
            <summary>
            Get bounding rectangle of the specified list of points.
            </summary>
            
            <param name="cloud">Collection of points to get bounding rectangle for.</param>
            <param name="minXY">Point comprised of smallest X and Y coordinates.</param>
            <param name="maxXY">Point comprised of biggest X and Y coordinates.</param>
            
        </member>
        <member name="M:AForge.Math.Geometry.PointsCloud.GetCenterOfGravity(System.Collections.Generic.IEnumerable{AForge.IntPoint})">
            <summary>
            Get center of gravity for the specified list of points.
            </summary>
            
            <param name="cloud">List of points to calculate center of gravity for.</param>
            
            <returns>Returns center of gravity (mean X-Y values) for the specified list of points.</returns>
            
        </member>
        <member name="M:AForge.Math.Geometry.PointsCloud.GetFurthestPoint(System.Collections.Generic.IEnumerable{AForge.IntPoint},AForge.IntPoint)">
            <summary>
            Find furthest point from the specified point.
            </summary>
            
            <param name="cloud">Collection of points to search furthest point in.</param>
            <param name="referencePoint">The point to search furthest point from.</param>
            
            <returns>Returns a point, which is the furthest away from the <paramref name="referencePoint"/>.</returns>
            
        </member>
        <member name="M:AForge.Math.Geometry.PointsCloud.GetFurthestPointsFromLine(System.Collections.Generic.IEnumerable{AForge.IntPoint},AForge.IntPoint,AForge.IntPoint,AForge.IntPoint@,AForge.IntPoint@)">
            <summary>
            Find two furthest points from the specified line.
            </summary>
            
            <param name="cloud">Collection of points to search furthest points in.</param>
            <param name="linePoint1">First point forming the line.</param>
            <param name="linePoint2">Second point forming the line.</param>
            <param name="furthestPoint1">First found furthest point.</param>
            <param name="furthestPoint2">Second found furthest point (which is on the
            opposite side from the line compared to the <paramref name="furthestPoint1"/>);</param>
            
            <remarks><para>The method finds two furthest points from the specified line,
            where one point is on one side from the line and the second point is on
            another side from the line.</para></remarks>
            
        </member>
        <member name="M:AForge.Math.Geometry.PointsCloud.GetFurthestPointsFromLine(System.Collections.Generic.IEnumerable{AForge.IntPoint},AForge.IntPoint,AForge.IntPoint,AForge.IntPoint@,System.Single@,AForge.IntPoint@,System.Single@)">
             <summary>
             Find two furthest points from the specified line.
             </summary>
             
             <param name="cloud">Collection of points to search furthest points in.</param>
             <param name="linePoint1">First point forming the line.</param>
             <param name="linePoint2">Second point forming the line.</param>
             <param name="furthestPoint1">First found furthest point.</param>
             <param name="distance1">Distance between the first found point and the given line.</param>
             <param name="furthestPoint2">Second found furthest point (which is on the
             opposite side from the line compared to the <paramref name="furthestPoint1"/>);</param>
             <param name="distance2">Distance between the second found point and the given line.</param>
             
             <remarks><para>The method finds two furthest points from the specified line,
             where one point is on one side from the line and the second point is on
             another side from the line.</para></remarks>
            
        </member>
        <member name="M:AForge.Math.Geometry.PointsCloud.GetFurthestPointFromLine(System.Collections.Generic.IEnumerable{AForge.IntPoint},AForge.IntPoint,AForge.IntPoint)">
             <summary>
             Find the furthest point from the specified line.
             </summary>
             
             <param name="cloud">Collection of points to search furthest point in.</param>
             <param name="linePoint1">First point forming the line.</param>
             <param name="linePoint2">Second point forming the line.</param>
             
             <returns>Returns a point, which is the furthest away from the
             specified line.</returns>
             
             <remarks><para>The method finds the furthest point from the specified line.
             Unlike the <see cref="M:AForge.Math.Geometry.PointsCloud.GetFurthestPointsFromLine(System.Collections.Generic.IEnumerable{AForge.IntPoint},AForge.IntPoint,AForge.IntPoint,AForge.IntPoint@,AForge.IntPoint@)"/>
             method, this method find only one point, which is the furthest away from the line
             regardless of side from the line.</para></remarks>
            
        </member>
        <member name="M:AForge.Math.Geometry.PointsCloud.GetFurthestPointFromLine(System.Collections.Generic.IEnumerable{AForge.IntPoint},AForge.IntPoint,AForge.IntPoint,System.Single@)">
             <summary>
             Find the furthest point from the specified line.
             </summary>
             
             <param name="cloud">Collection of points to search furthest points in.</param>
             <param name="linePoint1">First point forming the line.</param>
             <param name="linePoint2">Second point forming the line.</param>
             <param name="distance">Distance between the furthest found point and the given line.</param>
             
             <returns>Returns a point, which is the furthest away from the
             specified line.</returns>
             
             <remarks><para>The method finds the furthest point from the specified line.
             Unlike the <see cref="M:AForge.Math.Geometry.PointsCloud.GetFurthestPointsFromLine(System.Collections.Generic.IEnumerable{AForge.IntPoint},AForge.IntPoint,AForge.IntPoint,AForge.IntPoint@,System.Single@,AForge.IntPoint@,System.Single@)"/>
             method, this method find only one point, which is the furthest away from the line
             regardless of side from the line.</para></remarks>
            
        </member>
        <member name="M:AForge.Math.Geometry.PointsCloud.FindQuadrilateralCorners(System.Collections.Generic.IEnumerable{AForge.IntPoint})">
            <summary>
            Find corners of quadrilateral or triangular area, which contains the specified collection of points.
            </summary>
            
            <param name="cloud">Collection of points to search quadrilateral for.</param>
            
            <returns>Returns a list of 3 or 4 points, which are corners of the quadrilateral or
            triangular area filled by specified collection of point. The first point in the list
            is the point with lowest X coordinate (and with lowest Y if there are several points
            with the same X value). The corners are provided in counter clockwise order
            (<a href="http://en.wikipedia.org/wiki/Cartesian_coordinate_system">Cartesian
            coordinate system</a>).</returns>
            
            <remarks><para>The method makes an assumption that the specified collection of points
            form some sort of quadrilateral/triangular area. With this assumption it tries to find corners
            of the area.</para>
            
            <para><note>The method does not search for <b>bounding</b> quadrilateral/triangular area,
            where all specified points are <b>inside</b> of the found quadrilateral/triangle. Some of the
            specified points potentially may be outside of the found quadrilateral/triangle, since the
            method takes corners only from the specified collection of points, but does not calculate such
            to form true bounding quadrilateral/triangle.</note></para>
            
            <para>See <see cref="P:AForge.Math.Geometry.PointsCloud.QuadrilateralRelativeDistortionLimit"/> property for additional information.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Math.Geometry.PointsCloud.QuadrilateralRelativeDistortionLimit">
            <summary>
            Relative distortion limit allowed for quadrilaterals, [0.0, 0.25].
            </summary>
            
            <remarks><para>The value of this property is used to calculate distortion limit used by
            <see cref="M:AForge.Math.Geometry.PointsCloud.FindQuadrilateralCorners(System.Collections.Generic.IEnumerable{AForge.IntPoint})"/>, when processing potential corners and making decision
            if the provided points form a quadrilateral or a triangle. The distortion limit is
            calculated as:
            <code lang="none">
            distrtionLimit = RelativeDistortionLimit * ( W * H ) / 2,
            </code>
            where <b>W</b> and <b>H</b> are width and height of the "points cloud" passed to the
            <see cref="M:AForge.Math.Geometry.PointsCloud.FindQuadrilateralCorners(System.Collections.Generic.IEnumerable{AForge.IntPoint})"/>.
            </para>
            
            <para>To explain the idea behind distortion limit, letâ€™s suppose that quadrilateral finder routine found
            the next candidates for corners:<br/>
            <img src="img/math/potential_corners.png" width="151" height="128"/><br/>
            As we can see on the above picture, the shape there potentially can be a triangle, but not quadrilateral
            (suppose that points list comes from a hand drawn picture or acquired from camera, so some
            inaccuracy may exist). It may happen that the <b>D</b> point is just a distortion (noise, etc).
            So the <see cref="M:AForge.Math.Geometry.PointsCloud.FindQuadrilateralCorners(System.Collections.Generic.IEnumerable{AForge.IntPoint})"/> check what is the distance between a potential corner
            (D in this case) and a line connecting two adjacent points (AB in this case). If the distance is smaller
            then the distortion limit, then the point may be rejected, so the shape turns into triangle.
            </para>
            
            <para>An exception is the case when both <b>C</b> and <b>D</b> points are very close to the <b>AB</b> line,
            so both their distances are less than distortion limit. In this case both points will be accepted as corners -
            the shape is just a flat quadrilateral.</para>
            
            <para>Default value is set to <b>0.1</b>.</para>
            </remarks>
            
        </member>
        <member name="T:AForge.Math.Geometry.Posit">
            <summary>
            3D pose estimation algorithm.
            </summary>
            
            <remarks><para>The class implements an algorithm for 3D object's pose estimation from it's
            2D coordinates obtained by perspective projection, when the object is described none coplanar points.
            The idea of the implemented math and algorithm is described in "Model-Based Object Pose in 25
            Lines of Code" paper written by Daniel F. DeMenthon and Larry S. Davis (the implementation of
            the algorithm is almost 1 to 1 translation of the pseudo code given by the paper, so should
            be easy to follow).</para>
            
            <para><note>At this point the implementation works only with models described by 4 points, which is
            the minimum number of points enough for 3D pose estimation.</note></para>
            
            <para><note>The 4 model's point <b>must not be coplanar</b>, i.e. must not reside all within
            same planer. See <see cref="T:AForge.Math.Geometry.CoplanarPosit"/> for coplanar case.</note></para>
            
            <para>Read <a href="http://www.aforgenet.com/articles/posit/">3D Pose Estimation</a> article for
            additional information and samples.</para>
            
            <para>Sample usage:</para>
            <code>
            // points of real object - model
            Vector3[] positObject = new Vector3[4]
            { 
                new Vector3(  28,  28, -28 ),
                new Vector3( -28,  28, -28 ),
                new Vector3(  28, -28, -28 ),
                new Vector3(  28,  28,  28 ),
            };
            // focal length of camera used to capture the object
            float focalLength = 640; // depends on your camera or projection system
            // initialize POSIT object
            Posit posit = new Posit( positObject, focalLength );
            
            // 2D points of te object - projection
            AForge.Point[] projectedPoints = new AForge.Point[4]
            {
                new AForge.Point(   -4,   29 ),
                new AForge.Point( -180,   86 ),
                new AForge.Point(   -5, -102 ),
                new AForge.Point(   76,  137 ),
            };
            // estimate pose
            Matrix3x3 rotationMatrix;
            Vector3 translationVector;
            posit.EstimatePose( projectedPoints,
                out rotationMatrix, out translationVector );
            </code>
            </remarks>
            
            <seealso cref="T:AForge.Math.Geometry.CoplanarPosit"/>
            
        </member>
        <member name="M:AForge.Math.Geometry.Posit.#ctor(AForge.Math.Vector3[],System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Math.Geometry.Posit"/> class.
            </summary>
            
            <param name="model">Array of vectors containing coordinates of four real model's point (points
            must not be on the same plane).</param>
            <param name="focalLength">Effective focal length of the camera used to capture the model.</param>
            
            <exception cref="T:System.ArgumentException">The model must have 4 points.</exception>
            
        </member>
        <member name="M:AForge.Math.Geometry.Posit.EstimatePose(AForge.Point[],AForge.Math.Matrix3x3@,AForge.Math.Vector3@)">
            <summary>
            Estimate pose of a model from it's projected 2D coordinates.
            </summary>
            
            <param name="points">4 2D points of the <see cref="P:AForge.Math.Geometry.Posit.Model">model's</see> projection.</param>
            <param name="rotation">Gets object's rotation.</param>
            <param name="translation">Gets object's translation.</param>
            
            <exception cref="T:System.ArgumentException">4 points must be be given for pose estimation.</exception>
            
        </member>
        <member name="P:AForge.Math.Geometry.Posit.Model">
            <summary>
            Coordinates of the model points which pose should be estimated.
            </summary>
        </member>
        <member name="P:AForge.Math.Geometry.Posit.FocalLength">
            <summary>
            Effective focal length of the camera used to capture the model.
            </summary>
        </member>
        <member name="T:AForge.Math.Geometry.ShapeType">
            <summary>
            Enumeration of some basic shape types.
            </summary>
        </member>
        <member name="F:AForge.Math.Geometry.ShapeType.Unknown">
            <summary>
            Unknown shape type.
            </summary>
        </member>
        <member name="F:AForge.Math.Geometry.ShapeType.Circle">
            <summary>
            Circle shape.
            </summary>
        </member>
        <member name="F:AForge.Math.Geometry.ShapeType.Triangle">
            <summary>
            Triangle shape.
            </summary>
        </member>
        <member name="F:AForge.Math.Geometry.ShapeType.Quadrilateral">
            <summary>
            Quadrilateral shape.
            </summary>
        </member>
        <member name="T:AForge.Math.Geometry.PolygonSubType">
            <summary>
            Some common sub types of some basic shapes.
            </summary>
        </member>
        <member name="F:AForge.Math.Geometry.PolygonSubType.Unknown">
            <summary>
            Unrecognized sub type of a shape (generic shape which does not have
            any specific sub type).
            </summary>
        </member>
        <member name="F:AForge.Math.Geometry.PolygonSubType.Trapezoid">
            <summary>
            Quadrilateral with one pair of parallel sides.
            </summary>
        </member>
        <member name="F:AForge.Math.Geometry.PolygonSubType.Parallelogram">
            <summary>
            Quadrilateral with two pairs of parallel sides.
            </summary>
        </member>
        <member name="F:AForge.Math.Geometry.PolygonSubType.Rectangle">
            <summary>
            Parallelogram with perpendicular adjacent sides.
            </summary>
        </member>
        <member name="F:AForge.Math.Geometry.PolygonSubType.Rhombus">
            <summary>
            Parallelogram with all sides equal.
            </summary>
        </member>
        <member name="F:AForge.Math.Geometry.PolygonSubType.Square">
            <summary>
            Rectangle with all sides equal.
            </summary>
        </member>
        <member name="F:AForge.Math.Geometry.PolygonSubType.EquilateralTriangle">
            <summary>
            Triangle with all sides/angles equal.
            </summary>
        </member>
        <member name="F:AForge.Math.Geometry.PolygonSubType.IsoscelesTriangle">
            <summary>
            Triangle with two sides/angles equal.
            </summary>
        </member>
        <member name="F:AForge.Math.Geometry.PolygonSubType.RectangledTriangle">
            <summary>
            Triangle with a 90 degrees angle.
            </summary>
        </member>
        <member name="F:AForge.Math.Geometry.PolygonSubType.RectangledIsoscelesTriangle">
            <summary>
            Triangle with a 90 degrees angle and other two angles are equal.
            </summary>
        </member>
        <member name="T:AForge.Math.Geometry.SimpleShapeChecker">
             <summary>
             A class for checking simple geometrical shapes.
             </summary>
             
             <remarks><para>The class performs checking/detection of some simple geometrical
             shapes for provided set of points (shape's edge points). During the check
             the class goes through the list of all provided points and checks how accurately
             they fit into assumed shape.</para>
             
             <para>All the shape checks allow some deviation of
             points from the shape with assumed parameters. In other words it is allowed
             that specified set of points may form a little bit distorted shape, which may be
             still recognized. The allowed amount of distortion is controlled by two
             properties (<see cref="P:AForge.Math.Geometry.SimpleShapeChecker.MinAcceptableDistortion"/> and <see cref="P:AForge.Math.Geometry.SimpleShapeChecker.RelativeDistortionLimit"/>),
             which allow higher distortion level for bigger shapes and smaller amount of
             distortion for smaller shapes. Checking specified set of points, the class
             calculates mean distance between specified set of points and edge of the assumed
             shape. If the mean distance is equal to or less than maximum allowed distance,
             then a shape is recognized. The maximum allowed distance is calculated as:
             <code lang="none">
             maxDistance = max( minAcceptableDistortion, relativeDistortionLimit * ( width + height ) / 2 )
             </code>
             , where <b>width</b> and <b>height</b> is the size of bounding rectangle for the
             specified points.
             </para>
             
             <para>See also <see cref="P:AForge.Math.Geometry.SimpleShapeChecker.AngleError"/> and <see cref="P:AForge.Math.Geometry.SimpleShapeChecker.LengthError"/> properties,
             which set acceptable errors for polygon sub type checking done by
             <see cref="M:AForge.Math.Geometry.SimpleShapeChecker.CheckPolygonSubType(System.Collections.Generic.List{AForge.IntPoint})"/> method.</para>
             
             <para><note>See the next article for details about the implemented algorithms:
             <a href="http://www.aforgenet.com/articles/shape_checker/">Detecting some simple shapes in images</a>.
             </note></para>
             
             <para>Sample usage:</para>
             <code>
             private List&lt;IntPoint&gt; idealCicle = new List&lt;IntPoint&gt;( );
             private List&lt;IntPoint&gt; distorredCircle = new List&lt;IntPoint&gt;( );
             System.Random rand = new System.Random( );
            
             // generate sample circles
             float radius = 100;
            
             for ( int i = 0; i &lt; 360; i += 10 )
             {
                 float angle = (float) ( (float) i / 180 * System.Math.PI );
             
                 // add point to ideal circle
                 idealCicle.Add( new IntPoint(
                     (int) ( radius * System.Math.Cos( angle ) ),
                     (int) ( radius * System.Math.Sin( angle ) ) ) );
             
                 // add a bit distortion for distorred cirlce
                 float distorredRadius = radius + rand.Next( 7 ) - 3;
             
                 distorredCircle.Add( new IntPoint(
                     (int) ( distorredRadius * System.Math.Cos( angle ) ),
                     (int) ( distorredRadius * System.Math.Sin( angle ) ) ) );
             }
             
             // check shape
             SimpleShapeChecker shapeChecker = new SimpleShapeChecker( );
             
             if ( shapeChecker.IsCircle( idealCicle ) )
             {
                 // ...
             }
             
             if ( shapeChecker.CheckShapeType( distorredCircle ) == ShapeType.Circle )
             {
                 // ...
             }
             </code>
             </remarks>
             
        </member>
        <member name="M:AForge.Math.Geometry.SimpleShapeChecker.CheckShapeType(System.Collections.Generic.List{AForge.IntPoint})">
            <summary>
            Check type of the shape formed by specified points.
            </summary>
            
            <param name="edgePoints">Shape's points to check.</param>
            
            <returns>Returns type of the detected shape.</returns>
            
        </member>
        <member name="M:AForge.Math.Geometry.SimpleShapeChecker.IsCircle(System.Collections.Generic.List{AForge.IntPoint})">
            <summary>
            Check if the specified set of points form a circle shape.
            </summary>
            
            <param name="edgePoints">Shape's points to check.</param>
            
            <returns>Returns <see langword="true"/> if the specified set of points form a
            circle shape or <see langword="false"/> otherwise.</returns>
            
            <remarks><para><note>Circle shape must contain at least 8 points to be recognized.
            The method returns <see langword="false"/> always, of number of points in the specified
            shape is less than 8.</note></para></remarks>
            
        </member>
        <member name="M:AForge.Math.Geometry.SimpleShapeChecker.IsCircle(System.Collections.Generic.List{AForge.IntPoint},AForge.Point@,System.Single@)">
            <summary>
            Check if the specified set of points form a circle shape.
            </summary>
            
            <param name="edgePoints">Shape's points to check.</param>
            <param name="center">Receives circle's center on successful return.</param>
            <param name="radius">Receives circle's radius on successful return.</param>
            
            <returns>Returns <see langword="true"/> if the specified set of points form a
            circle shape or <see langword="false"/> otherwise.</returns>
            
            <remarks><para><note>Circle shape must contain at least 8 points to be recognized.
            The method returns <see langword="false"/> always, of number of points in the specified
            shape is less than 8.</note></para></remarks>
            
        </member>
        <member name="M:AForge.Math.Geometry.SimpleShapeChecker.IsQuadrilateral(System.Collections.Generic.List{AForge.IntPoint})">
            <summary>
            Check if the specified set of points form a quadrilateral shape.
            </summary>
            
            <param name="edgePoints">Shape's points to check.</param>
            
            <returns>Returns <see langword="true"/> if the specified set of points form a
            quadrilateral shape or <see langword="false"/> otherwise.</returns>
            
        </member>
        <member name="M:AForge.Math.Geometry.SimpleShapeChecker.IsQuadrilateral(System.Collections.Generic.List{AForge.IntPoint},System.Collections.Generic.List{AForge.IntPoint}@)">
            <summary>
            Check if the specified set of points form a quadrilateral shape.
            </summary>
            
            <param name="edgePoints">Shape's points to check.</param>
            <param name="corners">List of quadrilateral corners on successful return.</param>
            
            <returns>Returns <see langword="true"/> if the specified set of points form a
            quadrilateral shape or <see langword="false"/> otherwise.</returns>
            
        </member>
        <member name="M:AForge.Math.Geometry.SimpleShapeChecker.IsTriangle(System.Collections.Generic.List{AForge.IntPoint})">
            <summary>
            Check if the specified set of points form a triangle shape.
            </summary>
            
            <param name="edgePoints">Shape's points to check.</param>
            
            <returns>Returns <see langword="true"/> if the specified set of points form a
            triangle shape or <see langword="false"/> otherwise.</returns>
            
        </member>
        <member name="M:AForge.Math.Geometry.SimpleShapeChecker.IsTriangle(System.Collections.Generic.List{AForge.IntPoint},System.Collections.Generic.List{AForge.IntPoint}@)">
            <summary>
            Check if the specified set of points form a triangle shape.
            </summary>
            
            <param name="edgePoints">Shape's points to check.</param>
            <param name="corners">List of triangle corners on successful return.</param>
            
            <returns>Returns <see langword="true"/> if the specified set of points form a
            triangle shape or <see langword="false"/> otherwise.</returns>
            
        </member>
        <member name="M:AForge.Math.Geometry.SimpleShapeChecker.IsConvexPolygon(System.Collections.Generic.List{AForge.IntPoint},System.Collections.Generic.List{AForge.IntPoint}@)">
            <summary>
            Check if the specified set of points form a convex polygon shape.
            </summary>
            
            <param name="edgePoints">Shape's points to check.</param>
            <param name="corners">List of polygon corners on successful return.</param>
            
            <returns>Returns <see langword="true"/> if the specified set of points form a
            convex polygon shape or <see langword="false"/> otherwise.</returns>
            
            <remarks><para><note>The method is able to detect only triangles and quadrilaterals
            for now. Check number of detected corners to resolve type of the detected polygon.
            </note></para></remarks>
            
        </member>
        <member name="M:AForge.Math.Geometry.SimpleShapeChecker.CheckPolygonSubType(System.Collections.Generic.List{AForge.IntPoint})">
            <summary>
            Check sub type of a convex polygon.
            </summary>
            
            <param name="corners">Corners of the convex polygon to check.</param>
            
            <returns>Return detected sub type of the specified shape.</returns>
            
            <remarks><para>The method check corners of a convex polygon detecting
            its subtype. Polygon's corners are usually retrieved using <see cref="M:AForge.Math.Geometry.SimpleShapeChecker.IsConvexPolygon(System.Collections.Generic.List{AForge.IntPoint},System.Collections.Generic.List{AForge.IntPoint}@)"/>
            method, but can be any list of 3-4 points (only sub types of triangles and
            quadrilateral are checked).</para>
            
            <para>See <see cref="P:AForge.Math.Geometry.SimpleShapeChecker.AngleError"/> and <see cref="P:AForge.Math.Geometry.SimpleShapeChecker.LengthError"/> properties,
            which set acceptable errors for polygon sub type checking.</para>
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Geometry.SimpleShapeChecker.CheckIfPointsFitShape(System.Collections.Generic.List{AForge.IntPoint},System.Collections.Generic.List{AForge.IntPoint})">
             <summary>
             Check if a shape specified by the set of points fits a convex polygon
             specified by the set of corners.
             </summary>
             
             <param name="edgePoints">Shape's points to check.</param>
             <param name="corners">Corners of convex polygon to check fitting into.</param>
            
             <returns>Returns <see langword="true"/> if the specified shape fits
             the specified convex polygon or <see langword="false"/> otherwise.</returns>
             
             <remarks><para>The method checks if the set of specified points form the same shape
             as the set of provided corners.</para></remarks>
             
        </member>
        <member name="P:AForge.Math.Geometry.SimpleShapeChecker.MinAcceptableDistortion">
            <summary>
            Minimum value of allowed shapes' distortion.
            </summary>
            
            <remarks><para>The property sets minimum value for allowed shapes'
            distortion (in pixels). See documentation to <see cref="T:AForge.Math.Geometry.SimpleShapeChecker"/>
            class for more details about this property.</para>
            
            <para>Default value is set to <b>0.5</b>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Math.Geometry.SimpleShapeChecker.RelativeDistortionLimit">
            <summary>
            Maximum value of allowed shapes' distortion, [0, 1].
            </summary>
            
            <remarks><para>The property sets maximum value for allowed shapes'
            distortion. The value is measured in [0, 1] range, which corresponds
            to [0%, 100%] range, which means that maximum allowed shapes'
            distortion is calculated relatively to shape's size. This results to
            higher allowed distortion level for bigger shapes and smaller allowed
            distortion for smaller shapers. See documentation to <see cref="T:AForge.Math.Geometry.SimpleShapeChecker"/>
            class for more details about this property.</para>
            
            <para>Default value is set to <b>0.03</b> (3%).</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Math.Geometry.SimpleShapeChecker.AngleError">
            <summary>
            Maximum allowed angle error in degrees, [0, 20].
            </summary>
            
            <remarks><para>The value sets maximum allowed difference between two angles to
            treat them as equal. It is used by <see cref="M:AForge.Math.Geometry.SimpleShapeChecker.CheckPolygonSubType(System.Collections.Generic.List{AForge.IntPoint})"/> method to
            check for parallel lines and angles of triangles and quadrilaterals.
            For example, if angle between two lines equals 5 degrees and this properties value
            is set to 7, then two compared lines are treated as parallel.</para>
            
            <para>Default value is set to <b>7</b>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Math.Geometry.SimpleShapeChecker.LengthError">
             <summary>
             Maximum allowed difference in sides' length (relative to shapes' size), [0, 1].
             </summary>
            
             <remarks><para>The values sets maximum allowed difference between two sides' length
             to treat them as equal. The error value is set relative to shapes size and measured
             in [0, 1] range, which corresponds to [0%, 100%] range. Absolute length error in pixels
             is calculated as:
             <code lang="none">
             LengthError * ( width + height ) / 2
             </code>
             , where <b>width</b> and <b>height</b> is the size of bounding rectangle for the
             specified shape.
             </para>
             
             <para>Default value is set to <b>0.1</b> (10%).</para>
             </remarks>
            
        </member>
        <member name="T:AForge.Math.Histogram">
             <summary>
             Histogram for discrete random values.
             </summary>
             
             <remarks><para>The class wraps histogram for discrete stochastic function, which is represented
             by integer array, where indexes of the array are treated as values of the stochastic function,
             but array values are treated as "probabilities" (total amount of hits).
             </para>
             
             <para>Sample usage:</para>
             <code>
             // create histogram
             Histogram histogram = new Histogram( new int[10] { 0, 0, 1, 3, 6, 8, 11, 0, 0, 0 } );
             // get mean and standard deviation values
             Console.WriteLine( "mean = " + histogram.Mean + ", std.dev = " + histogram.StdDev );
             </code>
             </remarks>
            
        </member>
        <member name="M:AForge.Math.Histogram.#ctor(System.Int32[])">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Math.Histogram"/> class.
            </summary>
            
            <param name="values">Values of the histogram.</param>
            
            <remarks><para>Indexes of the input array are treated as values of stochastic function,
            but array values are treated as "probabilities" (total amount of hits).
            </para></remarks>
            
        </member>
        <member name="M:AForge.Math.Histogram.GetRange(System.Double)">
            <summary>
            Get range around median containing specified percentage of values.
            </summary>
            
            <param name="percent">Values percentage around median.</param>
            
            <returns>Returns the range which containes specifies percentage of values.</returns>
            
            <remarks><para>The method calculates range of stochastic variable, which summary probability
            comprises the specified percentage of histogram's hits.</para>
            
            <para>Sample usage:</para>
            <code>
            // create histogram
            Histogram histogram = new Histogram( new int[10] { 0, 0, 1, 3, 6, 8, 11, 0, 0, 0 } );
            // get 50% range
            IntRange range = histogram.GetRange( 0.5 );
            // show the range ([4, 6])
            Console.WriteLine( "50% range = [" + range.Min + ", " + range.Max + "]" );
            </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Histogram.Update">
            <summary>
            Update statistical value of the histogram.
            </summary>
            
            <remarks>The method recalculates statistical values of the histogram, like mean,
            standard deviation, etc., in the case if histogram's values were changed directly.
            The method should be called only in the case if histogram's values were retrieved
            through <see cref="P:AForge.Math.Histogram.Values"/> property and updated after that.
            </remarks>
            
        </member>
        <member name="P:AForge.Math.Histogram.Values">
            <summary>
            Values of the histogram.
            </summary>
            
            <remarks><para>Indexes of this array are treated as values of stochastic function,
            but array values are treated as "probabilities" (total amount of hits).
            </para></remarks>
            
        </member>
        <member name="P:AForge.Math.Histogram.Mean">
            <summary>
            Mean value.
            </summary>
            
            <remarks><para>The property allows to retrieve mean value of the histogram.</para>
            
            <para>Sample usage:</para>
            <code>
            // create histogram
            Histogram histogram = new Histogram( new int[10] { 0, 0, 1, 3, 6, 8, 11, 0, 0, 0 } );
            // get mean value (= 4.862)
            Console.WriteLine( "mean = " + histogram.Mean.ToString( "F3" ) );
            </code>
            </remarks>
            
        </member>
        <member name="P:AForge.Math.Histogram.StdDev">
            <summary>
            Standard deviation.
            </summary>
            
            <remarks><para>The property allows to retrieve standard deviation value of the histogram.</para>
            
            <para>Sample usage:</para>
            <code>
            // create histogram
            Histogram histogram = new Histogram( new int[10] { 0, 0, 1, 3, 6, 8, 11, 0, 0, 0 } );
            // get std.dev. value (= 1.136)
            Console.WriteLine( "std.dev. = " + histogram.StdDev.ToString( "F3" ) );
            </code>
            </remarks>
            
        </member>
        <member name="P:AForge.Math.Histogram.Median">
            <summary>
            Median value.
            </summary>
            
            <remarks><para>The property allows to retrieve median value of the histogram.</para>
            
            <para>Sample usage:</para>
            <code>
            // create histogram
            Histogram histogram = new Histogram( new int[10] { 0, 0, 1, 3, 6, 8, 11, 0, 0, 0 } );
            // get median value (= 5)
            Console.WriteLine( "median = " + histogram.Median );
            </code>
            </remarks>
            
        </member>
        <member name="P:AForge.Math.Histogram.Min">
            <summary>
            Minimum value.
            </summary>
            
            <remarks><para>The property allows to retrieve minimum value of the histogram with non zero
            hits count.</para>
            
            <para>Sample usage:</para>
            <code>
            // create histogram
            Histogram histogram = new Histogram( new int[10] { 0, 0, 1, 3, 6, 8, 11, 0, 0, 0 } );
            // get min value (= 2)
            Console.WriteLine( "min = " + histogram.Min );
            </code>
            </remarks>
            
        </member>
        <member name="P:AForge.Math.Histogram.Max">
            <summary>
            Maximum value.
            </summary>
            
            <remarks><para>The property allows to retrieve maximum value of the histogram with non zero
            hits count.</para>
            
            <para>Sample usage:</para>
            <code>
            // create histogram
            Histogram histogram = new Histogram( new int[10] { 0, 0, 1, 3, 6, 8, 11, 0, 0, 0 } );
            // get max value (= 6)
            Console.WriteLine( "max = " + histogram.Max );
            </code>
            </remarks>
            
        </member>
        <member name="P:AForge.Math.Histogram.TotalCount">
             <summary>
             Total count of values.
             </summary>
             
             <remarks><para>The property represents total count of values contributed to the histogram, which is
             essentially sum of the <see cref="P:AForge.Math.Histogram.Values"/> array.</para>
            
             <para>Sample usage:</para>
             <code>
             // create histogram
             Histogram histogram = new Histogram( new int[10] { 0, 0, 1, 3, 6, 8, 11, 0, 0, 0 } );
             // get total value (= 29)
             Console.WriteLine( "total = " + histogram.TotalCount );
             </code>
             </remarks>
             
        </member>
        <member name="T:AForge.Math.Matrix3x3">
            <summary>
            A structure representing 3x3 matrix.
            </summary>
            
            <remarks><para>The structure incapsulates elements of a 3x3 matrix and
            provides some operations with it.</para></remarks>
            
        </member>
        <member name="F:AForge.Math.Matrix3x3.V00">
            <summary>
            Row 0 column 0 element of the matrix.
            </summary>
        </member>
        <member name="F:AForge.Math.Matrix3x3.V01">
            <summary>
            Row 0 column 1 element of the matrix.
            </summary>
        </member>
        <member name="F:AForge.Math.Matrix3x3.V02">
            <summary>
            Row 0 column 2 element of the matrix.
            </summary>
        </member>
        <member name="F:AForge.Math.Matrix3x3.V10">
            <summary>
            Row 1 column 0 element of the matrix.
            </summary>
        </member>
        <member name="F:AForge.Math.Matrix3x3.V11">
            <summary>
            Row 1 column 1 element of the matrix.
            </summary>
        </member>
        <member name="F:AForge.Math.Matrix3x3.V12">
            <summary>
            Row 1 column 2 element of the matrix.
            </summary>
        </member>
        <member name="F:AForge.Math.Matrix3x3.V20">
            <summary>
            Row 2 column 0 element of the matrix.
            </summary>
        </member>
        <member name="F:AForge.Math.Matrix3x3.V21">
            <summary>
            Row 2 column 1 element of the matrix.
            </summary>
        </member>
        <member name="F:AForge.Math.Matrix3x3.V22">
            <summary>
            Row 2 column 2 element of the matrix.
            </summary>
        </member>
        <member name="M:AForge.Math.Matrix3x3.ToArray">
            <summary>
            Returns array representation of the matrix.
            </summary>
            
            <returns>Returns array which contains all elements of the matrix in the row-major order.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.CreateRotationY(System.Single)">
            <summary>
            Creates rotation matrix around Y axis.
            </summary>
            
            <param name="radians">Rotation angle around Y axis in radians.</param>
            
            <returns>Returns rotation matrix to rotate an object around Y axis.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.CreateRotationX(System.Single)">
            <summary>
            Creates rotation matrix around X axis.
            </summary>
            
            <param name="radians">Rotation angle around X axis in radians.</param>
            
            <returns>Returns rotation matrix to rotate an object around X axis.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.CreateRotationZ(System.Single)">
            <summary>
            Creates rotation matrix around Z axis.
            </summary>
            
            <param name="radians">Rotation angle around Z axis in radians.</param>
            
            <returns>Returns rotation matrix to rotate an object around Z axis.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.CreateFromYawPitchRoll(System.Single,System.Single,System.Single)">
            <summary>
            Creates rotation matrix to rotate an object around X, Y and Z axes.
            </summary>
            
            <param name="yaw">Rotation angle around Y axis in radians.</param>
            <param name="pitch">Rotation angle around X axis in radians.</param>
            <param name="roll">Rotation angle around Z axis in radians.</param>
            
            <returns>Returns rotation matrix to rotate an object around all 3 axes.</returns>
            
            <remarks>
            <para><note>The routine assumes roll-pitch-yaw rotation order, when creating rotation
            matrix, i.e. an object is first rotated around Z axis, then around X axis and finally around
            Y axis.</note></para>
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.ExtractYawPitchRoll(System.Single@,System.Single@,System.Single@)">
            <summary>
            Extract rotation angles from the rotation matrix.
            </summary>
            
            <param name="yaw">Extracted rotation angle around Y axis in radians.</param>
            <param name="pitch">Extracted rotation angle around X axis in radians.</param>
            <param name="roll">Extracted rotation angle around Z axis in radians.</param>
            
            <remarks><para><note>The routine assumes roll-pitch-yaw rotation order when extracting rotation angle.
            Using extracted angles with the <see cref="M:AForge.Math.Matrix3x3.CreateFromYawPitchRoll(System.Single,System.Single,System.Single)"/> should provide same rotation matrix.
            </note></para>
            
            <para><note>The method assumes the provided matrix represent valid rotation matrix.</note></para>
            
            <para>Sample usage:</para>
            <code>
            // assume we have a rotation matrix created like this
            float yaw   = 10.0f / 180 * Math.PI;
            float pitch = 30.0f / 180 * Math.PI;
            float roll  = 45.0f / 180 * Math.PI;
            
            Matrix3x3 rotationMatrix = Matrix3x3.CreateFromYawPitchRoll( yaw, pitch, roll );
            // ...
            
            // now somewhere in the code you may want to get rotation
            // angles back from a matrix assuming same rotation order
            float extractedYaw;
            float extractedPitch;
            float extractedRoll;
            
            rotation.ExtractYawPitchRoll( out extractedYaw, out extractedPitch, out extractedRoll );
            </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.CreateFromRows(AForge.Math.Vector3,AForge.Math.Vector3,AForge.Math.Vector3)">
            <summary>
            Creates a matrix from 3 rows specified as vectors.
            </summary>
            
            <param name="row0">First row of the matrix to create.</param>
            <param name="row1">Second row of the matrix to create.</param>
            <param name="row2">Third row of the matrix to create.</param>
            
            <returns>Returns a matrix from specified rows.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.CreateFromColumns(AForge.Math.Vector3,AForge.Math.Vector3,AForge.Math.Vector3)">
            <summary>
            Creates a matrix from 3 columns specified as vectors.
            </summary>
            
            <param name="column0">First column of the matrix to create.</param>
            <param name="column1">Second column of the matrix to create.</param>
            <param name="column2">Third column of the matrix to create.</param>
            
            <returns>Returns a matrix from specified columns.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.CreateDiagonal(AForge.Math.Vector3)">
            <summary>
            Creates a diagonal matrix using the specified vector as diagonal elements.
            </summary>
            
            <param name="vector">Vector to use for diagonal elements of the matrix.</param>
            
            <returns>Returns a diagonal matrix.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.GetRow(System.Int32)">
            <summary>
            Get row of the matrix.
            </summary>
            
            <param name="index">Row index to get, [0, 2].</param>
            
            <returns>Returns specified row of the matrix as a vector.</returns>
            
            <exception cref="T:System.ArgumentException">Invalid row index was specified.</exception>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.GetColumn(System.Int32)">
            <summary>
            Get column of the matrix.
            </summary>
            
            <param name="index">Column index to get, [0, 2].</param>
            
            <returns>Returns specified column of the matrix as a vector.</returns>
            
            <exception cref="T:System.ArgumentException">Invalid column index was specified.</exception>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.op_Multiply(AForge.Math.Matrix3x3,AForge.Math.Matrix3x3)">
            <summary>
            Multiplies two specified matrices.
            </summary>
            
            <param name="matrix1">Matrix to multiply.</param>
            <param name="matrix2">Matrix to multiply by.</param>
            
            <returns>Return new matrix, which the result of multiplication of the two specified matrices.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.Multiply(AForge.Math.Matrix3x3,AForge.Math.Matrix3x3)">
            <summary>
            Multiplies two specified matrices.
            </summary>
            
            <param name="matrix1">Matrix to multiply.</param>
            <param name="matrix2">Matrix to multiply by.</param>
            
            <returns>Return new matrix, which the result of multiplication of the two specified matrices.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.op_Addition(AForge.Math.Matrix3x3,AForge.Math.Matrix3x3)">
             <summary>
             Adds corresponding components of two matrices.
             </summary>
             
             <param name="matrix1">The matrix to add to.</param>
             <param name="matrix2">The matrix to add to the first matrix.</param>
             
             <returns>Returns a matrix which components are equal to sum of corresponding
             components of the two specified matrices.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.Add(AForge.Math.Matrix3x3,AForge.Math.Matrix3x3)">
             <summary>
             Adds corresponding components of two matrices.
             </summary>
             
             <param name="matrix1">The matrix to add to.</param>
             <param name="matrix2">The matrix to add to the first matrix.</param>
             
             <returns>Returns a matrix which components are equal to sum of corresponding
             components of the two specified matrices.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.op_Subtraction(AForge.Math.Matrix3x3,AForge.Math.Matrix3x3)">
             <summary>
             Subtracts corresponding components of two matrices.
             </summary>
             
             <param name="matrix1">The matrix to subtract from.</param>
             <param name="matrix2">The matrix to subtract from the first matrix.</param>
             
             <returns>Returns a matrix which components are equal to difference of corresponding
             components of the two specified matrices.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.Subtract(AForge.Math.Matrix3x3,AForge.Math.Matrix3x3)">
             <summary>
             Subtracts corresponding components of two matrices.
             </summary>
             
             <param name="matrix1">The matrix to subtract from.</param>
             <param name="matrix2">The matrix to subtract from the first matrix.</param>
             
             <returns>Returns a matrix which components are equal to difference of corresponding
             components of the two specified matrices.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.op_Multiply(AForge.Math.Matrix3x3,AForge.Math.Vector3)">
             <summary>
             Multiplies specified matrix by the specified vector.
             </summary>
             
             <param name="matrix">Matrix to multiply by vector.</param>
             <param name="vector">Vector to multiply matrix by.</param>
             
             <returns>Returns new vector which is the result of multiplication of the specified matrix
             by the specified vector.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.Multiply(AForge.Math.Matrix3x3,AForge.Math.Vector3)">
             <summary>
             Multiplies specified matrix by the specified vector.
             </summary>
             
             <param name="matrix">Matrix to multiply by vector.</param>
             <param name="vector">Vector to multiply matrix by.</param>
             
             <returns>Returns new vector which is the result of multiplication of the specified matrix
             by the specified vector.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.op_Multiply(AForge.Math.Matrix3x3,System.Single)">
            <summary>
            Multiplies matrix by the specified factor.
            </summary>
            
            <param name="matrix">Matrix to multiply.</param>
            <param name="factor">Factor to multiple the specified matrix by.</param>
            
            <returns>Returns new matrix with all components equal to corresponding components of the
            specified matrix multiples by the specified factor.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.Multiply(AForge.Math.Matrix3x3,System.Single)">
            <summary>
            Multiplies matrix by the specified factor.
            </summary>
            
            <param name="matrix">Matrix to multiply.</param>
            <param name="factor">Factor to multiple the specified matrix by.</param>
            
            <returns>Returns new matrix with all components equal to corresponding components of the
            specified matrix multiples by the specified factor.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.op_Addition(AForge.Math.Matrix3x3,System.Single)">
            <summary>
            Adds specified value to all components of the specified matrix.
            </summary>
            
            <param name="matrix">Matrix to add value to.</param>
            <param name="value">Value to add to all components of the specified matrix.</param>
            
            <returns>Returns new matrix with all components equal to corresponding components of the
            specified matrix increased by the specified value.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.Add(AForge.Math.Matrix3x3,System.Single)">
            <summary>
            Adds specified value to all components of the specified matrix.
            </summary>
            
            <param name="matrix">Matrix to add value to.</param>
            <param name="value">Value to add to all components of the specified matrix.</param>
            
            <returns>Returns new matrix with all components equal to corresponding components of the
            specified matrix increased by the specified value.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.op_Equality(AForge.Math.Matrix3x3,AForge.Math.Matrix3x3)">
            <summary>
            Tests whether two specified matrices are equal.
            </summary>
            
            <param name="matrix1">The left-hand matrix.</param>
            <param name="matrix2">The right-hand matrix.</param>
            
            <returns>Returns <see langword="true"/> if the two matrices are equal or <see langword="false"/> otherwise.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.op_Inequality(AForge.Math.Matrix3x3,AForge.Math.Matrix3x3)">
            <summary>
            Tests whether two specified matrices are not equal.
            </summary>
            
            <param name="matrix1">The left-hand matrix.</param>
            <param name="matrix2">The right-hand matrix.</param>
            
            <returns>Returns <see langword="true"/> if the two matrices are not equal or <see langword="false"/> otherwise.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.Equals(AForge.Math.Matrix3x3)">
            <summary>
            Tests whether the matrix equals to the specified one.
            </summary>
            
            <param name="matrix">The matrix to test equality with.</param>
            
            <returns>Returns <see langword="true"/> if the two matrices are equal or <see langword="false"/> otherwise.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.Equals(System.Object)">
            <summary>
            Tests whether the matrix equals to the specified object.
            </summary>
            
            <param name="obj">The object to test equality with.</param>
            
            <returns>Returns <see langword="true"/> if the matrix equals to the specified object or <see langword="false"/> otherwise.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.GetHashCode">
            <summary>
            Returns the hashcode for this instance.
            </summary>
            
            <returns>A 32-bit signed integer hash code.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.Transpose">
            <summary>
            Transpose the matrix, A<sup>T</sup>.
            </summary>
            
            <returns>Return a matrix which equals to transposition of this matrix.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.MultiplySelfByTranspose">
             <summary>
             Multiply the matrix by its transposition, A*A<sup>T</sup>.
             </summary>
             
             <returns>Returns a matrix which is the result of multiplying this matrix by its transposition.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.MultiplyTransposeBySelf">
             <summary>
             Multiply transposition of this matrix by itself, A<sup>T</sup>*A.
             </summary>
             
             <returns>Returns a matrix which is the result of multiplying this matrix's transposition by itself.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.Adjugate">
            <summary>
            Calculate adjugate of the matrix, adj(A).
            </summary>
            
            <returns>Returns adjugate of the matrix.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.Inverse">
            <summary>
            Calculate inverse of the matrix, A<sup>-1</sup>.
            </summary>
            
            <returns>Returns inverse of the matrix.</returns>
            
            <exception cref="T:System.ArgumentException">Cannot calculate inverse of the matrix since it is singular.</exception>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.PseudoInverse">
            <summary>
            Calculate pseudo inverse of the matrix, A<sup>+</sup>.
            </summary>
            
            <returns>Returns pseudo inverse of the matrix.</returns>
            
            <remarks><para>The pseudo inverse of the matrix is calculate through its <see cref="M:AForge.Math.Matrix3x3.SVD(AForge.Math.Matrix3x3@,AForge.Math.Vector3@,AForge.Math.Matrix3x3@)"/>
            as V*E<sup>+</sup>*U<sup>T</sup>.</para></remarks>
            
        </member>
        <member name="M:AForge.Math.Matrix3x3.SVD(AForge.Math.Matrix3x3@,AForge.Math.Vector3@,AForge.Math.Matrix3x3@)">
            <summary>
            Calculate Singular Value Decomposition (SVD) of the matrix, such as A=U*E*V<sup>T</sup>.
            </summary>
            
            <param name="u">Output parameter which gets 3x3 U matrix.</param>
            <param name="e">Output parameter which gets diagonal elements of the E matrix.</param>
            <param name="v">Output parameter which gets 3x3 V matrix.</param>
            
            <remarks><para>Having components U, E and V the source matrix can be reproduced using below code:
            <code>
            Matrix3x3 source = u * Matrix3x3.Diagonal( e ) * v.Transpose( );
            </code>
            </para></remarks>
            
        </member>
        <member name="P:AForge.Math.Matrix3x3.Identity">
            <summary>
            Provides an identity matrix with all diagonal elements set to 1.
            </summary>
        </member>
        <member name="P:AForge.Math.Matrix3x3.Determinant">
            <summary>
            Calculates determinant of the matrix.
            </summary>
        </member>
        <member name="T:AForge.Math.Matrix4x4">
            <summary>
            A structure representing 4x4 matrix.
            </summary>
            
            <remarks><para>The structure incapsulates elements of a 4x4 matrix and
            provides some operations with it.</para></remarks>
            
        </member>
        <member name="F:AForge.Math.Matrix4x4.V00">
            <summary>
            Row 0 column 0 element of the matrix.
            </summary>
            
        </member>
        <member name="F:AForge.Math.Matrix4x4.V01">
            <summary>
            Row 0 column 1 element of the matrix.
            </summary>
        </member>
        <member name="F:AForge.Math.Matrix4x4.V02">
            <summary>
            Row 0 column 2 element of the matrix.
            </summary>
        </member>
        <member name="F:AForge.Math.Matrix4x4.V03">
            <summary>
            Row 0 column 3 element of the matrix.
            </summary>
            
        </member>
        <member name="F:AForge.Math.Matrix4x4.V10">
            <summary>
            Row 1 column 0 element of the matrix.
            </summary>
            
        </member>
        <member name="F:AForge.Math.Matrix4x4.V11">
            <summary>
            Row 1 column 1 element of the matrix.
            </summary>
            
        </member>
        <member name="F:AForge.Math.Matrix4x4.V12">
            <summary>
            Row 1 column 2 element of the matrix.
            </summary>
            
        </member>
        <member name="F:AForge.Math.Matrix4x4.V13">
            <summary>
            Row 1 column 3 element of the matrix.
            </summary>
            
        </member>
        <member name="F:AForge.Math.Matrix4x4.V20">
            <summary>
            Row 2 column 0 element of the matrix.
            </summary>
            
        </member>
        <member name="F:AForge.Math.Matrix4x4.V21">
            <summary>
            Row 2 column 1 element of the matrix.
            </summary>
            
        </member>
        <member name="F:AForge.Math.Matrix4x4.V22">
            <summary>
            Row 2 column 2 element of the matrix.
            </summary>
        </member>
        <member name="F:AForge.Math.Matrix4x4.V23">
            <summary>
            Row 2 column 3 element of the matrix.
            </summary>
        </member>
        <member name="F:AForge.Math.Matrix4x4.V30">
            <summary>
            Row 3 column 0 element of the matrix.
            </summary>
            
        </member>
        <member name="F:AForge.Math.Matrix4x4.V31">
            <summary>
            Row 3 column 1 element of the matrix.
            </summary>
            
        </member>
        <member name="F:AForge.Math.Matrix4x4.V32">
            <summary>
            Row 3 column 2 element of the matrix.
            </summary>
            
        </member>
        <member name="F:AForge.Math.Matrix4x4.V33">
            <summary>
            Row 3 column 3 element of the matrix.
            </summary>
            
        </member>
        <member name="M:AForge.Math.Matrix4x4.ToArray">
            <summary>
            Returns array representation of the matrix.
            </summary>
            
            <returns>Returns array which contains all elements of the matrix in the row-major order.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix4x4.CreateRotationY(System.Single)">
            <summary>
            Creates rotation matrix around Y axis.
            </summary>
            
            <param name="radians">Rotation angle around Y axis in radians.</param>
            
            <returns>Returns rotation matrix to rotate an object around Y axis.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix4x4.CreateRotationX(System.Single)">
            <summary>
            Creates rotation matrix around X axis.
            </summary>
            
            <param name="radians">Rotation angle around X axis in radians.</param>
            
            <returns>Returns rotation matrix to rotate an object around X axis.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix4x4.CreateRotationZ(System.Single)">
            <summary>
            Creates rotation matrix around Z axis.
            </summary>
            
            <param name="radians">Rotation angle around Z axis in radians.</param>
            
            <returns>Returns rotation matrix to rotate an object around Z axis.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix4x4.CreateFromYawPitchRoll(System.Single,System.Single,System.Single)">
            <summary>
            Creates rotation matrix to rotate an object around X, Y and Z axes.
            </summary>
            
            <param name="yaw">Rotation angle around Y axis in radians.</param>
            <param name="pitch">Rotation angle around X axis in radians.</param>
            <param name="roll">Rotation angle around Z axis in radians.</param>
            
            <returns>Returns rotation matrix to rotate an object around all 3 axes.</returns>
            
            <remarks>
            <para><note>The routine assumes roll-pitch-yaw rotation order, when creating rotation
            matrix, i.e. an object is first rotated around Z axis, then around X axis and finally around
            Y axis.</note></para>
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Matrix4x4.ExtractYawPitchRoll(System.Single@,System.Single@,System.Single@)">
            <summary>
            Extract rotation angles from the rotation matrix.
            </summary>
            
            <param name="yaw">Extracted rotation angle around Y axis in radians.</param>
            <param name="pitch">Extracted rotation angle around X axis in radians.</param>
            <param name="roll">Extracted rotation angle around Z axis in radians.</param>
            
            <remarks><para><note>The routine assumes roll-pitch-yaw rotation order when extracting rotation angle.
            Using extracted angles with the <see cref="M:AForge.Math.Matrix4x4.CreateFromYawPitchRoll(System.Single,System.Single,System.Single)"/> should provide same rotation matrix.
            </note></para>
            
            <para><note>The method assumes the provided matrix represent valid rotation matrix.</note></para>
            
            <para>Sample usage:</para>
            <code>
            // assume we have a rotation matrix created like this
            float yaw   = 10.0f / 180 * Math.PI;
            float pitch = 30.0f / 180 * Math.PI;
            float roll  = 45.0f / 180 * Math.PI;
            
            Matrix4x4 rotationMatrix = Matrix3x3.CreateFromYawPitchRoll( yaw, pitch, roll );
            // ...
            
            // now somewhere in the code you may want to get rotation
            // angles back from a matrix assuming same rotation order
            float extractedYaw;
            float extractedPitch;
            float extractedRoll;
            
            rotation.ExtractYawPitchRoll( out extractedYaw, out extractedPitch, out extractedRoll );
            </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Matrix4x4.CreateFromRotation(AForge.Math.Matrix3x3)">
            <summary>
            Creates 4x4 tranformation matrix from 3x3 rotation matrix.
            </summary>
            
            <param name="rotationMatrix">Source 3x3 rotation matrix.</param>
            
            <returns>Returns 4x4 rotation matrix.</returns>
            
            <remarks><para>The source 3x3 rotation matrix is copied into the top left corner of the result 4x4 matrix,
            i.e. it represents 0th, 1st and 2nd row/column. The <see cref="F:AForge.Math.Matrix4x4.V33"/> element is set to 1 and the rest
            elements of 3rd row and 3rd column are set to zeros.</para></remarks>
            
        </member>
        <member name="M:AForge.Math.Matrix4x4.CreateTranslation(AForge.Math.Vector3)">
            <summary>
            Creates translation matrix for the specified movement amount.
            </summary>
            
            <param name="position">Vector which set direction and amount of movement.</param>
            
            <returns>Returns translation matrix.</returns>
            
            <remarks><para>The specified vector is copied to the 3rd column of the result matrix.
            All diagonal elements are set to 1. The rest of matrix is initialized with zeros.</para></remarks>
            
        </member>
        <member name="M:AForge.Math.Matrix4x4.CreateLookAt(AForge.Math.Vector3,AForge.Math.Vector3)">
            <summary>
            Creates a view matrix for the specified camera position and target point.
            </summary>
            
            <param name="cameraPosition">Position of camera.</param>
            <param name="cameraTarget">Target point towards which camera is pointing.</param>
            
            <returns>Returns a view matrix.</returns>
            
            <remarks><para>Camera's "up" vector is supposed to be (0, 1, 0).</para></remarks>
            
        </member>
        <member name="M:AForge.Math.Matrix4x4.CreatePerspective(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Creates a perspective projection matrix.
            </summary>
            
            <param name="width">Width of the view volume at the near view plane.</param>
            <param name="height">Height of the view volume at the near view plane.</param>
            <param name="nearPlaneDistance">Distance to the near view plane.</param>
            <param name="farPlaneDistance">Distance to the far view plane.</param>
            
            <returns>Return a perspective projection matrix.</returns>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Both near and far view planes' distances must be greater than zero.</exception>
            <exception cref="T:System.ArgumentException">Near plane must be closer than the far plane.</exception>
            
        </member>
        <member name="M:AForge.Math.Matrix4x4.CreateFromRows(AForge.Math.Vector4,AForge.Math.Vector4,AForge.Math.Vector4,AForge.Math.Vector4)">
            <summary>
            Creates a matrix from 4 rows specified as vectors.
            </summary>
            
            <param name="row0">First row of the matrix to create.</param>
            <param name="row1">Second row of the matrix to create.</param>
            <param name="row2">Third row of the matrix to create.</param>
            <param name="row3">Fourth row of the matrix to create.</param>
            
            <returns>Returns a matrix from specified rows.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix4x4.CreateFromColumns(AForge.Math.Vector4,AForge.Math.Vector4,AForge.Math.Vector4,AForge.Math.Vector4)">
            <summary>
            Creates a matrix from 4 columns specified as vectors.
            </summary>
            
            <param name="column0">First column of the matrix to create.</param>
            <param name="column1">Second column of the matrix to create.</param>
            <param name="column2">Third column of the matrix to create.</param>
            <param name="column3">Fourth column of the matrix to create.</param>
            
            <returns>Returns a matrix from specified columns.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix4x4.CreateDiagonal(AForge.Math.Vector4)">
            <summary>
            Creates a diagonal matrix using the specified vector as diagonal elements.
            </summary>
            
            <param name="vector">Vector to use for diagonal elements of the matrix.</param>
            
            <returns>Returns a diagonal matrix.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix4x4.GetRow(System.Int32)">
            <summary>
            Get row of the matrix.
            </summary>
            
            <param name="index">Row index to get, [0, 3].</param>
            
            <returns>Returns specified row of the matrix as a vector.</returns>
            
            <exception cref="T:System.ArgumentException">Invalid row index was specified.</exception>
            
        </member>
        <member name="M:AForge.Math.Matrix4x4.GetColumn(System.Int32)">
            <summary>
            Get column of the matrix.
            </summary>
            
            <param name="index">Column index to get, [0, 3].</param>
            
            <returns>Returns specified column of the matrix as a vector.</returns>
            
            <exception cref="T:System.ArgumentException">Invalid column index was specified.</exception>
            
        </member>
        <member name="M:AForge.Math.Matrix4x4.op_Multiply(AForge.Math.Matrix4x4,AForge.Math.Matrix4x4)">
            <summary>
            Multiplies two specified matrices.
            </summary>
            
            <param name="matrix1">Matrix to multiply.</param>
            <param name="matrix2">Matrix to multiply by.</param>
            
            <returns>Return new matrix, which the result of multiplication of the two specified matrices.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix4x4.Multiply(AForge.Math.Matrix4x4,AForge.Math.Matrix4x4)">
            <summary>
            Multiplies two specified matrices.
            </summary>
            
            <param name="matrix1">Matrix to multiply.</param>
            <param name="matrix2">Matrix to multiply by.</param>
            
            <returns>Return new matrix, which the result of multiplication of the two specified matrices.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix4x4.op_Addition(AForge.Math.Matrix4x4,AForge.Math.Matrix4x4)">
             <summary>
             Adds corresponding components of two matrices.
             </summary>
             
             <param name="matrix1">The matrix to add to.</param>
             <param name="matrix2">The matrix to add to the first matrix.</param>
             
             <returns>Returns a matrix which components are equal to sum of corresponding
             components of the two specified matrices.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix4x4.Add(AForge.Math.Matrix4x4,AForge.Math.Matrix4x4)">
             <summary>
             Adds corresponding components of two matrices.
             </summary>
             
             <param name="matrix1">The matrix to add to.</param>
             <param name="matrix2">The matrix to add to the first matrix.</param>
             
             <returns>Returns a matrix which components are equal to sum of corresponding
             components of the two specified matrices.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix4x4.op_Subtraction(AForge.Math.Matrix4x4,AForge.Math.Matrix4x4)">
             <summary>
             Subtracts corresponding components of two matrices.
             </summary>
             
             <param name="matrix1">The matrix to subtract from.</param>
             <param name="matrix2">The matrix to subtract from the first matrix.</param>
             
             <returns>Returns a matrix which components are equal to difference of corresponding
             components of the two specified matrices.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix4x4.Subtract(AForge.Math.Matrix4x4,AForge.Math.Matrix4x4)">
             <summary>
             Subtracts corresponding components of two matrices.
             </summary>
             
             <param name="matrix1">The matrix to subtract from.</param>
             <param name="matrix2">The matrix to subtract from the first matrix.</param>
             
             <returns>Returns a matrix which components are equal to difference of corresponding
             components of the two specified matrices.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix4x4.op_Multiply(AForge.Math.Matrix4x4,AForge.Math.Vector4)">
             <summary>
             Multiplies specified matrix by the specified vector.
             </summary>
             
             <param name="matrix">Matrix to multiply by vector.</param>
             <param name="vector">Vector to multiply matrix by.</param>
             
             <returns>Returns new vector which is the result of multiplication of the specified matrix
             by the specified vector.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix4x4.Multiply(AForge.Math.Matrix4x4,AForge.Math.Vector4)">
             <summary>
             Multiplies specified matrix by the specified vector.
             </summary>
             
             <param name="matrix">Matrix to multiply by vector.</param>
             <param name="vector">Vector to multiply matrix by.</param>
             
             <returns>Returns new vector which is the result of multiplication of the specified matrix
             by the specified vector.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix4x4.op_Equality(AForge.Math.Matrix4x4,AForge.Math.Matrix4x4)">
            <summary>
            Tests whether two specified matrices are equal.
            </summary>
            
            <param name="matrix1">The left-hand matrix.</param>
            <param name="matrix2">The right-hand matrix.</param>
            
            <returns>Returns <see langword="true"/> if the two matrices are equal or <see langword="false"/> otherwise.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix4x4.op_Inequality(AForge.Math.Matrix4x4,AForge.Math.Matrix4x4)">
            <summary>
            Tests whether two specified matrices are not equal.
            </summary>
            
            <param name="matrix1">The left-hand matrix.</param>
            <param name="matrix2">The right-hand matrix.</param>
            
            <returns>Returns <see langword="true"/> if the two matrices are not equal or <see langword="false"/> otherwise.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix4x4.Equals(AForge.Math.Matrix4x4)">
            <summary>
            Tests whether the matrix equals to the specified one.
            </summary>
            
            <param name="matrix">The matrix to test equality with.</param>
            
            <returns>Returns <see langword="true"/> if the two matrices are equal or <see langword="false"/> otherwise.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix4x4.Equals(System.Object)">
            <summary>
            Tests whether the matrix equals to the specified object.
            </summary>
            
            <param name="obj">The object to test equality with.</param>
            
            <returns>Returns <see langword="true"/> if the matrix equals to the specified object or <see langword="false"/> otherwise.</returns>
            
        </member>
        <member name="M:AForge.Math.Matrix4x4.GetHashCode">
            <summary>
            Returns the hashcode for this instance.
            </summary>
            
            <returns>A 32-bit signed integer hash code.</returns>
            
        </member>
        <member name="P:AForge.Math.Matrix4x4.Identity">
            <summary>
            Provides an identity matrix with all diagonal elements set to 1.
            </summary>
            
        </member>
        <member name="T:AForge.Math.Metrics.CosineDistance">
            <summary>
            Cosine distance metric. 
            </summary>
            
            <remarks><para>This class represents the cosine distance metric (1 - cosine similarity)
            <a href="http://en.wikipedia.org/wiki/Cosine_similarity"></a>.
            </para>
            
            <para>Sample usage:</para>
            <code>
            // instantiate new distance class
            CosineDistance dist = new CosineDistance(); 
            // create two vectors for inputs
            double[] p = new double[] { 2.5, 3.5, 3.0, 3.5, 2.5, 3.0 };
            double[] q = new double[] { 3.0, 3.5, 1.5, 5.0, 3.5, 3.0 };
            // get distance between the two vectors
            double distance = dist.GetDistance( p, q );
            </code>
            </remarks>
            
        </member>
        <member name="T:AForge.Math.Metrics.IDistance">
             <summary>
             Interface for distance metric algorithms.
             </summary>
             
             <remarks><para>The interface defines a set of methods implemented
             by distance metric algorithms. These algorithms typically take a set of points and return a 
             distance measure of the x and y coordinates. In this case, the points are represented by two vectors.</para>
             
             <para>Distance metric algorithms are used in many machine learning algorithms e.g K-nearest neighbor
             and K-means clustering.</para>
            
             <para>For additional details about distance metrics, documentation of the
             particular algorithms should be studied.</para>
             </remarks>
             
        </member>
        <member name="M:AForge.Math.Metrics.IDistance.GetDistance(System.Double[],System.Double[])">
            <summary>
            Returns distance between two N-dimensional double vectors.
            </summary>
            
            <param name="p">1st point vector.</param>
            <param name="q">2nd point vector.</param>
            
            <returns>Returns distance measurement determined by the given algorithm.</returns>
            
        </member>
        <member name="M:AForge.Math.Metrics.CosineDistance.GetDistance(System.Double[],System.Double[])">
            <summary>
            Returns distance between two N-dimensional double vectors.
            </summary>
            
            <param name="p">1st point vector.</param>
            <param name="q">2nd point vector.</param>
            
            <returns>Returns Cosine distance between two supplied vectors.</returns>
            
            <exception cref="T:System.ArgumentException">Thrown if the two vectors are of different dimensions (if specified
            array have different length).</exception>
            
        </member>
        <member name="T:AForge.Math.Metrics.CosineSimilarity">
            <summary>
            Cosine similarity metric. 
            </summary>
            
            <remarks><para>This class represents the 
            <a href="http://en.wikipedia.org/wiki/Cosine_similarity">Cosine Similarity metric</a>.</para>
            
            <para>Sample usage:</para>
            <code>
            // instantiate new similarity class
            CosineSimilarity sim = new CosineSimilarity( ); 
            // create two vectors for inputs
            double[] p = new double[] { 2.5, 3.5, 3.0, 3.5, 2.5, 3.0 };
            double[] q = new double[] { 3.0, 3.5, 1.5, 5.0, 3.5, 3.0 };
            // get similarity between the two vectors
            double similarityScore = sim.GetSimilarityScore( p, q );
            </code>    
            </remarks>
            
        </member>
        <member name="T:AForge.Math.Metrics.ISimilarity">
             <summary>
             Interface for similarity algorithms.
             </summary>
             
             <remarks><para>The interface defines a set of methods implemented
             by similarity and correlation algorithms. These algorithms typically take a set of points and return a 
             similarity score for the two vectors.</para>
             
             <para>Similarity and correlation algorithms are used in many machine learning and collaborative
             filtering algorithms.</para>
            
             <para>For additional details about similarity metrics, documentation of the
             particular algorithms should be studied.</para>
             </remarks>
             
        </member>
        <member name="M:AForge.Math.Metrics.ISimilarity.GetSimilarityScore(System.Double[],System.Double[])">
            <summary>
            Returns similarity score for two N-dimensional double vectors. 
            </summary>
            
            <param name="p">1st point vector.</param>
            <param name="q">2nd point vector.</param>
            
            <returns>Returns similarity score determined by the given algorithm.</returns>
            
        </member>
        <member name="M:AForge.Math.Metrics.CosineSimilarity.GetSimilarityScore(System.Double[],System.Double[])">
            <summary>
            Returns similarity score for two N-dimensional double vectors. 
            </summary>
            
            <param name="p">1st point vector.</param>
            <param name="q">2nd point vector.</param>
            
            <returns>Returns Cosine similarity between two supplied vectors.</returns>
            
            <exception cref="T:System.ArgumentException">Thrown if the two vectors are of different dimensions (if specified
            array have different length).</exception>
            
        </member>
        <member name="T:AForge.Math.Metrics.EuclideanDistance">
            <summary>
            Euclidean distance metric.
            </summary>
            
            <remarks><para>This class represents the 
            <a href="http://en.wikipedia.org/wiki/Euclidean_distance">Euclidean distance metric.</a></para>
            
            <para>Sample usage:</para>
            <code>
            // instantiate new distance class
            EuclideanDistance dist = new EuclideanDistance( );
            // create two vectors for inputs
            double[] p = new double[] { 2.5, 3.5, 3.0, 3.5, 2.5, 3.0 };
            double[] q = new double[] { 3.0, 3.5, 1.5, 5.0, 3.5, 3.0 };
            // get distance between the two vectors
            double distance = dist.GetDistance( p, q );
            </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Metrics.EuclideanDistance.GetDistance(System.Double[],System.Double[])">
            <summary>
            Returns distance between two N-dimensional double vectors.
            </summary>
            
            <param name="p">1st point vector.</param>
            <param name="q">2nd point vector.</param>
            
            <returns>Returns Euclidean distance between two supplied vectors.</returns>
            
            <exception cref="T:System.ArgumentException">Thrown if the two vectors are of different dimensions (if specified
            array have different length).</exception>
            
        </member>
        <member name="T:AForge.Math.Metrics.EuclideanSimilarity">
            <summary>
            Euclidean similarity metric. 
            </summary>
            
            <remarks><para>This class represents the 
            <a href="http://en.wikipedia.org/wiki/Euclidean_distance">Euclidean Similarity metric</a>,
            which is calculated as 1.0 / ( 1.0 + EuclideanDistance ).</para>
            
            <para>Sample usage:</para>
            <code>
            // instantiate new similarity class
            EuclideanSimilarity sim = new EuclideanSimilarity( ); 
            // create two vectors for inputs
            double[] p = new double[] { 2.5, 3.5, 3.0, 3.5, 2.5, 3.0 };
            double[] q = new double[] { 3.0, 3.5, 1.5, 5.0, 3.5, 3.0 };
            // get simirarity between the two vectors
            double similarityScore = sim.GetSimilarityScore( p, q );
            </code>    
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Metrics.EuclideanSimilarity.GetSimilarityScore(System.Double[],System.Double[])">
            <summary>
            Returns similarity score for two N-dimensional double vectors. 
            </summary>
            
            <param name="p">1st point vector.</param>
            <param name="q">2nd point vector.</param>
            
            <returns>Returns Euclidean similarity between two supplied vectors.</returns>
            
            <exception cref="T:System.ArgumentException">Thrown if the two vectors are of different dimensions (if specified
            array have different length).</exception>
            
        </member>
        <member name="T:AForge.Math.Metrics.HammingDistance">
            <summary>
            Hamming distance metric. 
            </summary>
            
            <remarks><para>This class represents the 
            <a href="http://en.wikipedia.org/wiki/Hamming_Distance">Hamming distance metric</a>.</para>
            
            <para>Sample usage:</para>
            <code>
            // instantiate new distance class
            HammingDistance dist = new HammingDistance( ); 
            // create two vectors for inputs
            double[] p = new double[] { 2.5, 3.5, 3.0, 3.5, 2.5, 3.0 };
            double[] q = new double[] { 3.0, 3.5, 1.5, 5.0, 3.5, 3.0 };
            // get distance between the two vectors
            double distance = dist.GetDistance( p, q );
            </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Metrics.HammingDistance.GetDistance(System.Double[],System.Double[])">
            <summary>
            Returns distance between two N-dimensional double vectors.
            </summary>
            
            <param name="p">1st point vector.</param>
            <param name="q">2nd point vector.</param>
            
            <returns>Returns Hamming distance between two supplied vectors.</returns>
            
            <exception cref="T:System.ArgumentException">Thrown if the two vectors are of different dimensions (if specified
            array have different length).</exception>
            
        </member>
        <member name="T:AForge.Math.Metrics.JaccardDistance">
            <summary>
            Jaccard distance metric. 
            </summary>
            
            <remarks><para>This class represents the 
            <a href="http://en.wikipedia.org/wiki/Jaccard_distance">Jaccard distance metric</a>.</para>
            
            <para>Sample usage:</para>
            <code>
            // instantiate new distance class
            JaccardDistance dist = new JaccardDistance( ); 
            // create two vectors for inputs
            double[] p = new double[] { 2.5, 3.5, 3.0, 3.5, 2.5, 3.0 };
            double[] q = new double[] { 3.0, 3.5, 1.5, 5.0, 3.5, 3.0 };
            // get distance between the two vectors
            double distance = dist.GetDistance( p, q );
            </code>   
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Metrics.JaccardDistance.GetDistance(System.Double[],System.Double[])">
            <summary>
            Returns distance between two N-dimensional double vectors.
            </summary>
            
            <param name="p">1st point vector.</param>
            <param name="q">2nd point vector.</param>
            
            <returns>Returns Jaccard distance between two supplied vectors.</returns>
            
            <exception cref="T:System.ArgumentException">Thrown if the two vectors are of different dimensions (if specified
            array have different length).</exception>
            
        </member>
        <member name="T:AForge.Math.Metrics.ManhattanDistance">
            <summary>
            Manhattan distance metric. 
            </summary>
            
            <remarks><para>This class represents the 
            <a href="http://en.wikipedia.org/wiki/Manhattan_distance">Manhattan distance metric</a>
            (aka City Block and Taxi Cab distance).</para>
            
            <para>Sample usage:</para>
            <code>
            // instantiate new distance class
            ManhattanDistance dist = new ManhattanDistance( ); 
            // create two vectors for inputs
            double[] p = new double[] { 2.5, 3.5, 3.0, 3.5, 2.5, 3.0 };
            double[] q = new double[] { 3.0, 3.5, 1.5, 5.0, 3.5, 3.0 };
            // get distance between the two vectors
            double distance = dist.GetDistance( p, q );
            </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Metrics.ManhattanDistance.GetDistance(System.Double[],System.Double[])">
            <summary>
            Returns distance between two N-dimensional double vectors.
            </summary>
            
            <param name="p">1st point vector.</param>
            <param name="q">2nd point vector.</param>
            
            <returns>Returns Manhattan distance between two supplied vectors.</returns>
            
            <exception cref="T:System.ArgumentException">Thrown if the two vectors are of different dimensions (if specified
            array have different length).</exception>
            
        </member>
        <member name="T:AForge.Math.Metrics.PearsonCorrelation">
            <summary>
            Pearson correlation metric. 
            </summary>
            
            <remarks><para>This class represents the 
            <a href="http://en.wikipedia.org/wiki/Pearson_correlation">Pearson correlation metric</a>.</para>
            
            <para>Sample usage:</para>
            <code>
            // instantiate new pearson correlation class
            PearsonCorrelation cor = new PearsonCorrelation( ); 
            // create two vectors for inputs
            double[] p = new double[] { 2.5, 3.5, 3.0, 3.5, 2.5, 3.0 };
            double[] q = new double[] { 3.0, 3.5, 1.5, 5.0, 3.5, 3.0 };
            // get correlation between the two vectors
            double correlation = cor.GetSimilarityScore( p, q );
            </code>    
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Metrics.PearsonCorrelation.GetSimilarityScore(System.Double[],System.Double[])">
            <summary>
            Returns the pearson correlation for two N-dimensional double vectors. 
            </summary>
            
            <param name="p">1st point vector.</param>
            <param name="q">2nd point vector.</param>
            
            <returns>Returns Pearson correlation between two supplied vectors.</returns>
            
            <exception cref="T:System.ArgumentException">Thrown if the two vectors are of different dimensions (if specified
            array have different length).</exception>
            
        </member>
        <member name="T:AForge.Math.PerlinNoise">
            <summary>
            Perlin noise function.
            </summary>
            
            <remarks><para>The class implements 1-D and 2-D Perlin noise functions, which represent
            sum of several smooth noise functions with different frequency and amplitude. The description
            of Perlin noise function and its calculation may be found on
            <a href="http://freespace.virgin.net/hugo.elias/models/m_perlin.htm" target="_blank">Hugo Elias's page</a>.
            </para>
            
            <para>The number of noise functions, which comprise the resulting Perlin noise function, is
            set by <see cref="P:AForge.Math.PerlinNoise.Octaves"/> property. Amplitude and frequency values for each octave
            start from values, which are set by <see cref="P:AForge.Math.PerlinNoise.InitFrequency"/> and <see cref="P:AForge.Math.PerlinNoise.InitAmplitude"/>
            properties.</para>
            
            <para>Sample usage (clouds effect):</para>
            <code>
            // create Perlin noise function
            PerlinNoise noise = new PerlinNoise( 8, 0.5, 1.0 / 32 );
            // generate clouds effect
            float[,] texture = new float[height, width];
            
            for ( int y = 0; y &lt; height; y++ )
            {
            	for ( int x = 0; x &lt; width; x++ )
            	{
            		texture[y, x] = 
            			Math.Max( 0.0f, Math.Min( 1.0f,
            				(float) noise.Function2D( x, y ) * 0.5f + 0.5f
            			) );
            	}
            }
            </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Math.PerlinNoise.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Math.PerlinNoise"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Math.PerlinNoise.#ctor(System.Int32,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Math.PerlinNoise"/> class.
            </summary>
            
            <param name="octaves">Number of octaves (see <see cref="P:AForge.Math.PerlinNoise.Octaves"/> property).</param>
            <param name="persistence">Persistence value (see <see cref="P:AForge.Math.PerlinNoise.Persistence"/> property).</param>
            
        </member>
        <member name="M:AForge.Math.PerlinNoise.#ctor(System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Math.PerlinNoise"/> class.
            </summary>
            
            <param name="octaves">Number of octaves (see <see cref="P:AForge.Math.PerlinNoise.Octaves"/> property).</param>
            <param name="persistence">Persistence value (see <see cref="P:AForge.Math.PerlinNoise.Persistence"/> property).</param>
            <param name="initFrequency">Initial frequency (see <see cref="P:AForge.Math.PerlinNoise.InitFrequency"/> property).</param>
            <param name="initAmplitude">Initial amplitude (see <see cref="P:AForge.Math.PerlinNoise.InitAmplitude"/> property).</param>
            
        </member>
        <member name="M:AForge.Math.PerlinNoise.Function(System.Double)">
            <summary>
            1-D Perlin noise function.
            </summary>
            
            <param name="x">x value.</param>
            
            <returns>Returns function's value at point <paramref name="x"/>.</returns>
            
        </member>
        <member name="M:AForge.Math.PerlinNoise.Function2D(System.Double,System.Double)">
            <summary>
            2-D Perlin noise function.
            </summary>
            
            <param name="x">x value.</param>
            <param name="y">y value.</param>
            
            <returns>Returns function's value at point (<paramref name="x"/>, <paramref name="y"/>).</returns>
            
        </member>
        <member name="M:AForge.Math.PerlinNoise.Noise(System.Int32)">
            <summary>
              Ordinary noise function
            </summary>
            
        </member>
        <member name="M:AForge.Math.PerlinNoise.SmoothedNoise(System.Double)">
            <summary>
            Smoothed noise.
            </summary>
        </member>
        <member name="M:AForge.Math.PerlinNoise.CosineInterpolate(System.Double,System.Double,System.Double)">
            <summary>
            Cosine interpolation.
            </summary>
        </member>
        <member name="P:AForge.Math.PerlinNoise.InitFrequency">
            <summary>
            Initial frequency.
            </summary>
            
            <remarks><para>The property sets initial frequency of the first octave. Frequencies for
            next octaves are calculated using the next equation:<br/>
            frequency<sub>i</sub> = <see cref="P:AForge.Math.PerlinNoise.InitFrequency"/> * 2<sup>i</sup>,
            where i = [0, <see cref="P:AForge.Math.PerlinNoise.Octaves"/>).
            </para>
            
            <para>Default value is set to <b>1</b>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Math.PerlinNoise.InitAmplitude">
             <summary>
             Initial amplitude.
             </summary>
             
             <remarks><para>The property sets initial amplitude of the first octave. Amplitudes for
             next octaves are calculated using the next equation:<br/>
             amplitude<sub>i</sub> = <see cref="P:AForge.Math.PerlinNoise.InitAmplitude"/> * <see cref="P:AForge.Math.PerlinNoise.Persistence"/><sup>i</sup>,
             where i = [0, <see cref="P:AForge.Math.PerlinNoise.Octaves"/>).
             </para>
             
             <para>Default value is set to <b>1</b>.</para>
             </remarks>
            
        </member>
        <member name="P:AForge.Math.PerlinNoise.Persistence">
             <summary>
             Persistence value.
             </summary>
            
             <remarks><para>The property sets so called persistence value, which controls the way
             how <see cref="P:AForge.Math.PerlinNoise.InitAmplitude">amplitude</see> is calculated for each octave comprising
             the Perlin noise function.</para>
             
             <para>Default value is set to <b>0.65</b>.</para>
             </remarks>
            
        </member>
        <member name="P:AForge.Math.PerlinNoise.Octaves">
            <summary>
            Number of octaves, [1, 32].
            </summary>
            
            <remarks><para>The property sets the number of noise functions, which sum up the resulting
            Perlin noise function.</para>
            
            <para>Default value is set to <b>4</b>.</para>
            </remarks>
            
        </member>
        <member name="T:AForge.Math.Random.ExponentialGenerator">
            <summary>
            Exponential random numbers generator.
            </summary>
            
            <remarks><para>The random number generator generates exponential
            random numbers with specified rate value (lambda).</para>
            
            <para>The generator uses <see cref="T:AForge.Math.Random.UniformOneGenerator"/> generator as a base
            to generate random numbers.</para>
            
            <para>Sample usage:</para>
            <code>
            // create instance of random generator
            IRandomNumberGenerator generator = new ExponentialGenerator( 5 );
            // generate random number
            float randomNumber = generator.Next( );
            </code>
            </remarks>
            
        </member>
        <member name="T:AForge.Math.Random.IRandomNumberGenerator">
            <summary>
            Interface for random numbers generators.
            </summary>
            
            <remarks><para>The interface defines set of methods and properties, which should
            be implemented by different algorithms for random numbers generatation.</para>
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Random.IRandomNumberGenerator.Next">
            <summary>
            Generate next random number.
            </summary>
            
            <returns>Returns next random number.</returns>
            
        </member>
        <member name="M:AForge.Math.Random.IRandomNumberGenerator.SetSeed(System.Int32)">
            <summary>
            Set seed of the random numbers generator.
            </summary>
            
            <param name="seed">Seed value.</param>
            
        </member>
        <member name="P:AForge.Math.Random.IRandomNumberGenerator.Mean">
            <summary>
            Mean value of generator.
            </summary>
            
        </member>
        <member name="P:AForge.Math.Random.IRandomNumberGenerator.Variance">
            <summary>
            Variance value of generator.
            </summary>
            
        </member>
        <member name="M:AForge.Math.Random.ExponentialGenerator.#ctor(System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Math.Random.ExponentialGenerator"/> class.
            </summary>
            
            <param name="rate">Rate value.</param>
            
            <exception cref="T:System.ArgumentException">Rate value should be greater than zero.</exception>
            
        </member>
        <member name="M:AForge.Math.Random.ExponentialGenerator.#ctor(System.Single,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Math.Random.ExponentialGenerator"/> class.
            </summary>
            
            <param name="rate">Rate value (inverse mean).</param>
            <param name="seed">Seed value to initialize random numbers generator.</param>
            
            <exception cref="T:System.ArgumentException">Rate value should be greater than zero.</exception>
            
        </member>
        <member name="M:AForge.Math.Random.ExponentialGenerator.Next">
            <summary>
            Generate next random number
            </summary>
            
            <returns>Returns next random number.</returns>
            
        </member>
        <member name="M:AForge.Math.Random.ExponentialGenerator.SetSeed(System.Int32)">
            <summary>
            Set seed of the random numbers generator.
            </summary>
            
            <param name="seed">Seed value.</param>
            
            <remarks>Resets random numbers generator initializing it with
            specified seed value.</remarks>
            
        </member>
        <member name="P:AForge.Math.Random.ExponentialGenerator.Rate">
            <summary>
            Rate value (inverse mean).
            </summary>
            
            <remarks>The rate value should be positive and non zero.</remarks>
            
        </member>
        <member name="P:AForge.Math.Random.ExponentialGenerator.Mean">
            <summary>
            Mean value of the generator.
            </summary>
            
        </member>
        <member name="P:AForge.Math.Random.ExponentialGenerator.Variance">
             <summary>
             Variance value of the generator.
             </summary>
            
        </member>
        <member name="T:AForge.Math.Random.GaussianGenerator">
            <summary>
            Gaussian random numbers generator.
            </summary>
            
            <remarks><para>The random number generator generates gaussian
            random numbers with specified mean and standard deviation values.</para>
            
            <para>The generator uses <see cref="T:AForge.Math.Random.StandardGenerator"/> generator as base
            to generate random numbers.</para>
            
            <para>Sample usage:</para>
            <code>
            // create instance of random generator
            IRandomNumberGenerator generator = new GaussianGenerator( 5.0, 1.5 );
            // generate random number
            float randomNumber = generator.Next( );
            </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Random.GaussianGenerator.#ctor(System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Math.Random.GaussianGenerator"/> class.
            </summary>
            
            <param name="mean">Mean value.</param>
            <param name="stdDev">Standard deviation value.</param>
            
        </member>
        <member name="M:AForge.Math.Random.GaussianGenerator.#ctor(System.Single,System.Single,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Math.Random.GaussianGenerator"/> class.
            </summary>
            
            <param name="mean">Mean value.</param>
            <param name="stdDev">Standard deviation value.</param>
            <param name="seed">Seed value to initialize random numbers generator.</param>
            
        </member>
        <member name="M:AForge.Math.Random.GaussianGenerator.Next">
            <summary>
            Generate next random number.
            </summary>
            
            <returns>Returns next random number.</returns>
            
        </member>
        <member name="M:AForge.Math.Random.GaussianGenerator.SetSeed(System.Int32)">
            <summary>
            Set seed of the random numbers generator.
            </summary>
            
            <param name="seed">Seed value.</param>
            
            <remarks>Resets random numbers generator initializing it with
            specified seed value.</remarks>
            
        </member>
        <member name="P:AForge.Math.Random.GaussianGenerator.Mean">
             <summary>
             Mean value of the generator.
             </summary>
            
        </member>
        <member name="P:AForge.Math.Random.GaussianGenerator.Variance">
             <summary>
             Variance value of the generator.
             </summary>
            
        </member>
        <member name="P:AForge.Math.Random.GaussianGenerator.StdDev">
             <summary>
             Standard deviation value.
             </summary>
            
        </member>
        <member name="T:AForge.Math.Random.StandardGenerator">
            <summary>
            Standard random numbers generator.
            </summary>
            
            <remarks><para>The random number generator generates gaussian
            random numbers with zero mean and standard deviation of one. The generator
            implements polar form of the Box-Muller transformation.</para>
            
            <para>The generator uses <see cref="T:AForge.Math.Random.UniformOneGenerator"/> generator as a base
            to generate random numbers.</para>
            
            <para>Sample usage:</para>
            <code>
            // create instance of random generator
            IRandomNumberGenerator generator = new StandardGenerator( );
            // generate random number
            float randomNumber = generator.Next( );
            </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Random.StandardGenerator.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Math.Random.StandardGenerator"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Math.Random.StandardGenerator.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Math.Random.StandardGenerator"/> class.
            </summary>
            
            <param name="seed">Seed value to initialize random numbers generator.</param>
            
        </member>
        <member name="M:AForge.Math.Random.StandardGenerator.Next">
            <summary>
            Generate next random number.
            </summary>
            
            <returns>Returns next random number.</returns>
            
        </member>
        <member name="M:AForge.Math.Random.StandardGenerator.SetSeed(System.Int32)">
            <summary>
            Set seed of the random numbers generator.
            </summary>
            
            <param name="seed">Seed value.</param>
            
            <remarks>Resets random numbers generator initializing it with
            specified seed value.</remarks>
            
        </member>
        <member name="P:AForge.Math.Random.StandardGenerator.Mean">
            <summary>
            Mean value of the generator.
            </summary>
            
        </member>
        <member name="P:AForge.Math.Random.StandardGenerator.Variance">
             <summary>
             Variance value of the generator.
             </summary>
            
        </member>
        <member name="T:AForge.Math.Random.UniformGenerator">
            <summary>
            Uniform random numbers generator.
            </summary>
            
            <remarks><para>The random numbers generator generates uniformly
            distributed numbers in the <see cref="P:AForge.Math.Random.UniformGenerator.Range">specified range</see> - values
            are greater or equal to minimum range's value and less than maximum range's
            value.</para>
            
            <para>The generator uses <see cref="T:AForge.Math.Random.UniformOneGenerator"/> generator
            to generate random numbers.</para>
            
            <para>Sample usage:</para>
            <code>
            // create instance of random generator
            IRandomNumberGenerator generator = new UniformGenerator( new Range( 50, 100 ) );
            // generate random number
            float randomNumber = generator.Next( );
            </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Random.UniformGenerator.#ctor(AForge.Range)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Math.Random.UniformGenerator"/> class.
            </summary>
            
            <param name="range">Random numbers range.</param>
            
            <remarks>Initializes random numbers generator with zero seed.</remarks>
            
        </member>
        <member name="M:AForge.Math.Random.UniformGenerator.#ctor(AForge.Range,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Math.Random.UniformGenerator"/> class.
            </summary>
            
            <param name="range">Random numbers range.</param>
            <param name="seed">Seed value to initialize random numbers generator.</param>
            
        </member>
        <member name="M:AForge.Math.Random.UniformGenerator.Next">
            <summary>
            Generate next random number.
            </summary>
            
            <returns>Returns next random number.</returns>
            
        </member>
        <member name="M:AForge.Math.Random.UniformGenerator.SetSeed(System.Int32)">
            <summary>
            Set seed of the random numbers generator.
            </summary>
            
            <param name="seed">Seed value.</param>
            
            <remarks>Resets random numbers generator initializing it with
            specified seed value.</remarks>
            
        </member>
        <member name="P:AForge.Math.Random.UniformGenerator.Mean">
             <summary>
             Mean value of the generator.
             </summary>
            
        </member>
        <member name="P:AForge.Math.Random.UniformGenerator.Variance">
             <summary>
             Variance value of the generator.
             </summary>
            
        </member>
        <member name="P:AForge.Math.Random.UniformGenerator.Range">
            <summary>
            Random numbers range.
            </summary>
            
            <remarks><para>Range of random numbers to generate. Generated numbers are
            greater or equal to minimum range's value and less than maximum range's
            value.</para>
            </remarks>
            
        </member>
        <member name="T:AForge.Math.Random.UniformOneGenerator">
            <summary>
            Uniform random numbers generator in the range of [0, 1).
            </summary>
            
            <remarks><para>The random number generator generates uniformly
            distributed numbers in the range of [0, 1) - greater or equal to 0.0
            and less than 1.0.</para>
            
            <para><note>At this point the generator is based on the
            internal .NET generator, but may be rewritten to
            use faster generation algorithm.</note></para>
            
            <para>Sample usage:</para>
            <code>
            // create instance of random generator
            IRandomNumberGenerator generator = new UniformOneGenerator( );
            // generate random number
            float randomNumber = generator.Next( );
            </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Random.UniformOneGenerator.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Math.Random.UniformOneGenerator"/> class.
            </summary>
            
            <remarks>Initializes random numbers generator with zero seed.</remarks>
            
        </member>
        <member name="M:AForge.Math.Random.UniformOneGenerator.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Math.Random.UniformOneGenerator"/> class.
            </summary>
            
            <param name="seed">Seed value to initialize random numbers generator.</param>
            
        </member>
        <member name="M:AForge.Math.Random.UniformOneGenerator.Next">
            <summary>
            Generate next random number.
            </summary>
            
            <returns>Returns next random number.</returns>
            
        </member>
        <member name="M:AForge.Math.Random.UniformOneGenerator.SetSeed(System.Int32)">
            <summary>
            Set seed of the random numbers generator.
            </summary>
            
            <param name="seed">Seed value.</param>
            
            <remarks>Resets random numbers generator initializing it with
            specified seed value.</remarks>
            
        </member>
        <member name="P:AForge.Math.Random.UniformOneGenerator.Mean">
             <summary>
             Mean value of the generator.
             </summary>
            
        </member>
        <member name="P:AForge.Math.Random.UniformOneGenerator.Variance">
             <summary>
             Variance value of the generator.
             </summary>
            
        </member>
        <member name="T:AForge.Math.Statistics">
            <summary>
            Set of statistics functions.
            </summary>
            
            <remarks>The class represents collection of simple functions used
            in statistics.</remarks>
            
        </member>
        <member name="M:AForge.Math.Statistics.Mean(System.Int32[])">
            <summary>
            Calculate mean value.
            </summary>
            
            <param name="values">Histogram array.</param>
            
            <returns>Returns mean value.</returns>
            
            <remarks><para>The input array is treated as histogram, i.e. its
            indexes are treated as values of stochastic function, but
            array values are treated as "probabilities" (total amount of
            hits).</para>
            
            <para>Sample usage:</para>
            <code>
            // create histogram array
            int[] histogram = new int[] { 1, 1, 2, 3, 6, 8, 11, 12, 7, 3 };
            // calculate mean value
            double mean = Statistics.Mean( histogram );
            // output it (5.759)
            Console.WriteLine( "mean = " + mean.ToString( "F3" ) );
            </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Statistics.StdDev(System.Int32[])">
            <summary>
            Calculate standard deviation.
            </summary>
            
            <param name="values">Histogram array.</param>
            
            <returns>Returns value of standard deviation.</returns>
            
            <remarks><para>The input array is treated as histogram, i.e. its
            indexes are treated as values of stochastic function, but
            array values are treated as "probabilities" (total amount of
            hits).</para>
            
            <para>Sample usage:</para>
            <code>
            // create histogram array
            int[] histogram = new int[] { 1, 1, 2, 3, 6, 8, 11, 12, 7, 3 };
            // calculate standard deviation value
            double stdDev = Statistics.StdDev( histogram );
            // output it (1.999)
            Console.WriteLine( "std.dev. = " + stdDev.ToString( "F3" ) );
            </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Statistics.StdDev(System.Int32[],System.Double)">
            <summary>
            Calculate standard deviation.
            </summary>
            
            <param name="values">Histogram array.</param>
            <param name="mean">Mean value of the histogram.</param>
            
            <returns>Returns value of standard deviation.</returns>
            
            <remarks><para>The input array is treated as histogram, i.e. its
            indexes are treated as values of stochastic function, but
            array values are treated as "probabilities" (total amount of
            hits).</para>
            
            <para>The method is an equevalent to the <see cref="M:AForge.Math.Statistics.StdDev(System.Int32[])"/> method,
            but it relieas on the passed mean value, which is previously calculated
            using <see cref="M:AForge.Math.Statistics.Mean(System.Int32[])"/> method.</para>
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Statistics.Median(System.Int32[])">
            <summary>
            Calculate median value.
            </summary>
            
            <param name="values">Histogram array.</param>
            
            <returns>Returns value of median.</returns>
            
            <remarks>
            <para>The input array is treated as histogram, i.e. its
            indexes are treated as values of stochastic function, but
            array values are treated as "probabilities" (total amount of
            hits).</para>
            
            <para><note>The median value is calculated accumulating histogram's
            values starting from the <b>left</b> point until the sum reaches 50% of
            histogram's sum.</note></para>
            
            <para>Sample usage:</para>
            <code>
            // create histogram array
            int[] histogram = new int[] { 1, 1, 2, 3, 6, 8, 11, 12, 7, 3 };
            // calculate median value
            int median = Statistics.Median( histogram );
            // output it (6)
            Console.WriteLine( "median = " + median );
            </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Statistics.GetRange(System.Int32[],System.Double)">
            <summary>
            Get range around median containing specified percentage of values.
            </summary>
            
            <param name="values">Histogram array.</param>
            <param name="percent">Values percentage around median.</param>
            
            <returns>Returns the range which containes specifies percentage
            of values.</returns>
            
            <remarks>
            <para>The input array is treated as histogram, i.e. its
            indexes are treated as values of stochastic function, but
            array values are treated as "probabilities" (total amount of
            hits).</para>
            
            <para>The method calculates range of stochastic variable, which summary probability
            comprises the specified percentage of histogram's hits.</para>
            
            <para>Sample usage:</para>
            <code>
            // create histogram array
            int[] histogram = new int[] { 1, 1, 2, 3, 6, 8, 11, 12, 7, 3 };
            // get 75% range around median
            IntRange range = Statistics.GetRange( histogram, 0.75 );
            // output it ([4, 8])
            Console.WriteLine( "range = [" + range.Min + ", " + range.Max + "]" );
            </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Statistics.Entropy(System.Int32[])">
            <summary>
            Calculate entropy value.
            </summary>
            
            <param name="values">Histogram array.</param>
            
            <returns>Returns entropy value of the specified histagram array.</returns>
            
            <remarks><para>The input array is treated as histogram, i.e. its
            indexes are treated as values of stochastic function, but
            array values are treated as "probabilities" (total amount of
            hits).</para>
            
            <para>Sample usage:</para>
            <code>
            // create histogram array with 2 values of equal probabilities
            int[] histogram1 = new int[2] { 3, 3 };
            // calculate entropy
            double entropy1 = Statistics.Entropy( histogram1 );
            // output it (1.000)
            Console.WriteLine( "entropy1 = " + entropy1.ToString( "F3" ) );
            
            // create histogram array with 4 values of equal probabilities
            int[] histogram2 = new int[4] { 1, 1, 1, 1 };
            // calculate entropy
            double entropy2 = Statistics.Entropy( histogram2 );
            // output it (2.000)
            Console.WriteLine( "entropy2 = " + entropy2.ToString( "F3" ) );
            
            // create histogram array with 4 values of different probabilities
            int[] histogram3 = new int[4] { 1, 2, 3, 4 };
            // calculate entropy
            double entropy3 = Statistics.Entropy( histogram3 );
            // output it (1.846)
            Console.WriteLine( "entropy3 = " + entropy3.ToString( "F3" ) );
            </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Math.Statistics.Mode(System.Int32[])">
             <summary>
             Calculate mode value.
             </summary>
             
             <param name="values">Histogram array.</param>
             
             <returns>Returns mode value of the histogram array.</returns>
             
             <remarks>
             <para>The input array is treated as histogram, i.e. its
             indexes are treated as values of stochastic function, but
             array values are treated as "probabilities" (total amount of
             hits).</para>
             
             <para><note>Returns the minimum mode value if the specified histogram is multimodal.</note></para>
            
             <para>Sample usage:</para>
             <code>
             // create array
             int[] values = new int[] { 1, 1, 2, 3, 6, 8, 11, 12, 7, 3 };
             // calculate mode value
             int mode = Statistics.Mode( values );
             // output it (7)
             Console.WriteLine( "mode = " + mode );
             </code>
             </remarks>
             
        </member>
        <member name="T:AForge.Math.Tools">
            <summary>
            Set of tool functions.
            </summary>
            
            <remarks>The class contains different utility functions.</remarks>
            
        </member>
        <member name="M:AForge.Math.Tools.Pow2(System.Int32)">
            <summary>
            Calculates power of 2.
            </summary>
            
            <param name="power">Power to raise in.</param>
            
            <returns>Returns specified power of 2 in the case if power is in the range of
            [0, 30]. Otherwise returns 0.</returns>
            
        </member>
        <member name="M:AForge.Math.Tools.IsPowerOf2(System.Int32)">
            <summary>
            Checks if the specified integer is power of 2.
            </summary>
            
            <param name="x">Integer number to check.</param>
            
            <returns>Returns <b>true</b> if the specified number is power of 2.
            Otherwise returns <b>false</b>.</returns>
            
        </member>
        <member name="M:AForge.Math.Tools.Log2(System.Int32)">
            <summary>
            Get base of binary logarithm.
            </summary>
            
            <param name="x">Source integer number.</param>
            
            <returns>Power of the number (base of binary logarithm).</returns>
            
        </member>
        <member name="T:AForge.Math.Vector3">
            <summary>
            3D Vector structure with X, Y and Z coordinates.
            </summary>
            
            <remarks><para>The structure incapsulates X, Y and Z coordinates of a 3D vector and
            provides some operations with it.</para></remarks>
            
        </member>
        <member name="F:AForge.Math.Vector3.X">
            <summary>
            X coordinate of the vector.
            </summary>
        </member>
        <member name="F:AForge.Math.Vector3.Y">
            <summary>
            Y coordinate of the vector.
            </summary>
        </member>
        <member name="F:AForge.Math.Vector3.Z">
            <summary>
            Z coordinate of the vector.
            </summary>
        </member>
        <member name="M:AForge.Math.Vector3.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Math.Vector3"/> structure.
            </summary>
            
            <param name="x">X coordinate of the vector.</param>
            <param name="y">Y coordinate of the vector.</param>
            <param name="z">Z coordinate of the vector.</param>
            
        </member>
        <member name="M:AForge.Math.Vector3.#ctor(System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Math.Vector3"/> structure.
            </summary>
            
            <param name="value">Value, which is set to all 3 coordinates of the vector.</param>
            
        </member>
        <member name="M:AForge.Math.Vector3.ToString">
            <summary>
            Returns a string representation of this object.
            </summary>
            
            <returns>A string representation of this object.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector3.ToArray">
            <summary>
            Returns array representation of the vector.
            </summary>
            
            <returns>Array with 3 values containing X/Y/Z coordinates.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector3.op_Addition(AForge.Math.Vector3,AForge.Math.Vector3)">
             <summary>
             Adds corresponding coordinates of two vectors.
             </summary>
             
             <param name="vector1">The vector to add to.</param>
             <param name="vector2">The vector to add to the first vector.</param>
             
             <returns>Returns a vector which coordinates are equal to sum of corresponding
             coordinates of the two specified vectors.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector3.Add(AForge.Math.Vector3,AForge.Math.Vector3)">
             <summary>
             Adds corresponding coordinates of two vectors.
             </summary>
             
             <param name="vector1">The vector to add to.</param>
             <param name="vector2">The vector to add to the first vector.</param>
             
             <returns>Returns a vector which coordinates are equal to sum of corresponding
             coordinates of the two specified vectors.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector3.op_Addition(AForge.Math.Vector3,System.Single)">
            <summary>
            Adds a value to all coordinates of the specified vector.
            </summary>
            
            <param name="vector">Vector to add the specified value to.</param>
            <param name="value">Value to add to all coordinates of the vector.</param>
            
            <returns>Returns new vector with all coordinates increased by the specified value.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector3.Add(AForge.Math.Vector3,System.Single)">
            <summary>
            Adds a value to all coordinates of the specified vector.
            </summary>
            
            <param name="vector">Vector to add the specified value to.</param>
            <param name="value">Value to add to all coordinates of the vector.</param>
            
            <returns>Returns new vector with all coordinates increased by the specified value.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector3.op_Subtraction(AForge.Math.Vector3,AForge.Math.Vector3)">
             <summary>
             Subtracts corresponding coordinates of two vectors.
             </summary>
             
             <param name="vector1">The vector to subtract from.</param>
             <param name="vector2">The vector to subtract from the first vector.</param>
             
             <returns>Returns a vector which coordinates are equal to difference of corresponding
             coordinates of the two specified vectors.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector3.Subtract(AForge.Math.Vector3,AForge.Math.Vector3)">
             <summary>
             Subtracts corresponding coordinates of two vectors.
             </summary>
             
             <param name="vector1">The vector to subtract from.</param>
             <param name="vector2">The vector to subtract from the first vector.</param>
             
             <returns>Returns a vector which coordinates are equal to difference of corresponding
             coordinates of the two specified vectors.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector3.op_Subtraction(AForge.Math.Vector3,System.Single)">
            <summary>
            Subtracts a value from all coordinates of the specified vector.
            </summary>
            
            <param name="vector">Vector to subtract the specified value from.</param>
            <param name="value">Value to subtract from all coordinates of the vector.</param>
            
            <returns>Returns new vector with all coordinates decreased by the specified value.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector3.Subtract(AForge.Math.Vector3,System.Single)">
            <summary>
            Subtracts a value from all coordinates of the specified vector.
            </summary>
            
            <param name="vector">Vector to subtract the specified value from.</param>
            <param name="value">Value to subtract from all coordinates of the vector.</param>
            
            <returns>Returns new vector with all coordinates decreased by the specified value.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector3.op_Multiply(AForge.Math.Vector3,AForge.Math.Vector3)">
             <summary>
             Multiplies corresponding coordinates of two vectors.
             </summary>
             
             <param name="vector1">The first vector to multiply.</param>
             <param name="vector2">The second vector to multiply.</param>
             
             <returns>Returns a vector which coordinates are equal to multiplication of corresponding
             coordinates of the two specified vectors.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector3.Multiply(AForge.Math.Vector3,AForge.Math.Vector3)">
             <summary>
             Multiplies corresponding coordinates of two vectors.
             </summary>
             
             <param name="vector1">The first vector to multiply.</param>
             <param name="vector2">The second vector to multiply.</param>
             
             <returns>Returns a vector which coordinates are equal to multiplication of corresponding
             coordinates of the two specified vectors.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector3.op_Multiply(AForge.Math.Vector3,System.Single)">
             <summary>
             Multiplies coordinates of the specified vector by the specified factor.
             </summary>
             
             <param name="vector">Vector to multiply coordinates of.</param>
             <param name="factor">Factor to multiple coordinates of the specified vector by.</param>
             
             <returns>Returns new vector with all coordinates multiplied by the specified factor.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector3.Multiply(AForge.Math.Vector3,System.Single)">
             <summary>
             Multiplies coordinates of the specified vector by the specified factor.
             </summary>
             
             <param name="vector">Vector to multiply coordinates of.</param>
             <param name="factor">Factor to multiple coordinates of the specified vector by.</param>
             
             <returns>Returns new vector with all coordinates multiplied by the specified factor.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector3.op_Division(AForge.Math.Vector3,AForge.Math.Vector3)">
             <summary>
             Divides corresponding coordinates of two vectors.
             </summary>
             
             <param name="vector1">The first vector to divide.</param>
             <param name="vector2">The second vector to devide.</param>
             
             <returns>Returns a vector which coordinates are equal to coordinates of the first vector divided by
             corresponding coordinates of the second vector.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector3.Divide(AForge.Math.Vector3,AForge.Math.Vector3)">
             <summary>
             Divides corresponding coordinates of two vectors.
             </summary>
             
             <param name="vector1">The first vector to divide.</param>
             <param name="vector2">The second vector to devide.</param>
             
             <returns>Returns a vector which coordinates are equal to coordinates of the first vector divided by
             corresponding coordinates of the second vector.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector3.op_Division(AForge.Math.Vector3,System.Single)">
             <summary>
             Divides coordinates of the specified vector by the specified factor.
             </summary>
             
             <param name="vector">Vector to divide coordinates of.</param>
             <param name="factor">Factor to divide coordinates of the specified vector by.</param>
             
             <returns>Returns new vector with all coordinates divided by the specified factor.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector3.Divide(AForge.Math.Vector3,System.Single)">
             <summary>
             Divides coordinates of the specified vector by the specified factor.
             </summary>
             
             <param name="vector">Vector to divide coordinates of.</param>
             <param name="factor">Factor to divide coordinates of the specified vector by.</param>
             
             <returns>Returns new vector with all coordinates divided by the specified factor.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector3.op_Equality(AForge.Math.Vector3,AForge.Math.Vector3)">
            <summary>
            Tests whether two specified vectors are equal.
            </summary>
            
            <param name="vector1">The left-hand vector.</param>
            <param name="vector2">The right-hand vector.</param>
            
            <returns>Returns <see langword="true"/> if the two vectors are equal or <see langword="false"/> otherwise.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector3.op_Inequality(AForge.Math.Vector3,AForge.Math.Vector3)">
            <summary>
            Tests whether two specified vectors are not equal.
            </summary>
            
            <param name="vector1">The left-hand vector.</param>
            <param name="vector2">The right-hand vector.</param>
            
            <returns>Returns <see langword="true"/> if the two vectors are not equal or <see langword="false"/> otherwise.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector3.Equals(AForge.Math.Vector3)">
            <summary>
            Tests whether the vector equals to the specified one.
            </summary>
            
            <param name="vector">The vector to test equality with.</param>
            
            <returns>Returns <see langword="true"/> if the two vectors are equal or <see langword="false"/> otherwise.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector3.Equals(System.Object)">
            <summary>
            Tests whether the vector equals to the specified object.
            </summary>
            
            <param name="obj">The object to test equality with.</param>
            
            <returns>Returns <see langword="true"/> if the vector equals to the specified object or <see langword="false"/> otherwise.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector3.GetHashCode">
            <summary>
            Returns the hashcode for this instance.
            </summary>
            
            <returns>A 32-bit signed integer hash code.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector3.Normalize">
             <summary>
             Normalizes the vector by dividing itâ€™s all coordinates with the vector's norm.
             </summary>
             
             <returns>Returns the value of vectorsâ€™ norm before normalization.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector3.Inverse">
             <summary>
             Inverse the vector.
             </summary>
             
             <returns>Returns a vector with all coordinates equal to 1.0 divided by the value of corresponding coordinate
             in this vector (or equal to 0.0 if this vector has corresponding coordinate also set to 0.0).</returns>
            
        </member>
        <member name="M:AForge.Math.Vector3.Abs">
            <summary>
            Calculate absolute values of the vector.
            </summary>
            
            <returns>Returns a vector with all coordinates equal to absolute values of this vector's coordinates.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector3.Cross(AForge.Math.Vector3,AForge.Math.Vector3)">
            <summary>
            Calculates cross product of two vectors.
            </summary>
            
            <param name="vector1">First vector to use for cross product calculation.</param>
            <param name="vector2">Second vector to use for cross product calculation.</param>
            
            <returns>Returns cross product of the two specified vectors.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector3.Dot(AForge.Math.Vector3,AForge.Math.Vector3)">
            <summary>
            Calculates dot product of two vectors.
            </summary>
            
            <param name="vector1">First vector to use for dot product calculation.</param>
            <param name="vector2">Second vector to use for dot product calculation.</param>
            
            <returns>Returns dot product of the two specified vectors.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector3.ToVector4">
            <summary>
            Converts the vector to a 4D vector.
            </summary>
            
            <returns>Returns 4D vector which is an extension of the 3D vector.</returns>
            
            <remarks><para>The method returns a 4D vector which has X, Y and Z coordinates equal to the
            coordinates of this 3D vector and <see cref="F:AForge.Math.Vector4.W">W</see> coordinate set to 1.0.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Math.Vector3.Max">
             <summary>
             Returns maximum value of the vector.
             </summary>
            
             <remarks><para>Returns maximum value of all 3 vector's coordinates.</para></remarks>
            
        </member>
        <member name="P:AForge.Math.Vector3.Min">
             <summary>
             Returns minimum value of the vector.
             </summary>
            
             <remarks><para>Returns minimum value of all 3 vector's coordinates.</para></remarks>
            
        </member>
        <member name="P:AForge.Math.Vector3.MaxIndex">
             <summary>
             Returns index of the coordinate with maximum value.
             </summary>
            
             <remarks><para>Returns index of the coordinate, which has the maximum value - 0 for X,
             1 for Y or 2 for Z.</para>
             
             <para><note>If there are multiple coordinates which have the same maximum value, the
             property returns smallest index.</note></para>
             </remarks>
            
        </member>
        <member name="P:AForge.Math.Vector3.MinIndex">
             <summary>
             Returns index of the coordinate with minimum value.
             </summary>
            
             <remarks><para>Returns index of the coordinate, which has the minimum value - 0 for X,
             1 for Y or 2 for Z.</para>
             
             <para><note>If there are multiple coordinates which have the same minimum value, the
             property returns smallest index.</note></para>
             </remarks>
            
        </member>
        <member name="P:AForge.Math.Vector3.Norm">
            <summary>
            Returns vector's norm.
            </summary>
            
            <remarks><para>Returns Euclidean norm of the vector, which is a
            square root of the sum: X<sup>2</sup>+Y<sup>2</sup>+Z<sup>2</sup>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Math.Vector3.Square">
            <summary>
            Returns square of the vector's norm.
            </summary>
            
            <remarks><para>Return X<sup>2</sup>+Y<sup>2</sup>+Z<sup>2</sup>, which is
            a square of <see cref="P:AForge.Math.Vector3.Norm">vector's norm</see> or a <see cref="M:AForge.Math.Vector3.Dot(AForge.Math.Vector3,AForge.Math.Vector3)">dot product</see> of this vector
            with itself.</para></remarks>
            
        </member>
        <member name="T:AForge.Math.Vector4">
            <summary>
            4D Vector structure with X, Y, Z and W coordinates.
            </summary>
            
            <remarks><para>The structure incapsulates X, Y, Z and W coordinates of a 4D vector and
            provides some operations with it.</para></remarks>
            
        </member>
        <member name="F:AForge.Math.Vector4.X">
            <summary>
            X coordinate of the vector.
            </summary>
        </member>
        <member name="F:AForge.Math.Vector4.Y">
            <summary>
            Y coordinate of the vector.
            </summary>
        </member>
        <member name="F:AForge.Math.Vector4.Z">
            <summary>
            Z coordinate of the vector.
            </summary>
        </member>
        <member name="F:AForge.Math.Vector4.W">
            <summary>
            W coordinate of the vector.
            </summary>
        </member>
        <member name="M:AForge.Math.Vector4.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Math.Vector4"/> structure.
            </summary>
            
            <param name="x">X coordinate of the vector.</param>
            <param name="y">Y coordinate of the vector.</param>
            <param name="z">Z coordinate of the vector.</param>
            <param name="w">W coordinate of the vector.</param>
            
        </member>
        <member name="M:AForge.Math.Vector4.#ctor(System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Math.Vector4"/> structure.
            </summary>
            
            <param name="value">Value, which is set to all 4 coordinates of the vector.</param>
            
        </member>
        <member name="M:AForge.Math.Vector4.ToString">
            <summary>
            Returns a string representation of this object.
            </summary>
            
            <returns>A string representation of this object.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector4.ToArray">
            <summary>
            Returns array representation of the vector.
            </summary>
            
            <returns>Array with 4 values containing X/Y/Z/W coordinates.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector4.op_Addition(AForge.Math.Vector4,AForge.Math.Vector4)">
             <summary>
             Adds corresponding coordinates of two vectors.
             </summary>
             
             <param name="vector1">The vector to add to.</param>
             <param name="vector2">The vector to add to the first vector.</param>
             
             <returns>Returns a vector which coordinates are equal to sum of corresponding
             coordinates of the two specified vectors.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector4.Add(AForge.Math.Vector4,AForge.Math.Vector4)">
             <summary>
             Adds corresponding coordinates of two vectors.
             </summary>
             
             <param name="vector1">The vector to add to.</param>
             <param name="vector2">The vector to add to the first vector.</param>
             
             <returns>Returns a vector which coordinates are equal to sum of corresponding
             coordinates of the two specified vectors.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector4.op_Addition(AForge.Math.Vector4,System.Single)">
            <summary>
            Adds a value to all coordinates of the specified vector.
            </summary>
            
            <param name="vector">Vector to add the specified value to.</param>
            <param name="value">Value to add to all coordinates of the vector.</param>
            
            <returns>Returns new vector with all coordinates increased by the specified value.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector4.Add(AForge.Math.Vector4,System.Single)">
            <summary>
            Adds a value to all coordinates of the specified vector.
            </summary>
            
            <param name="vector">Vector to add the specified value to.</param>
            <param name="value">Value to add to all coordinates of the vector.</param>
            
            <returns>Returns new vector with all coordinates increased by the specified value.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector4.op_Subtraction(AForge.Math.Vector4,AForge.Math.Vector4)">
             <summary>
             Subtracts corresponding coordinates of two vectors.
             </summary>
             
             <param name="vector1">The vector to subtract from.</param>
             <param name="vector2">The vector to subtract from the first vector.</param>
             
             <returns>Returns a vector which coordinates are equal to difference of corresponding
             coordinates of the two specified vectors.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector4.Subtract(AForge.Math.Vector4,AForge.Math.Vector4)">
             <summary>
             Subtracts corresponding coordinates of two vectors.
             </summary>
             
             <param name="vector1">The vector to subtract from.</param>
             <param name="vector2">The vector to subtract from the first vector.</param>
             
             <returns>Returns a vector which coordinates are equal to difference of corresponding
             coordinates of the two specified vectors.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector4.op_Subtraction(AForge.Math.Vector4,System.Single)">
            <summary>
            Subtracts a value from all coordinates of the specified vector.
            </summary>
            
            <param name="vector">Vector to subtract the specified value from.</param>
            <param name="value">Value to subtract from all coordinates of the vector.</param>
            
            <returns>Returns new vector with all coordinates decreased by the specified value.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector4.Subtract(AForge.Math.Vector4,System.Single)">
            <summary>
            Subtracts a value from all coordinates of the specified vector.
            </summary>
            
            <param name="vector">Vector to subtract the specified value from.</param>
            <param name="value">Value to subtract from all coordinates of the vector.</param>
            
            <returns>Returns new vector with all coordinates decreased by the specified value.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector4.op_Multiply(AForge.Math.Vector4,AForge.Math.Vector4)">
             <summary>
             Multiplies corresponding coordinates of two vectors.
             </summary>
             
             <param name="vector1">The first vector to multiply.</param>
             <param name="vector2">The second vector to multiply.</param>
             
             <returns>Returns a vector which coordinates are equal to multiplication of corresponding
             coordinates of the two specified vectors.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector4.Multiply(AForge.Math.Vector4,AForge.Math.Vector4)">
             <summary>
             Multiplies corresponding coordinates of two vectors.
             </summary>
             
             <param name="vector1">The first vector to multiply.</param>
             <param name="vector2">The second vector to multiply.</param>
             
             <returns>Returns a vector which coordinates are equal to multiplication of corresponding
             coordinates of the two specified vectors.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector4.op_Multiply(AForge.Math.Vector4,System.Single)">
             <summary>
             Multiplies coordinates of the specified vector by the specified factor.
             </summary>
             
             <param name="vector">Vector to multiply coordinates of.</param>
             <param name="factor">Factor to multiple coordinates of the specified vector by.</param>
             
             <returns>Returns new vector with all coordinates multiplied by the specified factor.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector4.Multiply(AForge.Math.Vector4,System.Single)">
             <summary>
             Multiplies coordinates of the specified vector by the specified factor.
             </summary>
             
             <param name="vector">Vector to multiply coordinates of.</param>
             <param name="factor">Factor to multiple coordinates of the specified vector by.</param>
             
             <returns>Returns new vector with all coordinates multiplied by the specified factor.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector4.op_Division(AForge.Math.Vector4,AForge.Math.Vector4)">
             <summary>
             Divides corresponding coordinates of two vectors.
             </summary>
             
             <param name="vector1">The first vector to divide.</param>
             <param name="vector2">The second vector to devide.</param>
             
             <returns>Returns a vector which coordinates are equal to coordinates of the first vector divided by
             corresponding coordinates of the second vector.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector4.Divide(AForge.Math.Vector4,AForge.Math.Vector4)">
             <summary>
             Divides corresponding coordinates of two vectors.
             </summary>
             
             <param name="vector1">The first vector to divide.</param>
             <param name="vector2">The second vector to devide.</param>
             
             <returns>Returns a vector which coordinates are equal to coordinates of the first vector divided by
             corresponding coordinates of the second vector.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector4.op_Division(AForge.Math.Vector4,System.Single)">
             <summary>
             Divides coordinates of the specified vector by the specified factor.
             </summary>
             
             <param name="vector">Vector to divide coordinates of.</param>
             <param name="factor">Factor to divide coordinates of the specified vector by.</param>
             
             <returns>Returns new vector with all coordinates divided by the specified factor.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector4.Divide(AForge.Math.Vector4,System.Single)">
             <summary>
             Divides coordinates of the specified vector by the specified factor.
             </summary>
             
             <param name="vector">Vector to divide coordinates of.</param>
             <param name="factor">Factor to divide coordinates of the specified vector by.</param>
             
             <returns>Returns new vector with all coordinates divided by the specified factor.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector4.op_Equality(AForge.Math.Vector4,AForge.Math.Vector4)">
            <summary>
            Tests whether two specified vectors are equal.
            </summary>
            
            <param name="vector1">The left-hand vector.</param>
            <param name="vector2">The right-hand vector.</param>
            
            <returns>Returns <see langword="true"/> if the two vectors are equal or <see langword="false"/> otherwise.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector4.op_Inequality(AForge.Math.Vector4,AForge.Math.Vector4)">
            <summary>
            Tests whether two specified vectors are not equal.
            </summary>
            
            <param name="vector1">The left-hand vector.</param>
            <param name="vector2">The right-hand vector.</param>
            
            <returns>Returns <see langword="true"/> if the two vectors are not equal or <see langword="false"/> otherwise.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector4.Equals(AForge.Math.Vector4)">
            <summary>
            Tests whether the vector equals to the specified one.
            </summary>
            
            <param name="vector">The vector to test equality with.</param>
            
            <returns>Returns <see langword="true"/> if the two vectors are equal or <see langword="false"/> otherwise.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector4.Equals(System.Object)">
            <summary>
            Tests whether the vector equals to the specified object.
            </summary>
            
            <param name="obj">The object to test equality with.</param>
            
            <returns>Returns <see langword="true"/> if the vector equals to the specified object or <see langword="false"/> otherwise.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector4.GetHashCode">
            <summary>
            Returns the hashcode for this instance.
            </summary>
            
            <returns>A 32-bit signed integer hash code.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector4.Normalize">
             <summary>
             Normalizes the vector by dividing itâ€™s all coordinates with the vector's norm.
             </summary>
             
             <returns>Returns the value of vectorsâ€™ norm before normalization.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector4.Inverse">
             <summary>
             Inverse the vector.
             </summary>
             
             <returns>Returns a vector with all coordinates equal to 1.0 divided by the value of corresponding coordinate
             in this vector (or equal to 0.0 if this vector has corresponding coordinate also set to 0.0).</returns>
            
        </member>
        <member name="M:AForge.Math.Vector4.Abs">
            <summary>
            Calculate absolute values of the vector.
            </summary>
            
            <returns>Returns a vector with all coordinates equal to absolute values of this vector's coordinates.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector4.Dot(AForge.Math.Vector4,AForge.Math.Vector4)">
            <summary>
            Calculates dot product of two vectors.
            </summary>
            
            <param name="vector1">First vector to use for dot product calculation.</param>
            <param name="vector2">Second vector to use for dot product calculation.</param>
            
            <returns>Returns dot product of the two specified vectors.</returns>
            
        </member>
        <member name="M:AForge.Math.Vector4.ToVector3">
            <summary>
            Converts the vector to a 3D vector.
            </summary>
            
            <returns>Returns 3D vector which has X/Y/Z coordinates equal to X/Y/Z coordinates
            of this vector divided by <see cref="F:AForge.Math.Vector4.W"/>.</returns>
            
        </member>
        <member name="P:AForge.Math.Vector4.Max">
             <summary>
             Returns maximum value of the vector.
             </summary>
            
             <remarks><para>Returns maximum value of all 4 vector's coordinates.</para></remarks>
            
        </member>
        <member name="P:AForge.Math.Vector4.Min">
             <summary>
             Returns minimum value of the vector.
             </summary>
            
             <remarks><para>Returns minimum value of all 4 vector's coordinates.</para></remarks>
            
        </member>
        <member name="P:AForge.Math.Vector4.MaxIndex">
             <summary>
             Returns index of the coordinate with maximum value.
             </summary>
            
             <remarks><para>Returns index of the coordinate, which has the maximum value - 0 for X,
             1 for Y, 2 for Z or 3 for W.</para>
             
             <para><note>If there are multiple coordinates which have the same maximum value, the
             property returns smallest index.</note></para>
             </remarks>
            
        </member>
        <member name="P:AForge.Math.Vector4.MinIndex">
             <summary>
             Returns index of the coordinate with minimum value.
             </summary>
            
             <remarks><para>Returns index of the coordinate, which has the minimum value - 0 for X,
             1 for Y, 2 for Z or 3 for W.</para>
             
             <para><note>If there are multiple coordinates which have the same minimum value, the
             property returns smallest index.</note></para>
             </remarks>
            
        </member>
        <member name="P:AForge.Math.Vector4.Norm">
            <summary>
            Returns vector's norm.
            </summary>
            
            <remarks><para>Returns Euclidean norm of the vector, which is a
            square root of the sum: X<sup>2</sup>+Y<sup>2</sup>+Z<sup>2</sup>+W<sup>2</sup>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Math.Vector4.Square">
            <summary>
            Returns square of the vector's norm.
            </summary>
            
            <remarks><para>Return X<sup>2</sup>+Y<sup>2</sup>+Z<sup>2</sup>+W<sup>2</sup>, which is
            a square of <see cref="P:AForge.Math.Vector4.Norm">vector's norm</see> or a <see cref="M:AForge.Math.Vector4.Dot(AForge.Math.Vector4,AForge.Math.Vector4)">dot product</see> of this vector
            with itself.</para></remarks>
            
        </member>
        <member name="T:Accord.Math.Indices">
            <summary>
              Static extension class for manipulating index vectors (i.e. vectors
              containing integers that represent positions within a collection or
              array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Indices.Random(System.Int32,System.Int32)">
            <summary>
              Returns a vector of the specified <paramref name="size"/> containing 
              indices (0, 1, 2, ... max) up to a given maximum number and in random 
              order. The vector can grow up to to <paramref name="max"/>, but does 
              not include <c>max</c> among its values.
            </summary>
            
            <remarks>
              In other words, this return a sample of size <c>k</c> from a population
              of size <c>n</c>, where <c>k</c> is the parameter <paramref name="size"/>
              and <c>n</c> is the parameter <paramref name="max"/>.
            </remarks>
            
            <example>
            <code>
              var a = Indices.Random(3, 10);  // a possible output is { 1, 7, 4 };
              var b = Indices.Random(10, 10); // a possible output is { 5, 4, 2, 0, 1, 3, 7, 9, 8, 6 };
              
              foreach (var i in Indices.Random(5, 6))
              {
                 // ...
              }
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.Indices.Random(System.Int32)">
            <summary>
              Returns a vector containing indices (0, 1, 2, ..., n - 1) in random 
              order. The vector grows up to to <paramref name="size"/>, but does not
              include <c>size</c> among its values.
            </summary>
            
            <example>
            <code>
              var a = Indices.Random(3);  // a possible output is { 2, 1, 0 };
              var b = Indices.Random(10); // a possible output is { 5, 4, 2, 0, 1, 3, 7, 9, 8, 6 };
              
              foreach (var i in Indices.Random(5))
              {
                 // ...
              }
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.Indices.Random``1(System.Int32,System.Int32)">
            <summary>
              Returns a vector of the specified <paramref name="size"/> containing 
              indices (0, 1, 2, ... max) up to a given maximum number and in random 
              order. The vector can grow up to to <paramref name="max"/>, but does 
              not include <c>max</c> among its values.
            </summary>
            
            <remarks>
              In other words, this return a sample of size <c>k</c> from a population
              of size <c>n</c>, where <c>k</c> is the parameter <paramref name="size"/>
              and <c>n</c> is the parameter <paramref name="max"/>.
            </remarks>
            
            <example>
            <code>
              var a = Indices.Random(3, 10);  // a possible output is { 1, 7, 4 };
              var b = Indices.Random(10, 10); // a possible output is { 5, 4, 2, 0, 1, 3, 7, 9, 8, 6 };
              
              foreach (var i in Indices.Random(5, 6))
              {
                 // ...
              }
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.Indices.Random``1(System.Int32)">
            <summary>
              Returns a vector containing indices (0, 1, 2, ..., n - 1) in random 
              order. The vector grows up to to <paramref name="size"/>, but does not
              include <c>size</c> among its values.
            </summary>
            
            <example>
            <code>
              var a = Indices.Random(3);  // a possible output is { 2, 1, 0 };
              var b = Indices.Random(10); // a possible output is { 5, 4, 2, 0, 1, 3, 7, 9, 8, 6 };
              
              foreach (var i in Indices.Random(5))
              {
                 // ...
              }
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.Indices.Until(System.Int32)">
            <summary>
              Creates a vector containing every index up to <paramref name="n"/>
              such as { 0, 1, 2, 3, 4, ..., n-1 }.
            </summary>
            
            <param name="n">The non-inclusive limit for the index generation.</param>
            
            <returns>
              A vector of size <paramref name="n"/> containing
              all vector indices up to <paramref name="n"/>.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Indices.Until``1(System.Int32)">
            <summary>
              Creates a vector containing every index up to <paramref name="n"/>
              such as { 0.0, 1.0, 2.0, 3.0, 4.0, ..., n-1 } using any choice of 
              numbers, such as byte or double.
            </summary>
            
            <param name="n">The non-inclusive limit for the index generation.</param>
            
            <returns>
              A vector of size <paramref name="n"/> containing
              all vector indices up to <paramref name="n"/>.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Indices.From``1(``0[])">
            <summary>
              Creates a vector containing every index that can be used to
              address a given <paramref name="array"/>, in order. 
            </summary>
            
            <param name="array">The array whose indices will be returned.</param>
            
            <returns>
              A vector of the same size as the given <paramref name="array"/> 
              containing all vector indices from 0 up to the length of 
              <paramref name="array"/>.
            </returns>
            
            <example>
            <code>
              double[] a = { 5.3, 2.3, 4.2 };
              int[] idx = Indices.From(a); // output will be { 0, 1, 2 }
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.Indices.From``2(``1[])">
            <summary>
              Creates a vector containing every index that can be used to
              address a given <paramref name="array"/>, in order, using any
              choice of numbers, such as byte or double.
            </summary>
            
            <param name="array">The array whose indices will be returned.</param>
            
            <returns>
              A vector of the same size as the given <paramref name="array"/> 
              containing all vector indices from 0 up to the length of 
              <paramref name="array"/>.
            </returns>
            
            <example>
            <code>
              double[] a = { 5.3, 2.3, 4.2 };
              int[] idx = Indices.From(a); // output will be { 0, 1, 2 }
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.Indices.From(System.Array)">
            <summary>
              Creates a vector containing every index that can be used to
              address a given <paramref name="array"/>, in order.
            </summary>
            
            <param name="array">The array whose indices will be returned.</param>
            
            <returns>
              An enumerable object that can be used to iterate over all
              positions of the given <paramref name="array">System.Array</paramref>.
            </returns>
            
            <example>
            <code>
              double[,] a = 
              { 
                 { 5.3, 2.3 },
                 { 4.2, 9.2 }
              };
              
              foreach (int[] idx in Indices.From(a))
              {
                 // Get the current element
                 double e = (double)a.GetValue(idx);
              }
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.Indices.Range(System.Int32,System.Int32)">
            <summary>
              Creates a vector containing every index starting at <paramref name="from"/>
              up to <paramref name="to"/> such as { from, from + 1, from + 2, ..., to-1 }.
            </summary>
            
            <param name="from">The inclusive start for the index generation.</param>
            <param name="to">The non-inclusive limit for the index generation.</param>
            
            <returns>
              A vector of size <c>to - from</c> containing all vector 
              indices starting at <paramref name="from"/> and going up
              to (but not including) <paramref name="to"/>.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Indices.Range``1(System.Int32,System.Int32)">
            <summary>
              Creates a vector containing every index starting at <paramref name="from"/>
              up to <paramref name="to"/> such as { from, from + 1, from + 2, ..., to-1 }
              using any choice of numbers, such as byte or double.
            </summary>
            
            <param name="from">The inclusive start for the index generation.</param>
            <param name="to">The non-inclusive limit for the index generation.</param>
            
            <returns>
              A vector of size <c>to - from</c> containing all vector 
              indices starting at <paramref name="from"/> and going up
              to (but not including) <paramref name="to"/>.
            </returns>
            
        </member>
        <member name="F:Accord.IO.MatArrayType.mxCELL_CLASS">
            <summary>
              Cell array
            </summary>
            
        </member>
        <member name="F:Accord.IO.MatArrayType.mxSTRUCT_CLASS">
            <summary>
              Structure 
            </summary>
            
        </member>
        <member name="F:Accord.IO.MatArrayType.mxOBJECT_CLASS">
            <summary>
              Object 
            </summary>
            
        </member>
        <member name="F:Accord.IO.MatArrayType.mxCHAR_CLASS">
            <summary>
              Character array
            </summary>
            
        </member>
        <member name="F:Accord.IO.MatArrayType.mxSPARSE_CLASS">
            <summary>
              Sparse array 
            </summary>
            
        </member>
        <member name="F:Accord.IO.MatArrayType.mxDOUBLE_CLASS">
            <summary>
              Double precision array 
            </summary>
            
        </member>
        <member name="F:Accord.IO.MatArrayType.mxSINGLE_CLASS">
            <summary>
              Single precision array 
            </summary>
            
        </member>
        <member name="F:Accord.IO.MatArrayType.mxINT8_CLASS">
            <summary>
              8-bit, signed integer 
            </summary>
            
        </member>
        <member name="F:Accord.IO.MatArrayType.mxUINT8_CLASS">
            <summary>
              8-bit, unsigned integer 
            </summary>
            
        </member>
        <member name="F:Accord.IO.MatArrayType.mxINT16_CLASS">
            <summary>
              16-bit, signed integer 
            </summary>
            
        </member>
        <member name="F:Accord.IO.MatArrayType.mxUINT16_CLASS">
            <summary>
              16-bit, unsigned integer 
            </summary>
            
        </member>
        <member name="F:Accord.IO.MatArrayType.mxINT32_CLASS">
            <summary>
              32-bit, signed integer 
            </summary>
            
        </member>
        <member name="F:Accord.IO.MatArrayType.mxUINT32_CLASS">
            <summary>
              32-bit, unsigned integer 
            </summary>
            
        </member>
        <member name="F:Accord.IO.MatArrayType.mxINT64_CLASS">
            <summary>
              64-bit, signed integer 
            </summary>
            
        </member>
        <member name="F:Accord.IO.MatArrayType.mxUINT64_CLASS">
            <summary>
              64-bit, unsigned integer 
            </summary>
            
        </member>
        <member name="F:Accord.IO.MatDataType.miINT8">
            <summary>
              8 bit, signed
            </summary>
            
        </member>
        <member name="F:Accord.IO.MatDataType.miUINT8">
             <summary>
               8 bit, unsigned
            </summary>
             
        </member>
        <member name="F:Accord.IO.MatDataType.miINT16">
            <summary>
              16-bit, signed
            </summary>
            
        </member>
        <member name="F:Accord.IO.MatDataType.miUINT16">
            <summary>
              16-bit, unsigned
            </summary>
            
        </member>
        <member name="F:Accord.IO.MatDataType.miINT32">
            <summary>
              32-bit, signed
            </summary>
            
        </member>
        <member name="F:Accord.IO.MatDataType.miUINT32">
            <summary>
              32-bit, unsigned
            </summary>
            
        </member>
        <member name="F:Accord.IO.MatDataType.miSINGLE">
            <summary>
              IEEEÂ® 754 single format
            </summary>
            
        </member>
        <member name="F:Accord.IO.MatDataType.miDOUBLE">
            <summary>
              IEEE 754 double format
            </summary>
            
        </member>
        <member name="F:Accord.IO.MatDataType.miINT64">
            <summary>
              64-bit, signed
            </summary>
            
        </member>
        <member name="F:Accord.IO.MatDataType.miUINT64">
            <summary>
              64-bit, unsigned
            </summary>
            
        </member>
        <member name="F:Accord.IO.MatDataType.miMATRIX">
            <summary>
              MATLAB array
            </summary>
            
        </member>
        <member name="F:Accord.IO.MatDataType.miCOMPRESSED">
            <summary>
              Compressed Data
            </summary>
            
        </member>
        <member name="F:Accord.IO.MatDataType.miUTF8">
            <summary>
              Unicode UTF-8 Encoded Character Data
            </summary>
            
        </member>
        <member name="F:Accord.IO.MatDataType.miUTF16">
            <summary>
              Unicode UTF-16 Encoded Character Data
            </summary>
            
        </member>
        <member name="F:Accord.IO.MatDataType.miUTF32">
            <summary>
              Unicode UTF-32 Encoded Character Data
            </summary>
            
        </member>
        <member name="T:Accord.IO.MatNode">
            <summary>
              Node object contained in <see cref="T:Accord.IO.MatReader">.MAT file</see>. 
              A node can contain a matrix object, a string, or another nodes.
            </summary>
            
        </member>
        <member name="M:Accord.IO.MatNode.GetValue``1">
            <summary>
              Gets the object value contained at this node, if any. 
              Its type can be known by checking the <see cref="T:System.Type"/>
              property of this node.
            </summary>
            
            <typeparam name="T">The object type, if known.</typeparam>
            
            <returns>The object stored at this node.</returns>
            
        </member>
        <member name="M:Accord.IO.MatNode.GetEnumerator">
            <summary>
              Returns an enumerator that iterates through a collection.
            </summary>
            
            <returns>
              An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            
        </member>
        <member name="M:Accord.IO.MatNode.System#Collections#IEnumerable#GetEnumerator">
            <summary>
              Returns an enumerator that iterates through a collection.
            </summary>
            
            <returns>
              An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            
        </member>
        <member name="P:Accord.IO.MatNode.Name">
            <summary>
              Gets the name of this node.
            </summary>
            
        </member>
        <member name="P:Accord.IO.MatNode.Fields">
            <summary>
              Gets the child nodes contained at this node.
            </summary>
            
        </member>
        <member name="P:Accord.IO.MatNode.Value">
            <summary>
              Gets the object value contained at this node, if any. 
              Its type can be known by checking the <see cref="T:System.Type"/>
              property of this node.
            </summary>
            
        </member>
        <member name="P:Accord.IO.MatNode.ValueType">
            <summary>
              Gets the type of the object value contained in this node.
            </summary>
            
        </member>
        <member name="P:Accord.IO.MatNode.Count">
            <summary>
              Gets the number of child objects contained in this node.
            </summary>
            
        </member>
        <member name="P:Accord.IO.MatNode.Item(System.String)">
            <summary>
              Gets the child fields contained under the given name.
            </summary>
            
            <param name="name">The name of the field to be retrieved.</param>
            
        </member>
        <member name="P:Accord.IO.MatNode.Item(System.Int32)">
            <summary>
              Gets the child fields contained under the given name.
            </summary>
            
            <param name="name">The name of the field to be retrieved.</param>
            
        </member>
        <member name="T:Accord.IO.MatReader">
            <summary>
              Reader for .mat files (such as the ones created by Matlab and Octave).
            </summary>
            
            <remarks>
            <para>
              MAT files are binary files containing variables and structures from mathematical 
              processing programs, such as MATLAB or Octave. In MATLAB, .mat files can be created
              using its <c>save</c> and <c>load</c> functions. For the moment, this reader supports
              only version 5 MAT files (Matlab 5 MAT-file).</para>
              
            <para>
              The MATLAB file format is documented at 
              <a href="http://www.mathworks.com/help/pdf_doc/matlab/matfile_format.pdf">
              http://www.mathworks.com/help/pdf_doc/matlab/matfile_format.pdf </a></para>
            </remarks>
            
            <example>
            <code>
            // Create a new MAT file reader
            var reader = new MatReader(file);
            
            // Extract some basic information about the file:
            string description = reader.Description; // "MATLAB 5.0 MAT-file, Platform: PCWIN"
            int    version     = reader.Version;     // 256
            bool   bigEndian   = reader.BigEndian;   // false
            
            
            // Enumerate the fields in the file
            foreach (var field in reader.Fields)
              Console.WriteLine(field.Key); // "structure"
            
            // We have the single following field
            var structure = reader["structure"];
            
            // Enumerate the fields in the structure
            foreach (var field in structure.Fields)
              Console.WriteLine(field.Key); // "a", "string"
            
            // Check the type for the field "a"
            var aType = structure["a"].Type; // byte[,]
            
            // Retrieve the field "a" from the file
            var a = structure["a"].GetValue&lt;byte[,]>();
            
            // We can also do directly if we know the type in advance
            var s = reader["structure"]["string"].GetValue&lt;string>();
            </code>
            </example>
            
        </member>
        <member name="M:Accord.IO.MatReader.#ctor(System.IO.Stream)">
            <summary>
              Creates a new <see cref="T:Accord.IO.MatReader"/>.
            </summary>
            
            <param name="input">The input stream containing the MAT file.</param>
            
        </member>
        <member name="M:Accord.IO.MatReader.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
              Creates a new <see cref="T:Accord.IO.MatReader"/>.
            </summary>
            
            <param name="input">The input stream containing the MAT file.</param>
            <param name="autoTranspose">Pass <c>true</c> to automatically transpose matrices if they 
              have been stored differently from .NET's default row-major order. Default is <c>true</c>.</param>
            
        </member>
        <member name="M:Accord.IO.MatReader.#ctor(System.IO.BinaryReader,System.Boolean)">
            <summary>
              Creates a new <see cref="T:Accord.IO.MatReader"/>.
            </summary>
            
            <param name="reader">A reader for input stream containing the MAT file.</param>
            <param name="autoTranspose">Pass <c>true</c> to automatically transpose matrices if they 
              have been stored differently from .NET's default row-major order. Default is <c>true</c>.</param>
            
        </member>
        <member name="M:Accord.IO.MatReader.Dispose">
            <summary>
              Performs application-defined tasks associated with
              freeing, releasing, or resetting unmanaged resources.
            </summary>
            
        </member>
        <member name="M:Accord.IO.MatReader.Dispose(System.Boolean)">
            <summary>
              Releases unmanaged and - optionally - managed resources
            </summary>
            
            <param name="disposing"><c>true</c> to release both managed and unmanaged
              resources; <c>false</c> to release only unmanaged resources.</param>
            
        </member>
        <member name="M:Accord.IO.MatReader.Finalize">
            <summary>
              Releases unmanaged resources and performs other cleanup operations before the
              <see cref="T:Accord.IO.MatReader"/> is reclaimed by garbage collection.
            </summary>
            
        </member>
        <member name="P:Accord.IO.MatReader.Fields">
            <summary>
              Gets the child nodes contained in this file.
            </summary>
            
        </member>
        <member name="P:Accord.IO.MatReader.Description">
            <summary>
              Gets the human readable description of the MAT file.
            </summary>
            
            <example>
              An example header description could be given by
              <c>"MATLAB 5.0 MAT-file, Platform: PCWIN, Created on: Thu Feb 22 03:12:25 2007"</c>.
            </example>
            
        </member>
        <member name="P:Accord.IO.MatReader.Version">
            <summary>
              Gets the version information about the file. 
              This field should always contain 256.
            </summary>
            
        </member>
        <member name="P:Accord.IO.MatReader.BigEndian">
            <summary>
              Gets whether the MAT file uses the Big-Endian
              standard for bit-order. Currently, only little
              endian is supported.
            </summary>
            
        </member>
        <member name="P:Accord.IO.MatReader.Transpose">
            <summary>
              Gets whether matrices will be auto-transposed 
              to .NET row and column format if necessary.
            </summary>
            
        </member>
        <member name="P:Accord.IO.MatReader.BaseStream">
            <summary>
              Returns the underlying stream.
            </summary>
            
        </member>
        <member name="P:Accord.IO.MatReader.Item(System.String)">
            <summary>
              Gets a child object contained in this node.
            </summary>
            
            <param name="key">The field name or index.</param>
            
        </member>
        <member name="P:Accord.IO.MatReader.Item(System.Int32)">
            <summary>
              Gets a child object contained in this node.
            </summary>
            
            <param name="key">The field index.</param>
            
        </member>
        <member name="T:Accord.IO.MatSparse">
            <summary>
              Sparse matrix representation used by
              <see cref="T:Accord.IO.MatReader">.MAT files</see>.
            </summary>
            
        </member>
        <member name="P:Accord.IO.MatSparse.Rows">
            <summary>
              Gets the sparse row index vector.
            </summary>
            
        </member>
        <member name="P:Accord.IO.MatSparse.Columns">
            <summary>
              Gets the sparse column index vector.
            </summary>
            
        </member>
        <member name="P:Accord.IO.MatSparse.Values">
            <summary>
              Gets the values vector.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.FanChenLinQuadraticOptimization">
             <summary>
               General Sequential Minimal Optimization algorithm for Quadratic Programming problems.
             </summary>
             
             <remarks>
             <para>
              This class implements the same optimization method found in LibSVM. It can be used
              to solve quadratic programming problems where the quadratic matrix Q may be too large
              to fit in memory.</para>
              
             <para>
              The method is described in Fan et al., JMLR 6(2005), p. 1889--1918. It solves the
              minimization problem:</para>
              
             <code>
                min 0.5(\alpha^T Q \alpha) + p^T \alpha
            
                  y^T \alpha = \delta
                  y_i = +1 or -1
                  0 &lt;= alpha_i &lt;= C_i
             </code>
             
             <para>
             Given Q, p, y, C, and an initial feasible point \alpha, where l is
             the size of vectors and matrices and eps is the stopping tolerance.
             </para>
             </remarks>
            
        </member>
        <member name="T:Accord.Math.Optimization.IOptimizationMethod">
            <summary>
              Common interface for function optimization methods.
            </summary>
            
            <seealso cref="T:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShanno"/>
            <seealso cref="T:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno"/>
            <seealso cref="T:Accord.Math.Optimization.ConjugateGradient"/>
            <seealso cref="T:Accord.Math.Optimization.ResilientBackpropagation"/>
            <seealso cref="T:Accord.Math.Optimization.GoldfarbIdnani"/>
            
        </member>
        <member name="M:Accord.Math.Optimization.IOptimizationMethod.Minimize">
            <summary>
              Finds the minimum value of a function. The solution vector
              will be made available at the <see cref="P:Accord.Math.Optimization.IOptimizationMethod.Solution"/> property.
            </summary>
            
            <returns>Returns <c>true</c> if the method converged to a <see cref="P:Accord.Math.Optimization.IOptimizationMethod.Solution"/>.
              In this case, the found value will also be available at the <see cref="P:Accord.Math.Optimization.IOptimizationMethod.Value"/>
              property.</returns>
             
        </member>
        <member name="M:Accord.Math.Optimization.IOptimizationMethod.Maximize">
            <summary>
              Finds the maximum value of a function. The solution vector
              will be made available at the <see cref="P:Accord.Math.Optimization.IOptimizationMethod.Solution"/> property.
            </summary>
            
            <returns>Returns <c>true</c> if the method converged to a <see cref="P:Accord.Math.Optimization.IOptimizationMethod.Solution"/>.
              In this case, the found value will also be available at the <see cref="P:Accord.Math.Optimization.IOptimizationMethod.Value"/>
              property.</returns>
             
        </member>
        <member name="P:Accord.Math.Optimization.IOptimizationMethod.NumberOfVariables">
            <summary>
              Gets the number of variables (free parameters)
              in the optimization problem.
            </summary>
            
            <value>The number of parameters.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.IOptimizationMethod.Solution">
            <summary>
              Gets the current solution found, the values of 
              the parameters which optimizes the function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.IOptimizationMethod.Value">
            <summary>
              Gets the output of the function at the current <see cref="P:Accord.Math.Optimization.IOptimizationMethod.Solution"/>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.FanChenLinQuadraticOptimization.#ctor(System.Int32,System.Func{System.Int32,System.Int32,System.Double})">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.FanChenLinQuadraticOptimization"/> class.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the optimization problem.</param>
            <param name="Q">
              The quadratic matrix Q. It should be specified as a lambda 
              function so Q doesn't need to be always kept in memory.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.FanChenLinQuadraticOptimization.#ctor(System.Int32,System.Func{System.Int32,System.Int32,System.Double},System.Double[],System.Int32[])">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.FanChenLinQuadraticOptimization"/> class.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the optimization problem.</param>
            <param name="Q">
              The quadratic matrix Q. It should be specified as a lambda 
              function so Q doesn't need to be always kept in memory.</param>
            <param name="p">The vector of linear terms p. Default is a zero vector.</param>
            <param name="y">The class labels y. Default is a unit vector.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.FanChenLinQuadraticOptimization.Minimize">
            <summary>
              Finds the minimum value of a function. The solution vector
              will be made available at the <see cref="P:Accord.Math.Optimization.FanChenLinQuadraticOptimization.Solution"/> property.
            </summary>
            
            <returns>
              Returns <c>true</c> if the method converged to a <see cref="P:Accord.Math.Optimization.FanChenLinQuadraticOptimization.Solution"/>.
              In this case, the found value will also be available at the <see cref="P:Accord.Math.Optimization.FanChenLinQuadraticOptimization.Value"/>
              property.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.FanChenLinQuadraticOptimization.Maximize">
            <summary>
              Not supported.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.FanChenLinQuadraticOptimization.NumberOfVariables">
            <summary>
              Gets the number of variables (free parameters) in the optimization 
              problem. In a SVM learning problem, this is the number of samples in
              the learning dataset.
            </summary>
            
            <value>
              The number of parameters for the optimization problem.
            </value>
            
        </member>
        <member name="P:Accord.Math.Optimization.FanChenLinQuadraticOptimization.Solution">
            <summary>
              Gets the current solution found, the values of
              the parameters which optimizes the function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.FanChenLinQuadraticOptimization.Value">
            <summary>
              Gets the output of the function at the current <see cref="P:Accord.Math.Optimization.FanChenLinQuadraticOptimization.Solution"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.FanChenLinQuadraticOptimization.Rho">
            <summary>
              Gets the threshold (bias) value for a SVM trained using this method.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.FanChenLinQuadraticOptimization.Tolerance">
            <summary>
              Gets or sets the precision tolerance before
              the method stops. Default is 0.001.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.FanChenLinQuadraticOptimization.Shrinking">
            <summary>
              Gets or sets a value indicating whether shrinking
              heuristics should be used.
            </summary>
            
            <value>
              <c>true</c> to use shrinking heuristics; otherwise, <c>false</c>.
            </value>
            
        </member>
        <member name="P:Accord.Math.Optimization.FanChenLinQuadraticOptimization.UpperBounds">
            <summary>
              Gets the upper bounds for the optimization problem. In
              a SVM learning problem, this would be the capacity limit
              for each Lagrange multiplier (alpha) in the machine. The
              default is to use a vector filled with 1's.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Random.Generator.Random">
            <summary>
              Gets a reference to the random number generator used
              internally by the Accord.NET classes and methods.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Random.Generator.Seed">
            <summary>
              Sets a random seed for the framework's main <see cref="P:Accord.Math.Random.Generator.Random">internal 
              number generator</see>. Preferably, this method should be called <b>before</b>
              other computations.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Comparers.NamespaceDoc">
            <summary>
              Comparison methods that can be used in sort 
              algorithms such as <see cref="M:System.Array.Sort(System.Array)"/>.
            </summary>
            
            <remarks>
            <para>
             This namespace contains different methods for comparing elements. For
             example, using the classes in this namespace makes it possible to sort
             <see cref="T:Accord.Math.Comparers.ArrayComparer`1">arrays of arrays</see>, <see cref="T:Accord.Math.Comparers.GeneralComparer">
             sort arrays into any direction</see>, or perform <see cref="T:Accord.Math.Comparers.StableComparer`1">
             stable sorts</see>.
             </para>
             
            <para>
              The namespace class diagram is shown below. </para>
              <img src="..\diagrams\classes\Accord.Math.Comparers.png"/>
            </remarks>
            
            <seealso cref="N:Accord.Math"/>
              
        </member>
        <member name="T:Accord.Math.IConvergence`1">
            <summary>
              Common interface for convergence detection algorithms.
            </summary>
            
        </member>
        <member name="M:Accord.Math.IConvergence`1.Clear">
            <summary>
              Resets this instance, reverting all iteration statistics
              statistics (number of iterations, last error) back to zero.
            </summary>
            
        </member>
        <member name="P:Accord.Math.IConvergence`1.Tolerance">
            <summary>
              Gets or sets the maximum relative change in the watched value
              after an iteration of the algorithm used to detect convergence.
            </summary>
            
        </member>
        <member name="P:Accord.Math.IConvergence`1.Iterations">
            <summary>
              Gets or sets the maximum number of iterations
              performed by the iterative algorithm.
            </summary>
            
        </member>
        <member name="P:Accord.Math.IConvergence`1.NewValue">
            <summary>
              Gets or sets the watched value after the iteration.
            </summary>
            
        </member>
        <member name="P:Accord.Math.IConvergence`1.CurrentIteration">
            <summary>
              Gets or sets the current iteration number.
            </summary>
            
        </member>
        <member name="P:Accord.Math.IConvergence`1.HasConverged">
            <summary>
              Gets whether the algorithm has converged.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Convergence.GeneralConvergence">
            <summary>
              General convergence options.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Convergence.GeneralConvergence.#ctor(System.Int32)">
            <summary>
              Creates a new <see cref="T:Accord.Math.Convergence.GeneralConvergence"/> object.
            </summary>
            
            <param name="numberOfVariables">The number of variables to be tracked.</param>
            
        </member>
        <member name="P:Accord.Math.Convergence.GeneralConvergence.NumberOfVariables">
            <summary>
              Gets or sets the number of variables in the problem.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Convergence.GeneralConvergence.RelativeFunctionTolerance">
            <summary>
              Gets or sets the relative function tolerance that should
              be used as convergence criteria. This tracks the relative
              amount that the function output changes after two consecutive
              iterations. Setting this value to zero disables those checks.
              Default is 0.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Convergence.GeneralConvergence.AbsoluteFunctionTolerance">
            <summary>
              Gets or sets the absolute function tolerance that should
              be used as convergence criteria. This tracks the absolute
              amount that the function output changes after two consecutive
              iterations. Setting this value to zero disables those checks.
              Default is 0.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Convergence.GeneralConvergence.RelativeParameterTolerance">
            <summary>
              Gets or sets the relative parameter tolerance that should
              be used as convergence criteria. This tracks the relative
              amount that the model parameters changes after two consecutive
              iterations. Setting this value to zero disables those checks.
              Default is 0.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Convergence.GeneralConvergence.AbsoluteParameterTolerance">
            <summary>
              Gets or sets the absolute parameter tolerance that should
              be used as convergence criteria. This tracks the absolute
              amount that the model parameters changes after two consecutive
              iterations. Setting this value to zero disables those checks.
              Default is 0.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Convergence.GeneralConvergence.Evaluations">
            <summary>
              Gets or sets the number of function evaluations 
              performed by the optimization algorithm.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Convergence.GeneralConvergence.MaximumEvaluations">
            <summary>
              Gets or sets the maximum number of function evaluations to
              be used as convergence criteria. This tracks how many times
              the function to be optimized has been called, and stops the
              algorithm when the number of times specified in this property
              has been reached. Setting this value to zero disables this check.
              Default is 0.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Convergence.GeneralConvergence.MaximumTime">
            <summary>
              Gets or sets the maximum amount of time that an optimization
              algorithm is allowed to run. This property must be set together
              with <see cref="P:Accord.Math.Convergence.GeneralConvergence.StartTime"/> in order to function correctly. 
              Setting this value to <see cref="F:System.TimeSpan.Zero"/> disables this
              check. Default is <see cref="F:System.TimeSpan.Zero"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Convergence.GeneralConvergence.StartTime">
            <summary>
              Gets or sets the time when the algorithm started running. When
              time will be tracked with the <see cref="P:Accord.Math.Convergence.GeneralConvergence.MaximumTime"/> property,
              this property must also be set to a correct value.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Convergence.GeneralConvergence.Cancel">
            <summary>
              Gets or sets whether the algorithm should
              be forced to terminate. Default is false.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.NamespaceDoc">
            <summary>
              Contains numerical decompositions such as <see cref="T:Accord.Math.Decompositions.QrDecomposition">QR</see>,
              <see cref="T:Accord.Math.Decompositions.SingularValueDecomposition">SVD</see>, <see cref="T:Accord.Math.Decompositions.LuDecomposition">LU</see>,
              <see cref="T:Accord.Math.Decompositions.CholeskyDecomposition">Cholesky</see>, and <see cref="T:Accord.Math.Decompositions.NonnegativeMatrixFactorization">
              NMF</see> with specialized definitions for most .NET data types: float, double, and decimals.
            </summary>
            
            <remarks>
            <para>
              The namespace class diagram is shown below. </para>
              <img src="..\diagrams\classes\Accord.Math.Decompositions.png"/>
            </remarks>
            
            <seealso cref="N:Accord.Math"/>
            <seealso cref="N:Accord.Math.Optimization"/>
              
        </member>
        <member name="T:Accord.Math.Decompositions.JaggedEigenvalueDecomposition">
             <summary>
                 Determines the eigenvalues and eigenvectors of a real square matrix.
             </summary>
            
             <remarks>
               <para>
                 In the mathematical discipline of linear algebra, eigendecomposition
                 or sometimes spectral decomposition is the factorization of a matrix
                 into a canonical form, whereby the matrix is represented in terms of
                 its eigenvalues and eigenvectors.</para>
               <para>
                 If <c>A</c> is symmetric, then <c>A = V * D * V'</c> and <c>A = V * V'</c>
                 where the eigenvalue matrix <c>D</c> is diagonal and the eigenvector matrix <c>V</c> is orthogonal.
                 If <c>A</c> is not symmetric, the eigenvalue matrix <c>D</c> is block diagonal
                 with the real eigenvalues in 1-by-1 blocks and any complex eigenvalues,
                 <c>lambda + i*mu</c>, in 2-by-2 blocks, <c>[lambda, mu; -mu, lambda]</c>.
                 The columns of <c>V</c> represent the eigenvectors in the sense that <c>A * V = V * D</c>.
                 The matrix V may be badly conditioned, or even singular, so the validity of the equation
                 <c>A = V * D * inverse(V)</c> depends upon the condition of <c>V</c>.
               </para>
             </remarks>
             
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedEigenvalueDecomposition.#ctor(System.Double[][])">
            <summary>
              Construct an eigenvalue decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedEigenvalueDecomposition.#ctor(System.Double[][],System.Boolean)">
             <summary>
               Construct an eigenvalue decomposition.</summary>
             <param name="value">
            
               The matrix to be decomposed.</param>
             <param name="assumeSymmetric">
               Defines if the matrix should be assumed as being symmetric
               regardless if it is or not. Default is <see langword="false"/>.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedEigenvalueDecomposition.#ctor(System.Double[][],System.Boolean,System.Boolean)">
            <summary>
              Construct an eigenvalue decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="assumeSymmetric">
              Defines if the matrix should be assumed as being symmetric
              regardless if it is or not. Default is <see langword="false"/>.</param>
            <param name="inPlace">
              Pass <see langword="true"/> to perform the decomposition in place. The matrix
              <paramref name="value"/> will be destroyed in the process, resulting in less
              memory comsumption.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedEigenvalueDecomposition.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedEigenvalueDecomposition.RealEigenvalues">
            <summary>Returns the real parts of the eigenvalues.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedEigenvalueDecomposition.ImaginaryEigenvalues">
            <summary>Returns the imaginary parts of the eigenvalues.</summary>    
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedEigenvalueDecomposition.Eigenvectors">
            <summary>Returns the eigenvector matrix.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedEigenvalueDecomposition.DiagonalMatrix">
            <summary>Returns the block diagonal eigenvalue matrix.</summary>
        </member>
        <member name="T:Accord.Math.Decompositions.JaggedEigenvalueDecompositionF">
             <summary>
                 Determines the eigenvalues and eigenvectors of a real square matrix.
             </summary>
            
             <remarks>
               <para>
                 In the mathematical discipline of linear algebra, eigendecomposition
                 or sometimes spectral decomposition is the factorization of a matrix
                 into a canonical form, whereby the matrix is represented in terms of
                 its eigenvalues and eigenvectors.</para>
               <para>
                 If <c>A</c> is symmetric, then <c>A = V * D * V'</c> and <c>A = V * V'</c>
                 where the eigenvalue matrix <c>D</c> is diagonal and the eigenvector matrix <c>V</c> is orthogonal.
                 If <c>A</c> is not symmetric, the eigenvalue matrix <c>D</c> is block diagonal
                 with the real eigenvalues in 1-by-1 blocks and any complex eigenvalues,
                 <c>lambda + i*mu</c>, in 2-by-2 blocks, <c>[lambda, mu; -mu, lambda]</c>.
                 The columns of <c>V</c> represent the eigenvectors in the sense that <c>A * V = V * D</c>.
                 The matrix V may be badly conditioned, or even singular, so the validity of the equation
                 <c>A = V * D * inverse(V)</c> depends upon the condition of <c>V</c>.
               </para>
             </remarks>
             
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedEigenvalueDecompositionF.#ctor(System.Single[][])">
            <summary>
              Construct an eigenvalue decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedEigenvalueDecompositionF.#ctor(System.Single[][],System.Boolean)">
             <summary>
               Construct an eigenvalue decomposition.</summary>
             <param name="value">
            
               The matrix to be decomposed.</param>
             <param name="assumeSymmetric">
               Defines if the matrix should be assumed as being symmetric
               regardless if it is or not. Default is <see langword="false"/>.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedEigenvalueDecompositionF.#ctor(System.Single[][],System.Boolean,System.Boolean)">
            <summary>
              Construct an eigenvalue decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="assumeSymmetric">
              Defines if the matrix should be assumed as being symmetric
              regardless if it is or not. Default is <see langword="false"/>.</param>
            <param name="inPlace">
              Pass <see langword="true"/> to perform the decomposition in place. The matrix
              <paramref name="value"/> will be destroyed in the process, resulting in less
              memory comsumption.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedEigenvalueDecompositionF.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedEigenvalueDecompositionF.RealEigenvalues">
            <summary>Returns the real parts of the eigenvalues.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedEigenvalueDecompositionF.ImaginaryEigenvalues">
            <summary>Returns the imaginary parts of the eigenvalues.</summary>    
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedEigenvalueDecompositionF.Eigenvectors">
            <summary>Returns the eigenvector matrix.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedEigenvalueDecompositionF.DiagonalMatrix">
            <summary>Returns the block diagonal eigenvalue matrix.</summary>
        </member>
        <member name="T:Accord.Math.Decompositions.JaggedQrDecomposition">
             <summary>
               QR decomposition for a rectangular matrix.
             </summary>
            
             <remarks>
             <para>
               For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the QR decomposition
               is an m-by-n orthogonal matrix <c>Q</c> and an n-by-n upper triangular
               matrix <c>R</c> so that <c>A = Q * R</c>.</para>
             <para>
               The QR decomposition always exists, even if the matrix does not have
               full rank, so the constructor will never fail. The primary use of the
               QR decomposition is in the least squares solution of nonsquare systems
               of simultaneous linear equations.
               This will fail if <see cref="P:Accord.Math.Decompositions.JaggedQrDecomposition.FullRank"/> returns <see langword="false"/>.</para>  
             </remarks>
             
        </member>
        <member name="T:Accord.Math.Decompositions.ISolverArrayDecomposition`1">
            <summary>
              Common interface for matrix decompositions which
              can be used to solve linear systems of equations
              involving jagged array matrices.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.ISolverArrayDecomposition`1.Solve(`0[][])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.ISolverArrayDecomposition`1.Solve(`0[])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.ISolverArrayDecomposition`1.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedQrDecomposition.#ctor(System.Double[][])">
            <summary>Constructs a QR decomposition.</summary>    
            <param name="value">The matrix A to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedQrDecomposition.#ctor(System.Double[][],System.Boolean)">
            <summary>Constructs a QR decomposition.</summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedQrDecomposition.Solve(System.Double[][])">
            <summary>Least squares solution of <c>A * X = B</c></summary>
            <param name="value">Right-hand-side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>A matrix that minimized the two norm of <c>Q * R * X - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix row dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedQrDecomposition.SolveTranspose(System.Double[][])">
            <summary>Least squares solution of <c>X * A = B</c></summary>
            <param name="value">Right-hand-side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>A matrix that minimized the two norm of <c>X * Q * R - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix column dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedQrDecomposition.Solve(System.Double[])">
            <summary>Least squares solution of <c>A * X = B</c></summary>
            <param name="value">Right-hand-side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>A matrix that minimized the two norm of <c>Q * R * X - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix row dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedQrDecomposition.Inverse">
            <summary>Least squares solution of <c>A * X = I</c></summary>
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedQrDecomposition.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedQrDecomposition.FullRank">
            <summary>Shows if the matrix <c>A</c> is of full rank.</summary>
            <value>The value is <see langword="true"/> if <c>R</c>, and hence <c>A</c>, has full rank.</value>
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedQrDecomposition.UpperTriangularFactor">
            <summary>Returns the upper triangular factor <c>R</c>.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedQrDecomposition.OrthogonalFactor">
            <summary>Returns the orthogonal factor <c>Q</c>.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedQrDecomposition.Diagonal">
            <summary>Returns the diagonal of <c>R</c>.</summary>
        </member>
        <member name="T:Accord.Math.Decompositions.JaggedQrDecompositionD">
             <summary>
               QR decomposition for a rectangular matrix.
             </summary>
            
             <remarks>
             <para>
               For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the QR decomposition
               is an m-by-n orthogonal matrix <c>Q</c> and an n-by-n upper triangular
               matrix <c>R</c> so that <c>A = Q * R</c>.</para>
             <para>
               The QR decomposition always exists, even if the matrix does not have
               full rank, so the constructor will never fail. The primary use of the
               QR decomposition is in the least squares solution of nonsquare systems
               of simultaneous linear equations.
               This will fail if <see cref="P:Accord.Math.Decompositions.JaggedQrDecompositionD.FullRank"/> returns <see langword="false"/>.</para>  
             </remarks>
             
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedQrDecompositionD.#ctor(System.Decimal[][])">
            <summary>Constructs a QR decomposition.</summary>    
            <param name="value">The matrix A to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedQrDecompositionD.#ctor(System.Decimal[][],System.Boolean)">
            <summary>Constructs a QR decomposition.</summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedQrDecompositionD.Solve(System.Decimal[][])">
            <summary>Least squares solution of <c>A * X = B</c></summary>
            <param name="value">Right-hand-side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>A matrix that minimized the two norm of <c>Q * R * X - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix row dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedQrDecompositionD.SolveTranspose(System.Decimal[][])">
            <summary>Least squares solution of <c>X * A = B</c></summary>
            <param name="value">Right-hand-side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>A matrix that minimized the two norm of <c>X * Q * R - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix column dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedQrDecompositionD.Solve(System.Decimal[])">
            <summary>Least squares solution of <c>A * X = B</c></summary>
            <param name="value">Right-hand-side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>A matrix that minimized the two norm of <c>Q * R * X - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix row dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedQrDecompositionD.Inverse">
            <summary>Least squares solution of <c>A * X = I</c></summary>
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedQrDecompositionD.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedQrDecompositionD.FullRank">
            <summary>Shows if the matrix <c>A</c> is of full rank.</summary>
            <value>The value is <see langword="true"/> if <c>R</c>, and hence <c>A</c>, has full rank.</value>
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedQrDecompositionD.UpperTriangularFactor">
            <summary>Returns the upper triangular factor <c>R</c>.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedQrDecompositionD.OrthogonalFactor">
            <summary>Returns the orthogonal factor <c>Q</c>.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedQrDecompositionD.Diagonal">
            <summary>Returns the diagonal of <c>R</c>.</summary>
        </member>
        <member name="T:Accord.Math.Decompositions.JaggedQrDecompositionF">
             <summary>
               QR decomposition for a rectangular matrix.
             </summary>
            
             <remarks>
             <para>
               For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the QR decomposition
               is an m-by-n orthogonal matrix <c>Q</c> and an n-by-n upper triangular
               matrix <c>R</c> so that <c>A = Q * R</c>.</para>
             <para>
               The QR decomposition always exists, even if the matrix does not have
               full rank, so the constructor will never fail. The primary use of the
               QR decomposition is in the least squares solution of nonsquare systems
               of simultaneous linear equations.
               This will fail if <see cref="P:Accord.Math.Decompositions.JaggedQrDecompositionF.FullRank"/> returns <see langword="false"/>.</para>  
             </remarks>
             
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedQrDecompositionF.#ctor(System.Single[][])">
            <summary>Constructs a QR decomposition.</summary>    
            <param name="value">The matrix A to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedQrDecompositionF.#ctor(System.Single[][],System.Boolean)">
            <summary>Constructs a QR decomposition.</summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedQrDecompositionF.Solve(System.Single[][])">
            <summary>Least squares solution of <c>A * X = B</c></summary>
            <param name="value">Right-hand-side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>A matrix that minimized the two norm of <c>Q * R * X - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix row dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedQrDecompositionF.SolveTranspose(System.Single[][])">
            <summary>Least squares solution of <c>X * A = B</c></summary>
            <param name="value">Right-hand-side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>A matrix that minimized the two norm of <c>X * Q * R - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix column dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedQrDecompositionF.Solve(System.Single[])">
            <summary>Least squares solution of <c>A * X = B</c></summary>
            <param name="value">Right-hand-side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>A matrix that minimized the two norm of <c>Q * R * X - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix row dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedQrDecompositionF.Inverse">
            <summary>Least squares solution of <c>A * X = I</c></summary>
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedQrDecompositionF.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedQrDecompositionF.FullRank">
            <summary>Shows if the matrix <c>A</c> is of full rank.</summary>
            <value>The value is <see langword="true"/> if <c>R</c>, and hence <c>A</c>, has full rank.</value>
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedQrDecompositionF.UpperTriangularFactor">
            <summary>Returns the upper triangular factor <c>R</c>.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedQrDecompositionF.OrthogonalFactor">
            <summary>Returns the orthogonal factor <c>Q</c>.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedQrDecompositionF.Diagonal">
            <summary>Returns the diagonal of <c>R</c>.</summary>
        </member>
        <member name="T:Accord.Math.Decompositions.QrDecomposition">
            <summary>
                 QR decomposition for a rectangular matrix.
            </summary>
            <remarks>
            <para>
              For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the QR decomposition
              is an m-by-n orthogonal matrix <c>Q</c> and an n-by-n upper triangular
              matrix <c>R</c> so that <c>A = Q * R</c>.</para>
            <para>
              The QR decomposition always exists, even if the matrix does not have
              full rank, so the constructor will never fail. The primary use of the
              QR decomposition is in the least squares solution of nonsquare systems
              of simultaneous linear equations.
              This will fail if <see cref="P:Accord.Math.Decompositions.QrDecomposition.FullRank"/> returns <see langword="false"/>.</para>  
            </remarks>
            
        </member>
        <member name="T:Accord.Math.Decompositions.ISolverMatrixDecomposition`1">
            <summary>
              Common interface for matrix decompositions which
              can be used to solve linear systems of equations.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.ISolverMatrixDecomposition`1.Solve(`0[0:,0:])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.ISolverMatrixDecomposition`1.Solve(`0[])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.ISolverMatrixDecomposition`1.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecomposition.#ctor(System.Double[0:,0:])">
            <summary>Constructs a QR decomposition.</summary>    
            <param name="value">The matrix A to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecomposition.#ctor(System.Double[0:,0:],System.Boolean)">
            <summary>Constructs a QR decomposition.</summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecomposition.Solve(System.Double[0:,0:])">
            <summary>Least squares solution of <c>A * X = B</c></summary>
            <param name="value">Right-hand-side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>A matrix that minimized the two norm of <c>Q * R * X - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix row dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecomposition.SolveTranspose(System.Double[0:,0:])">
            <summary>Least squares solution of <c>X * A = B</c></summary>
            <param name="value">Right-hand-side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>A matrix that minimized the two norm of <c>X * Q * R - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix column dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecomposition.Solve(System.Double[])">
            <summary>Least squares solution of <c>A * X = B</c></summary>
            <param name="value">Right-hand-side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>A matrix that minimized the two norm of <c>Q * R * X - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix row dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecomposition.Inverse">
            <summary>Least squares solution of <c>A * X = I</c></summary>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecomposition.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecomposition.FullRank">
            <summary>Shows if the matrix <c>A</c> is of full rank.</summary>
            <value>The value is <see langword="true"/> if <c>R</c>, and hence <c>A</c>, has full rank.</value>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecomposition.UpperTriangularFactor">
            <summary>Returns the upper triangular factor <c>R</c>.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecomposition.OrthogonalFactor">
            <summary>Returns the orthogonal factor <c>Q</c>.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecomposition.Diagonal">
            <summary>Returns the diagonal of <c>R</c>.</summary>
        </member>
        <member name="T:Accord.Math.Decompositions.QrDecompositionD">
            <summary>
                 QR decomposition for a rectangular matrix.
            </summary>
            <remarks>
            <para>
              For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the QR decomposition
              is an m-by-n orthogonal matrix <c>Q</c> and an n-by-n upper triangular
              matrix <c>R</c> so that <c>A = Q * R</c>.</para>
            <para>
              The QR decomposition always exists, even if the matrix does not have
              full rank, so the constructor will never fail. The primary use of the
              QR decomposition is in the least squares solution of nonsquare systems
              of simultaneous linear equations.
              This will fail if <see cref="P:Accord.Math.Decompositions.QrDecompositionD.FullRank"/> returns <see langword="false"/>.</para>  
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionD.#ctor(System.Decimal[0:,0:])">
            <summary>Constructs a QR decomposition.</summary>    
            <param name="value">The matrix A to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionD.#ctor(System.Decimal[0:,0:],System.Boolean)">
            <summary>Constructs a QR decomposition.</summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionD.Solve(System.Decimal[0:,0:])">
            <summary>Least squares solution of <c>A * X = B</c></summary>
            <param name="value">Right-hand-side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>A matrix that minimized the two norm of <c>Q * R * X - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix row dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionD.SolveTranspose(System.Decimal[0:,0:])">
            <summary>Least squares solution of <c>X * A = B</c></summary>
            <param name="value">Right-hand-side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>A matrix that minimized the two norm of <c>X * Q * R - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix column dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionD.Solve(System.Decimal[])">
            <summary>Least squares solution of <c>A * X = B</c></summary>
            <param name="value">Right-hand-side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>A matrix that minimized the two norm of <c>Q * R * X - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix row dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionD.Inverse">
            <summary>Least squares solution of <c>A * X = I</c></summary>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionD.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecompositionD.FullRank">
            <summary>Shows if the matrix <c>A</c> is of full rank.</summary>
            <value>The value is <see langword="true"/> if <c>R</c>, and hence <c>A</c>, has full rank.</value>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecompositionD.UpperTriangularFactor">
            <summary>Returns the upper triangular factor <c>R</c>.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecompositionD.OrthogonalFactor">
            <summary>Returns the orthogonal factor <c>Q</c>.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecompositionD.Diagonal">
            <summary>Returns the diagonal of <c>R</c>.</summary>
        </member>
        <member name="T:Accord.Math.Decompositions.QrDecompositionF">
            <summary>
                 QR decomposition for a rectangular matrix.
            </summary>
            <remarks>
            <para>
              For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the QR decomposition
              is an m-by-n orthogonal matrix <c>Q</c> and an n-by-n upper triangular
              matrix <c>R</c> so that <c>A = Q * R</c>.</para>
            <para>
              The QR decomposition always exists, even if the matrix does not have
              full rank, so the constructor will never fail. The primary use of the
              QR decomposition is in the least squares solution of nonsquare systems
              of simultaneous linear equations.
              This will fail if <see cref="P:Accord.Math.Decompositions.QrDecompositionF.FullRank"/> returns <see langword="false"/>.</para>  
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionF.#ctor(System.Single[0:,0:])">
            <summary>Constructs a QR decomposition.</summary>    
            <param name="value">The matrix A to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionF.#ctor(System.Single[0:,0:],System.Boolean)">
            <summary>Constructs a QR decomposition.</summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionF.Solve(System.Single[0:,0:])">
            <summary>Least squares solution of <c>A * X = B</c></summary>
            <param name="value">Right-hand-side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>A matrix that minimized the two norm of <c>Q * R * X - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix row dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionF.SolveTranspose(System.Single[0:,0:])">
            <summary>Least squares solution of <c>X * A = B</c></summary>
            <param name="value">Right-hand-side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>A matrix that minimized the two norm of <c>X * Q * R - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix column dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionF.Solve(System.Single[])">
            <summary>Least squares solution of <c>A * X = B</c></summary>
            <param name="value">Right-hand-side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>A matrix that minimized the two norm of <c>Q * R * X - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix row dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionF.Inverse">
            <summary>Least squares solution of <c>A * X = I</c></summary>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionF.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecompositionF.FullRank">
            <summary>Shows if the matrix <c>A</c> is of full rank.</summary>
            <value>The value is <see langword="true"/> if <c>R</c>, and hence <c>A</c>, has full rank.</value>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecompositionF.UpperTriangularFactor">
            <summary>Returns the upper triangular factor <c>R</c>.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecompositionF.OrthogonalFactor">
            <summary>Returns the orthogonal factor <c>Q</c>.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecompositionF.Diagonal">
            <summary>Returns the diagonal of <c>R</c>.</summary>
        </member>
        <member name="T:Accord.Math.Dissimilarity">
            <summary>
              Static class Dissimilarity. Provides extension methods defining dissimilarity measures.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Dissimilarity.Dice(System.Int32[],System.Int32[])">
            <summary>
              Computes the Dice dissimilarity between two vectors.
            </summary>
            
            <param name="x">A vector.</param>
            <param name="y">A vector.</param>
            
            <returns>The Dice dissimilarity between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Dissimilarity.Jaccard(System.Int32[],System.Int32[])">
            <summary>
              Computes the Jaccard dissimilarity between two vectors.
            </summary>
            
            <param name="x">A vector.</param>
            <param name="y">A vector.</param>
            
            <returns>The Jaccard dissimilarity between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Dissimilarity.Kulczynski(System.Int32[],System.Int32[])">
            <summary>
              Computes the Kulczynski dissimilarity between two vectors.
            </summary>
            
            <param name="x">A vector.</param>
            <param name="y">A vector.</param>
            
            <returns>The Kulczynski dissimilarity between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Dissimilarity.Matching(System.Int32[],System.Int32[])">
            <summary>
              Computes the Matching dissimilarity between two vectors.
            </summary>
            
            <param name="x">A vector.</param>
            <param name="y">A vector.</param>
            
            <returns>The Matching dissimilarity between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Dissimilarity.RogersTanimoto(System.Int32[],System.Int32[])">
            <summary>
              Computes the Rogers-Tanimoto dissimilarity between two vectors.
            </summary>
            
            <param name="x">A vector.</param>
            <param name="y">A vector.</param>
            
            <returns>The Rogers Tanimoto dissimilarity between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Dissimilarity.RusselRao(System.Int32[],System.Int32[])">
            <summary>
              Computes the Russel Rao dissimilarity between two vectors.
            </summary>
            
            <param name="x">A vector.</param>
            <param name="y">A vector.</param>
            
            <returns>The Russel Rao dissimilarity between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Dissimilarity.SokalMichener(System.Int32[],System.Int32[])">
            <summary>
              Computes the Sokal-Michener dissimilarity between two vectors.
            </summary>
            
            <param name="x">A vector.</param>
            <param name="y">A vector.</param>
            
            <returns>The Sokal-Michener dissimilarity between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Dissimilarity.SokalSneath(System.Int32[],System.Int32[])">
            <summary>
              Computes the Sokal Sneath dissimilarity between two vectors.
            </summary>
            
            <param name="x">A vector.</param>
            <param name="y">A vector.</param>
            
            <returns>The Sokal Sneath dissimilarity between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Dissimilarity.Yule(System.Int32[],System.Int32[])">
            <summary>
              Computes the Yule dissimilarity between two vectors.
            </summary>
            
            <param name="x">A vector.</param>
            <param name="y">A vector.</param>
            
            <returns>The Yule dissimilarity between x and y.</returns>
            
        </member>
        <member name="T:Accord.Math.OwensT">
            <summary>
              Owen's T function and related functions.
            </summary>
            
            <remarks>
            
            <para>
              In mathematics, Owen's T function T(h, a), named after statistician Donald Bruce Owen,
              is defined by</para>
            <code>
                             1   a   exp{-0.5 hÂ²(1+xÂ²)
                T(h, a) =  ----  âˆ«  ------------------- dx
                            2Ï€   0        1 + xÂ²
            </code>
            
            <para>
              The function <c>T(h, a)</c> gives the probability of the event <c>(X &gt; h and 0 &lt; Y &lt; aX)</c>
              where <c>X</c> and <c>Y</c> are independent standard normal random variables. This function can 
              be used to calculate <see cref="M:Accord.Math.Normal.Bivariate(System.Double,System.Double,System.Double)">bivariate normal distribution probabilities</see>
              and, from there, in the calculation of multivariate normal distribution probabilities. It also
              frequently appears in various integrals involving <see cref="T:Accord.Math.Normal">Gaussian</see> functions.
            </para>
            
            <para>
              The code is based on the original FORTRAN77 version by Mike Patefield, David Tandy;
              and the C version created by John Burkardt. The original code for the C version can
              be found at http://people.sc.fsu.edu/~jburkardt/c_src/owens/owens.html  and is valid
              under the LGPL.</para>
            
            <para>
              References:
              <list type="bullet">
                <item><description>
                  http://people.sc.fsu.edu/~jburkardt/c_src/owens/owens.html </description></item>
                <item><description>
                  Mike Patefield, David Tandy, Fast and Accurate Calculation of Owen's T Function,
                  Journal of Statistical Software, Volume 5, Number 5, 2000, pages 1-25.
                  </description></item>
              </list></para>  
            </remarks>
            
            <example>
            <code>
            // Computes Owens' T function
            double t = OwensT.Function(h: 2, a: 42); // 0.011375065974089608
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.OwensT.Function(System.Double,System.Double)">
            <summary>
              Computes Owen's T function for arbitrary H and A.
            </summary>
            
            <param name="h">Owen's T function argument H.</param>
            <param name="a">Owen's T function argument A.</param>
            
            <returns>The value of Owen's T function.</returns>
            
        </member>
        <member name="M:Accord.Math.OwensT.Function(System.Double,System.Double,System.Double)">
            <summary>
              Owen's T function for a restricted range of parameters.
            </summary>
            
            <param name="h">Owen's T function argument H (where 0 &lt;= H).</param>
            <param name="a">Owen's T function argument A (where 0 &lt;= A &lt;= 1).</param>
            <param name="ah">The value of A*H.</param>
            
            <returns>The value of Owen's T function.</returns>
            
        </member>
        <member name="T:Accord.Math.Integration.NamespaceDoc">
            <summary>
              Numerical methods for approximating integrals.
            </summary>
            
            <remarks>
            <para>
             This namespace contains different methods for numerically approximating 
             integrals, such as the <see cref="T:Accord.Math.Integration.TrapezoidalRule">Trapezoidal Rule</see>,
             <see cref="T:Accord.Math.Integration.RombergMethod">Romberg method</see>, up to more advanced versions
             such as the <see cref="T:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod">Infinite Adaptive Gauss
             Kronrod</see> for improper integrals or <see cref="T:Accord.Math.Integration.MonteCarloIntegration">
             Monte Carlo integration</see> for multivariate integrals.</para>
             
            <para>
              The namespace class diagram is shown below. </para>
              <img src="..\diagrams\classes\Accord.Math.Integration.png"/>
            </remarks>
            
            <seealso cref="N:Accord.Math"/>
            <seealso cref="N:Accord.Math.Differentiation"/>
              
        </member>
        <member name="T:Accord.Math.Integration.IMultidimensionalIntegration">
            <summary>
              Common interface for multidimensional integration methods.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Integration.INumericalIntegration">
            <summary>
              Common interface for numeric integration methods.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Integration.INumericalIntegration.Compute">
            <summary>
              Computes the area of the function under the selected 
              range. The computed value will be available at this 
              class's <see cref="P:Accord.Math.Integration.INumericalIntegration.Area"/> property.
            </summary>
            
            <returns>True if the integration method succeeds, false otherwise.</returns>
            
        </member>
        <member name="P:Accord.Math.Integration.INumericalIntegration.Area">
            <summary>
              Gets the numerically computed result of the 
              definite integral for the specified function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.IMultidimensionalIntegration.NumberOfParameters">
            <summary>
              Gets the number of parameters expected by
              the <see cref="P:Accord.Math.Integration.IMultidimensionalIntegration.Function"/> to be integrated.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.IMultidimensionalIntegration.Function">
            <summary>
              Gets or sets the multidimensional function
              whose integral should be computed.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.IMultidimensionalIntegration.Range">
            <summary>
              Gets or sets the range of each input variable 
              under which the integral must be computed.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Integration.IUnivariateIntegration">
            <summary>
              Common interface for multidimensional integration methods.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.IUnivariateIntegration.Function">
            <summary>
              Gets or sets the unidimensional function
              whose integral should be computed.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.IUnivariateIntegration.Range">
            <summary>
              Gets or sets the input range under 
              which the integral must be computed.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Integration.INumericalIntegration`1">
            <summary>
              Common interface for numeric integration methods.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.INumericalIntegration`1.Status">
            <summary>
              Get the exit code returned in the last call to the
              <see cref="M:Accord.Math.Integration.INumericalIntegration.Compute"/> method.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Integration.InfiniteAdaptiveGaussKronrodStatus">
            <summary>
              Status codes for the <see cref="T:Accord.Math.Integration.InfiniteAdaptiveGaussKronrodStatus"/>
              integration method.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Integration.InfiniteAdaptiveGaussKronrodStatus.Success">
            <summary>
              The integration calculation has been completed with success.
              The obtained result is under the selected convergence criteria.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Integration.InfiniteAdaptiveGaussKronrodStatus.MaximumSubdivisions">
            <summary>
              Maximum number of allowed subdivisions has been reached.
            </summary>
            
            <remarks>
             The maximum number of subdivisions allowed has been achieved. One can allow 
             more subdivisions by increasing the value of limit (and taking the according
             dimension adjustments into account). However, if this yields no improvement 
             it is advised to analyze the integrand in order to determine the integration 
             difficulties. If the position of a local difficulty can be determined (e.g. 
             singularity, discontinuity within the interval) one will probably gain from
             splitting up the interval at this point and calling the integrator on the 
             subranges. if possible, an appropriate special-purpose integrator should be
             used, which is designed for handling the type of difficulty involved.
            </remarks>
            
        </member>
        <member name="F:Accord.Math.Integration.InfiniteAdaptiveGaussKronrodStatus.RoundoffError">
            <summary>
              Roundoff errors prevent the tolerance from being reached.
            </summary>
            
            <remarks>
              The occurrence of roundoff error is detected, which prevents the requested 
              tolerance from being achieved. The error may be under-estimated.
            </remarks>
            
        </member>
        <member name="F:Accord.Math.Integration.InfiniteAdaptiveGaussKronrodStatus.BadBehavioredFunction">
            <summary>
              There are severe discontinuities in the integrand function.
            </summary>
            
            <remarks>
              Extremely bad integrand behaviour occurs at some points of the 
              integration interval.
            </remarks>
            
        </member>
        <member name="F:Accord.Math.Integration.InfiniteAdaptiveGaussKronrodStatus.AlgorithmDivergence">
            <summary>
              The algorithm cannot converge.
            </summary>
            
            <remarks>
              The algorithm does not converge. Roundoff error is detected in the
              extrapolation table. It is assumed that the requested tolerance cannot
              be achieved, and that the returned result is the best which can be obtained.
            </remarks>
            
        </member>
        <member name="F:Accord.Math.Integration.InfiniteAdaptiveGaussKronrodStatus.IntegralDiverence">
            <summary>
              The integral is divergent or slowly convergent.
            </summary>
            
            <remarks>
              The integral is probably divergent, or slowly convergent. It must be
              noted that divergence can occur with any other error code.
            </remarks>
            
        </member>
        <member name="T:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod">
             <summary>
               Infinite Adaptive Gauss-Kronrod integration method. 
             </summary>
             
             <remarks>
             <para>
               In applied mathematics, adaptive quadrature is a process in which the
               integral of a function f(x) is approximated using static quadrature rules
               on adaptively refined subintervals of the integration domain. Generally, 
               adaptive algorithms are just as efficient and effective as traditional
               algorithms for "well behaved" integrands, but are also effective for 
               "badly behaved" integrands for which traditional algorithms fail.</para>
             
             <para>
               The algorithm implemented by this class has been based on the original FORTRAN 
               implementation from QUADPACK. The function implemented the Non-adaptive Gauss-
               Kronrod integration is <c>qagi(f,bound,inf,epsabs,epsrel,result,abserr,neval,
               ier,limit,lenw,last,iwork,work)</c>. The original source code is in the public 
               domain, but this version is under the LGPL. The original authors, as long as the 
               original routine description, are listed below:</para>
               
             <para>
               Robert Piessens, Elise de Doncker; Applied Mathematics and Programming Division,
               K.U.Leuven, Leuvenappl. This routine calculates an approximation result to a given 
               integral   i = integral of f over (bound,+infinity) or i = integral of f over 
               (-infinity,bound) or i = integral of f over (-infinity,+infinity) hopefully satisfying
               following claim for accuracy abs(i-result).le.max(epsabs,epsrel*abs(i)).</para>
               
             <para>
               References:
               <list type="bullet">
                 <item><description><a href="http://en.wikipedia.org/wiki/Adaptive_quadrature">
                   Wikipedia, The Free Encyclopedia. Adaptive quadrature. Available on: 
                   http://en.wikipedia.org/wiki/Adaptive_quadrature </a></description></item>
                 <item><description><a href="http://en.wikipedia.org/wiki/QUADPACK">
                   Wikipedia, The Free Encyclopedia. QUADPACK. Available on: 
                   http://en.wikipedia.org/wiki/QUADPACK </a></description></item>
                 <item><description><a href="http://www.netlib.no/netlib/quadpack/qagi.f">
                   Robert Piessens, Elise de Doncker; Non-adaptive integration standard fortran 
                   subroutine (qng.f). Applied Mathematics and Programming Division, K.U.Leuven,
                   Leuvenappl. Available at: http://www.netlib.no/netlib/quadpack/qagi.f </a>
                 </description></item>
               </list>
              </para>
              </remarks>
             
             <example>
             <para>
               Let's say we would like to compute the definite integral of the function 
               <c>f(x) = cos(x)</c> in the interval -1 to +1 using a variety of integration 
               methods, including the <see cref="T:Accord.Math.Integration.TrapezoidalRule"/>, <see cref="T:Accord.Math.Integration.RombergMethod"/>
               and <see cref="T:Accord.Math.Integration.NonAdaptiveGaussKronrod"/>. Those methods can compute definite
               integrals where the integration interval is finite:
             </para>
             
             <code>
             // Declare the function we want to integrate
             Func&lt;double, double&gt; f = (x) =&gt; Math.Cos(x);
            
             // We would like to know its integral from -1 to +1
             double a = -1, b = +1;
            
             // Integrate!
             double trapez  = TrapezoidalRule.Integrate(f, a, b, steps: 1000); // 1.6829414
             double romberg = RombergMethod.Integrate(f, a, b);                // 1.6829419
             double nagk    = NonAdaptiveGaussKronrod.Integrate(f, a, b);      // 1.6829419
             </code>
             
             <para>
               Moreover, it is also possible to calculate the value of improper integrals
               (it is, integrals with infinite bounds) using <see cref="T:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod"/>,
               as shown below. Let's say we would like to compute the area under the Gaussian
               curve from -infinite to +infinite. While this function has infinite bounds, this
               function is known to integrate to 1.</para>
               
             <code>
             // Declare the Normal distribution's density function (which is the Gaussian's bell curve)
             Func&lt;double, double&gt; g = (x) =&gt; (1 / Math.Sqrt(2 * Math.PI)) * Math.Exp(-(x * x) / 2);
            
             // Integrate!
             double iagk = InfiniteAdaptiveGaussKronrod.Integrate(g,
                 Double.NegativeInfinity, Double.PositiveInfinity);   // Result should be 0.99999...
             </code>
             </example>
             
             <seealso cref="T:Accord.Math.Integration.TrapezoidalRule"/>
             <seealso cref="T:Accord.Math.Integration.RombergMethod"/>
             <seealso cref="T:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod"/>
             <seealso cref="T:Accord.Math.Integration.MonteCarloIntegration"/>
             
        </member>
        <member name="M:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod.#ctor(System.Int32)">
            <summary>
              Creates a new <see cref="T:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod"/> integration algorithm.
            </summary>
            
            <param name="subintervals">Maximum number of subintervals in the 
              partition of the given integration interval. Default is 100.</param>
            
        </member>
        <member name="M:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod.#ctor(System.Int32,System.Func{System.Double,System.Double})">
            <summary>
              Creates a new <see cref="T:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod"/> integration algorithm.
            </summary>
            
            <param name="subintervals">Maximum number of subintervals in the 
              partition of the given integration interval. Default is 100.</param>
            <param name="function">The function to be integrated.</param>
            
        </member>
        <member name="M:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod.#ctor(System.Int32,System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>
              Creates a new <see cref="T:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod"/> integration algorithm.
            </summary>
            
            <param name="subintervals">Maximum number of subintervals in the 
              partition of the given integration interval. Default is 100.</param>
            <param name="function">The function to be integrated.</param>
            <param name="a">The lower limit of integration.</param>
            <param name="b">The upper limit of integration.</param>
            
        </member>
        <member name="M:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod.Compute">
            <summary>
              Computes the area of the function under the selected <see cref="P:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod.Range"/>.
              The computed value will be available at this object's <see cref="P:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod.Area"/>.
            </summary>
            
            <remarks>
              If the integration method fails, the reason will be available at <see cref="P:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod.Status"/>.
            </remarks>
            
            <returns>
              True if the integration method succeeds, false otherwise.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod.Integrate(System.Func{System.Double,System.Double})">
            <summary>
              Computes the area under the integral for the given function, in the given 
              integration interval, using the Infinite Adaptive Gauss Kronrod algorithm.
            </summary>
            
            <param name="f">The unidimensional function whose integral should be computed.</param>
            
            <returns>The integral's value in the current interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod.Integrate(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>
              Computes the area under the integral for the given function, in the given 
              integration interval, using the Infinite Adaptive Gauss Kronrod algorithm.
            </summary>
            
            <param name="f">The unidimensional function whose integral should be computed.</param>
            <param name="a">The beginning of the integration interval.</param>
            <param name="b">The ending of the integration interval.</param>
            
            <returns>The integral's value in the current interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod.Integrate(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>
              Computes the area under the integral for the given function, in the given 
              integration interval, using the Infinite Adaptive Gauss Kronrod algorithm.
            </summary>
            
            <param name="f">The unidimensional function whose integral should be computed.</param>
            <param name="a">The beginning of the integration interval.</param>
            <param name="b">The ending of the integration interval.</param>
            <param name="tolerance">
              The relative tolerance under which the solution has to be found. Default is 1e-3.</param>
            
            <returns>The integral's value in the current interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod.Subintervals">
            <summary>
              Get the maximum number of subintervals to be utilized in the
              partition of the <see cref="P:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod.Range">integration interval</see>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod.Function">
            <summary>
              Gets or sets the function to be differentiated.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod.Range">
            <summary>
              Gets or sets the input range under
              which the integral must be computed.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod.ToleranceAbsolute">
            <summary>
              Desired absolute accuracy. If set to zero, this parameter
              will be ignored and only other requisites will be taken
              into account. Default is zero.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod.ToleranceRelative">
            <summary>
              Desired relative accuracy. If set to zero, this parameter
              will be ignored and only other requisites will be taken
              into account. Default is 1e-3.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod.Status">
            <summary>
              Get the exit code returned in the last call to the
              <see cref="M:Accord.Math.Integration.INumericalIntegration.Compute"/> method.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod.Area">
            <summary>
              Gets the numerically computed result of the
              definite integral for the specified function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod.Error">
            <summary>
              Gets the integration error for the
              computed <see cref="P:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod.Area"/> value.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod.FunctionEvaluations">
            <summary>
              Gets the number of function evaluations performed in 
              the last call to the <see cref="M:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod.Compute"/> method.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Integration.NonAdaptiveGaussKronrodStatus">
            <summary>
              Status codes for the <see cref="T:Accord.Math.Integration.NonAdaptiveGaussKronrod"/>
              integration method.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Integration.NonAdaptiveGaussKronrodStatus.Success">
            <summary>
              The integration calculation has been completed with success.
              The obtained result is under the selected convergence criteria.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Integration.NonAdaptiveGaussKronrodStatus.MaximumSteps">
            <summary>
              Maximum number of steps has been reached.
            </summary>
            
            <remarks>
              The maximum number of steps has been executed. The integral
              is probably too difficult to be calculated by dqng.
            </remarks>
            
        </member>
        <member name="T:Accord.Math.Integration.NonAdaptiveGaussKronrod">
             <summary>
               Non-Adaptive Gauss-Kronrod integration method. 
             </summary>
             
             <remarks>
             <para>
               The algorithm implemented by this class has been based on the original FORTRAN 
               implementation from QUADPACK. The function implemented the Non-adaptive Gauss-
               Kronrod integration is <c>qng(f,a,b,epsabs,epsrel,result,abserr,neval,ier)</c>.
               The original source code is in the public domain, but this version is under the
               LGPL. The original authors, as long as the original routine description, are 
               listed below:</para>
             <para>
               Robert Piessens, Elise de Doncker; Applied Mathematics and Programming Division,
               K.U.Leuven, Leuvenappl. This routine calculates an approximation result to a given
               definite integral i = integral of f over (a,b), hopefully satisfying following claim
               for accuracy abs(i-result).le.max(epsabs,epsrel*abs(i)).</para>
               
             <para>
               References:
               <list type="bullet">
                 <item><description><a href="http://en.wikipedia.org/wiki/QUADPACK">
                   Wikipedia, The Free Encyclopedia. QUADPACK. Available on: 
                   http://en.wikipedia.org/wiki/QUADPACK </a></description></item>
                 <item><description><a href="http://www.netlib.no/netlib/quadpack/qng.f">
                   Robert Piessens, Elise de Doncker; Non-adaptive integration standard fortran 
                   subroutine (qng.f). Applied Mathematics and Programming Division, K.U.Leuven,
                   Leuvenappl. Available at: http://www.netlib.no/netlib/quadpack/qng.f </a>
                 </description></item>
               </list>
              </para>
              </remarks>
             
             <example>
             <para>
               Let's say we would like to compute the definite integral of the function 
               <c>f(x) = cos(x)</c> in the interval -1 to +1 using a variety of integration 
               methods, including the <see cref="T:Accord.Math.Integration.TrapezoidalRule"/>, <see cref="T:Accord.Math.Integration.RombergMethod"/>
               and <see cref="T:Accord.Math.Integration.NonAdaptiveGaussKronrod"/>. Those methods can compute definite
               integrals where the integration interval is finite:
             </para>
             
             <code>
             // Declare the function we want to integrate
             Func&lt;double, double&gt; f = (x) =&gt; Math.Cos(x);
            
             // We would like to know its integral from -1 to +1
             double a = -1, b = +1;
            
             // Integrate!
             double trapez  = TrapezoidalRule.Integrate(f, a, b, steps: 1000); // 1.6829414
             double romberg = RombergMethod.Integrate(f, a, b);                // 1.6829419
             double nagk    = NonAdaptiveGaussKronrod.Integrate(f, a, b);      // 1.6829419
             </code>
             
             <para>
               Moreover, it is also possible to calculate the value of improper integrals
               (it is, integrals with infinite bounds) using <see cref="T:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod"/>,
               as shown below. Let's say we would like to compute the area under the Gaussian
               curve from -infinite to +infinite. While this function has infinite bounds, this
               function is known to integrate to 1.</para>
               
             <code>
             // Declare the Normal distribution's density function (which is the Gaussian's bell curve)
             Func&lt;double, double&gt; g = (x) =&gt; (1 / Math.Sqrt(2 * Math.PI)) * Math.Exp(-(x * x) / 2);
            
             // Integrate!
             double iagk = InfiniteAdaptiveGaussKronrod.Integrate(g,
                 Double.NegativeInfinity, Double.PositiveInfinity);   // Result should be 0.99999...
             </code>
             </example>
             
             <seealso cref="T:Accord.Math.Integration.TrapezoidalRule"/>
             <seealso cref="T:Accord.Math.Integration.RombergMethod"/>
             <seealso cref="T:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod"/>
             <seealso cref="T:Accord.Math.Integration.MonteCarloIntegration"/>
             
        </member>
        <member name="M:Accord.Math.Integration.NonAdaptiveGaussKronrod.#ctor">
            <summary>
              Creates a new <see cref="T:Accord.Math.Integration.NonAdaptiveGaussKronrod"/> integration algorithm.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Integration.NonAdaptiveGaussKronrod.#ctor(System.Func{System.Double,System.Double})">
            <summary>
              Creates a new <see cref="T:Accord.Math.Integration.NonAdaptiveGaussKronrod"/> integration algorithm.
            </summary>
            
            <param name="function">The function to be integrated.</param>
            
        </member>
        <member name="M:Accord.Math.Integration.NonAdaptiveGaussKronrod.#ctor(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>
              Creates a new <see cref="T:Accord.Math.Integration.NonAdaptiveGaussKronrod"/> integration algorithm.
            </summary>
            
            <param name="function">The function to be integrated.</param>
            <param name="a">The lower limit of integration.</param>
            <param name="b">The upper limit of integration.</param>
            
        </member>
        <member name="M:Accord.Math.Integration.NonAdaptiveGaussKronrod.Compute">
            <summary>
              Computes the area of the function under the selected <see cref="P:Accord.Math.Integration.NonAdaptiveGaussKronrod.Range"/>.
              The computed value will be available at this object's <see cref="P:Accord.Math.Integration.NonAdaptiveGaussKronrod.Area"/>.
            </summary>
            
            <remarks>
              If the integration method fails, the reason will be available at <see cref="P:Accord.Math.Integration.NonAdaptiveGaussKronrod.Status"/>.
            </remarks>
            
            <returns>
              True if the integration method succeeds, false otherwise.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Integration.NonAdaptiveGaussKronrod.Integrate(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>
              Computes the area under the integral for the given function, 
              in the given integration interval, using Gauss-Kronrod method.
            </summary>
            
            <param name="f">The unidimensional function whose integral should be computed.</param>
            <param name="a">The beginning of the integration interval.</param>
            <param name="b">The ending of the integration interval.</param>
            
            <returns>The integral's value in the current interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Integration.NonAdaptiveGaussKronrod.Integrate(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>
              Computes the area under the integral for the given function, in the given 
              integration interval, using the Non-Adaptive Gauss Kronrod algorithm.
            </summary>
            
            <param name="f">The unidimensional function whose integral should be computed.</param>
            <param name="a">The beginning of the integration interval.</param>
            <param name="b">The ending of the integration interval.</param>
            <param name="tolerance">
              The relative tolerance under which the solution has to be found. Default is 1e-3.</param>
            
            <returns>The integral's value in the current interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Integration.NonAdaptiveGaussKronrod.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Integration.NonAdaptiveGaussKronrod.Function">
            <summary>
              Gets or sets the function to be differentiated.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.NonAdaptiveGaussKronrod.Range">
            <summary>
              Gets or sets the input range under
              which the integral must be computed.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.NonAdaptiveGaussKronrod.ToleranceAbsolute">
            <summary>
              Desired absolute accuracy. If set to zero, this parameter
              will be ignored and only other requisites will be taken
              into account. Default is zero.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.NonAdaptiveGaussKronrod.ToleranceRelative">
            <summary>
              Desired relative accuracy. If set to zero, this parameter
              will be ignored and only other requisites will be taken
              into account. Default is 1e-3.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.NonAdaptiveGaussKronrod.Area">
            <summary>
              Gets the numerically computed result of the
              definite integral for the specified function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.NonAdaptiveGaussKronrod.Error">
            <summary>
              Gets the integration error for the
              computed <see cref="P:Accord.Math.Integration.NonAdaptiveGaussKronrod.Area"/> value.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.NonAdaptiveGaussKronrod.Status">
            <summary>
              Get the exit code returned in the last call to the
              <see cref="M:Accord.Math.Integration.INumericalIntegration.Compute"/> method.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.NonAdaptiveGaussKronrod.FunctionEvaluations">
            <summary>
              Gets the number of function evaluations performed in 
              the last call to the <see cref="M:Accord.Math.Integration.NonAdaptiveGaussKronrod.Compute"/> method.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Differentiation.FiniteDifferences">
            <summary>
              Derivative approximation by finite differences.
            </summary>
            
            <remarks>
            <para>
              Numerical differentiation is a technique of numerical analysis to produce an estimate
              of the derivative of a mathematical function or function subroutine using values from 
              the function and perhaps other knowledge about the function.</para>
              
            <para>
              A finite difference is a mathematical expression of the form f(x + b) âˆ’ f(x + a). If a
              finite difference is divided by b âˆ’ a, one gets a difference quotient. The approximation
              of derivatives by finite differences plays a central role in finite difference methods 
              for the numerical solution of differential equations, especially boundary value problems.
            </para>
            
            <para>
              This class implements Newton's finite differences method for approximating the derivatives 
              of a multivariate function. A simplified version of the class is also available for 
              <see cref="M:Accord.Math.Differentiation.FiniteDifferences.Derivative(System.Func{System.Double,System.Double},System.Double,System.Int32)">univariate functions through
              its Derivative static methods</see>.</para>
              
            <para>
              References:
              <list type="bullet">
                <item><description><a href="http://en.wikipedia.org/wiki/Finite_difference">
                  Wikipedia, The Free Encyclopedia. Finite difference. Available on: 
                  http://en.wikipedia.org/wiki/Finite_difference </a></description></item>
                <item><description>
                Trent F. Guidry, Calculating derivatives of a function numerically. Available on:
                http://www.trentfguidry.net/post/2009/07/12/Calculate-derivatives-function-numerically.aspx
                </description></item>
                </list>
             </para>
            </remarks>
            
            <example>
            <code>
            // Create a simple function with two parameters: f(x, y) = xÂ² + y
            Func &lt;double[], double&gt; function = x =&gt; Math.Pow(x[0], 2) + x[1];
            
            // The gradient function should be g(x,y) = &lt;2x, 1&gt;
            
            // Create a new finite differences calculator
            var calculator = new FiniteDifferences(2, function);
            
            // Evaluate the gradient function at the point (2, -1)
            double[] result = calculator.Compute(2, -1); // answer is (4, 1)
            </code>
            </example>
            
            <seealso cref="N:Accord.Math.Integration"/>
            
        </member>
        <member name="M:Accord.Math.Differentiation.FiniteDifferences.#ctor(System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Differentiation.FiniteDifferences"/> class.
            </summary>
            
            <param name="variables">The number of free parameters in the function.</param>
            
        </member>
        <member name="M:Accord.Math.Differentiation.FiniteDifferences.#ctor(System.Int32,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Differentiation.FiniteDifferences"/> class.
            </summary>
            
            <param name="variables">The number of free parameters in the function.</param>
            <param name="order">The derivative order that should be obtained. Default is 1.</param>
            
        </member>
        <member name="M:Accord.Math.Differentiation.FiniteDifferences.#ctor(System.Int32,System.Int32,System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Differentiation.FiniteDifferences"/> class.
            </summary>
            
            <param name="variables">The number of free parameters in the function.</param>
            <param name="order">The derivative order that should be obtained. Default is 1.</param>
            <param name="stepSize">The relative step size used to approximate the derivatives. Default is 0.01.</param>
            
        </member>
        <member name="M:Accord.Math.Differentiation.FiniteDifferences.#ctor(System.Int32,System.Func{System.Double[],System.Double})">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Differentiation.FiniteDifferences"/> class.
            </summary>
            
            <param name="variables">The number of free parameters in the function.</param>
            <param name="function">The function to be differentiated.</param>
            
        </member>
        <member name="M:Accord.Math.Differentiation.FiniteDifferences.#ctor(System.Int32,System.Func{System.Double[],System.Double},System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Differentiation.FiniteDifferences"/> class.
            </summary>
            
            <param name="variables">The number of free parameters in the function.</param>
            <param name="order">The derivative order that should be obtained. Default is 1.</param>
            <param name="function">The function to be differentiated.</param>
            
        </member>
        <member name="M:Accord.Math.Differentiation.FiniteDifferences.#ctor(System.Int32,System.Func{System.Double[],System.Double},System.Int32,System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Differentiation.FiniteDifferences"/> class.
            </summary>
            
            <param name="variables">The number of free parameters in the function.</param>
            <param name="order">The derivative order that should be obtained. Default is 1.</param>
            <param name="stepSize">The relative step size used to approximate the derivatives. Default is 0.01.</param>
            <param name="function">The function to be differentiated.</param>
            
        </member>
        <member name="M:Accord.Math.Differentiation.FiniteDifferences.Compute(System.Double[])">
            <summary>
              Computes the gradient at the given point <c>x</c>.
            </summary>
            <param name="x">The point where to compute the gradient.</param>
            <returns>The gradient of the function evaluated at point <c>x</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Differentiation.FiniteDifferences.Compute(System.Double[],System.Double[])">
            <summary>
              Computes the gradient at the given point <paramref name="x"/>, 
              storing the result at <paramref name="gradient"/>.
            </summary>
            
            <param name="x">The point where to compute the gradient.</param>
            <param name="gradient">The gradient of the function evaluated at point <c>x</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Differentiation.FiniteDifferences.derivative(System.Double[],System.Int32,System.Double)">
            <summary>
              Computes the derivative at point <c>x_i</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Differentiation.FiniteDifferences.CreateCoefficients(System.Int32)">
            <summary>
              Creates the interpolation coefficients.
            </summary>
            
            <param name="points">The number of points in the tableau.</param>
            
        </member>
        <member name="M:Accord.Math.Differentiation.FiniteDifferences.Interpolate(System.Double[0:,0:][],System.Double[],System.Int32,System.Int32,System.Double)">
            <summary>
              Interpolates the points to obtain an estimative of the derivative at x.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Differentiation.FiniteDifferences.Derivative(System.Func{System.Double,System.Double},System.Double,System.Int32)">
            <summary>
              Computes the derivative for a simpler unidimensional function.
            </summary>
            
            <param name="function">The function to be differentiated.</param>
            <param name="value">The value <c>x</c> at which the derivative should be evaluated.</param>
            <param name="order">The derivative order that should be obtained. Default is 1.</param>
            
            <returns>The derivative of the function at the point <paramref name="value">x</paramref>.</returns>
            
        </member>
        <member name="M:Accord.Math.Differentiation.FiniteDifferences.Derivative(System.Func{System.Double,System.Double},System.Double)">
            <summary>
              Computes the derivative for a simpler unidimensional function.
            </summary>
            
            <param name="function">The function to be differentiated.</param>
            <param name="value">The value <c>x</c> at which the derivative should be evaluated.</param>
            
            <returns>The derivative of the function at the point <paramref name="value">x</paramref>.</returns>
            
        </member>
        <member name="M:Accord.Math.Differentiation.FiniteDifferences.Derivative(System.Func{System.Double,System.Double},System.Double,System.Int32,System.Double)">
            <summary>
              Computes the derivative for a simpler unidimensional function.
            </summary>
            
            <param name="function">The function to be differentiated.</param>
            <param name="order">The derivative order that should be obtained. Default is 1.</param>
            <param name="stepSize">The relative step size used to approximate the derivatives. Default is 0.01.</param>
            <param name="value">The value <c>x</c> at which the derivative should be evaluated.</param>
            
            <returns>The derivative of the function at the point <paramref name="value">x</paramref>.</returns>
            
        </member>
        <member name="P:Accord.Math.Differentiation.FiniteDifferences.Function">
            <summary>
              Gets or sets the function to be differentiated.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Differentiation.FiniteDifferences.StepSizes">
            <summary>
              Gets or sets the relative step size used to
              approximate the derivatives. Default is 1e-2.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Differentiation.FiniteDifferences.Orders">
            <summary>
              Gets or sets the order of the derivatives to be
              obtained. Default is 1 (computes the first derivative).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Differentiation.FiniteDifferences.Points">
            <summary>
              Gets or sets the number of points to be used when 
              computing the approximation. Default is 3.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Integration.MonteCarloIntegration">
            <summary>
              Monte Carlo method for multi-dimensional integration.
            </summary>
            
            <remarks>
            <para>
              In mathematics, Monte Carlo integration is a technique for numerical 
              integration using random numbers. It is a particular Monte Carlo method
              that numerically computes a definite integral. While other algorithms 
              usually evaluate the integrand at a regular grid, Monte Carlo randomly
              choose points at which the integrand is evaluated. This method is 
              particularly useful for higher-dimensional integrals. There are different
              methods to perform a Monte Carlo integration, such as uniform sampling,
              stratified sampling and importance sampling.
            </para>
            
            <para>
              References:
              <list type="bullet">
                <item><description><a href="http://en.wikipedia.org/wiki/Monte_Carlo_integration">
                  Wikipedia, The Free Encyclopedia. Monte Carlo integration. Available on: 
                  http://en.wikipedia.org/wiki/Monte_Carlo_integration </a></description></item>
              </list>
             </para>
             </remarks>
             
            <example>
            <para>
              A common Monte-Carlo integration example is to compute the value of Pi. This is the 
              same example given in Wikipedia's page for Monte-Carlo Integration, available at
              https://en.wikipedia.org/wiki/Monte_Carlo_integration#Example </para>
            <code>
            // Define a function H that tells whether two points 
            // are inside a unit circle (a circle of radius one):
            //
            Func&lt;double, double, double&gt; H = 
                (x, y) =&gt; (x * x + y * y &lt;= 1) ? 1 : 0;
            
            // We will check how many points in the square (-1,-1), (-1,+1), 
            // (+1, -1), (+1, +1) fall into the circle defined by function H.
            //
            double[] from = { -1, -1 };
            double[] to   = { +1, +1 };
            
            int samples = 100000;
            
            // Integrate it! 
            double area = MonteCarloIntegration.Integrate(x =&gt; H(x[0], x[1]), from, to, samples);
            
            // Output should be approximately 3.14.
            </code>
            </example>
             
            <seealso cref="T:Accord.Math.Integration.NonAdaptiveGaussKronrod"/>
            <seealso cref="T:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod"/>
            
        </member>
        <member name="M:Accord.Math.Integration.MonteCarloIntegration.#ctor(System.Int32,System.Func{System.Double[],System.Double})">
            <summary>
              Constructs a new <see cref="T:Accord.Math.Integration.MonteCarloIntegration">Monte Carlo integration method</see>.
            </summary>
            
            <param name="function">The function to be integrated.</param>
            <param name="parameters">The number of parameters expected by the <paramref name="function"/>.</param>
            
        </member>
        <member name="M:Accord.Math.Integration.MonteCarloIntegration.#ctor(System.Int32)">
            <summary>
              Constructs a new <see cref="T:Accord.Math.Integration.MonteCarloIntegration">Monte Carlo integration method</see>.
            </summary>
            
            <param name="parameters">The number of parameters expected by the integrand.</param>
            
        </member>
        <member name="M:Accord.Math.Integration.MonteCarloIntegration.Reset">
            <summary>
              Manually resets the previously computed area and error 
              estimates, so the integral can be computed from scratch 
              without reusing previous computations.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Integration.MonteCarloIntegration.Compute">
            <summary>
              Computes the area of the function under the selected <see cref="P:Accord.Math.Integration.MonteCarloIntegration.Range"/>.
              The computed value will be available at this object's <see cref="P:Accord.Math.Integration.MonteCarloIntegration.Area"/>.
            </summary>
            
            <returns>
              True if the integration method succeeds, false otherwise.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Integration.MonteCarloIntegration.Integrate(System.Func{System.Double[],System.Double},System.Double[],System.Double[],System.Int32)">
            <summary>
              Computes the area of the function under the selected <see cref="P:Accord.Math.Integration.MonteCarloIntegration.Range"/>.
              The computed value will be available at this object's <see cref="P:Accord.Math.Integration.MonteCarloIntegration.Area"/>.
            </summary>
            
            <returns>
              True if the integration method succeeds, false otherwise.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Integration.MonteCarloIntegration.Integrate(System.Func{System.Double[],System.Double},System.Double[],System.Double[])">
            <summary>
              Computes the area of the function under the selected <see cref="P:Accord.Math.Integration.MonteCarloIntegration.Range"/>.
              The computed value will be available at this object's <see cref="P:Accord.Math.Integration.MonteCarloIntegration.Area"/>.
            </summary>
            
            <returns>
              True if the integration method succeeds, false otherwise.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Integration.MonteCarloIntegration.Integrate(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32)">
            <summary>
              Computes the area under the integral for the given function, in the 
              given integration interval, using a Monte Carlo integration algorithm.
            </summary>
            
            <param name="func">The unidimensional function whose integral should be computed.</param>
            <param name="a">The beginning of the integration interval.</param>
            <param name="b">The ending of the integration interval.</param>
            <param name="samples">The number of points that should be sampled.</param>
            
            <returns>The integral's value in the current interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Integration.MonteCarloIntegration.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Integration.MonteCarloIntegration.NumberOfParameters">
            <summary>
              Gets the number of parameters expected by
              the <see cref="P:Accord.Math.Integration.MonteCarloIntegration.Function"/> to be integrated.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.MonteCarloIntegration.Range">
            <summary>
              Gets or sets the range of each input variable
              under which the integral must be computed.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.MonteCarloIntegration.Function">
            <summary>
              Gets or sets the multidimensional function
              whose integral should be computed.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.MonteCarloIntegration.Random">
            <summary>
              Gets or sets the random generator algorithm to be used within
              this <see cref="T:Accord.Math.Integration.MonteCarloIntegration">Monte Carlo method</see>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.MonteCarloIntegration.Area">
            <summary>
              Gets the numerically computed result of the
              definite integral for the specified function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.MonteCarloIntegration.Error">
            <summary>
              Gets the integration error for the
              computed <see cref="P:Accord.Math.Integration.MonteCarloIntegration.Area"/> value.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.MonteCarloIntegration.Iterations">
            <summary>
              Gets or sets the number of random samples
              (iterations) generated by the algorithm.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Combinatorics">
            <summary>
              Static class for combinatorics functions.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Combinatorics.TruthTable(System.Int32)">
             <summary>
               Generates all possible two symbol ordered
               permutations with repetitions allowed (a truth table).
             </summary>
             
             <param name="length">The length of the sequence to generate.</param>
            
             <example>
             <para>
               Suppose we would like to generate a truth table for a binary
               problem. In this case, we are only interested in two symbols:
               0 and 1. Let's then generate the table for three binary values</para>
             
             <code>
             int length = 3;  // The number of variables; or number 
                              // of columns in the generated table.
             
             // Generate the table using Combinatorics.TruthTable(3)
             int[][] table = Combinatorics.TruthTable(length);
             
             // The generated table will be:
             {
                 new int[] { 0, 0, 0 },
                 new int[] { 0, 0, 1 },
                 new int[] { 0, 1, 0 },
                 new int[] { 0, 1, 1 },
                 new int[] { 1, 0, 0 },
                 new int[] { 1, 0, 1 },
                 new int[] { 1, 1, 0 },
                 new int[] { 1, 1, 1 },
             };
             </code>
             </example>
             
        </member>
        <member name="M:Accord.Math.Combinatorics.TruthTable(System.Int32,System.Int32)">
             <summary>
               Generates all possible ordered permutations
               with repetitions allowed (a truth table).
             </summary>
             
             <param name="symbols">The number of symbols.</param>
             <param name="length">The length of the sequence to generate.</param>
            
             <example>
             <para>
               Suppose we would like to generate a truth table for a binary
               problem. In this case, we are only interested in two symbols:
               0 and 1. Let's then generate the table for three binary values</para>
             
             <code>
             int symbols = 2; // Binary variables: either 0 or 1
             int length = 3;  // The number of variables; or number 
                              // of columns in the generated table.
             
             // Generate the table using Combinatorics.TruthTable(2,3)
             int[][] table = Combinatorics.TruthTable(symbols, length);
             
             // The generated table will be:
             {
                 new int[] { 0, 0, 0 },
                 new int[] { 0, 0, 1 },
                 new int[] { 0, 1, 0 },
                 new int[] { 0, 1, 1 },
                 new int[] { 1, 0, 0 },
                 new int[] { 1, 0, 1 },
                 new int[] { 1, 1, 0 },
                 new int[] { 1, 1, 1 },
             };
             </code>
             </example>
             
        </member>
        <member name="M:Accord.Math.Combinatorics.TruthTable(System.Int32[])">
             <summary>
               Generates all possible ordered permutations
               with repetitions allowed (a truth table).
             </summary>
             
             <param name="symbols">The number of symbols for each variable.</param>
             
             <example>
             <para>
               Suppose we would like to generate a truth table (i.e. all possible
               combinations of a set of discrete symbols) for variables that contain
               different numbers symbols. Let's say, for example, that the first 
               variable may contain symbols 0 and 1, the second could contain either
               0, 1, or 2, and the last one again could contain only 0 and 1. Thus
               we can generate the truth table in the following way: </para>
             
             <code>
             // Number of symbols for each variable
             int[] symbols = { 2, 3, 2 };
             
             // Generate the truth table for the given symbols
             int[][] table = Combinatorics.TruthTable(symbols);
             
             // The generated table will be:
             {
                 new int[] { 0, 0, 0 },
                 new int[] { 0, 0, 1 },
                 new int[] { 0, 1, 0 },
                 new int[] { 0, 1, 1 },
                 new int[] { 0, 2, 0 },
                 new int[] { 0, 2, 1 },
                 new int[] { 1, 0, 0 },
                 new int[] { 1, 0, 1 },
                 new int[] { 1, 1, 0 },
                 new int[] { 1, 1, 1 },
                 new int[] { 1, 2, 0 },
                 new int[] { 1, 2, 1 },
             };
             </code></example>
            
        </member>
        <member name="M:Accord.Math.Combinatorics.Sequences(System.Int32,System.Int32,System.Boolean)">
            <summary>
              Provides a way to enumerate all possible ordered permutations
              with repetitions allowed (i.e. a truth table), without using
              many memory allocations.
            </summary>
            
            <param name="symbols">The number of symbols.</param>
            <param name="length">The length of the sequence to generate.</param>
            <param name="inPlace">
              If set to true, the different generated sequences will be stored in 
              the same array, thus preserving memory. However, this may prevent the
              samples from being stored in other locations without having to clone
              them. If set to false, a new memory block will be allocated for each
              new object in the sequence.</param>
              
            <example>
            <para>
              Suppose we would like to generate the same sequences shown
              in the <see cref="M:Accord.Math.Combinatorics.TruthTable(System.Int32,System.Int32)"/>example,
              however, without explicitly storing all possible combinations
              in an array. In order to iterate over all possible combinations
              efficiently, we can use:
            </para>
            
            <code>
            int symbols = 2; // Binary variables: either 0 or 1
            int length = 3;  // The number of variables; or number 
                             // of columns in the generated table.
            
            foreach (int[] row in Combinatorics.Sequences(symbols, length))
            {
                // The following sequences will be generated in order:
                //
                //   new int[] { 0, 0, 0 },
                //   new int[] { 0, 0, 1 },
                //   new int[] { 0, 1, 0 },
                //   new int[] { 0, 1, 1 },
                //   new int[] { 1, 0, 0 },
                //   new int[] { 1, 0, 1 },
                //   new int[] { 1, 1, 0 },
                //   new int[] { 1, 1, 1 },
            }
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.Combinatorics.Sequences(System.Int32[],System.Boolean)">
            <summary>
              Provides a way to enumerate all possible ordered permutations
              with repetitions allowed (i.e. a truth table), without using
              many memory allocations.
            </summary>
            
            <param name="symbols">The number of symbols for each variable.</param>
            <param name="inPlace">
              If set to true, the different generated permutations will be stored in 
              the same array, thus preserving memory. However, this may prevent the
              samples from being stored in other locations without having to clone
              them. If set to false, a new memory block will be allocated for each
              new object in the sequence.</param>
            
            <example>
            <para>
              Suppose we would like to generate the same sequences shown
              in the <see cref="M:Accord.Math.Combinatorics.TruthTable(System.Int32,System.Int32)"/>example,
              however, without explicitly storing all possible combinations
              in an array. In order to iterate over all possible combinations
              efficiently, we can use:
            </para>
            
            <code>
            foreach (int[] row in Combinatorics.Sequences(new[] { 2, 2 }))
            {
                // The following sequences will be generated in order:
                //
                //   new int[] { 0, 0, 0 },
                //   new int[] { 0, 0, 1 },
                //   new int[] { 0, 1, 0 },
                //   new int[] { 0, 1, 1 },
                //   new int[] { 1, 0, 0 },
                //   new int[] { 1, 0, 1 },
                //   new int[] { 1, 1, 0 },
                //   new int[] { 1, 1, 1 },
            }
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.Combinatorics.Combinations``1(``0[],System.Int32,System.Boolean)">
            <summary>
              Enumerates all possible value combinations for a given array.
            </summary>
            
            <param name="values">The array whose combinations need to be generated.</param>
            <param name="k">The length of the combinations to be generated.</param>
            <param name="inPlace">
              If set to true, the different generated combinations will be stored in 
              the same array, thus preserving memory. However, this may prevent the
              samples from being stored in other locations without having to clone
              them. If set to false, a new memory block will be allocated for each
              new object in the sequence.</param>
              
            <example>
            <code>
              // Let's say we would like to generate all possible combinations
              // of the elements (1, 2, 3). In order to enumerate all those
              // combinations, we can use:
            
              int[] values = { 1, 2, 3 };
              
              foreach (int[] combination in Combinatorics.Combinations(values))
              {
                  // The combinations will be generated in the following order:
                  //
                  //   { 1, 2 };
                  //   { 1, 3 };
                  //   { 2, 3 };
                  //
              }
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.Combinatorics.Permutations``1(``0[],System.Boolean)">
            <summary>
              Enumerates all possible value permutations for a given array.
            </summary>
            
            <param name="values">The array whose permutations need to be generated</param>.
            <param name="inPlace">
              If set to true, the different generated permutations will be stored in 
              the same array, thus preserving memory. However, this may prevent the
              samples from being stored in other locations without having to clone
              them. If set to false, a new memory block will be allocated for each
              new object in the sequence.</param>
            
            <example>
            <code>
              // Let's say we would like to generate all possible permutations
              // of the elements (1, 2, 3). In order to enumerate all those
              // permutations, we can use:
            
              int[] values = { 1, 2, 3 };
              
              foreach (int[] permutation in Combinatorics.Permutations(values))
              {
                  // The permutations will be generated in the following order:
                  //
                  //   { 1, 3, 2 };
                  //   { 2, 1, 3 };
                  //   { 2, 3, 1 };
                  //   { 3, 1, 2 };
                  //   { 3, 2, 1 };
                  //
              }
            </code>
            </example>
            
        </member>
        <member name="T:Accord.Math.Comparers.IntegerArrayComparer">
            <summary>
              Elementwise comparer for integer arrays. 
              Please use ArrayComparer{T} instead.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Comparers.ArrayComparer`1">
            <summary>
              Elementwise comparer for arrays.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Comparers.ArrayComparer`1.Equals(`0[],`0[])">
            <summary>
              Determines whether two instances are equal.
            </summary>
            
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
            <returns>
              <c>true</c> if the specified object is equal to the other; otherwise, <c>false</c>.
            </returns>
              
        </member>
        <member name="M:Accord.Math.Comparers.ArrayComparer`1.GetHashCode(`0[])">
            <summary>
              Returns a hash code for a given instance.
            </summary>
            
            <param name="obj">The instance.</param>
            
            <returns>
              A hash code for the instance, suitable for use 
              in hashing algorithms and data structures like a hash table. 
            </returns>
            
        </member>
        <member name="T:Accord.Math.Comparers.ElementComparer">
            <summary>
              Element-at-position comparer.
            </summary>
            
            <remarks>
              This class compares arrays by checking the value
              of a particular element at a given array index.
            </remarks>
            
            <example>
            <code>
              // We sort the arrays according to the 
              // elements at their second column.
              
              double[][] values =
              {   //                 v
                  new double[] {  0, 3, 0 },
                  new double[] {  0, 4, 1 },
                  new double[] { -1, 1, 1 },
                  new double[] { -1, 5, 4 },
                  new double[] { -2, 2, 6 },
              };
              
              // Sort the array considering only the second column
              Array.Sort(values, new ElementComparer() { Index = 1 });
              
              // The result will be
              double[][] result =
              {
                  new double[] { -1, 1, 1 },
                  new double[] { -2, 2, 6 },
                  new double[] {  0, 3, 0 },
                  new double[] {  0, 4, 1 },
                  new double[] { -1, 5, 4 },
              };
            </code>
            </example>
            
            <seealso cref="T:Accord.Math.Comparers.ElementComparer`1"/>
            <seealso cref="T:Accord.Math.Comparers.ArrayComparer`1"/>
            <seealso cref="T:Accord.Math.Comparers.GeneralComparer"/>
            <seealso cref="T:Accord.Math.Comparers.CustomComparer`1"/>
            
        </member>
        <member name="T:Accord.Math.Comparers.ElementComparer`1">
            <summary>
              Element-at-position comparer.
            </summary>
            
            <remarks>
              This class compares arrays by checking the value
              of a particular element at a given array index.
            </remarks>
            
            <example>
            <code>
              // We sort the arrays according to the 
              // elements at their second column.
              
              double[][] values =
              {   //                 v
                  new double[] {  0, 3, 0 },
                  new double[] {  0, 4, 1 },
                  new double[] { -1, 1, 1 },
                  new double[] { -1, 5, 4 },
                  new double[] { -2, 2, 6 },
              };
              
              // Sort the array considering only the second column
              Array.Sort(values, new ElementComparer() { Index = 1 });
              
              // The result will be
              double[][] result =
              {
                  new double[] { -1, 1, 1 },
                  new double[] { -2, 2, 6 },
                  new double[] {  0, 3, 0 },
                  new double[] {  0, 4, 1 },
                  new double[] { -1, 5, 4 },
              };
            </code>
            </example>
            
            <seealso cref="T:Accord.Math.Comparers.ElementComparer"/>
            <seealso cref="T:Accord.Math.Comparers.ArrayComparer`1"/>
            <seealso cref="T:Accord.Math.Comparers.GeneralComparer"/>
            <seealso cref="T:Accord.Math.Comparers.CustomComparer`1"/>
            
        </member>
        <member name="M:Accord.Math.Comparers.ElementComparer`1.Compare(`0[],`0[])">
            <summary>
              Compares two objects and returns a value indicating 
              whether one is less than, equal to, or greater than the other.
            </summary>
            
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
            
        </member>
        <member name="M:Accord.Math.Comparers.ElementComparer`1.Equals(`0[],`0[])">
            <summary>
              Determines whether two instances are equal.
            </summary>
            
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
            
            <returns>
              <c>true</c> if the specified object is equal to the other; otherwise, <c>false</c>.
            </returns>
              
        </member>
        <member name="M:Accord.Math.Comparers.ElementComparer`1.GetHashCode(`0[])">
            <summary>
              Returns a hash code for a given instance.
            </summary>
            
            <param name="obj">The instance.</param>
            
            <returns>
              A hash code for the instance, suitable for use
              in hashing algorithms and data structures like a hash table. 
            </returns>
            
        </member>
        <member name="P:Accord.Math.Comparers.ElementComparer`1.Index">
            <summary>
              Gets or sets the element index to compare.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Comparers.CustomComparer`1">
            <summary>
              Custom comparer which accepts any delegate or
              anonymous function to perform value comparisons.
            </summary>
            
            <typeparam name="T">The type of objects to compare.</typeparam>
            
            <example>
            <code>
              // Assume we have values to sort
              double[] values = { 0, 5, 3, 1, 8 };
              
              // We can create an ad-hoc sorting rule using
              Array.Sort(values, new CustomComparer&lt;double>((a, b) => -a.CompareTo(b)));
              
              // Result will be { 8, 5, 3, 1, 0 }.
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.Comparers.CustomComparer`1.#ctor(System.Func{`0,`0,System.Int32})">
            <summary>
              Constructs a new <see cref="T:Accord.Math.Comparers.CustomComparer`1"/>.
            </summary>
            
            <param name="comparer">The comparer function.</param>
            
        </member>
        <member name="M:Accord.Math.Comparers.CustomComparer`1.Compare(`0,`0)">
            <summary>
              Compares two objects and returns a value indicating
              whether one is less than, equal to, or greater than
              the other.
            </summary>
            
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
            
            <returns>A signed integer that indicates the relative values of x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Comparers.CustomComparer`1.Equals(`0,`0)">
            <summary>
              Determines whether the specified objects are equal.
            </summary>
            
            <param name="x">The first object of type T to compare.</param>
            <param name="y">The second object of type T to compare.</param>
            
            <returns>true if the specified objects are equal; otherwise, false.</returns>
            
        </member>
        <member name="M:Accord.Math.Comparers.CustomComparer`1.GetHashCode(`0)">
            <summary>
              Returns a hash code for the given object.
            </summary>
            
            <param name="obj">The object.</param>
            
            <returns>
              A hash code for the given object, suitable for use in
              hashing algorithms and data structures like a hash table. 
            </returns>
            
        </member>
        <member name="T:Accord.Math.Comparers.ComparerDirection">
            <summary>
              Directions for the General Comparer.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Comparers.ComparerDirection.Ascending">
            <summary>
              Sorting will be performed in ascending order.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Comparers.ComparerDirection.Descending">
            <summary>
              Sorting will be performed in descending order.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Comparers.GeneralComparer">
            <summary>
              General comparer which supports multiple 
              directions and comparison of absolute values.
            </summary>
            
            <example>
            <code>
              // Assume we have values to sort
              double[] values = { 0, -5, 3, 1, 8 };
              
              // We can create an ad-hoc sorting rule considering only absolute values
              Array.Sort(values, new GeneralComparer(ComparerDirection.Ascending, Math.Abs));
              
              // Result will be { 0, 1, 3, 5, 8 }.
            </code>
            </example>
            
            <seealso cref="T:Accord.Math.Comparers.ElementComparer`1"/>
            <seealso cref="T:Accord.Math.Comparers.ArrayComparer`1"/>
            <seealso cref="T:Accord.Math.Comparers.GeneralComparer"/>
            <seealso cref="T:Accord.Math.Comparers.CustomComparer`1"/>
            
        </member>
        <member name="M:Accord.Math.Comparers.GeneralComparer.#ctor(Accord.Math.Comparers.ComparerDirection)">
            <summary>
              Constructs a new General Comparer.
            </summary>
            
            <param name="direction">The direction to compare.</param>
            
        </member>
        <member name="M:Accord.Math.Comparers.GeneralComparer.#ctor(Accord.Math.Comparers.ComparerDirection,System.Boolean)">
            <summary>
              Constructs a new General Comparer.
            </summary>
            
            <param name="direction">The direction to compare.</param>
            <param name="useAbsoluteValues">True to compare absolute values, false otherwise. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.Comparers.GeneralComparer.#ctor(Accord.Math.Comparers.ComparerDirection,System.Func{System.Double,System.Double})">
            <summary>
              Constructs a new General Comparer.
            </summary>
            
            <param name="direction">The direction to compare.</param>
            <param name="map">The mapping function which will be applied to
              each vector element prior to any comparisons.</param>
            
        </member>
        <member name="M:Accord.Math.Comparers.GeneralComparer.Compare(System.Double,System.Double)">
            <summary>
              Compares two objects and returns a value indicating whether one is less than,
               equal to, or greater than the other.
            </summary>
            
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
            
        </member>
        <member name="M:Accord.Math.Comparers.GeneralComparer.Compare(System.Int32,System.Int32)">
            <summary>
              Compares two objects and returns a value indicating whether one is less than,
               equal to, or greater than the other.
            </summary>
            
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
            
        </member>
        <member name="P:Accord.Math.Comparers.GeneralComparer.Direction">
            <summary>
              Gets or sets the sorting direction
              used by this comparer.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Comparers.GeneralComparer`1">
            <summary>
              General comparer which supports multiple sorting directions.
            </summary>
            
            <example>
            <code>
              // Assume we have values to sort
              double[] values = { 0, -5, 3, 1, 8 };
              
              // We can create an ad-hoc sorting rule
              Array.Sort(values, new GeneralComparer&lt;double&gt;(ComparerDirection.Descending));
              
              // Result will be { 8, 5, 3, 1, 0 }.
            </code>
            </example>
            
            <seealso cref="T:Accord.Math.Comparers.ElementComparer`1"/>
            <seealso cref="T:Accord.Math.Comparers.ArrayComparer`1"/>
            <seealso cref="T:Accord.Math.Comparers.GeneralComparer"/>
            <seealso cref="T:Accord.Math.Comparers.CustomComparer`1"/>
            
        </member>
        <member name="M:Accord.Math.Comparers.GeneralComparer`1.#ctor(Accord.Math.Comparers.ComparerDirection)">
            <summary>
              Constructs a new General Comparer.
            </summary>
            
            <param name="direction">The direction to compare.</param>
            
        </member>
        <member name="M:Accord.Math.Comparers.GeneralComparer`1.Compare(`0,`0)">
            <summary>
              Compares two objects and returns a value indicating whether one is less than,
               equal to, or greater than the other.
            </summary>
            
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
            
        </member>
        <member name="P:Accord.Math.Comparers.GeneralComparer`1.Direction">
            <summary>
              Gets or sets the sorting direction
              used by this comparer.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Comparers.StableComparer`1">
            <summary>
              Stable comparer for stable sorting algorithm.
            </summary>
            
            <typeparam name="T">The type of objects to compare.</typeparam>
            
            <remarks>
              This class helps sort the elements of an array without swapping
              elements which are already in order. This comprises a <c>stable</c>
              sorting algorithm. This class is used by the <see cref="M:Accord.Math.Tools.StableSort``1(``0[],System.Int32[]@)"/> method to produce a stable sort
              of its given arguments.
            </remarks>
            
            <example>
              In order to use this class, please use <see cref="M:Accord.Math.Tools.StableSort``1(``0[],System.Int32[]@)"/>.
            </example>
            
            <seealso cref="T:Accord.Math.Comparers.ElementComparer`1"/>
            <seealso cref="T:Accord.Math.Comparers.ArrayComparer`1"/>
            <seealso cref="T:Accord.Math.Comparers.GeneralComparer"/>
            <seealso cref="T:Accord.Math.Comparers.CustomComparer`1"/>
            
        </member>
        <member name="M:Accord.Math.Comparers.StableComparer`1.#ctor(System.Comparison{`0})">
            <summary>
              Constructs a new instance of the <see cref="T:Accord.Math.Comparers.StableComparer`1"/> class.
            </summary>
            
            <param name="comparison">The comparison function.</param>
            
        </member>
        <member name="M:Accord.Math.Comparers.StableComparer`1.Compare(System.Collections.Generic.KeyValuePair{System.Int32,`0},System.Collections.Generic.KeyValuePair{System.Int32,`0})">
            <summary>
              Compares two objects and returns a value indicating
              whether one is less than, equal to, or greater than
              the other.
            </summary>
            
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
            
            <returns>A signed integer that indicates the relative values of x and y.</returns>
            
        </member>
        <member name="T:Accord.Math.AbsoluteConvergence">
            <summary>
              Absolute convergence criteria.
            </summary>
            
            <remarks>
              This class can be used to track progress and convergence
              of methods which rely on the absolute change of a value.
            </remarks>
            
            <example>
            <code>
              // Create a new convergence criteria for a maximum of 10 iterations
              var criteria = new AbsoluteConvergence(iterations: 10, tolerance: 0.1);
            
              int progress = 1;
            
              do
              {
                  // Do some processing...
            
            
                  // Update current iteration information:
                  criteria.NewValue = 12345.6 / progress++;
            
              } while (!criteria.HasConverged);
            
              
              // The method will converge after reaching the 
              // maximum of 10 iterations with a final value
              // of 1371.73:
              
              int iterations = criteria.CurrentIteration; // 10
              double value = criteria.OldValue; // 1371.7333333
            </code>
            </example>
            
        </member>
        <member name="T:Accord.Math.ISingleValueConvergence">
            <summary>
              Common interface for convergence detection algorithms that 
              depend solely on a single value (such as the iteration error).
            </summary>
            
        </member>
        <member name="M:Accord.Math.AbsoluteConvergence.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.AbsoluteConvergence"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Math.AbsoluteConvergence.#ctor(System.Int32,System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.AbsoluteConvergence"/> class.
            </summary>
            
            <param name="iterations">The maximum number of iterations which should be
              performed by the iterative algorithm. Setting to zero indicates there
              is no maximum number of iterations. Default is 0.</param>
            <param name="tolerance">The maximum change in the watched value
              after an iteration of the algorithm used to detect convergence.
              Default is 0.</param>
            
        </member>
        <member name="M:Accord.Math.AbsoluteConvergence.Clear">
            <summary>
              Clears this instance.
            </summary>
            
        </member>
        <member name="P:Accord.Math.AbsoluteConvergence.Tolerance">
            <summary>
              Gets or sets the maximum change in the watched value
              after an iteration of the algorithm used to detect 
              convergence. Default is 0.
            </summary>
            
        </member>
        <member name="P:Accord.Math.AbsoluteConvergence.Iterations">
            <summary>
              Gets or sets the maximum number of iterations
              performed by the iterative algorithm. Default 
              is 100.
            </summary>
            
        </member>
        <member name="P:Accord.Math.AbsoluteConvergence.OldValue">
            <summary>
              Gets the watched value before the iteration.
            </summary>
            
        </member>
        <member name="P:Accord.Math.AbsoluteConvergence.NewValue">
            <summary>
              Gets or sets the watched value after the iteration.
            </summary>
            
        </member>
        <member name="P:Accord.Math.AbsoluteConvergence.CurrentIteration">
            <summary>
              Gets or sets the current iteration number.
            </summary>
            
        </member>
        <member name="P:Accord.Math.AbsoluteConvergence.HasConverged">
            <summary>
              Gets whether the algorithm has converged.
            </summary>
            
        </member>
        <member name="T:Accord.Math.RelativeConvergence">
            <summary>
              Relative convergence criteria.
            </summary>
            
            <remarks>
              This class can be used to track progress and convergence
              of methods which rely on the relative change of a value.
            </remarks>
            
            <example>
            <code>
              // Create a new convergence criteria with unlimited iterations
              var criteria = new RelativeConvergence(iterations: 0, tolerance: 0.1);
              
              int progress = 1;
              
              do
              {
                  // Do some processing...
              
              
                  // Update current iteration information:
                  criteria.NewValue = 12345.6 / progress++;
              
              } while (!criteria.HasConverged);
              
              
              // The method will converge after reaching the 
              // maximum of 11 iterations with a final value
              // of 1234.56:
              
              int iterations = criteria.CurrentIteration; // 11
              double value = criteria.OldValue; // 1234.56
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.RelativeConvergence.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.RelativeConvergence"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Math.RelativeConvergence.#ctor(System.Int32,System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.RelativeConvergence"/> class.
            </summary>
            
            <param name="iterations">The maximum number of iterations which should be
              performed by the iterative algorithm. Setting to zero indicates there
              is no maximum number of iterations. Default is 100.</param>
            <param name="tolerance">The maximum relative change in the watched value
              after an iteration of the algorithm used to detect convergence.
              Default is 0.</param>
            
        </member>
        <member name="M:Accord.Math.RelativeConvergence.#ctor(System.Int32,System.Double,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.RelativeConvergence"/> class.
            </summary>
            
            <param name="iterations">The maximum number of iterations which should be
              performed by the iterative algorithm. Setting to zero indicates there
              is no maximum number of iterations. Default is 0.</param>
            <param name="tolerance">The maximum relative change in the watched value
              after an iteration of the algorithm used to detect convergence.
              Default is 0.</param>
            <param name="checks">The minimum number of convergence checks that the
              iterative algorithm should pass before convergence can be declared
              reached.</param>
            
        </member>
        <member name="M:Accord.Math.RelativeConvergence.Clear">
            <summary>
              Resets this instance, reverting all iteration statistics
              statistics (number of iterations, last error) back to zero.
            </summary>
            
        </member>
        <member name="P:Accord.Math.RelativeConvergence.Tolerance">
            <summary>
              Gets or sets the maximum relative change in the watched value
              after an iteration of the algorithm used to detect convergence.
              Default is zero.
            </summary>
            
        </member>
        <member name="P:Accord.Math.RelativeConvergence.Iterations">
            <summary>
              Gets or sets the maximum number of iterations
              performed by the iterative algorithm. Default
              is 100.
            </summary>
            
        </member>
        <member name="P:Accord.Math.RelativeConvergence.OldValue">
            <summary>
              Gets or sets the watched value before the iteration.
            </summary>
            
        </member>
        <member name="P:Accord.Math.RelativeConvergence.NewValue">
            <summary>
              Gets or sets the watched value after the iteration.
            </summary>
            
        </member>
        <member name="P:Accord.Math.RelativeConvergence.CurrentIteration">
            <summary>
              Gets or sets the current iteration number.
            </summary>
            
        </member>
        <member name="P:Accord.Math.RelativeConvergence.HasConverged">
            <summary>
              Gets whether the algorithm has converged.
            </summary>
            
        </member>
        <member name="T:Accord.Math.RelativeParameterConvergence">
            <summary>
              Relative parameter change convergence criteria.
            </summary>
            
            <remarks>
              This class can be used to track progress and convergence
              of methods which rely on the maximum relative change of
              the values within a parameter vector.
            </remarks>
            
            <example>
            <code>
              // Converge if the maximum change amongst all parameters is less than 0.1:
              var criteria = new RelativeParameterConvergence(iterations: 0, tolerance: 0.1);
            
              int progress = 1;
              double[] parameters = { 12345.6, 952.12, 1925.1 };
              
              do
              {
                  // Do some processing...
            
                  // Update current iteration information:
                  criteria.NewValues = parameters.Divide(progress++);
            
              } while (!criteria.HasConverged);
            
            
              // The method will converge after reaching the 
              // maximum of 11 iterations with a final value
              // of { 1234.56, 95.212, 192.51 }:
            
              int iterations = criteria.CurrentIteration; // 11
              var v = criteria.OldValues; // { 1234.56, 95.212, 192.51 }
            
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.RelativeParameterConvergence.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.RelativeParameterConvergence"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Math.RelativeParameterConvergence.#ctor(System.Int32,System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.RelativeParameterConvergence"/> class.
            </summary>
            
            <param name="iterations">The maximum number of iterations which should be
              performed by the iterative algorithm. Setting to zero indicates there
              is no maximum number of iterations. Default is 0.</param>
            <param name="tolerance">The maximum relative change in the watched value
              after an iteration of the algorithm used to detect convergence.
              Default is 0.</param>
            
        </member>
        <member name="M:Accord.Math.RelativeParameterConvergence.Clear">
            <summary>
              Clears this instance.
            </summary>
            
        </member>
        <member name="P:Accord.Math.RelativeParameterConvergence.Tolerance">
            <summary>
              Gets or sets the maximum change in the watched value
              after an iteration of the algorithm used to detect convergence.
            </summary>
            
        </member>
        <member name="P:Accord.Math.RelativeParameterConvergence.Iterations">
            <summary>
              Gets or sets the maximum number of iterations
              performed by the iterative algorithm.
            </summary>
            
        </member>
        <member name="P:Accord.Math.RelativeParameterConvergence.Delta">
            <summary>
              Gets the maximum relative parameter
              change after the last iteration.
            </summary>
            
        </member>
        <member name="P:Accord.Math.RelativeParameterConvergence.OldValues">
            <summary>
              Gets or sets the watched value before the iteration.
            </summary>
            
        </member>
        <member name="P:Accord.Math.RelativeParameterConvergence.NewValues">
            <summary>
              Gets or sets the watched value after the iteration.
            </summary>
            
        </member>
        <member name="P:Accord.Math.RelativeParameterConvergence.CurrentIteration">
            <summary>
              Gets or sets the current iteration number.
            </summary>
            
        </member>
        <member name="P:Accord.Math.RelativeParameterConvergence.HasDiverged">
            <summary>
              Gets whether the algorithm has diverged.
            </summary>
            
        </member>
        <member name="P:Accord.Math.RelativeParameterConvergence.HasConverged">
            <summary>
              Gets whether the algorithm has converged.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.CholeskyDecomposition">
             <summary>
               Cholesky Decomposition of a symmetric, positive definite matrix.
             </summary>
            
             <remarks>
               <para>
                 For a symmetric, positive definite matrix <c>A</c>, the Cholesky decomposition is a
                 lower triangular matrix <c>L</c> so that <c>A = L * L'</c>.
                 If the matrix is not symmetric or positive definite, the constructor returns a partial 
                 decomposition and sets two internal variables that can be queried using the
                 <see cref="P:Accord.Math.Decompositions.CholeskyDecomposition.Symmetric"/> and <see cref="P:Accord.Math.Decompositions.CholeskyDecomposition.PositiveDefinite"/> properties.</para>
               <para>
                 Any square matrix A with non-zero pivots can be written as the product of a
                 lower triangular matrix L and an upper triangular matrix U; this is called
                 the LU decomposition. However, if A is symmetric and positive definite, we
                 can choose the factors such that U is the transpose of L, and this is called
                 the Cholesky decomposition. Both the LU and the Cholesky decomposition are
                 used to solve systems of linear equations.</para>
               <para>
                 When it is applicable, the Cholesky decomposition is twice as efficient
                 as the LU decomposition.</para>
                </remarks>
                
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.#ctor(System.Double[0:,0:])">
            <summary>Constructs a new Cholesky Decomposition.</summary>
            <param name="value">The matrix to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.#ctor(System.Double[0:,0:],System.Boolean)">
            <summary>Constructs a new Cholesky Decomposition.</summary>
            
            <param name="value">The matrix to be decomposed.</param>
            <param name="robust">True to perform a square root free LDLt decomposition,
            false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.#ctor(System.Double[0:,0:],System.Boolean,System.Boolean)">
            <summary>Constructs a new Cholesky Decomposition.</summary>
            
            <param name="value">The matrix to be decomposed.</param>
            <param name="robust">True to perform a square-root free LDLt decomposition,
            false otherwise.</param>
            <param name="lowerTriangular">True to assume the <paramref name="value">value
            matrix</paramref> is a lower triangular symmetric matrix, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.Solve(System.Double[0:,0:])">
            <summary>Solves a set of equation systems of type <c>A * X = B</c>.</summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is not symmetric and positive definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.Solve(System.Double[0:,0:],System.Boolean)">
            <summary>Solves a set of equation systems of type <c>A * X = B</c>.</summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.Solve(System.Double[])">
            <summary>Solves a set of equation systems of type <c>A * X = B</c>.</summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.Solve(System.Double[],System.Boolean)">
            <summary>Solves a set of equation systems of type <c>A * x = b</c>.</summary>
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Vector <c>x</c> so that <c>L * L' * x = b</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.Inverse">
            <summary>
              Computes the inverse of the decomposed matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.FromLeftTriangularMatrix(System.Double[0:,0:])">
            <summary>
              Creates a new Cholesky decomposition directly from
              an already computed left triangular matrix <c>L</c>.
            </summary>
            <param name="leftTriangular">The left triangular matrix from a Cholesky decomposition.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecomposition.Symmetric">
             <summary>
               Returns <see langword="true"/> if the matrix is symmetric.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecomposition.PositiveDefinite">
             <summary>
               Returns <see langword="true"/> if the matrix is positive definite.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecomposition.LeftTriangularFactor">
             <summary>
               Returns the left (lower) triangular factor <c>L</c> so that <c>A = L * D * L'</c>.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecomposition.DiagonalMatrix">
             <summary>
               Returns the block diagonal matrix of diagonal elements in a LDLt decomposition.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecomposition.Diagonal">
             <summary>
               Returns the one-dimensional array of diagonal elements in a LDLt decomposition.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecomposition.Determinant">
             <summary>
               Returns the determinant of the matrix.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecomposition.LogDeterminant">
             <summary>
               Returns the log-determinant of the matrix.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecomposition.Nonsingular">
             <summary>
               Returns if the matrix is non-singular (i.e. invertible).
             </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.CholeskyDecompositionD">
             <summary>
               Cholesky Decomposition of a symmetric, positive definite matrix.
             </summary>
            
             <remarks>
               <para>
                 For a symmetric, positive definite matrix <c>A</c>, the Cholesky decomposition is a
                 lower triangular matrix <c>L</c> so that <c>A = L * L'</c>.
                 If the matrix is not symmetric or positive definite, the constructor returns a partial 
                 decomposition and sets two internal variables that can be queried using the
                 <see cref="P:Accord.Math.Decompositions.CholeskyDecompositionD.Symmetric"/> and <see cref="P:Accord.Math.Decompositions.CholeskyDecompositionD.PositiveDefinite"/> properties.</para>
               <para>
                 Any square matrix A with non-zero pivots can be written as the product of a
                 lower triangular matrix L and an upper triangular matrix U; this is called
                 the LU decomposition. However, if A is symmetric and positive definite, we
                 can choose the factors such that U is the transpose of L, and this is called
                 the Cholesky decomposition. Both the LU and the Cholesky decomposition are
                 used to solve systems of linear equations.</para>
               <para>
                 When it is applicable, the Cholesky decomposition is twice as efficient
                 as the LU decomposition.</para>
                </remarks>
                
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.#ctor(System.Decimal[0:,0:])">
            <summary>Constructs a new Cholesky Decomposition.</summary>
            <param name="value">The matrix to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.#ctor(System.Decimal[0:,0:],System.Boolean)">
            <summary>Constructs a new Cholesky Decomposition.</summary>
            
            <param name="value">The matrix to be decomposed.</param>
            <param name="robust">True to perform a square root free LDLt decomposition,
            false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.#ctor(System.Decimal[0:,0:],System.Boolean,System.Boolean)">
            <summary>Constructs a new Cholesky Decomposition.</summary>
            
            <param name="value">The matrix to be decomposed.</param>
            <param name="robust">True to perform a square-root free LDLt decomposition,
            false otherwise.</param>
            <param name="lowerTriangular">True to assume the <paramref name="value">value
            matrix</paramref> is a lower triangular symmetric matrix, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.Solve(System.Decimal[0:,0:])">
            <summary>Solves a set of equation systems of type <c>A * X = B</c>.</summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is not symmetric and positive definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.Solve(System.Decimal[0:,0:],System.Boolean)">
            <summary>Solves a set of equation systems of type <c>A * X = B</c>.</summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.Solve(System.Decimal[])">
            <summary>Solves a set of equation systems of type <c>A * X = B</c>.</summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.Solve(System.Decimal[],System.Boolean)">
            <summary>Solves a set of equation systems of type <c>A * x = b</c>.</summary>
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Vector <c>x</c> so that <c>L * L' * x = b</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.Inverse">
            <summary>
              Computes the inverse of the decomposed matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.FromLeftTriangularMatrix(System.Decimal[0:,0:])">
            <summary>
              Creates a new Cholesky decomposition directly from
              an already computed left triangular matrix <c>L</c>.
            </summary>
            <param name="leftTriangular">The left triangular matrix from a Cholesky decomposition.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionD.Symmetric">
             <summary>
               Returns <see langword="true"/> if the matrix is symmetric.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionD.PositiveDefinite">
             <summary>
               Returns <see langword="true"/> if the matrix is positive definite.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionD.LeftTriangularFactor">
             <summary>
               Returns the left (lower) triangular factor <c>L</c> so that <c>A = L * D * L'</c>.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionD.DiagonalMatrix">
             <summary>
               Returns the block diagonal matrix of diagonal elements in a LDLt decomposition.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionD.Diagonal">
             <summary>
               Returns the one-dimensional array of diagonal elements in a LDLt decomposition.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionD.Determinant">
             <summary>
               Returns the determinant of the matrix.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionD.LogDeterminant">
             <summary>
               Returns the log-determinant of the matrix.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionD.Nonsingular">
             <summary>
               Returns if the matrix is non-singular (i.e. invertible).
             </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.CholeskyDecompositionF">
             <summary>
               Cholesky Decomposition of a symmetric, positive definite matrix.
             </summary>
            
             <remarks>
               <para>
                 For a symmetric, positive definite matrix <c>A</c>, the Cholesky decomposition is a
                 lower triangular matrix <c>L</c> so that <c>A = L * L'</c>.
                 If the matrix is not symmetric or positive definite, the constructor returns a partial 
                 decomposition and sets two internal variables that can be queried using the
                 <see cref="P:Accord.Math.Decompositions.CholeskyDecompositionF.Symmetric"/> and <see cref="P:Accord.Math.Decompositions.CholeskyDecompositionF.PositiveDefinite"/> properties.</para>
               <para>
                 Any square matrix A with non-zero pivots can be written as the product of a
                 lower triangular matrix L and an upper triangular matrix U; this is called
                 the LU decomposition. However, if A is symmetric and positive definite, we
                 can choose the factors such that U is the transpose of L, and this is called
                 the Cholesky decomposition. Both the LU and the Cholesky decomposition are
                 used to solve systems of linear equations.</para>
               <para>
                 When it is applicable, the Cholesky decomposition is twice as efficient
                 as the LU decomposition.</para>
                </remarks>
                
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.#ctor(System.Single[0:,0:])">
            <summary>Constructs a new Cholesky Decomposition.</summary>
            <param name="value">The matrix to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.#ctor(System.Single[0:,0:],System.Boolean)">
            <summary>Constructs a new Cholesky Decomposition.</summary>
            
            <param name="value">The matrix to be decomposed.</param>
            <param name="robust">True to perform a square root free LDLt decomposition,
            false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.#ctor(System.Single[0:,0:],System.Boolean,System.Boolean)">
            <summary>Constructs a new Cholesky Decomposition.</summary>
            
            <param name="value">The matrix to be decomposed.</param>
            <param name="robust">True to perform a square-root free LDLt decomposition,
            false otherwise.</param>
            <param name="lowerTriangular">True to assume the <paramref name="value">value
            matrix</paramref> is a lower triangular symmetric matrix, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.Solve(System.Single[0:,0:])">
            <summary>Solves a set of equation systems of type <c>A * X = B</c>.</summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is not symmetric and positive definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.Solve(System.Single[0:,0:],System.Boolean)">
            <summary>Solves a set of equation systems of type <c>A * X = B</c>.</summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.Solve(System.Single[])">
            <summary>Solves a set of equation systems of type <c>A * X = B</c>.</summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.Solve(System.Single[],System.Boolean)">
            <summary>Solves a set of equation systems of type <c>A * x = b</c>.</summary>
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Vector <c>x</c> so that <c>L * L' * x = b</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.Inverse">
            <summary>
              Computes the inverse of the decomposed matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.FromLeftTriangularMatrix(System.Single[0:,0:])">
            <summary>
              Creates a new Cholesky decomposition directly from
              an already computed left triangular matrix <c>L</c>.
            </summary>
            <param name="leftTriangular">The left triangular matrix from a Cholesky decomposition.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionF.Symmetric">
             <summary>
               Returns <see langword="true"/> if the matrix is symmetric.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionF.PositiveDefinite">
             <summary>
               Returns <see langword="true"/> if the matrix is positive definite.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionF.LeftTriangularFactor">
             <summary>
               Returns the left (lower) triangular factor <c>L</c> so that <c>A = L * D * L'</c>.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionF.DiagonalMatrix">
             <summary>
               Returns the block diagonal matrix of diagonal elements in a LDLt decomposition.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionF.Diagonal">
             <summary>
               Returns the one-dimensional array of diagonal elements in a LDLt decomposition.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionF.Determinant">
             <summary>
               Returns the determinant of the matrix.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionF.LogDeterminant">
             <summary>
               Returns the log-determinant of the matrix.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionF.Nonsingular">
             <summary>
               Returns if the matrix is non-singular (i.e. invertible).
             </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.EigenvalueDecomposition">
            <summary>
                Determines the eigenvalues and eigenvectors of a real square matrix.
            </summary>
            <remarks>
              <para>
                In the mathematical discipline of linear algebra, eigendecomposition
                or sometimes spectral decomposition is the factorization of a matrix
                into a canonical form, whereby the matrix is represented in terms of
                its eigenvalues and eigenvectors.</para>
              <para>
                If <c>A</c> is symmetric, then <c>A = V * D * V'</c> and <c>A = V * V'</c>
                where the eigenvalue matrix <c>D</c> is diagonal and the eigenvector matrix <c>V</c> is orthogonal.
                If <c>A</c> is not symmetric, the eigenvalue matrix <c>D</c> is block diagonal
                with the real eigenvalues in 1-by-1 blocks and any complex eigenvalues,
                <c>lambda + i*mu</c>, in 2-by-2 blocks, <c>[lambda, mu; -mu, lambda]</c>.
                The columns of <c>V</c> represent the eigenvectors in the sense that <c>A * V = V * D</c>.
                The matrix V may be badly conditioned, or even singular, so the validity of the equation
                <c>A = V * D * inverse(V)</c> depends upon the condition of <c>V</c>.
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.EigenvalueDecomposition.#ctor(System.Double[0:,0:])">
            <summary>
              Construct an eigenvalue decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.EigenvalueDecomposition.#ctor(System.Double[0:,0:],System.Boolean)">
            <summary>
              Construct an eigenvalue decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="assumeSymmetric">
              Defines if the matrix should be assumed as being symmetric
              regardless if it is or not. Default is <see langword="false"/>.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.EigenvalueDecomposition.#ctor(System.Double[0:,0:],System.Boolean,System.Boolean)">
            <summary>
              Construct an eigenvalue decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="assumeSymmetric">
              Defines if the matrix should be assumed as being symmetric
              regardless if it is or not. Default is <see langword="false"/>.</param>
            <param name="inPlace">
              Pass <see langword="true"/> to perform the decomposition in place. The matrix
              <paramref name="value"/> will be destroyed in the process, resulting in less
              memory comsumption.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.EigenvalueDecomposition.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="P:Accord.Math.Decompositions.EigenvalueDecomposition.RealEigenvalues">
            <summary>Returns the real parts of the eigenvalues.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.EigenvalueDecomposition.ImaginaryEigenvalues">
            <summary>Returns the imaginary parts of the eigenvalues.</summary>    
        </member>
        <member name="P:Accord.Math.Decompositions.EigenvalueDecomposition.Eigenvectors">
            <summary>Returns the eigenvector matrix.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.EigenvalueDecomposition.DiagonalMatrix">
            <summary>Returns the block diagonal eigenvalue matrix.</summary>
        </member>
        <member name="T:Accord.Math.Decompositions.EigenvalueDecompositionF">
            <summary>
                Determines the eigenvalues and eigenvectors of a real square matrix.
            </summary>
            <remarks>
              <para>
                In the mathematical discipline of linear algebra, eigendecomposition
                or sometimes spectral decomposition is the factorization of a matrix
                into a canonical form, whereby the matrix is represented in terms of
                its eigenvalues and eigenvectors.</para>
              <para>
                If <c>A</c> is symmetric, then <c>A = V * D * V'</c> and <c>A = V * V'</c>
                where the eigenvalue matrix <c>D</c> is diagonal and the eigenvector matrix <c>V</c> is orthogonal.
                If <c>A</c> is not symmetric, the eigenvalue matrix <c>D</c> is block diagonal
                with the real eigenvalues in 1-by-1 blocks and any complex eigenvalues,
                <c>lambda + i*mu</c>, in 2-by-2 blocks, <c>[lambda, mu; -mu, lambda]</c>.
                The columns of <c>V</c> represent the eigenvectors in the sense that <c>A * V = V * D</c>.
                The matrix V may be badly conditioned, or even singular, so the validity of the equation
                <c>A = V * D * inverse(V)</c> depends upon the condition of <c>V</c>.
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.EigenvalueDecompositionF.#ctor(System.Single[0:,0:])">
            <summary>
              Construct an eigenvalue decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.EigenvalueDecompositionF.#ctor(System.Single[0:,0:],System.Boolean)">
            <summary>
              Construct an eigenvalue decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="assumeSymmetric">
              Defines if the matrix should be assumed as being symmetric
              regardless if it is or not. Default is <see langword="false"/>.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.EigenvalueDecompositionF.#ctor(System.Single[0:,0:],System.Boolean,System.Boolean)">
            <summary>
              Construct an eigenvalue decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="assumeSymmetric">
              Defines if the matrix should be assumed as being symmetric
              regardless if it is or not. Default is <see langword="false"/>.</param>
            <param name="inPlace">
              Pass <see langword="true"/> to perform the decomposition in place. The matrix
              <paramref name="value"/> will be destroyed in the process, resulting in less
              memory comsumption.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.EigenvalueDecompositionF.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="P:Accord.Math.Decompositions.EigenvalueDecompositionF.RealEigenvalues">
            <summary>Returns the real parts of the eigenvalues.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.EigenvalueDecompositionF.ImaginaryEigenvalues">
            <summary>Returns the imaginary parts of the eigenvalues.</summary>    
        </member>
        <member name="P:Accord.Math.Decompositions.EigenvalueDecompositionF.Eigenvectors">
            <summary>Returns the eigenvector matrix.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.EigenvalueDecompositionF.DiagonalMatrix">
            <summary>Returns the block diagonal eigenvalue matrix.</summary>
        </member>
        <member name="T:Accord.Math.Decompositions.GramSchmidtOrthogonalization">
            <summary>
              Gram-Schmidt Orthogonalization.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.GramSchmidtOrthogonalization.#ctor(System.Double[0:,0:])">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Decompositions.GramSchmidtOrthogonalization"/> class.
            </summary>
            
            <param name="value">The matrix <c>A</c> to be decomposed.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.GramSchmidtOrthogonalization.#ctor(System.Double[0:,0:],System.Boolean)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Decompositions.GramSchmidtOrthogonalization"/> class.
            </summary>
            
            <param name="value">The matrix <c>A</c> to be decomposed.</param>
            <param name="modified">True to use modified Gram-Schmidt; false
              otherwise. Default is true (and is the recommended setup).</param>
            
        </member>
        <member name="P:Accord.Math.Decompositions.GramSchmidtOrthogonalization.OrthogonalFactor">
            <summary>
              Returns the orthogonal factor matrix <c>Q</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.GramSchmidtOrthogonalization.UpperTriangularFactor">
            <summary>
              Returns the upper triangular factor matrix <c>R</c>.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.JaggedLuDecomposition">
            <summary>
              LU decomposition of a rectangular matrix.
            </summary>
            <remarks>
              <para>
                For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the LU decomposition is an m-by-n
                unit lower triangular matrix <c>L</c>, an n-by-n upper triangular matrix <c>U</c>,
                and a permutation vector <c>piv</c> of length m so that <c>A(piv) = L*U</c>.
                If m &lt; n, then <c>L</c> is m-by-m and <c>U</c> is m-by-n.</para>
              <para>
                The LU decomposition with pivoting always exists, even if the matrix is
                singular, so the constructor will never fail.  The primary use of the
                LU decomposition is in the solution of square systems of simultaneous
                linear equations. This will fail if <see cref="P:Accord.Math.Decompositions.JaggedLuDecomposition.Nonsingular"/> returns
                <see langword="false"/>.
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecomposition.#ctor(System.Double[][],System.Boolean,System.Boolean)">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="inPlace">True if the decomposition should be performed over the
            <paramref name="value"/> matrix rather than on a copy of it. If true, the
            matrix will be destroyed during the decomposition. Default is false.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecomposition.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecomposition.Solve(System.Double[][])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecomposition.SolveTranspose(System.Double[][])">
            <summary>
              Solves a set of equation systems of type <c>X * A = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>Matrix <c>X</c> so that <c>X * L * U = A</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecomposition.Solve(System.Double[])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecomposition.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecomposition.Nonsingular">
            <summary>
              Returns if the matrix is non-singular (i.e. invertible).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecomposition.Determinant">
            <summary>
              Returns the determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecomposition.LogDeterminant">
            <summary>
              Returns the log-determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecomposition.LowerTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecomposition.UpperTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecomposition.PivotPermutationVector">
            <summary>
              Returns the pivot permutation vector.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.JaggedSingularValueDecomposition">
             <summary>
               Singular Value Decomposition for a rectangular matrix.
             </summary>
            
             <remarks>
              <para>
                  For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the singular value decomposition
               is an m-by-n orthogonal matrix <c>U</c>, an n-by-n diagonal matrix <c>S</c>, and
               an n-by-n orthogonal matrix <c>V</c> so that <c>A = U * S * V'</c>.
               The singular values, <c>sigma[k] = S[k,k]</c>, are ordered so that
               <c>sigma[0] &gt;= sigma[1] &gt;= ... &gt;= sigma[n-1]</c>.</para>
              <para>
               The singular value decomposition always exists, so the constructor will
               never fail. The matrix condition number and the effective numerical
               rank can be computed from this decomposition.</para>
              <para>
               WARNING! Please be aware that if A has less rows than columns, it is better
               to compute the decomposition on the transpose of A and then swap the left
               and right eigenvectors. If the routine is computed on A directly, the diagonal
               of singular values may contain one or more zeros. The identity A = U * S * V'
               may still hold, however. To overcome this problem, pass true to the
               <see cref="M:Accord.Math.Decompositions.JaggedSingularValueDecomposition.#ctor(System.Double[][],System.Boolean,System.Boolean,System.Boolean)">autoTranspose</see>
               argument of the class constructor.</para>
            
              <para>
               This routine computes the economy decomposition of A.</para> 
             </remarks>
             
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedSingularValueDecomposition.#ctor(System.Double[][])">
             <summary>
               Constructs a new singular value decomposition.
             </summary>
            
             <param name="value">
               The matrix to be decomposed.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedSingularValueDecomposition.#ctor(System.Double[][],System.Boolean,System.Boolean)">
            <summary>
                Constructs a new singular value decomposition.
            </summary>
            
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="computeLeftSingularVectors">
              Pass <see langword="true"/> if the left singular vector matrix U 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="computeRightSingularVectors">
              Pass <see langword="true"/> if the right singular vector matrix V
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedSingularValueDecomposition.#ctor(System.Double[][],System.Boolean,System.Boolean,System.Boolean)">
            <summary>
              Constructs a new singular value decomposition.
            </summary>
            
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="computeLeftSingularVectors">
              Pass <see langword="true"/> if the left singular vector matrix U 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="computeRightSingularVectors">
              Pass <see langword="true"/> if the right singular vector matrix V 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="autoTranspose">
              Pass <see langword="true"/> to automatically transpose the value matrix in
              case JAMA's assumptions about the dimensionality of the matrix are violated.
              Pass <see langword="false"/> otherwise. Default is <see langword="false"/>.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedSingularValueDecomposition.#ctor(System.Double[][],System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
              Constructs a new singular value decomposition.
            </summary>
            
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="computeLeftSingularVectors">
              Pass <see langword="true"/> if the left singular vector matrix U 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="computeRightSingularVectors">
              Pass <see langword="true"/> if the right singular vector matrix V 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="autoTranspose">
              Pass <see langword="true"/> to automatically transpose the value matrix in
              case JAMA's assumptions about the dimensionality of the matrix are violated.
              Pass <see langword="false"/> otherwise. Default is <see langword="false"/>.</param>
            <param name="inPlace">
              Pass <see langword="true"/> to perform the decomposition in place. The matrix
              <paramref name="value"/> will be destroyed in the process, resulting in less
              memory comsumption.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedSingularValueDecomposition.Solve(System.Double[][])">
            <summary>
              Solves a linear equation system of the form AX = B.
            </summary>
            <param name="value">Parameter B from the equation AX = B.</param>
            <returns>The solution X from equation AX = B.</returns>
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedSingularValueDecomposition.SolveForDiagonal(System.Double[])">
            <summary>
              Solves a linear equation system of the form AX = B.
            </summary>
            <param name="value">Parameter B from the equation AX = B.</param>
            <returns>The solution X from equation AX = B.</returns>
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedSingularValueDecomposition.Solve(System.Double[])">
            <summary>
              Solves a linear equation system of the form Ax = b.
            </summary>
            <param name="value">The b from the equation Ax = b.</param>
            <returns>The x from equation Ax = b.</returns>
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedSingularValueDecomposition.Inverse">
             <summary>
               Computes the (pseudo-)inverse of the matrix given to the Singular value decomposition.
             </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedSingularValueDecomposition.Clone">
             <summary>
               Creates a new object that is a copy of the current instance.
             </summary>
             <returns>
               A new object that is a copy of this instance.
             </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedSingularValueDecomposition.Condition">
             <summary>
               Returns the condition number <c>max(S) / min(S)</c>.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedSingularValueDecomposition.Threshold">
             <summary>
               Returns the singularity threshold.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedSingularValueDecomposition.TwoNorm">
             <summary>
               Returns the Two norm.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedSingularValueDecomposition.Rank">
             <summary>
               Returns the effective numerical matrix rank.
             </summary>
            
             <value>Number of non-negligible singular values.</value>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedSingularValueDecomposition.IsSingular">
             <summary>
               Gets whether the decomposed matrix is singular.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedSingularValueDecomposition.Diagonal">
             <summary>
               Gets the one-dimensional array of singular values.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedSingularValueDecomposition.DiagonalMatrix">
             <summary>
              Returns the block diagonal matrix of singular values.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedSingularValueDecomposition.RightSingularVectors">
             <summary>
               Returns the V matrix of Singular Vectors.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedSingularValueDecomposition.LeftSingularVectors">
             <summary>
               Returns the U matrix of Singular Vectors.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedSingularValueDecomposition.Ordering">
             <summary>
               Returns the ordering in which the singular values have been sorted.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedSingularValueDecomposition.AbsoluteDeterminant">
             <summary>
               Returns the absolute value of the matrix determinant.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedSingularValueDecomposition.LogDeterminant">
             <summary>
               Returns the log of the absolute value for the matrix determinant.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedSingularValueDecomposition.PseudoDeterminant">
             <summary>
               Returns the pseudo-determinant for the matrix.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedSingularValueDecomposition.LogPseudoDeterminant">
             <summary>
               Returns the log of the pseudo-determinant for the matrix.
             </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.JaggedSingularValueDecompositionF">
             <summary>
               Singular Value Decomposition for a rectangular matrix.
             </summary>
            
             <remarks>
              <para>
                  For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the singular value decomposition
               is an m-by-n orthogonal matrix <c>U</c>, an n-by-n diagonal matrix <c>S</c>, and
               an n-by-n orthogonal matrix <c>V</c> so that <c>A = U * S * V'</c>.
               The singular values, <c>sigma[k] = S[k,k]</c>, are ordered so that
               <c>sigma[0] &gt;= sigma[1] &gt;= ... &gt;= sigma[n-1]</c>.</para>
              <para>
               The singular value decomposition always exists, so the constructor will
               never fail. The matrix condition number and the effective numerical
               rank can be computed from this decomposition.</para>
              <para>
               WARNING! Please be aware that if A has less rows than columns, it is better
               to compute the decomposition on the transpose of A and then swap the left
               and right eigenvectors. If the routine is computed on A directly, the diagonal
               of singular values may contain one or more zeros. The identity A = U * S * V'
               may still hold, however. To overcome this problem, pass true to the
               <see cref="M:Accord.Math.Decompositions.JaggedSingularValueDecompositionF.#ctor(System.Single[][],System.Boolean,System.Boolean,System.Boolean)">autoTranspose</see>
               argument of the class constructor.</para>
            
              <para>
               This routine computes the economy decomposition of A.</para> 
             </remarks>
             
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedSingularValueDecompositionF.#ctor(System.Single[][])">
             <summary>
               Constructs a new singular value decomposition.
             </summary>
            
             <param name="value">
               The matrix to be decomposed.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedSingularValueDecompositionF.#ctor(System.Single[][],System.Boolean,System.Boolean)">
            <summary>
                Constructs a new singular value decomposition.
            </summary>
            
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="computeLeftSingularVectors">
              Pass <see langword="true"/> if the left singular vector matrix U 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="computeRightSingularVectors">
              Pass <see langword="true"/> if the right singular vector matrix V
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedSingularValueDecompositionF.#ctor(System.Single[][],System.Boolean,System.Boolean,System.Boolean)">
            <summary>
              Constructs a new singular value decomposition.
            </summary>
            
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="computeLeftSingularVectors">
              Pass <see langword="true"/> if the left singular vector matrix U 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="computeRightSingularVectors">
              Pass <see langword="true"/> if the right singular vector matrix V 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="autoTranspose">
              Pass <see langword="true"/> to automatically transpose the value matrix in
              case JAMA's assumptions about the dimensionality of the matrix are violated.
              Pass <see langword="false"/> otherwise. Default is <see langword="false"/>.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedSingularValueDecompositionF.#ctor(System.Single[][],System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
              Constructs a new singular value decomposition.
            </summary>
            
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="computeLeftSingularVectors">
              Pass <see langword="true"/> if the left singular vector matrix U 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="computeRightSingularVectors">
              Pass <see langword="true"/> if the right singular vector matrix V 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="autoTranspose">
              Pass <see langword="true"/> to automatically transpose the value matrix in
              case JAMA's assumptions about the dimensionality of the matrix are violated.
              Pass <see langword="false"/> otherwise. Default is <see langword="false"/>.</param>
            <param name="inPlace">
              Pass <see langword="true"/> to perform the decomposition in place. The matrix
              <paramref name="value"/> will be destroyed in the process, resulting in less
              memory comsumption.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedSingularValueDecompositionF.Solve(System.Single[][])">
            <summary>
              Solves a linear equation system of the form AX = B.
            </summary>
            <param name="value">Parameter B from the equation AX = B.</param>
            <returns>The solution X from equation AX = B.</returns>
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedSingularValueDecompositionF.SolveForDiagonal(System.Single[])">
            <summary>
              Solves a linear equation system of the form AX = B.
            </summary>
            <param name="value">Parameter B from the equation AX = B.</param>
            <returns>The solution X from equation AX = B.</returns>
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedSingularValueDecompositionF.Solve(System.Single[])">
            <summary>
              Solves a linear equation system of the form Ax = b.
            </summary>
            <param name="value">The b from the equation Ax = b.</param>
            <returns>The x from equation Ax = b.</returns>
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedSingularValueDecompositionF.Inverse">
             <summary>
               Computes the (pseudo-)inverse of the matrix given to the Singular value decomposition.
             </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedSingularValueDecompositionF.Clone">
             <summary>
               Creates a new object that is a copy of the current instance.
             </summary>
             <returns>
               A new object that is a copy of this instance.
             </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedSingularValueDecompositionF.Condition">
             <summary>
               Returns the condition number <c>max(S) / min(S)</c>.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedSingularValueDecompositionF.Threshold">
             <summary>
               Returns the singularity threshold.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedSingularValueDecompositionF.TwoNorm">
             <summary>
               Returns the Two norm.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedSingularValueDecompositionF.Rank">
             <summary>
               Returns the effective numerical matrix rank.
             </summary>
            
             <value>Number of non-negligible singular values.</value>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedSingularValueDecompositionF.IsSingular">
             <summary>
               Gets whether the decomposed matrix is singular.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedSingularValueDecompositionF.Diagonal">
             <summary>
               Gets the one-dimensional array of singular values.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedSingularValueDecompositionF.DiagonalMatrix">
             <summary>
              Returns the block diagonal matrix of singular values.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedSingularValueDecompositionF.RightSingularVectors">
             <summary>
               Returns the V matrix of Singular Vectors.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedSingularValueDecompositionF.LeftSingularVectors">
             <summary>
               Returns the U matrix of Singular Vectors.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedSingularValueDecompositionF.Ordering">
             <summary>
               Returns the ordering in which the singular values have been sorted.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedSingularValueDecompositionF.AbsoluteDeterminant">
             <summary>
               Returns the absolute value of the matrix determinant.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedSingularValueDecompositionF.LogDeterminant">
             <summary>
               Returns the log of the absolute value for the matrix determinant.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedSingularValueDecompositionF.PseudoDeterminant">
             <summary>
               Returns the pseudo-determinant for the matrix.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedSingularValueDecompositionF.LogPseudoDeterminant">
             <summary>
               Returns the log of the pseudo-determinant for the matrix.
             </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.SingularValueDecomposition">
             <summary>
               Singular Value Decomposition for a rectangular matrix.
             </summary>
            
             <remarks>
              <para>
                  For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the singular value decomposition
               is an m-by-n orthogonal matrix <c>U</c>, an n-by-n diagonal matrix <c>S</c>, and
               an n-by-n orthogonal matrix <c>V</c> so that <c>A = U * S * V'</c>.
               The singular values, <c>sigma[k] = S[k,k]</c>, are ordered so that
               <c>sigma[0] &gt;= sigma[1] &gt;= ... &gt;= sigma[n-1]</c>.</para>
              <para>
               The singular value decomposition always exists, so the constructor will
               never fail. The matrix condition number and the effective numerical
               rank can be computed from this decomposition.</para>
              <para>
               WARNING! Please be aware that if A has less rows than columns, it is better
               to compute the decomposition on the transpose of A and then swap the left
               and right eigenvectors. If the routine is computed on A directly, the diagonal
               of singular values may contain one or more zeros. The identity A = U * S * V'
               may still hold, however. To overcome this problem, pass true to the
               <see cref="M:Accord.Math.Decompositions.SingularValueDecomposition.#ctor(System.Double[0:,0:],System.Boolean,System.Boolean,System.Boolean)">autoTranspose</see>
               argument of the class constructor.</para>
            
              <para>
               This routine computes the economy decomposition of A.</para> 
             </remarks>
             
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecomposition.#ctor(System.Double[0:,0:])">
             <summary>
               Constructs a new singular value decomposition.
             </summary>
            
             <param name="value">
               The matrix to be decomposed.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecomposition.#ctor(System.Double[0:,0:],System.Boolean,System.Boolean)">
            <summary>
                Constructs a new singular value decomposition.
            </summary>
            
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="computeLeftSingularVectors">
              Pass <see langword="true"/> if the left singular vector matrix U 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="computeRightSingularVectors">
              Pass <see langword="true"/> if the right singular vector matrix V
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecomposition.#ctor(System.Double[0:,0:],System.Boolean,System.Boolean,System.Boolean)">
            <summary>
              Constructs a new singular value decomposition.
            </summary>
            
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="computeLeftSingularVectors">
              Pass <see langword="true"/> if the left singular vector matrix U 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="computeRightSingularVectors">
              Pass <see langword="true"/> if the right singular vector matrix V 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="autoTranspose">
              Pass <see langword="true"/> to automatically transpose the value matrix in
              case JAMA's assumptions about the dimensionality of the matrix are violated.
              Pass <see langword="false"/> otherwise. Default is <see langword="false"/>.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecomposition.#ctor(System.Double[0:,0:],System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
              Constructs a new singular value decomposition.
            </summary>
            
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="computeLeftSingularVectors">
              Pass <see langword="true"/> if the left singular vector matrix U 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="computeRightSingularVectors">
              Pass <see langword="true"/> if the right singular vector matrix V 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="autoTranspose">
              Pass <see langword="true"/> to automatically transpose the value matrix in
              case JAMA's assumptions about the dimensionality of the matrix are violated.
              Pass <see langword="false"/> otherwise. Default is <see langword="false"/>.</param>
            <param name="inPlace">
              Pass <see langword="true"/> to perform the decomposition in place. The matrix
              <paramref name="value"/> will be destroyed in the process, resulting in less
              memory comsumption.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecomposition.Solve(System.Double[0:,0:])">
            <summary>
              Solves a linear equation system of the form AX = B.
            </summary>
            <param name="value">Parameter B from the equation AX = B.</param>
            <returns>The solution X from equation AX = B.</returns>
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecomposition.SolveForDiagonal(System.Double[])">
            <summary>
              Solves a linear equation system of the form AX = B.
            </summary>
            <param name="value">Parameter B from the equation AX = B.</param>
            <returns>The solution X from equation AX = B.</returns>
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecomposition.Solve(System.Double[])">
            <summary>
              Solves a linear equation system of the form Ax = b.
            </summary>
            <param name="value">The b from the equation Ax = b.</param>
            <returns>The x from equation Ax = b.</returns>
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecomposition.Inverse">
             <summary>
               Computes the (pseudo-)inverse of the matrix given to the Singular value decomposition.
             </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecomposition.Clone">
             <summary>
               Creates a new object that is a copy of the current instance.
             </summary>
             <returns>
               A new object that is a copy of this instance.
             </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.Condition">
             <summary>
               Returns the condition number <c>max(S) / min(S)</c>.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.Threshold">
             <summary>
               Returns the singularity threshold.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.TwoNorm">
             <summary>
               Returns the Two norm.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.Rank">
             <summary>
               Returns the effective numerical matrix rank.
             </summary>
            
             <value>Number of non-negligible singular values.</value>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.IsSingular">
             <summary>
               Gets whether the decomposed matrix is singular.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.Diagonal">
             <summary>
               Gets the one-dimensional array of singular values.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.DiagonalMatrix">
             <summary>
              Returns the block diagonal matrix of singular values.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.RightSingularVectors">
             <summary>
               Returns the V matrix of Singular Vectors.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.LeftSingularVectors">
             <summary>
               Returns the U matrix of Singular Vectors.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.Ordering">
             <summary>
               Returns the ordering in which the singular values have been sorted.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.AbsoluteDeterminant">
             <summary>
               Returns the absolute value of the matrix determinant.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.LogDeterminant">
             <summary>
               Returns the log of the absolute value for the matrix determinant.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.PseudoDeterminant">
             <summary>
               Returns the pseudo-determinant for the matrix.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.LogPseudoDeterminant">
             <summary>
               Returns the log of the pseudo-determinant for the matrix.
             </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.SingularValueDecompositionF">
             <summary>
               Singular Value Decomposition for a rectangular matrix.
             </summary>
            
             <remarks>
              <para>
                  For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the singular value decomposition
               is an m-by-n orthogonal matrix <c>U</c>, an n-by-n diagonal matrix <c>S</c>, and
               an n-by-n orthogonal matrix <c>V</c> so that <c>A = U * S * V'</c>.
               The singular values, <c>sigma[k] = S[k,k]</c>, are ordered so that
               <c>sigma[0] &gt;= sigma[1] &gt;= ... &gt;= sigma[n-1]</c>.</para>
              <para>
               The singular value decomposition always exists, so the constructor will
               never fail. The matrix condition number and the effective numerical
               rank can be computed from this decomposition.</para>
              <para>
               WARNING! Please be aware that if A has less rows than columns, it is better
               to compute the decomposition on the transpose of A and then swap the left
               and right eigenvectors. If the routine is computed on A directly, the diagonal
               of singular values may contain one or more zeros. The identity A = U * S * V'
               may still hold, however. To overcome this problem, pass true to the
               <see cref="M:Accord.Math.Decompositions.SingularValueDecompositionF.#ctor(System.Single[0:,0:],System.Boolean,System.Boolean,System.Boolean)">autoTranspose</see>
               argument of the class constructor.</para>
            
              <para>
               This routine computes the economy decomposition of A.</para> 
             </remarks>
             
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecompositionF.#ctor(System.Single[0:,0:])">
             <summary>
               Constructs a new singular value decomposition.
             </summary>
            
             <param name="value">
               The matrix to be decomposed.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecompositionF.#ctor(System.Single[0:,0:],System.Boolean,System.Boolean)">
            <summary>
                Constructs a new singular value decomposition.
            </summary>
            
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="computeLeftSingularVectors">
              Pass <see langword="true"/> if the left singular vector matrix U 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="computeRightSingularVectors">
              Pass <see langword="true"/> if the right singular vector matrix V
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecompositionF.#ctor(System.Single[0:,0:],System.Boolean,System.Boolean,System.Boolean)">
            <summary>
              Constructs a new singular value decomposition.
            </summary>
            
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="computeLeftSingularVectors">
              Pass <see langword="true"/> if the left singular vector matrix U 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="computeRightSingularVectors">
              Pass <see langword="true"/> if the right singular vector matrix V 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="autoTranspose">
              Pass <see langword="true"/> to automatically transpose the value matrix in
              case JAMA's assumptions about the dimensionality of the matrix are violated.
              Pass <see langword="false"/> otherwise. Default is <see langword="false"/>.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecompositionF.#ctor(System.Single[0:,0:],System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
              Constructs a new singular value decomposition.
            </summary>
            
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="computeLeftSingularVectors">
              Pass <see langword="true"/> if the left singular vector matrix U 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="computeRightSingularVectors">
              Pass <see langword="true"/> if the right singular vector matrix V 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="autoTranspose">
              Pass <see langword="true"/> to automatically transpose the value matrix in
              case JAMA's assumptions about the dimensionality of the matrix are violated.
              Pass <see langword="false"/> otherwise. Default is <see langword="false"/>.</param>
            <param name="inPlace">
              Pass <see langword="true"/> to perform the decomposition in place. The matrix
              <paramref name="value"/> will be destroyed in the process, resulting in less
              memory comsumption.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecompositionF.Solve(System.Single[0:,0:])">
            <summary>
              Solves a linear equation system of the form AX = B.
            </summary>
            <param name="value">Parameter B from the equation AX = B.</param>
            <returns>The solution X from equation AX = B.</returns>
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecompositionF.SolveForDiagonal(System.Single[])">
            <summary>
              Solves a linear equation system of the form AX = B.
            </summary>
            <param name="value">Parameter B from the equation AX = B.</param>
            <returns>The solution X from equation AX = B.</returns>
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecompositionF.Solve(System.Single[])">
            <summary>
              Solves a linear equation system of the form Ax = b.
            </summary>
            <param name="value">The b from the equation Ax = b.</param>
            <returns>The x from equation Ax = b.</returns>
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecompositionF.Inverse">
             <summary>
               Computes the (pseudo-)inverse of the matrix given to the Singular value decomposition.
             </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecompositionF.Clone">
             <summary>
               Creates a new object that is a copy of the current instance.
             </summary>
             <returns>
               A new object that is a copy of this instance.
             </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.Condition">
             <summary>
               Returns the condition number <c>max(S) / min(S)</c>.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.Threshold">
             <summary>
               Returns the singularity threshold.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.TwoNorm">
             <summary>
               Returns the Two norm.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.Rank">
             <summary>
               Returns the effective numerical matrix rank.
             </summary>
            
             <value>Number of non-negligible singular values.</value>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.IsSingular">
             <summary>
               Gets whether the decomposed matrix is singular.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.Diagonal">
             <summary>
               Gets the one-dimensional array of singular values.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.DiagonalMatrix">
             <summary>
              Returns the block diagonal matrix of singular values.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.RightSingularVectors">
             <summary>
               Returns the V matrix of Singular Vectors.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.LeftSingularVectors">
             <summary>
               Returns the U matrix of Singular Vectors.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.Ordering">
             <summary>
               Returns the ordering in which the singular values have been sorted.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.AbsoluteDeterminant">
             <summary>
               Returns the absolute value of the matrix determinant.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.LogDeterminant">
             <summary>
               Returns the log of the absolute value for the matrix determinant.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.PseudoDeterminant">
             <summary>
               Returns the pseudo-determinant for the matrix.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.LogPseudoDeterminant">
             <summary>
               Returns the log of the pseudo-determinant for the matrix.
             </summary>
            
        </member>
        <member name="T:Accord.Math.Integration.RombergMethod">
             <summary>
               Romberg's method for numerical integration. 
             </summary>
             
             <remarks>
             <para>
               In numerical analysis, Romberg's method (Romberg 1955) is used to estimate 
               the definite integral <c>âˆ«_a^b(x) dx</c> by applying Richardson extrapolation
               repeatedly on the trapezium rule or the rectangle rule (midpoint rule). The 
               estimates generate a triangular array. Romberg's method is a Newtonâ€“Cotes 
               formula â€“ it evaluates the integrand at equally spaced points. The integrand
               must have continuous derivatives, though fairly good results may be obtained 
               if only a few derivatives exist. If it is possible to evaluate the integrand 
               at unequally spaced points, then other methods such as Gaussian quadrature 
               and Clenshawâ€“Curtis quadrature are generally more accurate.
             </para>
             
             <para>
               References:
               <list type="bullet">
                 <item><description><a href="http://en.wikipedia.org/wiki/Romberg's_method">
                   Wikipedia, The Free Encyclopedia. Romberg's method. Available on: 
                   http://en.wikipedia.org/wiki/Romberg's_method </a></description></item>
               </list>
              </para>
              </remarks>
              
             <example>
             <para>
               Let's say we would like to compute the definite integral of the function 
               <c>f(x) = cos(x)</c> in the interval -1 to +1 using a variety of integration 
               methods, including the <see cref="T:Accord.Math.Integration.TrapezoidalRule"/>, <see cref="T:Accord.Math.Integration.RombergMethod"/>
               and <see cref="T:Accord.Math.Integration.NonAdaptiveGaussKronrod"/>. Those methods can compute definite
               integrals where the integration interval is finite:
             </para>
             
             <code>
             // Declare the function we want to integrate
             Func&lt;double, double&gt; f = (x) =&gt; Math.Cos(x);
            
             // We would like to know its integral from -1 to +1
             double a = -1, b = +1;
            
             // Integrate!
             double trapez  = TrapezoidalRule.Integrate(f, a, b, steps: 1000); // 1.6829414
             double romberg = RombergMethod.Integrate(f, a, b);                // 1.6829419
             double nagk    = NonAdaptiveGaussKronrod.Integrate(f, a, b);      // 1.6829419
             </code>
             
             <para>
               Moreover, it is also possible to calculate the value of improper integrals
               (it is, integrals with infinite bounds) using <see cref="T:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod"/>,
               as shown below. Let's say we would like to compute the area under the Gaussian
               curve from -infinite to +infinite. While this function has infinite bounds, this
               function is known to integrate to 1.</para>
               
             <code>
             // Declare the Normal distribution's density function (which is the Gaussian's bell curve)
             Func&lt;double, double&gt; g = (x) =&gt; (1 / Math.Sqrt(2 * Math.PI)) * Math.Exp(-(x * x) / 2);
            
             // Integrate!
             double iagk = InfiniteAdaptiveGaussKronrod.Integrate(g,
                 Double.NegativeInfinity, Double.PositiveInfinity);   // Result should be 0.99999...
             </code>
             </example>
             
             <seealso cref="T:Accord.Math.Integration.TrapezoidalRule"/>
             <seealso cref="T:Accord.Math.Integration.NonAdaptiveGaussKronrod"/>
             <seealso cref="T:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod"/>
             <seealso cref="T:Accord.Math.Integration.MonteCarloIntegration"/>
             
        </member>
        <member name="M:Accord.Math.Integration.RombergMethod.#ctor">
            <summary>
              Constructs a new <see cref="T:Accord.Math.Integration.RombergMethod">Romberg's integration method</see>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Integration.RombergMethod.#ctor(System.Func{System.Double,System.Double})">
            <summary>
              Constructs a new <see cref="T:Accord.Math.Integration.RombergMethod">Romberg's integration method</see>.
            </summary>
            
            <param name="function">The unidimensional function whose integral should be computed.</param>
            
        </member>
        <member name="M:Accord.Math.Integration.RombergMethod.#ctor(System.Func{System.Double,System.Double},System.Double,System.Double)">
             <summary>
               Constructs a new <see cref="T:Accord.Math.Integration.RombergMethod">Romberg's integration method</see>.
             </summary>
             
             <param name="function">The unidimensional function whose integral should be computed.</param>
             <param name="a">The beginning of the integration interval.</param>
             <param name="b">The ending of the integration interval.</param>
            
        </member>
        <member name="M:Accord.Math.Integration.RombergMethod.#ctor(System.Int32)">
            <summary>
              Constructs a new <see cref="T:Accord.Math.Integration.RombergMethod">Romberg's integration method</see>.
            </summary>
            
            <param name="steps">The number of steps used in Romberg's method. Default is 6.</param>
            
        </member>
        <member name="M:Accord.Math.Integration.RombergMethod.#ctor(System.Int32,System.Func{System.Double,System.Double})">
             <summary>
               Constructs a new <see cref="T:Accord.Math.Integration.RombergMethod">Romberg's integration method</see>.
             </summary>
             
             <param name="steps">The number of steps used in Romberg's method. Default is 6.</param>
             <param name="function">The unidimensional function whose integral should be computed.</param>
            
        </member>
        <member name="M:Accord.Math.Integration.RombergMethod.#ctor(System.Int32,System.Func{System.Double,System.Double},System.Double,System.Double)">
             <summary>
               Constructs a new <see cref="T:Accord.Math.Integration.RombergMethod">Romberg's integration method</see>.
             </summary>
             
             <param name="steps">The number of steps used in Romberg's method. Default is 6.</param>
             <param name="function">The unidimensional function whose integral should be computed.</param>
             <param name="a">The beginning of the integration interval.</param>
             <param name="b">The ending of the integration interval.</param>
            
        </member>
        <member name="M:Accord.Math.Integration.RombergMethod.Compute">
            <summary>
              Computes the area of the function under the selected <see cref="P:Accord.Math.Integration.RombergMethod.Range"/>.
              The computed value will be available at this object's <see cref="P:Accord.Math.Integration.RombergMethod.Area"/>.
            </summary>
            
            <returns>
              True if the integration method succeeds, false otherwise.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Integration.RombergMethod.Integrate(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>
              Computes the area under the integral for the given function, 
              in the given integration interval, using Romberg's method.
            </summary>
            
            <param name="func">The unidimensional function whose integral should be computed.</param>
            <param name="a">The beginning of the integration interval.</param>
            <param name="b">The ending of the integration interval.</param>
            
            <returns>The integral's value in the current interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Integration.RombergMethod.Integrate(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32)">
            <summary>
              Computes the area under the integral for the given function, 
              in the given integration interval, using Romberg's method.
            </summary>
            
            <param name="steps">The number of steps used in Romberg's method. Default is 6.</param>
            <param name="func">The unidimensional function whose integral should be computed.</param>
            <param name="a">The beginning of the integration interval.</param>
            <param name="b">The ending of the integration interval.</param>
            
            <returns>The integral's value in the current interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Integration.RombergMethod.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Integration.RombergMethod.Function">
            <summary>
              Gets or sets the unidimensional function
              whose integral should be computed.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.RombergMethod.Area">
            <summary>
              Gets the numerically computed result of the
              definite integral for the specified function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.RombergMethod.Steps">
            <summary>
              Gets or sets the number of steps used
              by Romberg's method. Default is 6.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.RombergMethod.Range">
            <summary>
              Gets or sets the input range under
              which the integral must be computed.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Integration.TrapezoidalRule">
             <summary>
               Trapezoidal rule for numerical integration.
             </summary>
             
             <remarks>
             <para>
               In numerical analysis, the trapezoidal rule (also known as the trapezoid rule 
               or trapezium rule) is a technique for approximating the definite integral 
               <c>âˆ«_a^b(x) dx</c>. The trapezoidal rule works by approximating the region 
               under the graph of the function f(x) as a trapezoid and calculating its area.
               It follows that <c>âˆ«_a^b(x) dx ~ (b - a) [f(a) - f(b)] / 2</c>.
             </para>
             
             <para>
               References:
               <list type="bullet">
                 <item><description><a href="http://en.wikipedia.org/wiki/Trapezoidal_rule">
                   Wikipedia, The Free Encyclopedia. Trapezoidal rule. Available on: 
                   http://en.wikipedia.org/wiki/Trapezoidal_rule </a></description></item>
               </list>
              </para>
              </remarks>
              
             <example>
             <para>
               Let's say we would like to compute the definite integral of the function 
               <c>f(x) = cos(x)</c> in the interval -1 to +1 using a variety of integration 
               methods, including the <see cref="T:Accord.Math.Integration.TrapezoidalRule"/>, <see cref="T:Accord.Math.Integration.RombergMethod"/>
               and <see cref="T:Accord.Math.Integration.NonAdaptiveGaussKronrod"/>. Those methods can compute definite
               integrals where the integration interval is finite:
             </para>
             
             <code>
             // Declare the function we want to integrate
             Func&lt;double, double&gt; f = (x) =&gt; Math.Cos(x);
            
             // We would like to know its integral from -1 to +1
             double a = -1, b = +1;
            
             // Integrate!
             double trapez  = TrapezoidalRule.Integrate(f, a, b, steps: 1000); // 1.6829414
             double romberg = RombergMethod.Integrate(f, a, b);                // 1.6829419
             double nagk    = NonAdaptiveGaussKronrod.Integrate(f, a, b);      // 1.6829419
             </code>
             
             <para>
               Moreover, it is also possible to calculate the value of improper integrals
               (it is, integrals with infinite bounds) using <see cref="T:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod"/>,
               as shown below. Let's say we would like to compute the area under the Gaussian
               curve from -infinite to +infinite. While this function has infinite bounds, this
               function is known to integrate to 1.</para>
               
             <code>
             // Declare the Normal distribution's density function (which is the Gaussian's bell curve)
             Func&lt;double, double&gt; g = (x) =&gt; (1 / Math.Sqrt(2 * Math.PI)) * Math.Exp(-(x * x) / 2);
            
             // Integrate!
             double iagk = InfiniteAdaptiveGaussKronrod.Integrate(g,
                 Double.NegativeInfinity, Double.PositiveInfinity);   // Result should be 0.99999...
             </code>
             </example>
             
             <seealso cref="T:Accord.Math.Integration.RombergMethod"/>
             <seealso cref="T:Accord.Math.Integration.NonAdaptiveGaussKronrod"/>
             <seealso cref="T:Accord.Math.Integration.InfiniteAdaptiveGaussKronrod"/>
             <seealso cref="T:Accord.Math.Integration.MonteCarloIntegration"/>
             
        </member>
        <member name="M:Accord.Math.Integration.TrapezoidalRule.#ctor">
            <summary>
              Constructs a new <see cref="T:Accord.Math.Integration.TrapezoidalRule"/> integration method.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Integration.TrapezoidalRule.#ctor(System.Func{System.Double,System.Double})">
            <summary>
              Constructs a new <see cref="T:Accord.Math.Integration.TrapezoidalRule"/> integration method.
            </summary>
            
            <param name="function">The unidimensional function whose integral should be computed.</param>
            
        </member>
        <member name="M:Accord.Math.Integration.TrapezoidalRule.#ctor(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>
              Constructs a new <see cref="T:Accord.Math.Integration.TrapezoidalRule"/> integration method.
            </summary>
            
            <param name="function">The unidimensional function whose integral should be computed.</param>
            <param name="a">The beginning of the integration interval.</param>
            <param name="b">The ending of the integration interval.</param>
            
        </member>
        <member name="M:Accord.Math.Integration.TrapezoidalRule.#ctor(System.Int32)">
            <summary>
              Constructs a new <see cref="T:Accord.Math.Integration.TrapezoidalRule"/> integration method.
            </summary>
            
            <param name="steps">The number of steps into which the integration 
              interval will be divided.</param>
            
        </member>
        <member name="M:Accord.Math.Integration.TrapezoidalRule.#ctor(System.Int32,System.Func{System.Double,System.Double})">
            <summary>
              Constructs a new <see cref="T:Accord.Math.Integration.TrapezoidalRule"/> integration method.
            </summary>
            
            <param name="steps">The number of steps into which the integration 
              interval will be divided.</param>
            <param name="function">The unidimensional function 
              whose integral should be computed.</param>
            
        </member>
        <member name="M:Accord.Math.Integration.TrapezoidalRule.#ctor(System.Int32,System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>
              Constructs a new <see cref="T:Accord.Math.Integration.TrapezoidalRule"/> integration method.
            </summary>
            
            <param name="steps">The number of steps into which the integration 
              interval will be divided.</param>
            <param name="function">The unidimensional function 
              whose integral should be computed.</param>
            <param name="a">The beginning of the integration interval.</param>
            <param name="b">The ending of the integration interval.</param>
            
        </member>
        <member name="M:Accord.Math.Integration.TrapezoidalRule.Compute">
            <summary>
              Computes the area of the function under the selected <see cref="P:Accord.Math.Integration.TrapezoidalRule.Range"/>.
              The computed value will be available at this object's <see cref="P:Accord.Math.Integration.TrapezoidalRule.Area"/>.
            </summary>
            
            <returns>
              True if the integration method succeeds, false otherwise.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Integration.TrapezoidalRule.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Integration.TrapezoidalRule.Integrate(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32)">
            <summary>
              Computes the area under the integral for the given function, 
              in the given integration interval, using the Trapezoidal rule.
            </summary>
            
            <param name="steps">The number of steps into which the integration interval will be divided.</param>
            <param name="func">The unidimensional function whose integral should be computed.</param>
            <param name="a">The beginning of the integration interval.</param>
            <param name="b">The ending of the integration interval.</param>
            
            <returns>The integral's value in the current interval.</returns>
            
        </member>
        <member name="P:Accord.Math.Integration.TrapezoidalRule.Function">
            <summary>
              Gets or sets the unidimensional function
              whose integral should be computed.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.TrapezoidalRule.Area">
            <summary>
              Gets the numerically computed result of the
              definite integral for the specified function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.TrapezoidalRule.Steps">
            <summary>
              Gets or sets the number of steps into which the
              <see cref="P:Accord.Math.Integration.TrapezoidalRule.Range">integration interval</see> will 
              be divided. Default is 6.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Integration.TrapezoidalRule.Range">
            <summary>
              Gets or sets the input range under
              which the integral must be computed.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Environments.REnvironment">
            <summary>
              GNU R algorithm environment. Work in progress.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.REnvironment.c(System.Double[])">
            <summary>
              Creates a new vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.REnvironment.matrix(System.Double[],System.Int32,System.Int32)">
            <summary>
              Creates a new matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Environments.REnvironment._">
            <summary>
              Placeholder vector definition
            </summary>
            
        </member>
        <member name="T:Accord.Math.Environments.REnvironment.vec">
            <summary>
              Vector definition operator.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Environments.REnvironment.vec.vector">
            <summary>
              Inner vector object
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.REnvironment.vec.#ctor(System.Double[])">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Environments.REnvironment.vec"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.REnvironment.vec.op_UnaryNegation(Accord.Math.Environments.REnvironment.vec)">
            <summary>
              Implements the operator -.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.REnvironment.vec.op_LessThan(Accord.Math.Environments.REnvironment.vec,Accord.Math.Environments.REnvironment.vec)">
            <summary>
              Implements the operator &lt;.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.REnvironment.vec.op_GreaterThan(Accord.Math.Environments.REnvironment.vec,Accord.Math.Environments.REnvironment.vec)">
            <summary>
              Implements the operator &gt;.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.REnvironment.vec.op_Implicit(System.Double[])~Accord.Math.Environments.REnvironment.vec">
            <summary>
              Performs an implicit conversion from <see cref="T:System.Double[]"/>
              to <see cref="T:Accord.Math.Environments.REnvironment.vec"/>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.REnvironment.vec.op_Implicit(Accord.Math.Environments.REnvironment.vec)~System.Double[]">
            <summary>
              Performs an implicit conversion from 
              <see cref="T:Accord.Math.Environments.REnvironment.vec"/> 
              to <see cref="T:System.Double[]"/>.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Environments.REnvironment.mat">
            <summary>
              Matrix definition operator.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Environments.REnvironment.mat.matrix">
            <summary>
              Inner matrix object.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.REnvironment.mat.#ctor(System.Double[0:,0:])">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Environments.REnvironment.mat"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.REnvironment.mat.op_UnaryNegation(Accord.Math.Environments.REnvironment.mat)">
            <summary>
              Implements the operator -.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.REnvironment.mat.op_LessThan(Accord.Math.Environments.REnvironment.mat,Accord.Math.Environments.REnvironment.mat)">
            <summary>
              Implements the operator &lt;.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.REnvironment.mat.op_GreaterThan(Accord.Math.Environments.REnvironment.mat,Accord.Math.Environments.REnvironment.mat)">
            <summary>
               Implements the operator &gt;.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.REnvironment.mat.op_Implicit(System.Double[0:,0:])~Accord.Math.Environments.REnvironment.mat">
            <summary>
              Performs an implicit conversion from 
              <see cref="T:System.Double[]"/> to 
              <see cref="T:Accord.Math.Environments.REnvironment.mat"/>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.REnvironment.mat.op_Implicit(Accord.Math.Environments.REnvironment.mat)~System.Double[0:,0:]">
            <summary>
              Performs an implicit conversion from 
              <see cref="T:Accord.Math.Environments.REnvironment.mat"/> 
              to <see cref="T:System.Double[]"/>.
            </summary>
            
        </member>
        <member name="T:Accord.Math.GaborKernelKind">
            <summary>
              Gabor kernel types.
            </summary>
            
        </member>
        <member name="F:Accord.Math.GaborKernelKind.Real">
            <summary>
              Creates kernel based on the real part of the Gabor function.
            </summary>
            
        </member>
        <member name="F:Accord.Math.GaborKernelKind.Imaginary">
            <summary>
              Creates a kernel based on the imaginary part of the Gabor function.
            </summary>
            
        </member>
        <member name="F:Accord.Math.GaborKernelKind.Magnitude">
            <summary>
              Creates a kernel based on the Magnitude of the Gabor function.
            </summary>
            
        </member>
        <member name="F:Accord.Math.GaborKernelKind.SquaredMagnitude">
            <summary>
              Creates a kernel based on the Squared Magnitude of the Gabor function.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Gabor">
            <summary>
              Gabor functions.
            </summary>
            
            <remarks>
              This class has been contributed by Diego Catalano, author of the Catalano 
              Framework, a native port of AForge.NET and Accord.NET for Java and Android.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Gabor.Function1D(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
              1-D Gabor function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gabor.Function2D(System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
              2-D Gabor function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gabor.RealFunction2D(System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
              Real part of the 2-D Gabor function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gabor.ImaginaryFunction2D(System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
              Imaginary part of the 2-D Gabor function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gabor.Kernel2D(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
              Computes the 2-D Gabor kernel.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gabor.Kernel2D(System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
            <summary>
              Computes the 2-D Gabor kernel.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gabor.Kernel2D(System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
            <summary>
              Computes the 2-D Gabor kernel.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gabor.Kernel2D(System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean,Accord.Math.GaborKernelKind)">
            <summary>
              Computes the 2-D Gabor kernel.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Geometry.Circle">
            <summary>
              2D circle class.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Geometry.Circle.#ctor">
            <summary>
              Creates a new unit <see cref="T:Accord.Math.Geometry.Circle"/> at the origin.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Geometry.Circle.#ctor(System.Single,System.Single,System.Double)">
            <summary>
              Creates a new <see cref="T:Accord.Math.Geometry.Circle"/> with the given radius 
              centered at the given <c>x</c> and <c>y</c> coordinates.
            </summary>
            
            <param name="x">The x-coordinate of the circle's center.</param>
            <param name="y">The y-coordinate of the circle's center.</param>
            <param name="radius">The circle radius.</param>
            
        </member>
        <member name="M:Accord.Math.Geometry.Circle.#ctor(System.Double,System.Double,System.Double)">
            <summary>
              Creates a new <see cref="T:Accord.Math.Geometry.Circle"/> with the given radius 
              centered at the given <c>x</c> and <c>y</c> coordinates.
            </summary>
            
            <param name="x">The x-coordinate of the circle's center.</param>
            <param name="y">The y-coordinate of the circle's center.</param>
            <param name="radius">The circle radius.</param>
            
        </member>
        <member name="M:Accord.Math.Geometry.Circle.#ctor(AForge.Point,System.Double)">
            <summary>
              Creates a new <see cref="T:Accord.Math.Geometry.Circle"/> with the given radius 
              centered at the given center point coordinates.
            </summary>
            
            <param name="origin">The point at the circle's center.</param>
            <param name="radius">The circle radius.</param>
            
        </member>
        <member name="M:Accord.Math.Geometry.Circle.#ctor(AForge.Point,AForge.Point,AForge.Point)">
            <summary>
              Creates a new <see cref="T:Accord.Math.Geometry.Circle"/> from three non-linear points.
            </summary>
            
            <param name="p1">The first point.</param>
            <param name="p2">The second point.</param>
            <param name="p3">The third point.</param>
            
        </member>
        <member name="M:Accord.Math.Geometry.Circle.DistanceToPoint(AForge.Point)">
            <summary>
              Computes the distance from circle to point.
            </summary>
            
            <param name="point">The point to have its distance from the circle computed.</param>
            
            <returns>The distance from <paramref name="point"/> to this circle.</returns>
            
        </member>
        <member name="P:Accord.Math.Geometry.Circle.Area">
            <summary>
              Gets the area of the circle (Ï€RÂ²).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Geometry.Circle.Circumference">
            <summary>
              Gets the circumference of the circle (2Ï€R).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Geometry.Circle.Diameter">
            <summary>
              Gets the diameter of the circle (2R).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Geometry.Circle.Radius">
            <summary>
              Gets or sets the radius for this circle.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Geometry.Circle.Origin">
            <summary>
              Gets or sets the origin (center) of this circle.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Geometry.DiscreteCurveEvolution">
             <summary>
               Discrete Curve Evolution.
             </summary>
             
             <remarks>
             <para>
               The Discrete Curve Evolution (DCE) algorithm can be used to simplify 
               contour curves. It can preserve the outline of a shape by preserving
               its most visually critical points.</para>
               
             <para>
               The implementation available in the framework has been contributed by
               Diego Catalano, from the Catalano Framework for Java. The original work
               has been developed by Dr. Longin Jan Latecki, and has been redistributed
               under the LGPL with explicit permission from the original author, as long
               as the following references are acknowledged in derived applications:</para>
            
             <para>
               L.J. Latecki and R. Lakaemper; Convexity rule for shape decomposition based
               on discrete contour evolution. Computer Vision and Image Understanding 73 (3),
               441-454, 1999.</para>
               
             <para>
               References:
               <list type="bullet">
                 <item><description><a 
                 href="http://knight.temple.edu/~lakaemper/courses/cis2168_2010FALL/assignments/assig05_folder/CVIU1999.pdf">
                   L.J. Latecki and R. Lakaemper; Convexity rule for shape decomposition based
                   on discrete contour evolution. Computer Vision and Image Understanding 73 (3),
                   441-454, 1999.</a></description></item>
               </list>
             </para>   
             </remarks>
             
        </member>
        <member name="M:Accord.Math.Geometry.DiscreteCurveEvolution.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Geometry.DiscreteCurveEvolution"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Geometry.DiscreteCurveEvolution.#ctor(System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Geometry.DiscreteCurveEvolution"/> class.
            </summary>
            
            <param name="vertices">Number of vertices.</param>
            
        </member>
        <member name="M:Accord.Math.Geometry.DiscreteCurveEvolution.OptimizeShape(System.Collections.Generic.List{AForge.IntPoint})">
            <summary>
              Optimize specified shape.
            </summary>
            
            <param name="shape">Shape to be optimized.</param>
            
            <returns>
              Returns final optimized shape, which may have reduced amount of points.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Geometry.DiscreteCurveEvolution.NumberOfVertices">
            <summary>
            Gets or sets the number of vertices.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Plane">
            <summary>
              3D Plane class with normal vector and distance from origin.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Plane.#ctor(System.Single,System.Single,System.Single)">
            <summary>
              Creates a new <see cref="T:Accord.Math.Plane"/> object
              passing through the <see cref="P:Accord.Math.Point3.Origin"/>.
            </summary>
            
            <param name="a">The first component of the plane's normal vector.</param>
            <param name="b">The second component of the plane's normal vector.</param>
            <param name="c">The third component of the plane's normal vector.</param>
            
        </member>
        <member name="M:Accord.Math.Plane.#ctor(AForge.Math.Vector3)">
            <summary>
              Creates a new <see cref="T:Accord.Math.Plane"/> object
              passing through the <see cref="P:Accord.Math.Point3.Origin"/>.
            </summary>
            
            <param name="normal">The plane's normal vector.</param>
            
        </member>
        <member name="M:Accord.Math.Plane.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Plane"/> class.
            </summary>
            
            <param name="a">The first component of the plane's normal vector.</param>
            <param name="b">The second component of the plane's normal vector.</param>
            <param name="c">The third component of the plane's normal vector.</param>
            
            <param name="offset">The distance from the plane to the origin.</param>
            
        </member>
        <member name="M:Accord.Math.Plane.#ctor(AForge.Math.Vector3,System.Single)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Plane"/> class.
            </summary>
            
            <param name="normal">The plane's normal vector.</param>
            <param name="offset">The distance from the plane to the origin.</param>
            
        </member>
        <member name="M:Accord.Math.Plane.FromPoints(Accord.Math.Point3,Accord.Math.Point3,Accord.Math.Point3)">
            <summary>
              Constructs a new <see cref="T:Accord.Math.Plane"/> object from three points.
            </summary>
            
            <param name="point1">The first point.</param>
            <param name="point2">The second point.</param>
            <param name="point3">The third point.</param>
            
            <returns>A <see cref="T:Accord.Math.Plane"/> passing through the three points.</returns>
            
        </member>
        <member name="M:Accord.Math.Plane.DistanceToPoint(Accord.Math.Point3)">
            <summary>
              Computes the distance from point to plane.
            </summary>
            
            <param name="point">The point to have its distance from the plane computed.</param>
            
            <returns>The distance from <paramref name="point"/> to this plane.</returns>
            
        </member>
        <member name="M:Accord.Math.Plane.Normalize">
            <summary>
              Normalizes this plane by dividing its components
              by the <see cref="P:Accord.Math.Plane.Normal"/> vector's norm.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Plane.op_Equality(Accord.Math.Plane,Accord.Math.Plane)">
            <summary>
              Implements the operator !=.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Plane.op_Inequality(Accord.Math.Plane,Accord.Math.Plane)">
            <summary>
              Implements the operator !=.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Plane.Equals(Accord.Math.Plane,System.Double)">
            <summary>
              Determines whether the specified <see cref="T:Accord.Math.Plane"/> is equal to this instance.
            </summary>
            
            <param name="other">The <see cref="T:Accord.Math.Plane"/> to compare with this instance.</param>
            <param name="tolerance">The acceptance tolerance threshold to consider the instances equal.</param>
            
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Plane.Equals(Accord.Math.Plane)">
            <summary>
              Determines whether the specified <see cref="T:Accord.Math.Plane"/> is equal to this instance.
            </summary>
            
            <param name="other">The <see cref="T:Accord.Math.Plane"/> to compare with this instance.</param>
            
            <returns>
              <c>true</c> if the specified <see cref="T:Accord.Math.Plane"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Plane.Equals(System.Object)">
            <summary>
              Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Plane.GetHashCode">
            <summary>
              Returns a hash code for this instance.
            </summary>
            
            <returns>
              A hash code for this instance, suitable for use in hashing 
              algorithms and data structures like a hash table. 
            </returns>
            
        </member>
        <member name="M:Accord.Math.Plane.ToString">
            <summary>
              Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Plane.ToString(System.String,System.IFormatProvider)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            
            <param name="format">The format.</param>
            <param name="formatProvider">The format provider.</param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Plane.ToString(System.Char)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            
            <param name="variable">The variable to put on the left hand side. Can
              be either 'x', 'y' or 'z'.</param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Plane.ToString(System.Char,System.IFormatProvider)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            
            <param name="variable">The variable to put on the left hand side. Can
              be either 'x', 'y' or 'z'.</param>
            <param name="formatProvider">The format provider.</param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Plane.Normal">
            <summary>
              Gets the plane's normal vector.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Plane.A">
            <summary>
              Gets or sets the constant <c>a</c> in the plane
              definition <c>a * x + b * y + c * z + d = 0</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Plane.B">
            <summary>
              Gets or sets the constant <c>b</c> in the plane
              definition <c>a * x + b * y + c * z + d = 0</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Plane.C">
            <summary>
              Gets or sets the constant <c>c</c> in the plane
              definition <c>a * x + b * y + c * z + d = 0</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Plane.Offset">
            <summary>
              Gets or sets the distance offset 
              between the plane and the origin.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Point3">
            <summary>
              3D point structure with X, Y, and coordinates.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Point3.#ctor(System.Single,System.Single,System.Single)">
            <summary>
              Creates a new <see cref="T:Accord.Math.Point3"/> 
              structure from the given coordinates.
            </summary>
            
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
            <param name="z">The z coordinate.</param>
            
        </member>
        <member name="M:Accord.Math.Point3.#ctor(AForge.Math.Vector3)">
            <summary>
              Creates a new <see cref="T:Accord.Math.Point3"/> 
              structure from the given coordinates.
            </summary>
            
            <param name="coordinates">The point coordinates.</param>
            
        </member>
        <member name="M:Accord.Math.Point3.op_Implicit(Accord.Math.Point3)~AForge.Math.Vector3">
            <summary>
              Performs an implicit conversion from
              <see cref="T:Accord.Math.Point3"/> to <see cref="T:AForge.Math.Vector3"/>.
            </summary>
            
            <param name="point">The point to be converted.</param>
            
            <returns>
              The result of the conversion.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Point3.op_Implicit(AForge.Math.Vector3)~Accord.Math.Point3">
            <summary>
              Performs an implicit conversion from
              <see cref="T:Accord.Math.Point3"/> to <see cref="T:Accord.Math.Point3"/>.
            </summary>
            
            <param name="vector">The vector to be converted.</param>
            
            <returns>
              The result of the conversion.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Point3.FromVector(AForge.Math.Vector3)">
            <summary>
              Performs a conversion from <see cref="T:AForge.Math.Vector3"/>
              to <see cref="T:Accord.Math.Point3"/>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Point3.Collinear(Accord.Math.Point3,Accord.Math.Point3,Accord.Math.Point3)">
            <summary>
              Gets whether three points lie on the same line.
            </summary>
            
            <param name="p1">The first point.</param>
            <param name="p2">The second point.</param>
            <param name="p3">The third point.</param>
            
            <returns>True if there is a line passing through all
             three points; false otherwise.</returns>
            
        </member>
        <member name="M:Accord.Math.Point3.op_Equality(Accord.Math.Point3,Accord.Math.Point3)">
            <summary>
              Implements the operator !=.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Point3.op_Inequality(Accord.Math.Point3,Accord.Math.Point3)">
            <summary>
              Implements the operator !=.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Point3.Equals(Accord.Math.Point3,System.Double)">
            <summary>
              Determines whether the specified <see cref="T:Accord.Math.Point3"/> is equal to this instance.
            </summary>
            
            <param name="other">The <see cref="T:Accord.Math.Point3"/> to compare with this instance.</param>
            <param name="tolerance">The acceptance tolerance threshold to consider the instances equal.</param>
            
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Point3.Equals(Accord.Math.Point3)">
            <summary>
              Determines whether the specified <see cref="T:Accord.Math.Point3"/> is equal to this instance.
            </summary>
            
            <param name="other">The <see cref="T:Accord.Math.Point3"/> to compare with this instance.</param>
            
            <returns>
              <c>true</c> if the specified <see cref="T:Accord.Math.Plane"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Point3.Equals(System.Object)">
            <summary>
              Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Point3.GetHashCode">
            <summary>
              Returns a hash code for this instance.
            </summary>
            
            <returns>
              A hash code for this instance, suitable for use in hashing 
              algorithms and data structures like a hash table. 
            </returns>
            
        </member>
        <member name="P:Accord.Math.Point3.X">
            <summary>
              Gets or sets the point's X coordinate.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Point3.Y">
            <summary>
              Gets or sets the point's Y coordinate.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Point3.Z">
            <summary>
              Gets or sets the point's Z coordinate.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Point3.Origin">
            <summary>
              Gets the point at the 3D space origin: (0, 0, 0)
            </summary>
            
        </member>
        <member name="T:Accord.Math.Kinematics.DenavitHartenbergMatrix">
            <summary>
              Denavit Hartenberg matrix (commonly referred as T).
            </summary>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergMatrix.Compute(Accord.Math.Kinematics.DenavitHartenbergParameters)">
            <summary>
              Executes the transform calculations (T = Z*X).
            </summary>
            
            <returns>Transform matrix T.</returns>
            
            <remarks>Calling this method also updates the Transform property.</remarks>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergMatrix.Transform">
            <summary>
              Gets or sets the transformation matrix T (as in T = Z * X).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergMatrix.X">
            <summary>
              Gets or sets the matrix regarding X axis transformations.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergMatrix.Z">
            <summary>
              Gets or sets the matrix regarding Z axis transformations.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Kinematics.DenavitHartenbergModel">
             <summary>
               Denavit Hartenberg model for joints.
             </summary>
             
             <remarks>
             <para>
               This class represents either a model itself or a submodel 
               when used with a <see cref="T:Accord.Math.Kinematics.DenavitHartenbergNode"> 
               DenavitHartenbergModelCombinator instance</see>. </para>
             
             <para>
               References:
               <list type="bullet">
                 <item><description>
                   Wikipedia contributors, "Denavit-Hartenberg parameters," Wikipedia,
                   The Free Encyclopedia, available at: 
                   http://en.wikipedia.org/wiki/Denavit%E2%80%93Hartenberg_parameters 
                   </description></item>
               </list></para>
             </remarks>
            
             <example>
             <para>
               The following example shows the creation and animation
               of a 2-link planar manipulator.</para>
             
             <code>
               // Create the DH-model at location (0, 0, 0) 
            	  DenavitHartenbergModel model = new DenavitHartenbergModel();
            	  
            	  // Add the first joint
            	  model.Joints.Add(alpha: 0, theta: Math.PI / 4, radius: 35, offset: 0);
            	  
               // Add the second joint
            	  model.Joints.Add(alpha: 0, theta: -Math.PI / 3, radius: 35, offset: 0);
            	  
            	  // Now move the arm
            	  model.Joints[0].Parameters.Theta += Math.PI / 10;
            	  model.Joints[1].Parameters.Theta -= Math.PI / 10;
            	  
            	  // Calculate the model
            	  model.Compute();
            	</code>
             </example>
             
             <seealso cref="T:Accord.Math.Kinematics.DenavitHartenbergNode"/>
             <seealso cref="T:Accord.Math.Kinematics.DenavitHartenbergParameters"/>
             
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergModel.#ctor(AForge.Math.Vector3)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Kinematics.DenavitHartenbergModel"/>
              class given a specified model position in 3D space.
            </summary>
            
            <param name="position">The model's position in 3D space. Default is (0,0,0).</param>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergModel.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Kinematics.DenavitHartenbergModel"/>
              class at the origin of the space (0,0,0).
            </summary>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergModel.Compute">
            <summary>
              Computes the entire model, calculating the 
              final position for each joint in the model.
            </summary>
            
            <returns>The model transformation matrix</returns>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergModel.Compute(Accord.Math.Kinematics.DenavitHartenbergModel)">
            <summary>
              Calculates the entire model given it is attached to a parent model and computes each joint position.
            </summary>
            
            <param name="parent">Parent model this model is attached to.</param>
            
            <returns>Model transform matrix of the whole chain (parent + model).</returns>
            
            <remarks>This function assumes the parent model has already been calculated.</remarks>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergModel.GetEnumerator">
            <summary>
              Returns an enumerator that iterates through a collection.
            </summary>
            
            <returns>
              An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergModel.System#Collections#IEnumerable#GetEnumerator">
            <summary>
              Returns an enumerator that iterates through a collection.
            </summary>
            
            <returns>
              An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergModel.Joints">
            <summary>
              Gets the model kinematic chain.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergModel.Position">
            <summary>
              Gets or sets the model position.
            </summary>
              
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergModel.Transform">
            <summary>
              Gets the transformation matrix T for the full model, given
              as T = T_0 * T_1 * T_2 ...T_n in which T_i is the transform
              matrix for each joint in the model.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Kinematics.DenavitHartenbergNode">
             <summary>
               Denavit Hartenberg Model Combinator class to make combination
               of models to create a complex model composed of multiple chains.
             </summary>
            
             <example>
             <para>
               The following example shows the creation and animation of a
               2-link planar manipulator with a dual 2-link planar gripper.
               </para>
             
             <code>
               // Create the DH-model at (0, 0, 0) location
            	  DenavitHartenbergModel model = new DenavitHartenbergModel();
            	  
            	  // Add the first joint
            	  model.Joints.Add(alpha: 0, theta: Math.PI / 4, radius: 35, offset: 0);
            	  
            	  // Add the second joint
            	  model.Joints.Add(alpha: 0, theta: -Math.PI / 3, radius: 35, offset: 0);
            	
            	  // Create the top finger
            	  DenavitHartenbergModel model_tgripper = new DenavitHartenbergModel();
            	  model_tgripper.Joints.Add(alpha: 0, theta:  Math.PI / 4, radius: 20, offset: 0);
            	  model_tgripper.Joints.Add(alpha: 0, theta: -Math.PI / 3, radius: 20, offset: 0);
            	  
            	  // Create the bottom finger
            	  DenavitHartenbergModel model_bgripper = new DenavitHartenbergModel();
            	  model_bgripper.Joints.Add(0, -Math.PI / 4, 20, 0);
            	  model_bgripper.Joints.Add(0,  Math.PI / 3, 20, 0);
            	  
            	  // Create the model combinator from the parent model
            	  DenavitHartenbergModelCombinator arm = new DenavitHartenbergModelCombinator(model);
            	  
            	  // Add the top finger
            	  arm.Children.Add(model_tgripper);
            	  
            	  // Add the bottom finger
            	  arm.Children.Add(model_bgripper);
            	  
            	  // Calculate the whole model (parent model + children models)
            	  arm.Compute();
            	</code>
             </example>
             
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergNode.#ctor(Accord.Math.Kinematics.DenavitHartenbergModel)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Kinematics.DenavitHartenbergNode"/> class.
            </summary>
            
            <param name="model">The inner model contained at this node.</param>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergNode.Compute">
            <summary>
              Calculates the whole combined model (this model plus all its 
              children plus all the children of the children and so on)
            </summary>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergNode.Parent">
            <summary>
              Gets the parent of this node.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergNode.Model">
            <summary>
              Gets the model contained at this node.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergNode.Children">
            <summary>
              Gets the collection of models attached to this node.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Kinematics.DenavitHartenbergNodeCollection">
            <summary>
              Collection of Denavit-Hartenberg model nodes.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergNodeCollection.#ctor(Accord.Math.Kinematics.DenavitHartenbergNode)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Kinematics.DenavitHartenbergNodeCollection"/> class.
            </summary>
            
            <param name="owner">The <see cref="T:Accord.Math.Kinematics.DenavitHartenbergNode"/> owner.</param>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergNodeCollection.Add(Accord.Math.Kinematics.DenavitHartenbergModel)">
            <summary>
              Adds a children model to the end of this <see cref="T:Accord.Math.Kinematics.DenavitHartenbergNodeCollection"/>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergNodeCollection.InsertItem(System.Int32,Accord.Math.Kinematics.DenavitHartenbergNode)">
            <summary>
               Inserts an element into the Collection&lt;T> at the specified index.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergNodeCollection.Owner">
            <summary>
              Gets the owner of this collection (i.e. the parent
              <see cref="T:Accord.Math.Kinematics.DenavitHartenbergNode"/> which owns the
              children contained at this collection.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Kinematics.DenavitHartenbergParameters">
            <summary>
               Denavit Hartenberg joint-description parameters.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergParameters.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Kinematics.DenavitHartenbergParameters"/> class.
            </summary>
            
            <param name="alpha">Angle (in radians) of the Z axis relative to the last joint.</param>
            <param name="theta">Angle (in radians) of the X axis relative to the last joint.</param>
            <param name="radius">Length or radius of the joint.</param>
            <param name="offset">Offset along Z axis relatively to the last joint.</param>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergParameters.#ctor">
            <summary>
               Denavit Hartenberg parameters constructor
            </summary>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergParameters.Alpha">
            <summary>
               Angle in radians about common normal, from 
               old <c>z</c> axis to the new <c>z</c> axis.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergParameters.Theta">
            <summary>
               Angle in radians about previous <c>z</c>, 
               from old <c>x</c> to the new <c>x</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergParameters.Radius">
            <summary>
               Length of the joint (also known as <c>a</c>).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergParameters.Offset">
            <summary>
               Offset along previous <c>z</c> to the common normal (also known as <c>d</c>).
            </summary>
            
        </member>
        <member name="T:Accord.Math.Kinematics.DenavitHartenbergJoint">
            <summary>
              Denavit-Hartenberg Model Joint.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergJoint.#ctor(Accord.Math.Kinematics.DenavitHartenbergParameters)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Kinematics.DenavitHartenbergJoint"/> class.
            </summary>
            
            <param name="parameters">The <see cref="T:Accord.Math.Kinematics.DenavitHartenbergParameters">
            parameters </see> to be used to create the joint.</param>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergJoint.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Kinematics.DenavitHartenbergJoint"/> class.
            </summary>
            
            <param name="alpha">Angle in radians on the Z axis relatively to the last joint.</param>
            <param name="theta">Angle in radians on the X axis relatively to the last joint.</param>
            <param name="radius">Length or radius of the joint.</param>
            <param name="offset">Offset along Z axis relatively to the last joint.</param>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergJoint.Compute(AForge.Math.Matrix4x4,AForge.Math.Vector4)">
            <summary>
              Updates the joint transformation matrix and position
              given a model transform matrix and reference position.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergJoint.Matrix">
            <summary>
              Gets or sets the current <see cref="T:Accord.Math.Kinematics.DenavitHartenbergMatrix"/> associated with this joint.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergJoint.Position">
            <summary>
              Gets or sets the position of this joint.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergJoint.Parameters">
            <summary>
              Gets or sets the parameters for this joint.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Kinematics.DenavitHartenbergJointCollection">
            <summary>
              Collection of Denavit Hartenberg Joints.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergJointCollection.Add(Accord.Math.Kinematics.DenavitHartenbergParameters)">
            <summary>
              Adds an object to the end of this <see cref="T:Accord.Math.Kinematics.DenavitHartenbergJointCollection"/>.
            </summary>
            
            <param name="parameters">The <see cref="T:Accord.Math.Kinematics.DenavitHartenbergParameters">
              parameters</see> specifying the joint to be added.</param>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergJointCollection.Add(System.Double,System.Double,System.Double,System.Double)">
            <summary>
              Adds an object to the end of this <see cref="T:Accord.Math.Kinematics.DenavitHartenbergJointCollection"/>.
            </summary>
            
            <param name="alpha">Angle in radians on the Z axis relatively to the last joint.</param>
            <param name="theta">Angle in radians on the X axis relatively to the last joint.</param>
            <param name="radius">Length or radius of the joint.</param>
            <param name="offset">Offset along Z axis relatively to the last joint.</param>
            
        </member>
        <member name="T:Accord.Math.Matrix">
             <summary>
               Static class Matrix. Defines a set of extension methods
               that operates mainly on multidimensional arrays and vectors.
             </summary>
             
             
             <remarks>
               The matrix class is a static class containing several extension methods.
               To use this class, import the <see cref="N:Accord.Math"/> and use the
               standard .NET's matrices and jagged arrays. When you call the dot (.)
               operator on those classes, the extension methods offered by this class
               should become available through IntelliSense auto-complete.
             </remarks>
             
             <example>
               <h2>Introduction</h2>
               
               <para>
                 Declaring and using matrices in the Accord.NET Framework does
                 not requires much. In fact, it does not require anything else
                 that is not already present at the .NET Framework. If you have
                 already existing and working code using other libraries, you
                 don't have to convert your matrices to any special format used
                 by Accord.NET. This is because Accord.NET is built to interoperate
                 with other libraries and existing solutions, relying solely on
                 default .NET structures to work.</para>
                 
               <para>
                 To begin, please add the following <c>using</c> directive on
                 top of your .cs (or equivalent) source code file: </para>
                 
               <code>
                 using Accord.Math;
               </code>
               
               <para>
                 This is all you need to start using the Accord.NET matrix library.</para>
                 
               <h2>Creating matrices</h2>
               
               <para>
                 Let's start by declaring a matrix, or otherwise specifying matrices
                 from other sources. The most straightforward way to declare a matrix
                 in Accord.NET is simply using: </para>
                 
             <code>
                 double[,] matrix = 
                 {
                    { 1, 2 },
                    { 3, 4 },
                    { 5, 6 },
                };
             </code>
             
              <para>
                Yep, that is right. You don't need to create any fancy custom Matrix
                classes or vectors to make Accord.NET work, which is a plus if you
                have already existent code using other libraries. You are also free
                to use both the multidimensional matrix syntax above or the jagged
                matrix syntax below:</para>
                
             <code>
                 double[][] matrix = 
                 {
                    new double[] { 1, 2 },
                    new double[] { 3, 4 },
                    new double[] { 5, 6 },
                };
             </code>
             
              <para>
                Special purpose matrices can also be created through specialized methods.
                Those include</para>
                
             <code>
               // Creates a vector of indices
               int[] idx = Matrix.Indices(0, 10);  // { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
               
               // Creates a step vector within a given interval
               double[] interval = Matrix.Interval(from: -2, to: 4); // { -2, -1, 0, 1, 2, 3, 4 };
               
               // Special matrices
               double[,] I = Matrix.Identity(3);     // creates a 3x3 identity matrix
               double[,] magic = Matrix.Magic(5);    // creates a magic square matrix of size 5
               
               double[] v = Matrix.Vector(5, 1.0);      // generates { 1, 1, 1, 1, 1 }
               double[,] diagonal = Matrix.Diagonal(v); // matrix with v on its diagonal
             </code>
                
              <para>
                Another way to declare matrices is by parsing the contents of a string:</para>
                
             <code>
               string str = @"1 2
                              3 4";
                              
               double[,] matrix = Matrix.Parse(str);
             </code>
             
              <para>
                You can even read directly from matrices formatted in C# syntax:</para>
                
              <code>
               string str = @"double[,] matrix = 
                              {
                                 { 1, 2 },
                                 { 3, 4 },
                                 { 5, 6 },
                              }";
                              
               double[,] multid = Matrix.Parse(str, CSharpMatrixFormatProvider.InvariantCulture);
               double[,] jagged = Matrix.ParseJagged(str, CSharpMatrixFormatProvider.InvariantCulture);
              </code>
              
              <para>
                And even from <a href="http://www.gnu.org/software/octave/">Octave-compatible</a> syntax!</para>
                
              <code>
               string str = "[1 2; 3 4]";
                              
               double[,] matrix = Matrix.Parse(str, OctaveMatrixFormatProvider.InvariantCulture);
              </code>
              
              <para>
                There are also other methods, such as specialization for arrays and other formats.
                For more details, please take a look on <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/>,
                <see cref="T:Accord.Math.CSharpArrayFormatProvider"/>, <see cref="T:Accord.Math.DefaultArrayFormatProvider"/>,
                <see cref="T:Accord.Math.DefaultMatrixFormatProvider"/> and <see cref="M:Accord.Math.Matrix.Parse(System.String)"/>.
              </para>
                
                 
              <h2>Matrix operations</h2>
              
              <para>
                Albeit being simple <see cref="T:double[]"/> matrices, the framework leverages
                .NET extension methods to support all basic matrix operations. For instance,
                consider the elementwise operations (also known as dot operations in Octave):</para>
             
             <code>
               double[] vector = { 0, 2, 4 };
               double[] a = vector.ElementwiseMultiply(2); // vector .* 2, generates { 0,  4,  8 }
               double[] b = vector.ElementwiseDivide(2);   // vector ./ 2, generates { 0,  1,  2 }
               double[] c = vector.ElementwisePower(2);    // vector .^ 2, generates { 0,  4, 16 }
             </code>
             
             <para>
               Operations between vectors, matrices, and both are also completely supported:</para>
               
             <code>
               // Declare two vectors
               double[] u = { 1, 6, 3 };
               double[] v = { 9, 4, 2 };
             
               // Products between vectors
               double inner = u.InnerProduct(v);    // 39.0
               double[,] outer = u.OuterProduct(v); // see below
               double[] kronecker = u.KroneckerProduct(v); // { 9, 4, 2, 54, 24, 12, 27, 12, 6 }
               double[][] cartesian = u.CartesianProduct(v); // all possible pair-wise combinations
             
             /* outer =
                { 
                   {  9,  4,  2 },
                   { 54, 24, 12 },
                   { 27, 12,  6 },
                };                  */
            
               // Addition
               double[] addv = u.Add(v); // { 10, 10, 5 }
               double[] add5 = u.Add(5); // {  6, 11, 8 }
            
               // Elementwise operations
               double[] abs = u.Abs();   // { 1, 6, 3 }
               double[] log = u.Log();   // { 0, 1.79, 1.09 }
               
               // Apply *any* function to all elements in a vector
               double[] cos = u.Apply(Math.Cos); // { 0.54, 0.96, -0.989 }
               u.ApplyInPlace(Math.Cos); // can also do optionally in-place
            
               
               // Declare a matrix
               double[,] M = 
               {
                  { 0, 5, 2 },
                  { 2, 1, 5 }
               };
              
               // Extract a subvector from v:
               double[] vcut = v.Submatrix(0, 1); // { 9, 4 }
               
               // Some operations between vectors and matrices
               double[] Mv = m.Multiply(v);    //  { 24, 32 }
               double[] vM = vcut.Multiply(m); // { 8, 49, 38 }
               
               // Some operations between matrices
               double[,] Md = m.MultiplyByDiagonal(v);   // { { 0, 20, 4 }, { 18, 4, 10 } }
               double[,] MMt = m.MultiplyByTranspose(m); //   { { 29, 15 }, { 15, 30 } }
             </code>
             
             <para>
               Please note this is by no means an extensive list; please take a look on
               all members available on this class or (preferably) use IntelliSense to
               navigate through all possible options when trying to perform an operation.</para>
             </example>
             
             <seealso cref="T:Accord.Math.DefaultMatrixFormatProvider"/>
             <seealso cref="T:Accord.Math.DefaultArrayFormatProvider"/>
             <seealso cref="T:Accord.Math.OctaveMatrixFormatProvider"/>
             <seealso cref="T:Accord.Math.OctaveArrayFormatProvider"/>
             <seealso cref="T:Accord.Math.CSharpMatrixFormatProvider"/>
             <seealso cref="T:Accord.Math.CSharpArrayFormatProvider"/>
             
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[0:,0:],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
              Returns a sub matrix extracted from the current matrix.
            </summary>
            
            <param name="source">The matrix to return the submatrix from.</param>
            <param name="startRow">Start row index</param>
            <param name="endRow">End row index</param>
            <param name="startColumn">Start column index</param>
            <param name="endColumn">End column index</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[0:,0:],``0[0:,0:],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
              Returns a sub matrix extracted from the current matrix.
            </summary>
            
            <param name="source">The matrix to return the submatrix from.</param>
            <param name="destination">The matrix where results should be stored.</param>
            <param name="startRow">Start row index</param>
            <param name="endRow">End row index</param>
            <param name="startColumn">Start column index</param>
            <param name="endColumn">End column index</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[0:,0:],System.Int32[],System.Int32[])">
            <summary>
              Returns a sub matrix extracted from the current matrix.
            </summary>
            
            <param name="source">The matrix to return the submatrix from.</param>
            <param name="rowIndexes">Array of row indices. Pass null to select all indices.</param>
            <param name="columnIndexes">Array of column indices. Pass null to select all indices.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[0:,0:],``0[0:,0:],System.Int32[],System.Int32[])">
            <summary>
              Returns a sub matrix extracted from the current matrix.
            </summary>
            
            <param name="source">The matrix to return the submatrix from.</param>
            <param name="destination">The matrix where results should be stored.</param>
            <param name="rowIndexes">Array of row indices. Pass null to select all indices.</param>
            <param name="columnIndexes">Array of column indices. Pass null to select all indices.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[0:,0:],System.Int32[])">
            <summary>
              Returns a sub matrix extracted from the current matrix.
            </summary>
            
            <param name="source">The matrix to return the submatrix from.</param>
            <param name="rowIndexes">Array of row indices</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[0:,0:],System.Int32,System.Int32,System.Int32[])">
            <summary>
              Returns a sub matrix extracted from the current matrix.
            </summary>
            
            <param name="source">The matrix to return the submatrix from.</param>
            <param name="startRow">Starting row index</param>
            <param name="endRow">End row index</param>
            <param name="columnIndexes">Array of column indices</param>
            
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[0:,0:],System.Int32[],System.Int32,System.Int32)">
            <summary>
              Returns a sub matrix extracted from the current matrix.
            </summary>
            
            <param name="source">The matrix to return the submatrix from.</param>
            <param name="rowIndexes">Array of row indices</param>
            <param name="startColumn">Start column index</param>
            <param name="endColumn">End column index</param>
            
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[][],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
              Returns a sub matrix extracted from the current matrix.
            </summary>
            
            <param name="source">The matrix to return the submatrix from.</param>
            <param name="startRow">Start row index</param>
            <param name="endRow">End row index</param>
            <param name="startColumn">Start column index</param>
            <param name="endColumn">End column index</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[][],System.Int32[],System.Int32[],System.Boolean)">
            <summary>
              Returns a sub matrix extracted from the current matrix.
            </summary>
            
            <param name="source">The matrix to return the submatrix from.</param>
            <param name="rowIndexes">Array of row indices. Pass null to select all indices.</param>
            <param name="columnIndexes">Array of column indices. Pass null to select all indices.</param>
            <param name="reuseMemory">Set to true to avoid memory allocations 
              when possible. This might result on the shallow copies of some
              elements. Default is false (default is to always provide a true,
              deep copy of every element in the matrices, using more memory).</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[][],System.Int32[],System.Boolean)">
            <summary>
              Returns a sub matrix extracted from the current matrix.
            </summary>
            
            <param name="source">The matrix to return the submatrix from.</param>
            <param name="indexes">Array of indices.</param>
            <param name="transpose">True to return a transposed matrix; false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[][],System.Int32[],System.Int32,System.Int32,System.Boolean)">
            <summary>
              Returns a sub matrix extracted from the current matrix.
            </summary>
            
            <param name="source">The matrix to return the submatrix from.</param>
            <param name="rowIndexes">Array of row indices</param>
            <param name="startColumn">Start column index</param>
            <param name="endColumn">End column index</param>
            <param name="reuseMemory">Set to true to avoid memory allocations 
              when possible. This might result on the shallow copies of some
              elements. Default is false (default is to always provide a true,
              deep copy of every element in the matrices, using more memory).</param>
            
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[][],System.Int32,System.Int32,System.Int32[])">
            <summary>
              Returns a sub matrix extracted from the current matrix.
            </summary>
            
            <param name="source">The matrix to return the submatrix from.</param>
            <param name="startRow">Starting row index</param>
            <param name="endRow">End row index</param>
            <param name="columnIndexes">Array of column indices</param>
            
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[],System.Int32[])">
            <summary>
              Returns a subvector extracted from the current vector.
            </summary>
            
            <param name="source">The vector to return the subvector from.</param>
            <param name="indexes">Array of indices.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[],System.Collections.Generic.IList{System.Int32})">
            <summary>
              Returns a subvector extracted from the current vector.
            </summary>
            
            <param name="source">The vector to return the subvector from.</param>
            <param name="indexes">Array of indices.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[],System.Int32,System.Int32)">
            <summary>
              Returns a subvector extracted from the current vector.
            </summary>
            
            <param name="source">The vector to return the subvector from.</param>
            <param name="startRow">Starting index.</param>
            <param name="endRow">End index.</param>
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[],System.Int32)">
            <summary>
              Returns a subvector extracted from the current vector.
            </summary>
            
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(System.Collections.Generic.List{``0},System.Int32[])">
            <summary>
              Returns a subvector extracted from the current vector.
            </summary>
            
            <param name="source">The vector to return the subvector from.</param>
            <param name="indexes">Array of indices.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subgroups``1(``0[],System.Int32[])">
            <summary>
              Returns subgroups extracted from the given vector.
            </summary>
            
            <param name="values">The vector to extract the groups from.</param>
            <param name="groups">The vector of indices for the groups.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subgroups``1(``0[],System.Int32[],System.Int32)">
            <summary>
              Returns subgroups extracted from the given vector, assuming that
              the groups should have been labels from 0 until the given number
              of <paramref name="classes"/>.
            </summary>
            
            <param name="values">The vector to extract the groups from.</param>
            <param name="groups">The vector of indices for the groups.</param>
            <param name="classes">The number of classes in the groups. Specifying this
              parameter will make the method assume the groups should be containing
              integer labels ranging from 0 until the number of classes.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.submatrix``1(``0[0:,0:],``0[0:,0:],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
              Extracts a selected area from a matrix.
            </summary>
            
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.submatrix``1(``0[0:,0:],``0[0:,0:],System.Int32[],System.Int32[])">
            <summary>
              Extracts a selected area from a matrix.
            </summary>
            
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.submatrix``1(``0[][],``0[][],System.Int32[],System.Int32[],System.Boolean)">
            <summary>
              Extracts a selected area from a matrix.
            </summary>
            
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.submatrix``1(``0[][],``0[][],System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
              Extracts a selected area from a matrix.
            </summary>
            
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.Create``1(System.Int32,System.Int32,``0)">
            <summary>
              Returns a matrix with all elements set to a given value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Create``1(System.Int32,``0)">
            <summary>
              Returns a matrix with all elements set to a given value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Create``1(System.Int32,System.Int32)">
            <summary>
              Returns a new multidimensional matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Create``1(System.Int32)">
            <summary>
              Returns a new multidimensional matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Jagged``1(System.Int32,System.Int32,``0)">
            <summary>
              Returns a matrix with all elements set to a given value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Jagged``1(System.Int32,``0)">
            <summary>
              Returns a matrix with all elements set to a given value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Jagged``1(System.Int32,System.Int32)">
            <summary>
              Returns a new jagged matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Jagged``1(System.Int32)">
            <summary>
              Returns a new jagged matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Diagonal``1(System.Int32,``0)">
            <summary>
              Returns a square diagonal matrix of the given size.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Diagonal``1(System.Int32,System.Int32,``0)">
            <summary>
              Returns a matrix of the given size with value on its diagonal.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Diagonal``1(``0[])">
            <summary>
              Return a square matrix with a vector of values on its diagonal.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.JaggedDiagonal``1(``0[])">
            <summary>
              Return a jagged matrix with a vector of values on its diagonal.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.JaggedDiagonal``1(System.Int32,``0)">
            <summary>
              Returns a square diagonal matrix of the given size.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Diagonal``1(System.Int32,``0[])">
            <summary>
              Return a square matrix with a vector of values on its diagonal.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Diagonal``1(System.Int32,System.Int32,``0[])">
            <summary>
              Returns a matrix with a vector of values on its diagonal.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Identity(System.Int32)">
            <summary>
              Returns the Identity matrix of the given size.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.JaggedIdentity(System.Int32)">
            <summary>
              Returns the Identity matrix of the given size.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.JaggedMagic(System.Int32)">
            <summary>
              Creates a jagged magic square matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Magic(System.Int32)">
            <summary>
              Creates a magic square matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Centering(System.Int32)">
            <summary>
              Creates a centering matrix of size <c>N x N</c> in the
              form <c>(I - 1N)</c> where <c>1N</c> is a matrix with 
              all elements equal to <c>1 / N</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Random(System.Int32,System.Int32)">
            <summary>
              Creates a rows-by-cols matrix with uniformly distributed random data.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Random(System.Int32,System.Boolean,System.Double,System.Double)">
            <summary>
              Creates a rows-by-cols matrix with uniformly distributed random data.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Random(System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
              Creates a rows-by-cols matrix with uniformly distributed random data.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Random(System.Int32,System.Int32,AForge.Math.Random.IRandomNumberGenerator)">
            <summary>
              Creates a rows-by-cols matrix random data drawn from a given distribution.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Random(System.Int32,System.Single,System.Single)">
            <summary>
              Creates a vector with uniformly distributed random data.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Random(System.Int32,System.Double,System.Double)">
            <summary>
              Creates a vector with uniformly distributed random data.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Random(System.Int32,AForge.Math.Random.IRandomNumberGenerator)">
            <summary>
              Creates a vector with random data drawn from a given distribution.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.RowVector``1(``0[])">
            <summary>
              Creates a matrix with a single row vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ColumnVector``1(``0[])">
            <summary>
              Creates a matrix with a single column vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Vector``1(System.Int32,``0[])">
            <summary>
              Creates a vector with the given dimension and starting values.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Vector``1(System.Int32,``0)">
            <summary>
              Creates a vector with the given dimension and starting values.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Vector(System.Double,System.Double,System.Double)">
            <summary>
              Creates a vector with the given dimension and starting values.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Vector(System.Int32,System.Int32,System.Int32)">
            <summary>
              Creates a vector with the given dimension and starting values.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Vector(System.Double,System.Double,System.Int32)">
            <summary>
              Creates a vector with the given dimension and starting values.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Indices(System.Int32,System.Int32)">
            <summary>
              Creates a index vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Indices(System.Int32)">
            <summary>
              Creates a index vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.GetDimensions(System.Array)">
            <summary>
              Gets the dimensions of an array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Interval(System.Int32,System.Int32)">
            <summary>
              Creates an interval vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Interval(AForge.DoubleRange,System.Double)">
            <summary>
              Creates an interval vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Interval(System.Double,System.Double,System.Double)">
            <summary>
              Creates an interval vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Interval(System.Single,System.Single,System.Double)">
            <summary>
              Creates an interval vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Interval(AForge.DoubleRange,System.Int32)">
            <summary>
              Creates an interval vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Interval(System.Double,System.Double,System.Int32)">
            <summary>
              Creates an interval vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Mesh(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
              Creates a bi-dimensional mesh matrix.
            </summary>
            
            <example>
            <code>
            // The Mesh method can be used to generate all
            // possible (x,y) pairs between two ranges. 
            
            // We can create a grid as
            double[][] grid = Matrix.Mesh
            (
                rowMin: 0, rowMax: 1, rowStepSize: 0.3,
                colMin: 0, colMax: 1, colStepSize: 0.1
            );
            
            // Now we can plot the points on-screen
            ScatterplotBox.Show("Grid (step size)", grid).Hold();
            </code>
            
            <para>
              The resulting image is shown below. </para>
              <img src="..\images\grid-step-size.png" /> 
            </example>
            
        </member>
        <member name="M:Accord.Math.Matrix.Mesh(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
              Creates a bi-dimensional mesh matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Mesh(System.Double,System.Double,System.Int32,System.Double,System.Double,System.Int32)">
             <summary>
               Creates a bi-dimensional mesh matrix.
             </summary>
             
             <example>
             <code>
             // The Mesh method can be used to generate all
             // possible (x,y) pairs between two ranges. 
             
             // We can create a grid as
             double[][] grid = Matrix.Mesh
             (
                 rowMin: 0, rowMax: 1, rowSteps: 10,
                 colMin: 0, colMax: 1, colSteps: 5
             );
            
             // Now we can plot the points on-screen
             ScatterplotBox.Show("Grid (fixed steps)", grid).Hold();
             </code>
             
             <para>
               The resulting image is shown below. </para>
               <img src="..\images\grid-fixed-steps.png" /> 
             </example>
             
        </member>
        <member name="M:Accord.Math.Matrix.Mesh(AForge.DoubleRange,AForge.DoubleRange,System.Double,System.Double)">
            <summary>
              Creates a bi-dimensional mesh matrix.
            </summary>
            
            <example>
            <code>
            // The Mesh method can be used to generate all
            // possible (x,y) pairs between two ranges. 
            
            // We can create a grid as
            double[][] grid = Matrix.Mesh
            (
                rowRange: new DoubleRange(0, 1), rowStepSize: 0.3,
                colRange: new DoubleRange(0, 1), colStepSize: 0.1
            );
            
            // Now we can plot the points on-screen
            ScatterplotBox.Show("Grid (step size)", grid).Hold();
            </code>
            
            <para>
              The resulting image is shown below. </para>
              <img src="..\images\grid-step-size.png" /> 
            </example>
            
        </member>
        <member name="M:Accord.Math.Matrix.Mesh``1(``0[],``0[])">
            <summary>
              Creates a bi-dimensional mesh matrix.
            </summary>
            
            <param name="x">The values to be replicated vertically.</param>
            <param name="y">The values to be replicated horizontally.</param>
            
            <example>
            <code>
            // The Mesh method generates all possible (x,y) pairs
            // between two vector of points. For example, let's
            // suppose we have the values:
            //
            double[] a = { 0, 1 };
            double[] b = { 0, 1 };
            
            // We can create a grid as
            double[][] grid = a.Mesh(b);
            
            // the result will be:
            double[][] expected =
            {
                new double[] { 0, 0 },
                new double[] { 0, 1 },
                new double[] { 1, 0 },
                new double[] { 1, 1 },
            };
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.Matrix.MeshGrid``1(``0[],``0[])">
             <summary>
               Generates a 2-D mesh grid from two vectors <c>a</c> and <c>b</c>,
               generating two matrices <c>len(a)</c> x <c>len(b)</c> with all
               all possible combinations of values between the two vectors. This
               method is analogous to MATLAB/Octave's <c>meshgrid</c> function.
             </summary>
            
             <returns>A tuple containing two matrices: the first containing values
             for the x-coordinates and the second for the y-coordinates.</returns>
             
             <example>
             // The MeshGrid method generates two matrices that can be
             // used to generate all possible (x,y) pairs between two
             // vector of points. For example, let's suppose we have
             // the values:
             //
             double[] a = { 1, 2, 3 };
             double[] b = { 4, 5, 6 };
             
             // We can create a grid
             var grid = a.MeshGrid(b);
             
             // get the x-axis values     //        | 1   1   1 |
             double[,] x = grid.Item1;    //  x =   | 2   2   2 |
                                          //        | 3   3   3 |
             
             // get the y-axis values     //        | 4   5   6 |
             double[,] y = grid.Item2;    //  y =   | 4   5   6 |
                                          //        | 4   5   6 |
             
             // we can either use those matrices separately (such as for plotting 
             // purposes) or we can also generate a grid of all the (x,y) pairs as
             //
             double[,][] xy = x.ApplyWithIndex((v, i, j) => new[] { x[i, j], y[i, j] });
            
             // The result will be
             // 
             //         |  (1, 4)   (1, 5)   (1, 6)  |
             //  xy  =  |  (2, 4)   (2, 5)   (2, 6)  |
             //         |  (3, 4)   (3, 5)   (3, 6)  |
             </example>
            
        </member>
        <member name="M:Accord.Math.Matrix.Concatenate``1(``0[],``0[])">
            <summary>
              Combines two vectors horizontally.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Concatenate``1(``0[],``0)">
            <summary>
              Combines a vector and a element horizontally.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Concatenate``1(``0,``0[])">
            <summary>
              Combines a vector and a element horizontally.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Concatenate``1(``0[0:,0:],``0[])">
            <summary>
              Combines a matrix and a vector horizontally.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Concatenate``1(``0[0:,0:],``0[0:,0:])">
            <summary>
              Combines two matrices horizontally.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Concatenate``1(``0[][],``0[][])">
            <summary>
              Combines two matrices horizontally.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Concatenate``1(``0[0:,0:][])">
            <summary>
              Combines a matrix and a vector horizontally.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Concatenate``1(``0[][][])">
            <summary>
              Combines a matrix and a vector horizontally.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Concatenate``1(``0[][])">
            <summary>
              Combine vectors horizontally.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Stack``1(``0[],``0[])">
            <summary>
              Combines vectors vertically.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Stack``1(``0[][],``0[][])">
            <summary>
              Combines vectors vertically.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Stack``1(``0[][])">
            <summary>
              Combines vectors vertically.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Stack``1(``0[])">
            <summary>
              Combines vectors vertically.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Stack``1(``0[],``0)">
            <summary>
              Combines vectors vertically.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Stack``1(``0[0:,0:][])">
            <summary>
              Combines matrices vertically.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Stack``1(``0[0:,0:],``0[])">
            <summary>
              Combines matrices vertically.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Stack``1(``0[][][])">
            <summary>
              Combines matrices vertically.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Expand``1(``0[],System.Int32[])">
            <summary>
              Expands a data vector given in summary form.
            </summary>
            
            <param name="vector">A base vector.</param>
            <param name="count">An array containing by how much each line should be replicated.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Expand``1(``0[0:,0:],System.Int32[])">
            <summary>
              Expands a data matrix given in summary form.
            </summary>
            
            <param name="matrix">A base matrix.</param>
            <param name="count">An array containing by how much each line should be replicated.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Split``1(``0[],System.Int32)">
            <summary>
              Splits a given vector into a smaller vectors of the given size.
              This operation can be reverted using <see cref="M:Accord.Math.Matrix.Merge``1(``0[][],System.Int32)"/>.
            </summary>
            
            <param name="vector">The vector to be splitted.</param>
            <param name="size">The size of the resulting vectors.</param>
            
            <returns>An array of vectors containing the subdivisions of the given vector.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Merge``1(``0[][],System.Int32)">
            <summary>
              Merges a series of vectors into a single vector. This
              operation can be reverted using <see cref="M:Accord.Math.Matrix.Split``1(``0[],System.Int32)"/>.
            </summary>
            
            <param name="vectors">The vectors to be merged.</param>
            <param name="size">The size of the inner vectors.</param>
            
            <returns>A single array containing the given vectors.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Merge``1(``0[][])">
            <summary>
              Merges a series of vectors into a single vector. This
              operation can be reverted using <see cref="M:Accord.Math.Matrix.Split``1(``0[],System.Int32)"/>.
            </summary>
            
            <param name="vectors">The vectors to be merged.</param>
            
            <returns>A single array containing the given vectors.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Pad``1(``0[0:,0:],System.Int32)">
            <summary>
              Pads a matrix by filling all of its sides with zeros.
            </summary>
            
            <param name="matrix">The matrix whose contents will be padded.</param>
            <param name="all">How many rows and columns to add at each side of the matrix.</param>
            
            <returns>The original matrix with an extra row of zeros at the selected places.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Pad``1(``0[0:,0:],System.Int32,System.Int32)">
            <summary>
              Pads a matrix by filling all of its sides with zeros.
            </summary>
            
            <param name="matrix">The matrix whose contents will be padded.</param>
            <param name="rightLeft">How many columns to add at the sides of the matrix.</param>
            <param name="topBottom">How many rows to add at the bottom and top of the matrix.</param>
            
            <returns>The original matrix with an extra row of zeros at the selected places.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Pad``1(``0[0:,0:],System.Int32,System.Int32,System.Int32)">
            <summary>
              Pads a matrix by filling all of its sides with zeros.
            </summary>
            
            <param name="matrix">The matrix whose contents will be padded.</param>
            <param name="bottom">How many rows to add at the bottom.</param>
            <param name="top">How many rows to add at the top.</param>
            <param name="sides">How many columns to add at the sides.</param>
            
            <returns>The original matrix with an extra row of zeros at the selected places.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Pad``1(``0[0:,0:],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
              Pads a matrix by filling all of its sides with zeros.
            </summary>
            
            <param name="matrix">The matrix whose contents will be padded.</param>
            <param name="bottom">How many rows to add at the bottom.</param>
            <param name="top">How many rows to add at the top.</param>
            <param name="left">How many columns to add at the left side.</param>
            <param name="right">How many columns to add at the right side.</param>
            
            <returns>The original matrix with an extra row of zeros at the selected places.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString``1(``0[0:,0:])">
            <summary>
              Returns a <see cref="T:System.String"/> represents a matrix.
            </summary>
            <param name="matrix">The matrix.</param>
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
            <example>
              Please see <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/>,
              <see cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>, <see cref="T:Accord.Math.CSharpArrayFormatProvider"/>,
              <see cref="T:Accord.Math.OctaveMatrixFormatProvider"/>, or <see cref="T:Accord.Math.OctaveArrayFormatProvider"/> 
              for more details.
            </example>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString``1(``0[0:,0:],System.Boolean,Accord.Math.IMatrixFormatProvider)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents a matrix.
            </summary>
            
            <param name="matrix">The matrix.</param>
            
            <param name="multiline">
              If set to <c>true</c>, the matrix will be written using multiple
              lines. If set to <c>false</c>, the matrix will be written in a 
              single line.</param>
              
            <param name="provider">
              The <see cref="T:Accord.Math.IMatrixFormatProvider"/> to be used
              when creating the resulting string. Default is to use
              <see cref="P:Accord.Math.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
            <example>
              Please see <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/>,
              <see cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>, <see cref="T:Accord.Math.CSharpArrayFormatProvider"/>,
              <see cref="T:Accord.Math.OctaveMatrixFormatProvider"/>, or <see cref="T:Accord.Math.OctaveArrayFormatProvider"/> 
              for more details.
            </example>
            
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString``1(``0[0:,0:],Accord.Math.IMatrixFormatProvider)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents a matrix.
            </summary>
            
            <param name="matrix">The matrix.</param>
            
            <param name="provider">
              The <see cref="T:Accord.Math.IMatrixFormatProvider"/> to be used
              when creating the resulting string. Default is to use
              <see cref="P:Accord.Math.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
            <example>
              Please see <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/>,
              <see cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>, <see cref="T:Accord.Math.CSharpArrayFormatProvider"/>,
              <see cref="T:Accord.Math.OctaveMatrixFormatProvider"/>, or <see cref="T:Accord.Math.OctaveArrayFormatProvider"/> 
              for more details.
            </example>
            
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString``1(``0[0:,0:],System.String,Accord.Math.IMatrixFormatProvider)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents a matrix.
            </summary>
            
            <param name="matrix">The matrix.</param>
            <param name="format">
              The format to use when creating the resulting string.
            </param>
            <param name="provider">
              The <see cref="T:Accord.Math.IMatrixFormatProvider"/> to be used
              when creating the resulting string. Default is to use
              <see cref="P:Accord.Math.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
            <example>
              Please see <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/>,
              <see cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>, <see cref="T:Accord.Math.CSharpArrayFormatProvider"/>,
              <see cref="T:Accord.Math.OctaveMatrixFormatProvider"/>, or <see cref="T:Accord.Math.OctaveArrayFormatProvider"/> 
              for more details.
            </example>
            
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString``1(``0[0:,0:],System.String)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents a matrix.
            </summary>
            
            <param name="matrix">The matrix.</param>
            
            <param name="format">
              The format to use when creating the resulting string.
            </param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
            <example>
              Please see <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/>,
              <see cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>, <see cref="T:Accord.Math.CSharpArrayFormatProvider"/>,
              <see cref="T:Accord.Math.OctaveMatrixFormatProvider"/>, or <see cref="T:Accord.Math.OctaveArrayFormatProvider"/> 
              for more details.
            </example>
            
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString``1(``0[][])">
            <summary>
              Returns a <see cref="T:System.String"/> that represents a matrix.
            </summary>
            
            <param name="matrix">The matrix.</param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
            <example>
              Please see <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/>,
              <see cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>, <see cref="T:Accord.Math.CSharpArrayFormatProvider"/>,
              <see cref="T:Accord.Math.OctaveMatrixFormatProvider"/>, or <see cref="T:Accord.Math.OctaveArrayFormatProvider"/> 
              for more details.
            </example>
            
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString``1(``0[][],Accord.Math.IMatrixFormatProvider)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents a matrix.
            </summary>
            
            <param name="matrix">The matrix.</param>
            <param name="provider">
              The <see cref="T:Accord.Math.IMatrixFormatProvider"/> to be used
              when creating the resulting string. Default is to use
              <see cref="P:Accord.Math.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
            <example>
              Please see <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/>,
              <see cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>, <see cref="T:Accord.Math.CSharpArrayFormatProvider"/>,
              <see cref="T:Accord.Math.OctaveMatrixFormatProvider"/>, or <see cref="T:Accord.Math.OctaveArrayFormatProvider"/> 
              for more details.
            </example>
            
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString``1(``0[][],System.String,Accord.Math.IMatrixFormatProvider)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents a matrix.
            </summary>
            <param name="matrix">The matrix.</param>
            <param name="format">
              The format to use when creating the resulting string.
            </param>
            
            <param name="provider">
              The <see cref="T:Accord.Math.IMatrixFormatProvider"/> to be used
              when creating the resulting string. Default is to use
              <see cref="P:Accord.Math.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
            <example>
              Please see <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/>,
              <see cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>, <see cref="T:Accord.Math.CSharpArrayFormatProvider"/>,
              <see cref="T:Accord.Math.OctaveMatrixFormatProvider"/>, or <see cref="T:Accord.Math.OctaveArrayFormatProvider"/> 
              for more details.
            </example>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString``1(``0[][],System.String)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents a matrix.
            </summary>
            
            <param name="matrix">The matrix.</param>
            
            <param name="format">
              The format to use when creating the resulting string.
            </param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
            <example>
              Please see <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/>,
              <see cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>, <see cref="T:Accord.Math.CSharpArrayFormatProvider"/>,
              <see cref="T:Accord.Math.OctaveMatrixFormatProvider"/>, or <see cref="T:Accord.Math.OctaveArrayFormatProvider"/> 
              for more details.
            </example>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString``1(``0[])">
            <summary>
              Returns a <see cref="T:System.String"/> that represents an array.
            </summary>
            
            <param name="array">The array.</param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
            <example>
              Please see <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/>,
              <see cref="T:Accord.Math.OctaveArrayFormatProvider"/> or <see cref="T:Accord.Math.DefaultArrayFormatProvider"/>
              for examples and more details.
            </example>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString``1(``0[],Accord.Math.IMatrixFormatProvider)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents an array.
            </summary>
            
            <param name="array">The array.</param>
            
            <param name="provider">
              The <see cref="T:Accord.Math.IMatrixFormatProvider"/> to be used
              when creating the resulting string. Default is to use
              <see cref="P:Accord.Math.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
            <example>
              Please see <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/>,
              <see cref="T:Accord.Math.OctaveArrayFormatProvider"/> or <see cref="T:Accord.Math.DefaultArrayFormatProvider"/>
              for examples and more details.
            </example>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString``1(``0[],System.String,Accord.Math.IMatrixFormatProvider)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents an array.
            </summary>
            
            <param name="matrix">The matrix.</param>
            
            <param name="format">
              The format to use when creating the resulting string.
            </param>
            
            <param name="provider">
              The <see cref="T:Accord.Math.IMatrixFormatProvider"/> to be used
              when creating the resulting string. Default is to use
              <see cref="P:Accord.Math.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
            <example>
              Please see <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/>,
              <see cref="T:Accord.Math.OctaveArrayFormatProvider"/> or <see cref="T:Accord.Math.DefaultArrayFormatProvider"/>
              for examples and more details.
            </example>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString``1(``0[],System.String)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents an array.
            </summary>
            
            <param name="array">The array.</param>
            
            <param name="format">
              The format to use when creating the resulting string.
            </param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
            <example>
              Please see <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/>,
              <see cref="T:Accord.Math.OctaveArrayFormatProvider"/> or <see cref="T:Accord.Math.DefaultArrayFormatProvider"/>
              for examples and more details.
            </example>
            
        </member>
        <member name="M:Accord.Math.Matrix.Parse(System.String)">
            <summary>
              Converts the string representation of a matrix to its
              double-precision floating-point number matrix equivalent.
            </summary>
            <param name="str">The string representation of the matrix.</param>
            <returns>A double-precision floating-point number matrix parsed
            from the given string using the given format provider.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Parse(System.String,Accord.Math.IMatrixFormatProvider)">
            <summary>
              Converts the string representation of a matrix to its
              double-precision floating-point number matrix equivalent.
            </summary>
            <param name="str">The string representation of the matrix.</param>
            <param name="provider">
              The format provider to use in the conversion. Default is to use
              <see cref="P:Accord.Math.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            <returns>A double-precision floating-point number matrix parsed
            from the given string using the given format provider.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.ParseJagged(System.String,Accord.Math.IMatrixFormatProvider)">
            <summary>
              Converts the string representation of a matrix to its
              double-precision floating-point number matrix equivalent.
            </summary>
            <param name="s">The string representation of the matrix.</param>
            <param name="provider">
              The format provider to use in the conversion. Default is to use
              <see cref="P:Accord.Math.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            <returns>A double-precision floating-point number matrix parsed
            from the given string using the given format provider.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.TryParse(System.String,Accord.Math.IMatrixFormatProvider,System.Double[0:,0:]@)">
            <summary>
              Converts the string representation of a matrix to its
              double-precision floating-point number matrix equivalent.
              A return value indicates whether the conversion succeeded or failed.
            </summary>
            <param name="s">The string representation of the matrix.</param>
            <param name="provider">
              The format provider to use in the conversion. Default is to use
              <see cref="P:Accord.Math.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            <param name="matrix">A double-precision floating-point number matrix parsed
            from the given string using the given format provider.</param>
            <result>When this method returns, contains the double-precision floating-point
            number matrix equivalent to the <see param="s"/> parameter, if the conversion succeeded, 
            or null if the conversion failed. The conversion fails if the <see param="s"/> parameter
            is null, is not a matrix in a valid format, or contains elements which represent
            a number less than MinValue or greater than MaxValue. This parameter is passed
            uninitialized. </result>
            
        </member>
        <member name="M:Accord.Math.Matrix.TryParse(System.String,Accord.Math.IMatrixFormatProvider,System.Double[][]@)">
            <summary>
              Converts the string representation of a matrix to its
              double-precision floating-point number matrix equivalent.
              A return value indicates whether the conversion succeeded or failed.
            </summary>
            <param name="s">The string representation of the matrix.</param>
            <param name="provider">
              The format provider to use in the conversion. Default is to use
              <see cref="P:Accord.Math.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            <param name="matrix">A double-precision floating-point number matrix parsed
            from the given string using the given format provider.</param>
            <result>When this method returns, contains the double-precision floating-point
            number matrix equivalent to the <see param="s"/> parameter, if the conversion succeeded, 
            or null if the conversion failed. The conversion fails if the <see param="s"/> parameter
            is null, is not a matrix in a valid format, or contains elements which represent
            a number less than MinValue or greater than MaxValue. This parameter is passed
            uninitialized. </result>
            
        </member>
        <member name="M:Accord.Math.Matrix.Abs(System.Int32[])">
            <summary>
              Elementwise absolute value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Abs(System.Double[])">
            <summary>
              Elementwise absolute value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Sign(System.Double[])">
            <summary>
              Elementwise absolute value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Abs(System.Double[0:,0:])">
            <summary>
              Elementwise absolute value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Abs(System.Int32[0:,0:])">
            <summary>
              Elementwise absolute value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Sqrt(System.Double[])">
            <summary>
              Elementwise Square root.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Sqrt(System.Double[0:,0:])">
            <summary>
              Elementwise Square root.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Log(System.Double[0:,0:])">
            <summary>
              Elementwise Log operation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Exp(System.Double[0:,0:])">
            <summary>
              Elementwise Exp operation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Exp(System.Double[])">
            <summary>
              Elementwise Exp operation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Log(System.Double[])">
            <summary>
              Elementwise Log operation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Log(System.Int32[])">
            <summary>
              Elementwise Log operation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwisePower(System.Double[0:,0:],System.Double)">
            <summary>
              Elementwise power operation.
            </summary>
            
            <param name="x">A matrix.</param>
            <param name="y">A power.</param>
            
            <returns>Returns x elevated to the power of y.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwisePower(System.Double[],System.Double)">
            <summary>
              Elementwise power operation.
            </summary>
            
            <param name="x">A matrix.</param>
            <param name="y">A power.</param>
            
            <returns>Returns x elevated to the power of y.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseDivide(System.Double[],System.Double[])">
            <summary>
              Elementwise divide operation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseDivide(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Elementwise divide operation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseDivide(System.Single[0:,0:],System.Single[0:,0:])">
            <summary>
              Elementwise divide operation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseDivide(System.Double[0:,0:],System.Double[],System.Int32,System.Boolean)">
            <summary>
              Elementwise division.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseDivide(System.Double[][],System.Double[],System.Int32,System.Boolean)">
            <summary>
              Elementwise division.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseDivide(System.Int32[0:,0:],System.Int32[],System.Int32)">
            <summary>
              Elementwise division.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseMultiply(System.Double[],System.Double[])">
            <summary>
              Elementwise multiply operation.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseMultiply(System.Double[],System.Int32[])">
            <summary>
              Elementwise multiply operation.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseMultiply(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Elementwise multiply operation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseMultiply(System.Int32[],System.Int32[])">
            <summary>
              Elementwise multiply operation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseMultiply(System.Int32[0:,0:],System.Int32[0:,0:])">
            <summary>
              Elementwise multiplication.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseMultiply(System.Double[0:,0:],System.Double[],System.Int32)">
            <summary>
              Elementwise multiplication.
            </summary>
            
            <param name="a">The left matrix a.</param>
            <param name="b">The right vector b.</param>
            <param name="dimension">
              If set to 0, b will be multiplied with every row vector in a. 
              If set to 1, b will be multiplied with every column vector.
            </param>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseMultiply(System.Double[0:,0:],System.Double[],System.Double[0:,0:],System.Int32)">
            <summary>
              Elementwise multiplication.
            </summary>
            
            <param name="a">The left matrix a.</param>
            <param name="b">The right vector b.</param>
            <param name="r">The result vector r.</param>
            <param name="dimension">
              If set to 0, b will be multiplied with every row vector in a. 
              If set to 1, b will be multiplied with every column vector.
            </param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Solve(System.Double[0:,0:],System.Double[0:,0:],System.Boolean)">
            <summary>
              Returns the solution matrix if the matrix is square or the least squares solution otherwise.
            </summary>
            
            <param name="matrix">The matrix for the linear problem.</param>
            <param name="rightSide">The right side <c>b</c>.</param>
            <param name="leastSquares">True to produce a solution even if the 
              <paramref name="matrix"/> is singular; false otherwise. Default is false.</param>
            
            <remarks>
              Please note that this does not check if the matrix is non-singular
              before attempting to solve. If a least squares solution is desired
              in case the matrix is singular, pass true to the <paramref name="leastSquares"/>
              parameter when calling this function.
            </remarks>
            
            <example>
            <code>
            // Create a matrix. Please note that this matrix
            // is singular (i.e. not invertible), so only a 
            // least squares solution would be feasible here.
            
            double[,] matrix = 
            {
                { 1, 2, 3 },
                { 4, 5, 6 },
                { 7, 8, 9 },
            };
            
            // Define a right side matrix b:
            double[,] rightSide = { {1}, {2}, {3} };
            
            // Solve the linear system Ax = b by finding x:
            double[,] x = Matrix.Solve(matrix, rightSide, leastSquares: true);
            
            // The answer should be { {-1/18}, {2/18}, {5/18} }.
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.Matrix.Solve(System.Double[0:,0:],System.Double[],System.Boolean)">
            <summary>
              Returns the solution matrix if the matrix is square or the least squares solution otherwise.
            </summary>
            
            <param name="matrix">The matrix for the linear problem.</param>
            <param name="rightSide">The right side <c>b</c>.</param>
            <param name="leastSquares">True to produce a solution even if the 
              <paramref name="matrix"/> is singular; false otherwise. Default is false.</param>
            
            <remarks>
              Please note that this does not check if the matrix is non-singular
              before attempting to solve. If a least squares solution is desired
              in case the matrix is singular, pass true to the <paramref name="leastSquares"/>
              parameter when calling this function.
            </remarks>
            
            <example>
            <code>
            // Create a matrix. Please note that this matrix
            // is singular (i.e. not invertible), so only a 
            // least squares solution would be feasible here.
            
            double[,] matrix = 
            {
                { 1, 2, 3 },
                { 4, 5, 6 },
                { 7, 8, 9 },
            };
            
            // Define a right side vector b:
            double[] rightSide = { 1, 2, 3 };
            
            // Solve the linear system Ax = b by finding x:
            double[] x = Matrix.Solve(matrix, rightSide, leastSquares: true);
            
            // The answer should be { -1/18, 2/18, 5/18 }.
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.Matrix.Inverse(System.Double[0:,0:])">
            <summary>
              Computes the inverse of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Inverse(System.Double[0:,0:],System.Boolean)">
            <summary>
              Computes the inverse of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.PseudoInverse(System.Double[0:,0:])">
            <summary>
              Computes the pseudo-inverse of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Solve(System.Double[][],System.Double[][],System.Boolean)">
            <summary>
              Returns the solution matrix if the matrix is square or the least squares solution otherwise.
            </summary>
            
            <param name="matrix">The matrix for the linear problem.</param>
            <param name="rightSide">The right side <c>b</c>.</param>
            <param name="leastSquares">True to produce a solution even if the 
              <paramref name="matrix"/> is singular; false otherwise. Default is false.</param>
            
            <remarks>
              Please note that this does not check if the matrix is non-singular
              before attempting to solve. If a least squares solution is desired
              in case the matrix is singular, pass true to the <paramref name="leastSquares"/>
              parameter when calling this function.
            </remarks>
            
            <example>
            <code>
            // Create a matrix. Please note that this matrix
            // is singular (i.e. not invertible), so only a 
            // least squares solution would be feasible here.
            
            double[,] matrix = 
            {
                { 1, 2, 3 },
                { 4, 5, 6 },
                { 7, 8, 9 },
            };
            
            // Define a right side matrix b:
            double[,] rightSide = { {1}, {2}, {3} };
            
            // Solve the linear system Ax = b by finding x:
            double[,] x = Matrix.Solve(matrix, rightSide, leastSquares: true);
            
            // The answer should be { {-1/18}, {2/18}, {5/18} }.
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.Matrix.Solve(System.Double[][],System.Double[],System.Boolean)">
            <summary>
              Returns the solution matrix if the matrix is square or the least squares solution otherwise.
            </summary>
            
            <param name="matrix">The matrix for the linear problem.</param>
            <param name="rightSide">The right side <c>b</c>.</param>
            <param name="leastSquares">True to produce a solution even if the 
              <paramref name="matrix"/> is singular; false otherwise. Default is false.</param>
            
            <remarks>
              Please note that this does not check if the matrix is non-singular
              before attempting to solve. If a least squares solution is desired
              in case the matrix is singular, pass true to the <paramref name="leastSquares"/>
              parameter when calling this function.
            </remarks>
            
            <example>
            <code>
            // Create a matrix. Please note that this matrix
            // is singular (i.e. not invertible), so only a 
            // least squares solution would be feasible here.
            
            double[,] matrix = 
            {
                { 1, 2, 3 },
                { 4, 5, 6 },
                { 7, 8, 9 },
            };
            
            // Define a right side vector b:
            double[] rightSide = { 1, 2, 3 };
            
            // Solve the linear system Ax = b by finding x:
            double[] x = Matrix.Solve(matrix, rightSide, leastSquares: true);
            
            // The answer should be { -1/18, 2/18, 5/18 }.
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.Matrix.Inverse(System.Double[][])">
            <summary>
              Computes the inverse of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Inverse(System.Double[][],System.Boolean)">
            <summary>
              Computes the inverse of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.PseudoInverse(System.Double[][])">
            <summary>
              Computes the pseudo-inverse of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToMatrix``1(``0[][])">
            <summary>
              Converts a jagged-array into a multidimensional array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToMatrix``1(``0[][],System.Boolean)">
            <summary>
              Converts a jagged-array into a multidimensional array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToMatrix``1(``0[])">
            <summary>
              Converts an array into a multidimensional array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray``1(``0[],System.Boolean)">
            <summary>
              Converts an array into a multidimensional array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToMatrix``1(``0[],System.Boolean)">
            <summary>
              Converts an array into a multidimensional array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray``1(``0[0:,0:])">
            <summary>
              Converts a multidimensional array into a jagged array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray``1(``0[0:,0:],System.Boolean)">
            <summary>
              Converts a multidimensional array into a jagged array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToDouble(System.Single[0:,0:])">
            <summary>
              Converts a double-precision floating point multidimensional
              array into a double-precision floating point multidimensional
              array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToDouble(System.Byte[0:,0:])">
            <summary>
              Converts a byte multidimensional array into a double-
              precision floating point multidimensional array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToDouble(System.Int32[0:,0:])">
            <summary>
              Converts a double-precision floating point multidimensional
              array into a single-precision floating point multidimensional
              array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToSingle(System.Double[0:,0:])">
            <summary>
              Converts a single-precision floating point multidimensional
              array into a double-precision floating point multidimensional
              array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToInt32(System.Double[0:,0:])">
            <summary>
              Truncates a double matrix to integer values.
            </summary>
            <param name="matrix">The matrix to be truncated.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToInt32(System.Double[][])">
            <summary>
              Truncates a double matrix to integer values.
            </summary>
            <param name="matrix">The matrix to be truncated.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToInt32(System.Byte[][])">
            <summary>
              Converts a matrix to integer values.
            </summary>
            
            <param name="matrix">The matrix to be converted.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToInt32(System.SByte[][])">
            <summary>
              Converts a matrix to integer values.
            </summary>
            
            <param name="matrix">The matrix to be converted.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToDouble(System.Int32[][])">
            <summary>
              Converts an integer matrix to double values.
            </summary>
            
            <param name="matrix">The matrix to be converted.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToDouble(System.Byte[][])">
            <summary>
              Converts an integer matrix to double values.
            </summary>
            
            <param name="matrix">The matrix to be converted.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToDouble(System.SByte[][])">
            <summary>
              Converts an integer matrix to double values.
            </summary>
            
            <param name="matrix">The matrix to be converted.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToSingle(System.Double[][])">
            <summary>
              Converts an integer matrix to double values.
            </summary>
            
            <param name="matrix">The matrix to be converted.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToDouble(System.Single[])">
            <summary>
              Converts a double-precision floating point multidimensional
              array into a single-precision floating point multidimensional
              array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToDouble(System.Int16[])">
            <summary>
              Converts a double-precision floating point multidimensional
              array into a single-precision floating point multidimensional
              array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToInt32(System.Double[])">
            <summary>
              Truncates a double vector to integer values.
            </summary>
            <param name="vector">The vector to be truncated.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToInt32(System.Byte[])">
            <summary>
              Converts a vector to integer values.
            </summary>
            
            <param name="vector">The vector to be converted.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToInt32(System.SByte[])">
            <summary>
              Converts a vector to integer values.
            </summary>
            
            <param name="vector">The vector to be converted.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToDouble(System.Int32[])">
            <summary>
              Converts a integer vector into a double vector.
            </summary>
            <param name="vector">The vector to be converted.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToSingle(System.Double[])">
            <summary>
              Converts a double vector into a single vector.
            </summary>
            <param name="vector">The vector to be converted.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Convert``2(``0[],System.Converter{``0,``1})">
            <summary>
              Converts the values of a vector using the given converter expression.
            </summary>
            <typeparam name="TInput">The type of the input.</typeparam>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <param name="vector">The vector to be converted.</param>
            <param name="converter">The converter function.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Convert``2(``0[][],System.Converter{``0,``1})">
            <summary>
              Converts the values of a matrix using the given converter expression.
            </summary>
            <typeparam name="TInput">The type of the input.</typeparam>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <param name="matrix">The matrix to be converted.</param>
            <param name="converter">The converter function.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Convert``2(``0[0:,0:],System.Converter{``0,``1})">
            <summary>
              Converts the values of a matrix using the given converter expression.
            </summary>
            <typeparam name="TInput">The type of the input.</typeparam>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <param name="matrix">The vector to be converted.</param>
            <param name="converter">The converter function.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.To``1(System.Object)">
            <summary>
              Converts an object into another type, irrespective of whether
              the conversion can be done at compile time or not. This can be
              used to convert generic types to numeric types during runtime.
            </summary>
            
            <typeparam name="T">The destination type.</typeparam>
            
            <param name="value">The value to be converted.</param>
            
            <returns>The result of the conversion.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.To``1(System.Array)">
            <summary>
              Converts the values of a vector using the given converter expression.
            </summary>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <param name="array">The vector or array to be converted.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.GetIndices(System.Array)">
            <summary>
              Creates a vector containing every index that can be used to
              address a given <paramref name="array"/>, in order.
            </summary>
            
            <param name="array">The array whose indices will be returned.</param>
            
            <returns>
              An enumerable object that can be used to iterate over all
              positions of the given <paramref name="array">System.Array</paramref>.
            </returns>
            
            <example>
            <code>
              double[,] a = 
              { 
                 { 5.3, 2.3 },
                 { 4.2, 9.2 }
              };
              
              foreach (int[] idx in a.GetIndices())
              {
                 // Get the current element
                 double e = (double)a.GetValue(idx);
              }
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToMatrix(System.Data.DataTable)">
            <summary>
              Converts a DataTable to a double[,] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToMatrix(System.Data.DataTable,System.String[]@)">
            <summary>
              Converts a DataTable to a double[,] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToMatrix(System.Data.DataTable,System.IFormatProvider)">
            <summary>
              Converts a DataTable to a double[,] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToMatrix(System.Data.DataTable,System.String[])">
            <summary>
              Converts a DataTable to a double[,] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToMatrix``1(System.Data.DataTable,System.IFormatProvider)">
            <summary>
              Converts a DataTable to a double[,] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToMatrix``1(System.Data.DataTable)">
            <summary>
              Converts a DataTable to a double[,] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToMatrix``1(System.Data.DataTable,System.String[]@)">
            <summary>
              Converts a DataTable to a double[,] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToMatrix``1(System.Data.DataTable,System.String[]@,System.IFormatProvider)">
            <summary>
              Converts a DataTable to a double[,] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToMatrix``1(System.Data.DataTable,System.String[])">
            <summary>
              Converts a DataTable to a double[,] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToMatrix``1(System.Data.DataTable,System.IFormatProvider,System.String[])">
            <summary>
              Converts a DataTable to a double[,] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToTable(System.Double[0:,0:])">
            <summary>
              Converts a DataTable to a double[,] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToTable(System.Double[0:,0:],System.String[])">
            <summary>
              Converts a DataTable to a double[,] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToTable(System.Double[][])">
            <summary>
              Converts a DataTable to a double[,] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToTable(System.Double[][],System.String[])">
            <summary>
              Converts a DataTable to a double[,] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToTable(System.Object[0:,0:])">
            <summary>
              Converts an array of values into a <see cref="T:System.Data.DataTable"/>,
              attempting to guess column types by inspecting the data.
            </summary>
            
            <param name="values">The values to be converted.</param>
            
            <returns>A <see cref="T:System.Data.DataTable"/> containing the given values.</returns>
            
            <example>
            <code>
            // Specify some data in a table format
            //
            object[,] data = 
            {
                { "Id", "IsSmoker", "Age" },
                {   0,       1,        10  },
                {   1,       1,        15  },
                {   2,       0,        40  },
                {   3,       1,        20  },
                {   4,       0,        70  },
                {   5,       0,        55  },
            };
            
            // Create a new table with the data
            DataTable dataTable = data.ToTable();
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray(System.Data.DataTable)">
            <summary>
              Converts a DataTable to a double[][] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray(System.Data.DataTable,System.IFormatProvider)">
            <summary>
              Converts a DataTable to a double[][] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray(System.Data.DataTable,System.String[]@)">
            <summary>
              Converts a DataTable to a double[][] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray(System.Data.DataTable,System.IFormatProvider,System.String[]@)">
            <summary>
              Converts a DataTable to a double[][] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray(System.Data.DataTable,System.String[])">
            <summary>
              Converts a DataTable to a double[][] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray``1(System.Data.DataTable)">
            <summary>
              Converts a DataTable to a double[][] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray``1(System.Data.DataTable,System.IFormatProvider)">
            <summary>
              Converts a DataTable to a double[][] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray``1(System.Data.DataTable,System.String[]@)">
            <summary>
              Converts a DataTable to a double[][] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray``1(System.Data.DataTable,System.IFormatProvider,System.String[]@)">
            <summary>
              Converts a DataTable to a double[][] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray``1(System.Data.DataTable,System.String[])">
            <summary>
              Converts a DataTable to a double[][] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray(System.Data.DataColumn)">
            <summary>
              Converts a DataColumn to a double[] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray(System.Data.DataColumn,System.IFormatProvider)">
            <summary>
              Converts a DataColumn to a double[] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray(System.Data.DataRow,System.IFormatProvider,System.String[])">
            <summary>
              Converts a DataColumn to a double[] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray(System.Data.DataRow,System.String[])">
            <summary>
              Converts a DataColumn to a double[] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray``1(System.Data.DataColumn)">
            <summary>
              Converts a DataColumn to a double[] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray``1(System.Data.DataColumn,System.IFormatProvider)">
            <summary>
              Converts a DataColumn to a double[] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray``1(System.Data.DataRow,System.String[])">
            <summary>
              Converts a DataColumn to a generic array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray``1(System.Data.DataRow,System.IFormatProvider,System.String[])">
            <summary>
              Converts a DataColumn to a generic array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray``1(System.Data.DataTable,System.String)">
            <summary>
              Converts a DataTable to a generic array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray``1(System.Data.DataTable,System.IFormatProvider,System.String)">
            <summary>
              Converts a DataTable to a generic array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToInt32Array(System.Data.DataColumn)">
            <summary>
              Converts a DataColumn to a int[] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToIntArray(System.Data.DataTable,System.String[])">
            <summary>
              Converts a DataTable to a int[][] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Computes the product <c>A*B</c> of two matrices <c>A</c> and <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[][],System.Double[][])">
            <summary>
              Computes the product <c>A*B</c> of two matrices <c>A</c> and <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single[][],System.Single[][])">
            <summary>
              Computes the product <c>A*B</c> of two matrices <c>A</c> and <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single[][],System.Double[][])">
            <summary>
              Computes the product <c>A*B</c> of two matrices <c>A</c> and <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single[0:,0:],System.Single[0:,0:])">
            <summary>
              Computes the product <c>A*B</c> of two matrices <c>A</c> and <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Computes the product <c>R = A*B</c> of two matrices <c>A</c>
              and <c>B</c>, storing the result in matrix <c>R</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[][],System.Double[][],System.Double[][])">
            <summary>
              Computes the product <c>R = A*B</c> of two matrices <c>A</c>
              and <c>B</c>, storing the result in matrix <c>R</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[0:,0:],System.Double[0:,0:],System.Double[][])">
            <summary>
              Computes the product <c>R = A*B</c> of two matrices <c>A</c>
              and <c>B</c>, storing the result in matrix <c>R</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single[][],System.Single[][],System.Single[][])">
            <summary>
              Computes the product <c>R = A*B</c> of two matrices <c>A</c>
              and <c>B</c>, storing the result in matrix <c>R</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single[][],System.Double[][],System.Double[][])">
            <summary>
              Computes the product <c>R = A*B</c> of two matrices <c>A</c>
              and <c>B</c>, storing the result in matrix <c>R</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single[0:,0:],System.Single[0:,0:],System.Single[0:,0:])">
            <summary>
              Computes the product <c>R = A*B</c> of two matrices <c>A</c>
              and <c>B</c>, storing the result in matrix <c>R</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.MultiplyByTranspose(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Computes the product <c>A*B'</c> of matrix <c>A</c> and transpose of <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The transposed right matrix <c>B</c>.</param>
            <returns>The product <c>A*B'</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.MultiplyByTranspose(System.Single[0:,0:],System.Single[0:,0:])">
            <summary>
              Computes the product <c>A*B'</c> of matrix <c>A</c> and transpose of <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The transposed right matrix <c>B</c>.</param>
            <returns>The product <c>A*B'</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.MultiplyByTranspose(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Computes the product <c>A*B'</c> of matrix <c>A</c> and
              transpose of <c>B</c>, storing the result in matrix <c>R</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The transposed right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B'</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
               
        </member>
        <member name="M:Accord.Math.Matrix.MultiplyByTranspose(System.Single[0:,0:],System.Single[0:,0:],System.Single[0:,0:])">
            <summary>
              Computes the product <c>A*B'</c> of matrix <c>A</c> and
              transpose of <c>B</c>, storing the result in matrix <c>R</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The transposed right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B'</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
               
        </member>
        <member name="M:Accord.Math.Matrix.TransposeAndMultiply(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Computes the product <c>A'*B</c> of matrix <c>A</c> transposed and matrix <c>B</c>.
            </summary>
            
            <param name="a">The transposed left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <returns>The product <c>A'*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.TransposeAndMultiply(System.Double[][],System.Double[][])">
            <summary>
              Computes the product <c>A'*B</c> of matrix <c>A</c> transposed and matrix <c>B</c>.
            </summary>
            
            <param name="a">The transposed left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <returns>The product <c>A'*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.TransposeAndMultiply(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Computes the product <c>A'*B</c> of matrix <c>A</c> transposed and matrix <c>B</c>.
            </summary>
            
            <param name="a">The transposed left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A'*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.TransposeAndMultiply(System.Double[][],System.Double[][],System.Double[][])">
            <summary>
              Computes the product <c>A'*B</c> of matrix <c>A</c> transposed and matrix <c>B</c>.
            </summary>
            
            <param name="a">The transposed left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A'*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.TransposeAndMultiply(System.Double[0:,0:],System.Double[])">
            <summary>
              Computes the product <c>A'*B</c> of matrix <c>A</c> transposed and vector <c>b</c>.
            </summary>
            
            <param name="a">The transposed left matrix <c>A</c>.</param>
            <param name="b">The right column vector <c>b</c>.</param>
            <returns>The product <c>A'*b</c> of the given matrices <c>A</c> and vector <c>b</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.TransposeAndMultiply(System.Double[0:,0:],System.Double[],System.Double[])">
            <summary>
              Computes the product <c>A'*b</c> of matrix <c>A</c> transposed and column vector <c>b</c>.
            </summary>
            
            <param name="a">The transposed left matrix <c>A</c>.</param>
            <param name="b">The right column vector <c>b</c>.</param>
            <param name="result">The vector <c>r</c> to store the product <c>r = A'*b</c>
              of the given matrix <c>A</c> and vector <c>b</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.TransposeAndMultiplyByDiagonal(System.Double[0:,0:],System.Double[])">
            <summary>
              Computes the product A'*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The diagonal vector of right matrix <c>B</c>.</param>
            <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.TransposeAndMultiplyByDiagonal(System.Double[0:,0:],System.Double[],System.Double[0:,0:])">
            <summary>
              Computes the product A'*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The diagonal vector of right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.MultiplyByDiagonal(System.Double[][],System.Double[])">
            <summary>
              Computes the product A*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The diagonal vector of right matrix <c>B</c>.</param>
            <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.MultiplyByDiagonal(System.Single[][],System.Single[])">
            <summary>
              Computes the product A*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The diagonal vector of right matrix <c>B</c>.</param>
            <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.MultiplyByDiagonal(System.Double[0:,0:],System.Double[])">
            <summary>
              Computes the product A*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The diagonal vector of right matrix <c>B</c>.</param>
            <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.MultiplyByDiagonal(System.Double[0:,0:],System.Double[],System.Double[0:,0:])">
            <summary>
              Computes the product A*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The diagonal vector of right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.MultiplyByDiagonal(System.Double[][],System.Double[],System.Double[][])">
            <summary>
              Computes the product A*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The diagonal vector of right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.MultiplyByDiagonal(System.Single[][],System.Single[],System.Single[][])">
            <summary>
              Computes the product A*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The diagonal vector of right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.MultiplyByDiagonal(System.Single[0:,0:],System.Single[])">
            <summary>
              Computes the product A*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The diagonal vector of right matrix <c>B</c>.</param>
            <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.MultiplyByDiagonal(System.Single[0:,0:],System.Single[],System.Single[0:,0:])">
            <summary>
              Computes the product A*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The diagonal vector of right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.DivideByDiagonal(System.Double[0:,0:],System.Double[])">
            <summary>
              Computes the product A*inv(B) of matrix <c>A</c> and diagonal matrix <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The diagonal vector of inverse right matrix <c>B</c>.</param>
            <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.DivideByDiagonal(System.Double[0:,0:],System.Double[],System.Double[0:,0:])">
            <summary>
              Computes the product A*inv(B) of matrix <c>A</c> and diagonal matrix <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The diagonal vector of inverse right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[],System.Double[0:,0:])">
            <summary>
              Multiplies a row vector <c>v</c> and a matrix <c>A</c>,
              giving the product <c>v'*A</c>.
            </summary>
            
            <param name="rowVector">The row vector <c>v</c>.</param>
            <param name="matrix">The matrix <c>A</c>.</param>
            <returns>The product <c>v'*A</c>of the multiplication of the
              given row vector <c>v</c> and matrix <c>A</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single[],System.Single[0:,0:])">
            <summary>
              Multiplies a row vector <c>v</c> and a matrix <c>A</c>,
              giving the product <c>v'*A</c>.
            </summary>
            
            <param name="rowVector">The row vector <c>v</c>.</param>
            <param name="matrix">The matrix <c>A</c>.</param>
            <returns>The product <c>v'*A</c>of the multiplication of the
              given row vector <c>v</c> and matrix <c>A</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[0:,0:],System.Double[])">
            <summary>
              Multiplies a matrix <c>A</c> and a column vector <c>v</c>,
              giving the product <c>A*v</c>
            </summary>
            
            <param name="matrix">The matrix <c>A</c>.</param>
            <param name="columnVector">The column vector <c>v</c>.</param>
            <returns>The product <c>A*v</c> of the multiplication of the
              given matrix <c>A</c> and column vector <c>v</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single[][],System.Single[])">
            <summary>
              Multiplies a matrix <c>A</c> and a column vector <c>v</c>,
              giving the product <c>A*v</c>
            </summary>
            
            <param name="matrix">The matrix <c>A</c>.</param>
            <param name="columnVector">The column vector <c>v</c>.</param>
            <returns>The product <c>A*v</c> of the multiplication of the
              given matrix <c>A</c> and column vector <c>v</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[][],System.Double[])">
            <summary>
              Multiplies a matrix <c>A</c> and a column vector <c>v</c>,
              giving the product <c>A*v</c>
            </summary>
            
            <param name="matrix">The matrix <c>A</c>.</param>
            <param name="columnVector">The column vector <c>v</c>.</param>
            <returns>The product <c>A*v</c> of the multiplication of the
              given matrix <c>A</c> and column vector <c>v</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single[0:,0:],System.Single[])">
            <summary>
              Multiplies a matrix <c>A</c> and a column vector <c>v</c>,
              giving the product <c>A*v</c>
            </summary>
            
            <param name="matrix">The matrix <c>A</c>.</param>
            <param name="columnVector">The column vector <c>v</c>.</param>
            <returns>The product <c>A*v</c> of the multiplication of the
              given matrix <c>A</c> and column vector <c>v</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[0:,0:],System.Double,System.Boolean)">
            <summary>
              Multiplies a matrix <c>A</c> by a scalar <c>x</c>.
            </summary>
            
            <param name="matrix">The matrix <c>A</c>.</param>
            <param name="x">The scalar <c>x</c>.</param>
            <param name="inPlace">True to perform the operation in-place,
              overwriting the original matrix; false to return a new matrix.</param>
            
            <returns>The product <c>A*x</c> of the multiplication of the
              given matrix <c>A</c> and scalar <c>x</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[0:,0:],System.Double)">
            <summary>
              Multiplies a matrix <c>A</c> by a scalar <c>x</c>.
            </summary>
            
            <param name="matrix">The matrix <c>A</c>.</param>
            <param name="x">The scalar <c>x</c>.</param>
            <returns>The product <c>A*x</c> of the multiplication of the
              given matrix <c>A</c> and scalar <c>x</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single[0:,0:],System.Single)">
            <summary>
              Multiplies a matrix <c>A</c> by a scalar <c>x</c>.
            </summary>
            
            <param name="matrix">The matrix <c>A</c>.</param>
            <param name="x">The scalar <c>x</c>.</param>
            <returns>The product <c>A*x</c> of the multiplication of the
              given matrix <c>A</c> and scalar <c>x</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[0:,0:],System.Double,System.Double[0:,0:])">
            <summary>
              Multiplies a matrix <c>A</c> by a scalar <c>x</c>.
            </summary>
            
            <param name="matrix">The matrix <c>A</c>.</param>
            <param name="x">The scalar <c>x</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R=A*x</c>
              of the multiplication of the given matrix <c>A</c> and scalar <c>x</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single[0:,0:],System.Single,System.Single[0:,0:])">
            <summary>
              Multiplies a matrix <c>A</c> by a scalar <c>x</c>.
            </summary>
            
            <param name="matrix">The matrix <c>A</c>.</param>
            <param name="x">The scalar <c>x</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R=A*x</c>
              of the multiplication of the given matrix <c>A</c> and scalar <c>x</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[],System.Double)">
            <summary>
              Multiplies a vector <c>v</c> by a scalar <c>x</c>.
            </summary>
            <param name="vector">The vector <c>v</c>.</param>
            <param name="x">The scalar <c>x</c>.</param>
            <returns>The product <c>v*x</c> of the multiplication of the 
              given vector <c>v</c> and scalar <c>x</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[],System.Double,System.Boolean)">
            <summary>
              Multiplies a vector <c>v</c> by a scalar <c>x</c>.
            </summary>
            <param name="vector">The vector <c>v</c>.</param>
            <param name="x">The scalar <c>x</c>.</param>
            <param name="inPlace">True to perform the operation in-place,
              overwriting the original matrix; false to return a new matrix.</param>
              
            <returns>The product <c>v*x</c> of the multiplication of the 
              given vector <c>v</c> and scalar <c>x</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single[],System.Single)">
            <summary>
              Multiplies a vector <c>v</c> by a scalar <c>x</c>.
            </summary>
            <param name="vector">The vector <c>v</c>.</param>
            <param name="x">The scalar <c>x</c>.</param>
            <returns>The product <c>v*x</c> of the multiplication of the 
              given vector <c>v</c> and scalar <c>x</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double,System.Double[0:,0:])">
            <summary>
              Multiplies a scalar <c>x</c> by a matrix <c>A</c>.
            </summary>
            <param name="x">The scalar <c>x</c>.</param>
            <param name="matrix">The matrix <c>A</c>.</param>
            <returns>The product <c>x*A</c> of the multiplication of the
              given scalar <c>x</c> and matrix <c>A</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single,System.Single[0:,0:])">
            <summary>
              Multiplies a scalar <c>x</c> by a matrix <c>A</c>.
            </summary>
            <param name="x">The scalar <c>x</c>.</param>
            <param name="matrix">The matrix <c>A</c>.</param>
            <returns>The product <c>x*A</c> of the multiplication of the
              given scalar <c>x</c> and matrix <c>A</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double,System.Double[])">
            <summary>
              Multiplies a scalar <c>x</c> by a vector <c>v</c>.
            </summary>
            <param name="x">The scalar <c>x</c>.</param>
            <param name="vector">The vector <c>v</c>.</param>
            <returns>The product <c>x*v</c> of the multiplication of the 
              given scalar <c>x</c> and vector <c>v</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single,System.Single[])">
            <summary>
              Multiplies a scalar <c>x</c> by a vector <c>v</c>.
            </summary>
            <param name="x">The scalar <c>x</c>.</param>
            <param name="vector">The vector <c>v</c>.</param>
            <returns>The product <c>x*v</c> of the multiplication of the 
              given scalar <c>x</c> and vector <c>v</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Int32,System.Double[])">
            <summary>
              Multiplies a scalar <c>x</c> by a vector <c>v</c>.
            </summary>
            <param name="x">The scalar <c>x</c>.</param>
            <param name="vector">The vector <c>v</c>.</param>
            <returns>The product <c>x*v</c> of the multiplication of the 
              given scalar <c>x</c> and vector <c>v</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Int32,System.Single[])">
            <summary>
              Multiplies a scalar <c>x</c> by a vector <c>v</c>.
            </summary>
            <param name="x">The scalar <c>x</c>.</param>
            <param name="vector">The vector <c>v</c>.</param>
            <returns>The product <c>x*v</c> of the multiplication of the 
              given scalar <c>x</c> and vector <c>v</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.Double,System.Double[],System.Boolean)">
            <summary>
              Divides a scalar by a vector.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="x">A scalar.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original array; false to return a new array.</param>
            
            <returns>The division quotient of the given vector <c>a</c> and scalar <c>b</c>.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.Int32,System.Double[],System.Boolean)">
            <summary>
              Divides a scalar by a vector.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="x">A scalar.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original array; false to return a new array.</param>
            
            <returns>The division quotient of the given vector <c>a</c> and scalar <c>b</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.Double[],System.Double,System.Boolean)">
            <summary>
              Divides a vector by a scalar.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="x">A scalar.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original array; false to return a new array.</param>
            
            <returns>The division quotient of the given vector <c>a</c> and scalar <c>b</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.Int32[],System.Double)">
            <summary>
              Divides a vector by a scalar.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="x">A scalar.</param>
            
            <returns>The division quotient of the given vector <c>a</c> and scalar <c>b</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.Single[],System.Single)">
            <summary>
              Divides a vector by a scalar.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="x">A scalar.</param>
            
            <returns>The division quotient of the given vector <c>a</c> and scalar <c>b</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.Double,System.Double[])">
            <summary>
              Elementwise divides a scalar by a vector.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="x">A scalar.</param>
            
            <returns>The division quotient of the given scalar <c>a</c> and vector <c>b</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Divides two matrices by multiplying A by the inverse of B.
            </summary>
            
            <param name="a">The first matrix.</param>
            <param name="b">The second matrix (which will be inverted).</param>
            
            <returns>The result from the division <c>AB^-1</c> of the given matrices.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.Double[0:,0:],System.Double,System.Boolean)">
            <summary>
              Divides a matrix by a scalar.
            </summary>
            
            <param name="matrix">A matrix.</param>
            <param name="x">A scalar.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original matrix; false to return a new matrix.</param>
            
            <returns>The division quotient of the given matrix and scalar.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.UInt32[0:,0:],System.Single)">
            <summary>
              Divides a matrix by a scalar.
            </summary>
            
            <param name="matrix">A matrix.</param>
            <param name="x">A scalar.</param>
            
            <returns>The division quotient of the given matrix and scalar.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.Double,System.Double[0:,0:])">
            <summary>
              Elementwise divides a scalar by a matrix.
            </summary>
            
            <param name="x">A scalar.</param>
            <param name="matrix">A matrix.</param>
            
            <returns>The elementwise division of the given scalar and matrix.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.Int32,System.Double[0:,0:])">
            <summary>
              Elementwise divides a scalar by a matrix.
            </summary>
            
            <param name="x">A scalar.</param>
            <param name="matrix">A matrix.</param>
            
            <returns>The elementwise division of the given scalar and matrix.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.InnerProduct(System.Double[],System.Double[])">
            <summary>
              Gets the inner product (scalar product) between two vectors (a'*b).
            </summary>
            
            <param name="a">A vector.</param>
            <param name="b">A vector.</param>
            
            <returns>The inner product of the multiplication of the vectors.</returns>
            
            <remarks>
             <para>
               In mathematics, the dot product is an algebraic operation that takes two
               equal-length sequences of numbers (usually coordinate vectors) and returns
               a single number obtained by multiplying corresponding entries and adding up
               those products. The name is derived from the dot that is often used to designate
               this operation; the alternative name scalar product emphasizes the scalar
               (rather than vector) nature of the result.</para>
             <para>
               The principal use of this product is the inner product in a Euclidean vector space:
               when two vectors are expressed on an orthonormal basis, the dot product of their 
               coordinate vectors gives their inner product.</para>  
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.InnerProduct(System.Single[],System.Single[])">
            <summary>
              Gets the inner product (scalar product) between two vectors (a'*b).
            </summary>
            
            <param name="a">A vector.</param>
            <param name="b">A vector.</param>
            
            <returns>The inner product of the multiplication of the vectors.</returns>
            
            <remarks>
             <para>
               In mathematics, the dot product is an algebraic operation that takes two
               equal-length sequences of numbers (usually coordinate vectors) and returns
               a single number obtained by multiplying corresponding entries and adding up
               those products. The name is derived from the dot that is often used to designate
               this operation; the alternative name scalar product emphasizes the scalar
               (rather than vector) nature of the result.</para>
             <para>
               The principal use of this product is the inner product in a Euclidean vector space:
               when two vectors are expressed on an orthonormal basis, the dot product of their 
               coordinate vectors gives their inner product.</para>  
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.OuterProduct(System.Double[],System.Double[])">
            <summary>
              Gets the outer product (matrix product) between two vectors (a*bT).
            </summary>
            
            <remarks>
              In linear algebra, the outer product typically refers to the tensor
              product of two vectors. The result of applying the outer product to
              a pair of vectors is a matrix. The name contrasts with the inner product,
              which takes as input a pair of vectors and produces a scalar.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.VectorProduct(System.Double[],System.Double[])">
            <summary>
              Vector product.
            </summary>
            
            <remarks>
              The cross product, vector product or Gibbs vector product is a binary operation
              on two vectors in three-dimensional space. It has a vector result, a vector which
              is always perpendicular to both of the vectors being multiplied and the plane
              containing them. It has many applications in mathematics, engineering and physics.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.VectorProduct(System.Single[],System.Single[])">
            <summary>
              Vector product.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.CartesianProduct``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
              Computes the Cartesian product of many sets.
            </summary>
            
            <remarks>
              References:
              - http://blogs.msdn.com/b/ericlippert/archive/2010/06/28/computing-a-Cartesian-product-with-linq.aspx 
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.CartesianProduct``1(``0[][])">
            <summary>
              Computes the Cartesian product of many sets.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.CartesianProduct``1(``0[],``0[])">
            <summary>
              Computes the Cartesian product of two sets.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.KroneckerProduct(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Computes the Kronecker product between two matrices.
            </summary>
            
            <param name="a">The left matrix a.</param>
            <param name="b">The right matrix b.</param>
            
            <returns>The Kronecker product of the two matrices.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.KroneckerProduct(System.Double[],System.Double[])">
            <summary>
              Computes the Kronecker product between two vectors.
            </summary>
            
            <param name="a">The left vector a.</param>
            <param name="b">The right vector b.</param>
            
            <returns>The Kronecker product of the two vectors.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Add(System.Double[0:,0:],System.Double)">
            <summary>
              Adds a scalar to each element of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Add(System.Double,System.Double[0:,0:])">
            <summary>
              Subtracts a scalar to each element of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Add(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Adds two matrices.
            </summary>
            
            <param name="a">A matrix.</param>
            <param name="b">A matrix.</param>
            
            <returns>The sum of the given matrices.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Add(System.Double[][],System.Double[][])">
            <summary>
              Adds two matrices.
            </summary>
            
            <param name="a">A matrix.</param>
            <param name="b">A matrix.</param>
            
            <returns>The sum of the given matrices.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Add(System.Double[][],System.Double)">
            <summary>
              Adds a matrix and a scalar.
            </summary>
            
            <param name="a">A matrix.</param>
            <param name="x">A scalar.</param>
            
            <returns>The sum of the given matrix and scalar.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Add(System.Double[0:,0:],System.Double[],System.Int32)">
            <summary>
              Adds a vector to a column or row of a matrix.
            </summary>
            
            <param name="matrix">A matrix.</param>
            <param name="vector">A vector.</param>
            <param name="dimension">
              Pass 0 if the vector should be added row-wise, 
              or 1 if the vector should be added column-wise.
            </param>
            
        </member>
        <member name="M:Accord.Math.Matrix.AddToDiagonal(System.Double[0:,0:],System.Double,System.Boolean)">
            <summary>
              Adds a scalar to the diagonal of a matrix.
            </summary>
            
            <param name="matrix">A matrix.</param>
            <param name="scalar">A scalar.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original matrix; false to return a new matrix.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.AddToDiagonal(System.Double[][],System.Double,System.Boolean)">
            <summary>
              Adds a scalar to the diagonal of a matrix.
            </summary>
            
            <param name="matrix">A matrix.</param>
            <param name="scalar">A scalar.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original matrix; false to return a new matrix.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.SubtractFromDiagonal(System.Double[][],System.Double,System.Boolean)">
            <summary>
              Subtracts a scalar from the diagonal of a matrix.
            </summary>
            
            <param name="matrix">A matrix.</param>
            <param name="scalar">A scalar.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original matrix; false to return a new matrix.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.SubtractFromDiagonal(System.Double[0:,0:],System.Double,System.Boolean)">
            <summary>
              Subtracts a scalar from the diagonal of a matrix.
            </summary>
            
            <param name="matrix">A matrix.</param>
            <param name="scalar">A scalar.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original matrix; false to return a new matrix.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Double[0:,0:],System.Double[],System.Int32)">
            <summary>
              Adds a vector to a column or row of a matrix.
            </summary>
            
            <param name="a">A matrix.</param>
            <param name="b">A vector.</param>
            <param name="dimension">The dimension to add the vector to.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Double[][],System.Double[],System.Int32)">
            <summary>
              Adds a vector to a column or row of a matrix.
            </summary>
            
            <param name="a">A matrix.</param>
            <param name="b">A vector.</param>
            <param name="dimension">The dimension to add the vector to.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Add(System.Double[],System.Double[])">
            <summary>
              Adds two vectors.
            </summary>
            
            <param name="a">A vector.</param>
            <param name="b">A vector.</param>
            
            <returns>The addition of the given vectors.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Add(System.Double[],System.Double)">
            <summary>
              Adds two vectors.
            </summary>
            
            <param name="a">A vector.</param>
            <param name="b">A vector.</param>
            
            <returns>The addition of the given vectors.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Double[0:,0:],System.Double[0:,0:],System.Boolean)">
            <summary>
              Subtracts two matrices.
            </summary>
            
            <param name="a">A matrix.</param>
            <param name="b">A matrix.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original matrix; false to return a new matrix.</param>
            
            <returns>The subtraction of the given matrices.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Double[][],System.Double[][])">
            <summary>
              Subtracts two matrices.
            </summary>
            
            <param name="a">A matrix.</param>
            <param name="b">A matrix.</param>
            
            <returns>The subtraction of the given matrices.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Double[0:,0:],System.Double)">
            <summary>
              Subtracts a scalar from each element of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Double,System.Double[0:,0:])">
            <summary>
              Elementwise subtracts an element of a matrix from a scalar.
            </summary>
            
            <param name="x">A scalar.</param>
            <param name="matrix">A matrix.</param>
            
            <returns>The elementwise subtraction of scalar a and matrix b.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Int32,System.Double[0:,0:])">
            <summary>
              Elementwise subtracts an element of a matrix from a scalar.
            </summary>
            
            <param name="x">A scalar.</param>
            <param name="matrix">A matrix.</param>
            
            <returns>The elementwise subtraction of scalar a and matrix b.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Double[],System.Double[],System.Boolean)">
            <summary>
              Subtracts two vectors.
            </summary>
            
            <param name="a">A vector.</param>
            <param name="b">A vector.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original array; false to return a new array.</param>
            
            <returns>The subtraction of vector b from vector a.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Int32[],System.Int32[],System.Boolean)">
            <summary>
              Subtracts two vectors.
            </summary>
            
            <param name="a">A vector.</param>
            <param name="b">A vector.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original array; false to return a new array.</param>
            
            <returns>The subtraction of vector b from vector a.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Double[],System.Double,System.Boolean)">
            <summary>
              Subtracts a scalar from a vector.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="x">A scalar.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original array; false to return a new array.</param>
            
            <returns>The subtraction of given scalar from all elements in the given vector.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Int32[],System.Int32,System.Boolean)">
            <summary>
              Subtracts a scalar from a vector.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="x">A scalar.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original array; false to return a new array.</param>
            
            <returns>The subtraction of given scalar from all elements in the given vector.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Int32,System.Double[])">
            <summary>
              Subtracts a scalar from a vector.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="x">A scalar.</param>
            
            <returns>The subtraction of the given vector elements from the given scalar.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Double,System.Double[])">
            <summary>
              Subtracts a scalar from a vector.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="x">A scalar.</param>
            
            <returns>The subtraction of the given vector elements from the given scalar.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Normalize(System.Double[],System.Func{System.Double[],System.Double},System.Boolean)">
            <summary>
              Normalizes a vector to have unit length.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="norm">A norm to use. Default is <see cref="M:Accord.Math.Norm.Euclidean(System.Double[])"/>.</param>
            <param name="inPlace">True to perform the operation in-place,
              overwriting the original array; false to return a new array.</param>
            
            <returns>A multiple of vector <c>a</c> where <c>||a|| = 1</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Normalize(System.Single[],System.Func{System.Single[],System.Single},System.Boolean)">
            <summary>
              Normalizes a vector to have unit length.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="norm">A norm to use. Default is <see cref="M:Accord.Math.Norm.Euclidean(System.Single[])"/>.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original array; false to return a new array.</param>
            
            <returns>A multiple of vector <c>a</c> where <c>||a|| = 1</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Normalize(System.Double[],System.Boolean)">
            <summary>
              Normalizes a vector to have unit length.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original array; false to return a new array.</param>
            
            <returns>A multiple of vector <c>a</c> where <c>||a|| = 1</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Normalize(System.Single[],System.Boolean)">
            <summary>
              Normalizes a vector to have unit length.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original array; false to return a new array.</param>
            
            <returns>A multiple of vector <c>a</c> where <c>||a|| = 1</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Power(System.Double[0:,0:],System.Int32)">
            <summary>
              Multiplies a matrix by itself <c>n</c> times.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Remove``1(``0[0:,0:],System.Int32[],System.Int32[])">
            <summary>Returns a sub matrix extracted from the current matrix.</summary>
            <param name="data">The matrix to return the submatrix from.</param>
            <param name="rowIndexes">Array of row indices. Pass null to select all indices.</param>
            <param name="columnIndexes">Array of column indices. Pass null to select all indices.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.GetColumn``1(``0[0:,0:],System.Int32)">
            <summary>
              Gets a column vector from a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.GetColumn``1(``0[][],System.Int32)">
            <summary>
              Gets a column vector from a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.GetColumns``1(``0[][],System.Int32[])">
            <summary>
              Gets a column vector from a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.GetRow``1(``0[][],System.Int32)">
            <summary>
              Gets a row vector from a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.GetRows``1(``0[][],System.Int32[])">
            <summary>
              Gets a row vector from a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.GetColumns``1(``0[0:,0:],System.Int32[])">
            <summary>
              Gets a column vector from a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.SetColumn``1(``0[0:,0:],System.Int32,``0[])">
            <summary>
              Stores a column vector into the given column position of the matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.SetColumn``1(``0[][],System.Int32,``0[])">
            <summary>
              Stores a column vector into the given column position of the matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.GetRow``1(``0[0:,0:],System.Int32)">
            <summary>
              Gets a row vector from a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.SetRow``1(``0[0:,0:],System.Int32,``0[])">
            <summary>
              Stores a row vector into the given row position of the matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.SetRow``1(``0[][],System.Int32,``0[])">
            <summary>
              Stores a row vector into the given row position of the matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.RemoveColumn``1(``0[][],System.Int32)">
            <summary>
              Returns a new matrix without one of its columns.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.RemoveColumn``1(``0[0:,0:],System.Int32)">
            <summary>
              Returns a new matrix without one of its columns.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.InsertColumn``1(``0[0:,0:])">
            <summary>
              Returns a new matrix with a new column vector inserted at the end of the original matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.InsertColumn``1(``0[][])">
            <summary>
              Returns a new matrix with a new column vector inserted at the end of the original matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.InsertColumn``2(``0[0:,0:],``1[])">
            <summary>
              Returns a new matrix with a given column vector inserted at the end of the original matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.InsertColumn``2(``0[][],``1[])">
            <summary>
              Returns a new matrix with a given column vector inserted at the end of the original matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.InsertRow``2(``0[0:,0:],``1[])">
            <summary>
              Returns a new matrix with a given row vector inserted at the end of the original matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.InsertRow``2(``0[][],``1[])">
            <summary>
              Returns a new matrix with a given row vector inserted at the end of the original matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.InsertRow``1(``0[0:,0:])">
            <summary>
              Returns a new matrix with a new row vector inserted at the end of the original matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.InsertRow``1(``0[][])">
            <summary>
              Returns a new matrix with a new row vector inserted at the end of the original matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.InsertColumn``2(``0[0:,0:],``1[],System.Int32)">
            <summary>
              Returns a new matrix with a given column vector inserted at a given index.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.InsertColumn``2(``0[][],``1[],System.Int32)">
            <summary>
              Returns a new matrix with a given column vector inserted at a given index.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.InsertRow``2(``0[0:,0:],``1[],System.Int32)">
            <summary>
              Returns a new matrix with a given row vector inserted at a given index.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.InsertRow``2(``0[][],``1[],System.Int32)">
            <summary>
              Returns a new matrix with a given row vector inserted at a given index.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.RemoveRow``1(``0[0:,0:],System.Int32)">
            <summary>
              Returns a new matrix without one of its rows.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.RemoveAt``1(``0[],System.Int32)">
            <summary>
              Removes an element from a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Count``1(``0[],System.Func{``0,System.Boolean})">
            <summary>
              Gets the number of elements matching a certain criteria.
            </summary>
            
            <typeparam name="T">The type of the array.</typeparam>
            <param name="data">The array to search inside.</param>
            <param name="func">The search criteria.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.First``1(``0[],System.Func{``0,System.Boolean})">
            <summary>
              Gets the indices of the first element matching a certain criteria.
            </summary>
            
            <typeparam name="T">The type of the array.</typeparam>
            
            <param name="data">The array to search inside.</param>
            <param name="func">The search criteria.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.IndexOf``1(``0[],``0)">
            <summary>
              Searches for the specified value and returns the index of the first occurrence within the array.
            </summary>
            
            <typeparam name="T">The type of the array.</typeparam>
            
            <param name="data">The array to search.</param>
            <param name="value">The value to be searched.</param>
            
            <returns>The index of the searched value within the array, or -1 if not found.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Find``1(``0[],System.Func{``0,System.Boolean})">
             <summary>
               Gets the indices of all elements matching a certain criteria.
             </summary>
             
             <typeparam name="T">The type of the array.</typeparam>
             <param name="data">The array to search inside.</param>
             <param name="func">The search criteria.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Find``1(``0[],System.Func{``0,System.Boolean},System.Boolean)">
            <summary>
              Gets the indices of all elements matching a certain criteria.
            </summary>
            <typeparam name="T">The type of the array.</typeparam>
            <param name="data">The array to search inside.</param>
            <param name="func">The search criteria.</param>
            <param name="firstOnly">
               Set to true to stop when the first element is
               found, set to false to get all elements.
            </param>
        </member>
        <member name="M:Accord.Math.Matrix.Find``1(``0[0:,0:],System.Func{``0,System.Boolean})">
            <summary>
              Gets the indices of all elements matching a certain criteria.
            </summary>
            <typeparam name="T">The type of the array.</typeparam>
            <param name="data">The array to search inside.</param>
            <param name="func">The search criteria.</param>
        </member>
        <member name="M:Accord.Math.Matrix.Find``1(``0[0:,0:],System.Func{``0,System.Boolean},System.Boolean)">
            <summary>
              Gets the indices of all elements matching a certain criteria.
            </summary>
            <typeparam name="T">The type of the array.</typeparam>
            <param name="data">The array to search inside.</param>
            <param name="func">The search criteria.</param>
            <param name="firstOnly">
               Set to true to stop when the first element is
               found, set to false to get all elements.
            </param>
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(System.Nullable{``0}[],System.Int32@)">
            <summary>
              Gets the maximum non-null element in a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[],System.Int32@)">
            <summary>
              Gets the maximum element in a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[],System.Int32@,System.Boolean)">
            <summary>
              Gets the maximum element in a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[])">
            <summary>
              Gets the maximum element in a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[],System.Int32@)">
            <summary>
              Gets the minimum element in a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[])">
            <summary>
              Gets the minimum element in a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[],System.Int32,System.Int32@)">
            <summary>
              Gets the maximum element in a vector up to a fixed length.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[],System.Int32)">
            <summary>
              Gets the maximum element in a vector up to a fixed length.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[],System.Int32,System.Int32@)">
            <summary>
              Gets the minimum element in a vector up to a fixed length.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[],System.Int32)">
            <summary>
              Gets the minimum element in a vector up to a fixed length.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[0:,0:])">
            <summary>
              Gets the maximum value of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[0:,0:],System.Tuple{System.Int32,System.Int32}@)">
            <summary>
              Gets the maximum value of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[0:,0:])">
            <summary>
              Gets the minimum value of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[0:,0:],System.Tuple{System.Int32,System.Int32}@)">
            <summary>
              Gets the minimum value of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[][])">
            <summary>
              Gets the maximum value of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[][],System.Tuple{System.Int32,System.Int32}@)">
            <summary>
              Gets the maximum value of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[][])">
            <summary>
              Gets the minimum value of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[][],System.Tuple{System.Int32,System.Int32}@)">
            <summary>
              Gets the minimum value of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[0:,0:],System.Int32)">
            <summary>
              Gets the maximum values across one dimension of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[0:,0:],System.Int32,System.Int32[]@)">
            <summary>
              Gets the maximum values across one dimension of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[0:,0:],System.Int32)">
            <summary>
              Gets the minimum values across one dimension of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[0:,0:],System.Int32,System.Int32[]@)">
            <summary>
              Gets the minimum values across one dimension of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[][],System.Int32)">
            <summary>
              Gets the maximum values across one dimension of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[][],System.Int32,System.Int32[]@)">
            <summary>
              Gets the maximum values across one dimension of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[][],System.Int32)">
            <summary>
              Gets the minimum values across one dimension of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[][],System.Int32,System.Int32[]@)">
            <summary>
              Gets the minimum values across one dimension of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Range(System.Double[])">
            <summary>
              Gets the range of the values in a vector.
            </summary>
            
            <param name="values">The matrix whose ranges should be computed.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Range(System.Int32[])">
            <summary>
              Gets the range of the values in a vector.
            </summary>
            
            <param name="values">The matrix whose ranges should be computed.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Range(System.Int32[0:,0:])">
            <summary>
              Gets the range of the values across a matrix.
            </summary>
            
            <param name="value">The matrix whose ranges should be computed.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Range(System.Double[0:,0:])">
            <summary>
              Gets the range of the values across a matrix.
            </summary>
            
            <param name="value">The matrix whose ranges should be computed.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Range(System.Double[0:,0:],System.Int32)">
            <summary>
              Gets the range of the values across the columns of a matrix.
            </summary>
            
            <param name="value">The matrix whose ranges should be computed.</param>
            <param name="dimension">
              Pass 0 if the range should be computed for each of the columns. Pass 1
              if the range should be computed for each row. Default is 0.
            </param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Range(System.Double[][],System.Int32)">
            <summary>
              Gets the range of the values across the columns of a matrix.
            </summary>
            
            <param name="value">The matrix whose ranges should be computed.</param>
            <param name="dimension">
              Pass 0 if the range should be computed for each of the columns. Pass 1
              if the range should be computed for each row. Default is 0.
            </param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Swap``1(``0[],System.Int32[])">
            <summary>
              Performs an in-place re-ordering of elements in 
              a given array using the given vector of indices.
            </summary>
            
            <param name="values">The values to be ordered.</param>
            <param name="indices">The new index positions.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Distinct``1(``0[0:,0:])">
            <summary>
              Retrieves a list of the distinct values for each matrix column.
            </summary>
            
            <param name="values">The matrix.</param>
            
            <returns>An array containing arrays of distinct values for
            each column in the <paramref name="values"/>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Distinct``1(``0[][])">
            <summary>
              Retrieves a list of the distinct values for each matrix column.
            </summary>
            
            <param name="values">The matrix.</param>
            
            <returns>An array containing arrays of distinct values for
            each column in the <paramref name="values"/>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Distinct``1(``0[])">
            <summary>
              Retrieves only distinct values contained in an array.
            </summary>
            
            <param name="values">The array.</param>
            
            <returns>An array containing only the distinct values in <paramref name="values"/>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Distinct``1(``0[],System.Boolean)">
            <summary>
              Retrieves only distinct values contained in an array.
            </summary>
            
            <param name="values">The array.</param>
            <param name="allowNulls">Whether to allow null values in 
              the method's output. Default is true.</param>
            
            <returns>An array containing only the distinct values in <paramref name="values"/>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Distinct``2(``0[],System.Func{``0,``1})">
            <summary>
              Retrieves only distinct values contained in an array.
            </summary>
            
            <param name="values">The array.</param>
            <param name="property">The property of the object used to determine distinct instances.</param>
            
            <returns>An array containing only the distinct values in <paramref name="values"/>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Sort``2(``0[],``1[0:,0:],System.Collections.Generic.IComparer{``0})">
            <summary>
              Sorts the columns of a matrix by sorting keys.
            </summary>
            
            <param name="keys">The key value for each column.</param>
            <param name="values">The matrix to be sorted.</param>
            <param name="comparer">The comparer to use.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Sort``2(``0[],``1[][],System.Collections.Generic.IComparer{``0})">
            <summary>
              Sorts the columns of a matrix by sorting keys.
            </summary>
            
            <param name="keys">The key value for each column.</param>
            <param name="values">The matrix to be sorted.</param>
            <param name="comparer">The comparer to use.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Top``1(``0[],System.Int32,System.Boolean)">
            <summary>
              Retrieves the top <c>count</c> values of an array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Bottom``1(``0[],System.Int32,System.Boolean)">
            <summary>
              Retrieves the bottom <c>count</c> values of an array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsInteger(System.Double,System.Double)">
            <summary>
              Determines whether a number is an integer, given a tolerance threshold.
            </summary>
            
            <param name="x">The value to be compared.</param>
            <param name="threshold">The maximum that the number can deviate from its closest integer number.</param>
            
            <returns>True if the number if an integer, false otherwise.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsRelativelyEqual(System.Double,System.Double,System.Double)">
            <summary>
              Compares two values for equality, considering a relative acceptance threshold.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual(System.Double,System.Double,System.Double)">
            <summary>
              Compares two matrices for equality, considering an acceptance threshold.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual(System.Double[0:,0:],System.Double[0:,0:],System.Double)">
            <summary>
              Compares two matrices for equality, considering an acceptance threshold.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual(System.Single[0:,0:],System.Single[0:,0:],System.Double)">
            <summary>
              Compares two matrices for equality, considering an acceptance threshold.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual(System.Double[][],System.Double[][],System.Double)">
            <summary>
              Compares two matrices for equality, considering an acceptance threshold.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual(System.Single[][],System.Single[][],System.Double)">
            <summary>
              Compares two matrices for equality, considering an acceptance threshold.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual(System.Double[],System.Double[],System.Double)">
            <summary>
              Compares two vectors for equality, considering an acceptance threshold.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual(System.Single[],System.Single[],System.Double)">
            <summary>
              Compares two vectors for equality, considering an acceptance threshold.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual(System.Double[],System.Double)">
            <summary>
              Compares each member of a vector for equality with a scalar value x.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual(System.Double[0:,0:],System.Double)">
            <summary>
              Compares each member of a matrix for equality with a scalar value x.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual(System.Double[],System.Double,System.Double)">
            <summary>
              Compares each member of a vector for equality with a scalar value x.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual(System.Double[0:,0:],System.Double,System.Double)">
            <summary>
              Compares each member of a matrix for equality with a scalar value x.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual``1(``0[][],``0[][])">
            <summary>
              Compares two matrices for equality.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual``1(``0[0:,0:],``0[0:,0:])">
            <summary>Compares two matrices for equality.</summary>
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual``1(``0[],``0[])">
            <summary>Compares two vectors for equality.</summary>
        </member>
        <member name="M:Accord.Math.Matrix.Equals(System.Object)">
            <summary>
              This method should not be called. Use Matrix.IsEqual instead.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.SetEquals``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
              Compares two enumerables for set equality. Two
              enumerables are set equal if they contain the
              same elements, but not necessarily in the same
              order.
            </summary>
            
            <typeparam name="T">The element type.</typeparam>
            
            <param name="list1">The first set.</param>
            <param name="list2">The first set.</param>
            
            <returns>
              True if the two sets contains the same elements, false otherwise.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.HasNaN(System.Double[0:,0:])">
            <summary>
              Returns a value indicating whether the specified
              matrix contains a value that is not a number (NaN).
            </summary>
            
            <param name="matrix">A double-precision multidimensional matrix.</param>
            
            <returns>True if the matrix contains a value that is not a number, false otherwise.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.HasNaN(System.Double[])">
            <summary>
              Returns a value indicating whether the specified
              matrix contains a value that is not a number (NaN).
            </summary>
            
            <param name="matrix">A double-precision multidimensional matrix.</param>
            
            <returns>True if the matrix contains a value that is not a number, false otherwise.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.HasNaN(System.Double[][])">
            <summary>
              Returns a value indicating whether the specified
              matrix contains a value that is not a number (NaN).
            </summary>
            
            <param name="matrix">A double-precision multidimensional matrix.</param>
            
            <returns>True if the matrix contains a value that is not a number, false otherwise.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.HasInfinity(System.Double[0:,0:])">
            <summary>
              Returns a value indicating whether the specified
              matrix contains a infinity value.
            </summary>
            
            <param name="matrix">A double-precision multidimensional matrix.</param>
            
            <returns>True if the matrix contains infinity values, false otherwise.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Has(System.Double[0:,0:],System.Double,System.Double)">
            <summary>
              Returns a value indicating whether the specified
              matrix contains a value within a given tolerance.
            </summary>
            
            <param name="matrix">A double-precision multidimensional matrix.</param>
            <param name="value">The value to search for in the matrix.</param>
            <param name="tolerance">The relative tolerance that a value must be in
              order to be considered equal to the value being searched.</param>
            
            <returns>True if the matrix contains the value, false otherwise.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Has(System.Single[0:,0:],System.Single,System.Double)">
            <summary>
              Returns a value indicating whether the specified
              matrix contains a value within a given tolerance.
            </summary>
            
            <param name="matrix">A single-precision multidimensional matrix.</param>
            <param name="value">The value to search for in the matrix.</param>
            <param name="tolerance">The relative tolerance that a value must be in
              order to be considered equal to the value being searched.</param>
            
            <returns>True if the matrix contains the value, false otherwise.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.HasInfinity(System.Double[])">
            <summary>
              Returns a value indicating whether the specified
              matrix contains a infinity value.
            </summary>
            
            <param name="matrix">A double-precision multidimensional matrix.</param>
            
            <returns>True if the matrix contains a infinity value, false otherwise.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.HasInfinity(System.Double[][])">
            <summary>
              Returns a value indicating whether the specified
              matrix contains a infinity value.
            </summary>
            
            <param name="matrix">A double-precision multidimensional matrix.</param>
            
            <returns>True if the matrix contains a infinity value, false otherwise.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Transpose``1(``0[0:,0:])">
            <summary>
              Gets the transpose of a matrix.
            </summary>
            
            <param name="matrix">A matrix.</param>
            
            <returns>The transpose of the given matrix.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Transpose``1(``0[][])">
            <summary>
              Gets the transpose of a matrix.
            </summary>
            
            <param name="matrix">A matrix.</param>
            
            <returns>The transpose of the given matrix.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Transpose``1(``0[0:,0:],System.Boolean)">
            <summary>
              Gets the transpose of a matrix.
            </summary>
            
            <param name="matrix">A matrix.</param>
            
            <param name="inPlace">True to store the transpose over the same input
              <paramref name="matrix"/>, false otherwise. Default is false.</param>
              
            <returns>The transpose of the given matrix.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Transpose``1(``0[][],System.Boolean)">
            <summary>
              Gets the transpose of a matrix.
            </summary>
            
            <param name="matrix">A matrix.</param>
            
            <param name="inPlace">True to store the transpose over the same input
              <paramref name="matrix"/>, false otherwise. Default is false.</param>
              
            <returns>The transpose of the given matrix.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Transpose``1(``0[])">
            <summary>
              Gets the transpose of a row vector.
            </summary>
            
            <param name="rowVector">A row vector.</param>
            
            <returns>The transpose of the given vector.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Transpose(System.Array,System.Int32[])">
            <summary>
              Gets the generalized transpose of a tensor.
            </summary>
            
            <param name="array">A tensor.</param>
            <param name="order">The new order for the tensor's dimensions.</param>
            
            <returns>The transpose of the given tensor.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Transpose``1(``0,System.Int32[])">
            <summary>
              Gets the generalized transpose of a tensor.
            </summary>
            
            <param name="array">A tensor.</param>
            <param name="order">The new order for the tensor's dimensions.</param>
            
            <returns>The transpose of the given tensor.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Rows``1(``0[0:,0:])">
            <summary>
              Gets the number of rows in a multidimensional matrix.
            </summary>
            
            <typeparam name="T">The type of the elements in the matrix.</typeparam>
            <param name="matrix">The matrix whose number of rows must be computed.</param>
            
            <returns>The number of rows in the matrix.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Columns``1(``0[0:,0:])">
            <summary>
              Gets the number of columns in a multidimensional matrix.
            </summary>
            
            <typeparam name="T">The type of the elements in the matrix.</typeparam>
            <param name="matrix">The matrix whose number of columns must be computed.</param>
            
            <returns>The number of columns in the matrix.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Rows``1(``0[][])">
            <summary>
              Gets the number of rows in a jagged matrix.
            </summary>
            
            <typeparam name="T">The type of the elements in the matrix.</typeparam>
            <param name="matrix">The matrix whose number of rows must be computed.</param>
            
            <returns>The number of rows in the matrix.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Columns``1(``0[][])">
            <summary>
              Gets the number of columns in a jagged matrix.
            </summary>
            
            <typeparam name="T">The type of the elements in the matrix.</typeparam>
            <param name="matrix">The matrix whose number of columns must be computed.</param>
            
            <returns>The number of columns in the matrix.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsSorted``1(``0[],Accord.Math.Comparers.ComparerDirection)">
            <summary>
              Returns true if a vector of real-valued observations
              is ordered in ascending or descending order.
            </summary>
            
            <param name="values">An array of values.</param>
            <param name="direction">The sort order direction.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsSquare``1(``0[0:,0:])">
            <summary>
              Returns true if a matrix is square.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.IsSymmetric``1(``0[0:,0:])">
            <summary>
              Returns true if a matrix is symmetric.
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Accord.Math.Matrix.IsUpperTriangular``1(``0[][])">
            <summary>
              Returns true if a matrix is upper triangular.
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Accord.Math.Matrix.IsLowerTriangular``1(``0[][])">
            <summary>
              Returns true if a matrix is lower triangular.
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Accord.Math.Matrix.IsUpperTriangular``1(``0[0:,0:])">
            <summary>
              Returns true if a matrix is upper triangular.
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Accord.Math.Matrix.IsLowerTriangular``1(``0[0:,0:])">
            <summary>
              Returns true if a matrix is lower triangular.
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Accord.Math.Matrix.IsDiagonal``1(``0[0:,0:])">
            <summary>
              Returns true if a matrix is lower triangular.
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Accord.Math.Matrix.IsDiagonal``1(``0[][])">
            <summary>
              Returns true if a matrix is lower triangular.
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Accord.Math.Matrix.IsSymmetric``1(``0[][])">
            <summary>
              Returns true if a matrix is symmetric.
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Accord.Math.Matrix.Trace(System.Double[0:,0:])">
            <summary>
              Gets the trace of a matrix.
            </summary>
            
            <remarks>
              The trace of an n-by-n square matrix A is defined to be the sum of the
              elements on the main diagonal (the diagonal from the upper left to the
              lower right) of A.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.Trace(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Gets the trace of a matrix product.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Trace(System.Int32[0:,0:])">
            <summary>
              Gets the trace of a matrix.
            </summary>
            
            <remarks>
              The trace of an n-by-n square matrix A is defined to be the sum of the
              elements on the main diagonal (the diagonal from the upper left to the
              lower right) of A.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.Trace(System.Single[0:,0:])">
            <summary>
              Gets the trace of a matrix.
            </summary>
            
            <remarks>
              The trace of an n-by-n square matrix A is defined to be the sum of the
              elements on the main diagonal (the diagonal from the upper left to the
              lower right) of A.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.Trace(System.Single[][])">
            <summary>
              Gets the trace of a matrix.
            </summary>
            
            <remarks>
              The trace of an n-by-n square matrix A is defined to be the sum of the
              elements on the main diagonal (the diagonal from the upper left to the
              lower right) of A.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.Diagonal``1(``0[][])">
            <summary>
              Gets the diagonal vector from a matrix.
            </summary>
            
            <param name="matrix">A matrix.</param>
            
            <returns>The diagonal vector from the given matrix.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Diagonal``1(``0[0:,0:])">
            <summary>
              Gets the diagonal vector from a matrix.
            </summary>
            
            <param name="matrix">A matrix.</param>
            
            <returns>The diagonal vector from the given matrix.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Determinant(System.Double[0:,0:])">
            <summary>
              Gets the determinant of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Determinant(System.Double[0:,0:],System.Boolean)">
            <summary>
              Gets the determinant of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.LogDeterminant(System.Double[0:,0:])">
            <summary>
              Gets the log-determinant of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.LogDeterminant(System.Double[0:,0:],System.Boolean)">
            <summary>
              Gets the log-determinant of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.PseudoDeterminant(System.Double[0:,0:])">
            <summary>
              Gets the pseudo-determinant of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.LogPseudoDeterminant(System.Double[0:,0:])">
            <summary>
              Gets the log of the pseudo-determinant of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Rank(System.Double[0:,0:])">
            <summary>
              Gets the determinant of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Rank(System.Single[0:,0:])">
            <summary>
              Gets the determinant of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsSingular(System.Double[0:,0:])">
            <summary>
               Gets whether a matrix is singular.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsPositiveDefinite(System.Double[0:,0:])">
            <summary>
               Gets whether a matrix is positive definite.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsPositiveDefinite(System.Double[][])">
            <summary>
               Gets whether a matrix is positive definite.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Single[0:,0:])">
            <summary>Calculates the matrix Sum vector.</summary>
            
            <param name="matrix">A matrix whose sums will be calculated.</param>
            
            <returns>Returns a vector containing the sums of each variable in the given matrix.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Double[0:,0:])">
            <summary>Calculates the matrix Sum vector.</summary>
            <param name="matrix">A matrix whose sums will be calculated.</param>
            <returns>Returns a vector containing the sums of each variable in the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Double[0:,0:],System.Int32)">
            <summary>Calculates the matrix Sum vector.</summary>
            <param name="matrix">A matrix whose sums will be calculated.</param>
            <param name="dimension">The dimension in which the sum will be calculated.</param>
            <returns>Returns a vector containing the sums of each variable in the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Single[0:,0:],System.Int32)">
            <summary>Calculates the matrix Sum vector.</summary>
            <param name="matrix">A matrix whose sums will be calculated.</param>
            <param name="dimension">The dimension in which the sum will be calculated.</param>
            <returns>Returns a vector containing the sums of each variable in the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Double[][])">
            <summary>Calculates the matrix Sum vector.</summary>
            <param name="matrix">A matrix whose sums will be calculated.</param>
            <returns>Returns a vector containing the sums of each variable in the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Double[][],System.Int32)">
            <summary>Calculates the matrix Sum vector.</summary>
            <param name="matrix">A matrix whose sums will be calculated.</param>
            <param name="dimension">The dimension in which the sum will be calculated.</param>
            <returns>Returns a vector containing the sums of each variable in the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Int32[0:,0:])">
            <summary>Calculates the matrix Sum vector.</summary>
            <param name="matrix">A matrix whose sums will be calculated.</param>
            <returns>Returns a vector containing the sums of each variable in the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Int32[0:,0:],System.Int32)">
            <summary>Calculates the matrix Sum vector.</summary>
            <param name="matrix">A matrix whose sums will be calculated.</param>
            <param name="dimension">The dimension in which the sum will be calculated. Default is 0.</param>
            <returns>Returns a vector containing the sums of each variable in the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Double[])">
            <summary>
              Gets the sum of all elements in a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Single[])">
            <summary>
              Gets the sum of all elements in a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Int32[])">
            <summary>
              Gets the sum of all elements in a vector.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.CumulativeSum(System.Double[])">
            <summary>Calculates a vector cumulative sum.</summary>
        </member>
        <member name="M:Accord.Math.Matrix.CumulativeSum(System.Double[0:,0:],System.Int32)">
            <summary>Calculates the matrix Sum vector.</summary>
            <param name="matrix">A matrix whose sums will be calculated.</param>
            <param name="dimension">The dimension in which the cumulative sum will be calculated.</param>
            <returns>Returns a vector containing the sums of each variable in the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Product(System.Double[])">
            <summary>
              Gets the product of all elements in a vector.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Product(System.Int32[])">
            <summary>
              Gets the product of all elements in a vector.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ApplyInPlace``1(``0[],System.Func{``0,``0})">
            <summary>
              Applies a function to every element of the array.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ApplyInPlace``1(``0[],System.Func{``0,System.Int32,``0})">
            <summary>
              Applies a function to every element of the array.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ApplyInPlace``1(``0[0:,0:],System.Func{``0,``0})">
            <summary>
              Applies a function to every element of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ApplyInPlace``1(``0[0:,0:],System.Func{``0,System.Int32,System.Int32,``0})">
            <summary>
              Applies a function to every element of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Apply``2(``0[],System.Func{``0,``1})">
            <summary>
              Applies a function to every element of the array.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ApplyWithIndex``2(``0[],System.Func{``0,System.Int32,``1})">
            <summary>
              Applies a function to every element of the array.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Apply``2(``0[0:,0:],System.Func{``0,``1})">
            <summary>
              Applies a function to every element of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ApplyWithIndex``2(``0[0:,0:],System.Func{``0,System.Int32,System.Int32,``1})">
            <summary>
              Applies a function to every element of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Apply``2(System.Collections.Generic.IList{``0},System.Func{``0,``1})">
            <summary>
              Applies a function to every element of the array.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Round(System.Double[0:,0:],System.Int32)">
            <summary>
              Rounds a double-precision floating-point matrix to a specified number of fractional digits.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Floor(System.Double[0:,0:])">
            <summary>
              Returns the largest integer less than or equal than to the specified 
              double-precision floating-point number for each element of the matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Ceiling(System.Double[0:,0:])">
            <summary>
              Returns the largest integer greater than or equal than to the specified 
              double-precision floating-point number for each element of the matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Round(System.Double[],System.Int32)">
            <summary>
              Rounds a double-precision floating-point number array to a specified number of fractional digits.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Floor(System.Double[])">
            <summary>
              Returns the largest integer less than or equal than to the specified 
              double-precision floating-point number for each element of the array.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Ceiling(System.Double[])">
            <summary>
              Returns the largest integer greater than or equal than to the specified 
              double-precision floating-point number for each element of the array.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Reshape``1(``0[],System.Int32,System.Int32)">
            <summary>
              Transforms a vector into a matrix of given dimensions.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Reshape``1(``0[0:,0:])">
            <summary>
              Transforms a matrix into a single vector.
            </summary>
            
            <param name="matrix">A matrix.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Reshape``1(``0[0:,0:],System.Int32)">
            <summary>
              Transforms a matrix into a single vector.
            </summary>
            
            <param name="matrix">A matrix.</param>
            <param name="dimension">The direction to perform copying. Pass
            0 to perform a row-wise copy. Pass 1 to perform a column-wise
            copy. Default is 0.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Reshape``1(``0[][])">
            <summary>
              Transforms a jagged array matrix into a single vector.
            </summary>
            <param name="array">A jagged array.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Reshape``1(``0[][],System.Int32)">
            <summary>
              Transforms a jagged array matrix into a single vector.
            </summary>
            
            <param name="array">A jagged array.</param>
            <param name="dimension">The direction to perform copying. Pass
            0 to perform a row-wise copy. Pass 1 to perform a column-wise
            copy. Default is 0.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Convolve(System.Double[],System.Double[])">
            <summary>
              Convolves an array with the given kernel.
            </summary>
            
            <param name="a">A floating number array.</param>
            <param name="kernel">A convolution kernel.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Convolve(System.Double[],System.Double[],System.Boolean)">
            <summary>
            Convolves an array with the given kernel.
            </summary>
            
            <param name="a">A floating number array.</param>
            <param name="kernel">A convolution kernel.</param>
            <param name="trim">
              If <c>true</c> the resulting array will be trimmed to
              have the same length as the input array. Default is false.</param>
              
        </member>
        <member name="M:Accord.Math.Matrix.MemberwiseClone``1(``0[][])">
            <summary>
              Creates a memberwise copy of a jagged matrix. Matrix elements
              themselves are copied only in a shallowed manner (i.e. not cloned).
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.MemberwiseClone``1(``0[0:,0:])">
            <summary>
              Creates a memberwise copy of a multidimensional matrix. Matrix elements
              themselves are copied only in a shallowed manner (i.e. not cloned).
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.NamespaceDoc">
            <summary>
              Contains classes for constrained and unconstrained optimization. Includes 
              <see cref="T:Accord.Math.Optimization.ConjugateGradient">Conjugate Gradient (CG)</see>, <see cref="T:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShanno">
              Bounded</see> and <see cref="T:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno">Unbounded Broydenâ€“Fletcherâ€“Goldfarbâ€“Shanno (BFGS)</see>,
              gradient-free optimization methods such as <see cref="T:Accord.Math.Optimization.Cobyla"/> and the <see cref="T:Accord.Math.Optimization.GoldfarbIdnani">Goldfarb-Idnani
              </see> solver for Quadratic Programming (QP) problems.
            </summary>
            
            <remarks>
            <para>
              This namespace contains different methods for solving both constrained and unconstrained
              optimization problems. For unconstrained optimization, methods available include 
              <see cref="T:Accord.Math.Optimization.ConjugateGradient">Conjugate Gradient (CG)</see>, <see cref="T:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShanno">
              Bounded</see> and <see cref="T:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno">Unbounded Broydenâ€“Fletcherâ€“Goldfarbâ€“Shanno (BFGS)</see>,
              <see cref="T:Accord.Math.Optimization.ResilientBackpropagation">Resilient Backpropagation</see> and a simplified implementation of the 
              <see cref="T:Accord.Math.Optimization.TrustRegionNewtonMethod">Trust Region Newton Method (TRON)</see>.</para>
              
            <para>
              For constrained optimization problems, methods available include the <see cref="T:Accord.Math.Optimization.AugmentedLagrangian">
              Augmented Lagrangian method</see> for general non-linear optimization, <see cref="T:Accord.Math.Optimization.Cobyla"/> for
              gradient-free non-linear optimization, and the <see cref="T:Accord.Math.Optimization.GoldfarbIdnani">Goldfarb-Idnani</see>
              method for solving Quadratic Programming (QP) problems.</para>
              
            <para>
              This namespace also contains optimizers specialized for least squares problems, such as <see cref="T:Accord.Math.Optimization.GaussNewton">
              Gauss Newton</see> and the <see cref="T:Accord.Math.Optimization.LevenbergMarquardt">Levenberg-Marquart</see> least squares solvers.</para>
              
            <para>
              For univariate problems, standard search algorithms are also available, such as <see cref="T:Accord.Math.Optimization.BrentSearch">
              Brent</see> and <see cref="T:Accord.Math.Optimization.BinarySearch">Binary search</see>.</para>
             
            <para>
              The namespace class diagram is shown below. </para>
              <img src="..\diagrams\classes\Accord.Math.Optimization.png"/>
            </remarks>
            
            <seealso cref="N:Accord.Math"/>
            <seealso cref="N:Accord.Math.Differentiation"/>
            <seealso cref="N:Accord.Math.Integration"/>
              
        </member>
        <member name="T:Accord.Math.Optimization.BaseGradientOptimizationMethod">
            <summary>
              Base class for gradient-based optimization methods.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.BaseOptimizationMethod">
            <summary>
              Base class for optimization methods.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.BaseOptimizationMethod.#ctor(System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.BaseOptimizationMethod"/> class.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the optimization problem.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.BaseOptimizationMethod.#ctor(System.Int32,System.Func{System.Double[],System.Double})">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.BaseOptimizationMethod"/> class.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the optimization problem.</param>
            <param name="function">The objective function whose optimum values should be found.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.BaseOptimizationMethod.#ctor(Accord.Math.Optimization.NonlinearObjectiveFunction)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.BaseOptimizationMethod"/> class.
            </summary>
            
            <param name="function">The objective function whose optimum values should be found.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.BaseOptimizationMethod.Maximize(System.Double[])">
            <summary>
              Finds the maximum value of a function. The solution vector
              will be made available at the <see cref="P:Accord.Math.Optimization.BaseOptimizationMethod.Solution"/> property.
            </summary>
            
            <param name="values">The initial solution vector to start the search.</param>
            
            <returns>Returns <c>true</c> if the method converged to a <see cref="P:Accord.Math.Optimization.BaseOptimizationMethod.Solution"/>.
              In this case, the found value will also be available at the <see cref="P:Accord.Math.Optimization.BaseOptimizationMethod.Value"/>
              property.</returns>
             
        </member>
        <member name="M:Accord.Math.Optimization.BaseOptimizationMethod.Minimize(System.Double[])">
            <summary>
              Finds the minimum value of a function. The solution vector
              will be made available at the <see cref="P:Accord.Math.Optimization.BaseOptimizationMethod.Solution"/> property.
            </summary>
            
            <param name="values">The initial solution vector to start the search.</param>
            
            <returns>Returns <c>true</c> if the method converged to a <see cref="P:Accord.Math.Optimization.BaseOptimizationMethod.Solution"/>.
              In this case, the found value will also be available at the <see cref="P:Accord.Math.Optimization.BaseOptimizationMethod.Value"/>
              property.</returns>
             
        </member>
        <member name="M:Accord.Math.Optimization.BaseOptimizationMethod.Maximize">
            <summary>
              Finds the maximum value of a function. The solution vector
              will be made available at the <see cref="P:Accord.Math.Optimization.BaseOptimizationMethod.Solution"/> property.
            </summary>
            
            <returns>Returns <c>true</c> if the method converged to a <see cref="P:Accord.Math.Optimization.BaseOptimizationMethod.Solution"/>.
              In this case, the found value will also be available at the <see cref="P:Accord.Math.Optimization.BaseOptimizationMethod.Value"/>
              property.</returns>
             
        </member>
        <member name="M:Accord.Math.Optimization.BaseOptimizationMethod.Minimize">
            <summary>
              Finds the minimum value of a function. The solution vector
              will be made available at the <see cref="P:Accord.Math.Optimization.BaseOptimizationMethod.Solution"/> property.
            </summary>
            
            <returns>Returns <c>true</c> if the method converged to a <see cref="P:Accord.Math.Optimization.BaseOptimizationMethod.Solution"/>.
              In this case, the found value will also be available at the <see cref="P:Accord.Math.Optimization.BaseOptimizationMethod.Value"/>
              property.</returns>
             
        </member>
        <member name="M:Accord.Math.Optimization.BaseOptimizationMethod.Optimize">
            <summary>
              Implements the actual optimization algorithm. This
              method should try to minimize the objective function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.BaseOptimizationMethod.ArgumentException(System.String,System.String,System.String)">
            <summary>
              Creates an exception with a given inner optimization algorithm code (for debugging purposes).
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.BaseOptimizationMethod.OperationException(System.String,System.String)">
            <summary>
              Creates an exception with a given inner optimization algorithm code (for debugging purposes).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BaseOptimizationMethod.Function">
            <summary>
              Gets or sets the function to be optimized.
            </summary>
            
            <value>The function to be optimized.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.BaseOptimizationMethod.NumberOfVariables">
            <summary>
              Gets the number of variables (free parameters)
              in the optimization problem.
            </summary>
            
            <value>The number of parameters.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.BaseOptimizationMethod.Solution">
            <summary>
              Gets the current solution found, the values of 
              the parameters which optimizes the function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BaseOptimizationMethod.Value">
            <summary>
              Gets the output of the function at the current <see cref="P:Accord.Math.Optimization.BaseOptimizationMethod.Solution"/>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.BaseGradientOptimizationMethod.#ctor(System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.BaseGradientOptimizationMethod"/> class.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the optimization problem.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.BaseGradientOptimizationMethod.#ctor(System.Int32,System.Func{System.Double[],System.Double},System.Func{System.Double[],System.Double[]})">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.BaseGradientOptimizationMethod"/> class.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the optimization problem.</param>
            <param name="function">The objective function whose optimum values should be found.</param>
            <param name="gradient">The gradient of the objective <paramref name="function"/>.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.BaseGradientOptimizationMethod.Maximize">
            <summary>
              Finds the maximum value of a function. The solution vector
              will be made available at the <see cref="P:Accord.Math.Optimization.IOptimizationMethod.Solution"/> property.
            </summary>
            
            <returns>Returns <c>true</c> if the method converged to a <see cref="P:Accord.Math.Optimization.IOptimizationMethod.Solution"/>.
              In this case, the found value will also be available at the <see cref="P:Accord.Math.Optimization.IOptimizationMethod.Value"/>
              property.</returns>
             
        </member>
        <member name="M:Accord.Math.Optimization.BaseGradientOptimizationMethod.Minimize">
            <summary>
              Finds the minimum value of a function. The solution vector
              will be made available at the <see cref="P:Accord.Math.Optimization.IOptimizationMethod.Solution"/> property.
            </summary>
            
            <returns>Returns <c>true</c> if the method converged to a <see cref="P:Accord.Math.Optimization.IOptimizationMethod.Solution"/>.
              In this case, the found value will also be available at the <see cref="P:Accord.Math.Optimization.IOptimizationMethod.Value"/>
              property.</returns>
             
        </member>
        <member name="P:Accord.Math.Optimization.BaseGradientOptimizationMethod.Gradient">
            <summary>
              Gets or sets a function returning the gradient
              vector of the function to be optimized for a
              given value of its free parameters.
            </summary>
            
            <value>The gradient function.</value>
            
        </member>
        <member name="T:Accord.Math.Optimization.IGradientOptimizationMethod">
            <summary>
              Common interface for function optimization methods which depend on
              having both an objective function and a gradient function definition
              available.
            </summary>
            
            <seealso cref="T:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno"/>
            <seealso cref="T:Accord.Math.Optimization.ConjugateGradient"/>
            <seealso cref="T:Accord.Math.Optimization.ResilientBackpropagation"/>
            
        </member>
        <member name="P:Accord.Math.Optimization.IGradientOptimizationMethod.Function">
            <summary>
              Gets or sets the function to be optimized.
            </summary>
            
            <value>The function to be optimized.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.IGradientOptimizationMethod.Gradient">
            <summary>
              Gets or sets a function returning the gradient
              vector of the function to be optimized for a
              given value of its free parameters.
            </summary>
            
            <value>The gradient function.</value>
            
        </member>
        <member name="T:Accord.Math.Optimization.LeastSquaresFunction">
            <summary>
              Least Squares function delegate.
            </summary>
            
            <remarks>
              This delegate represents a parameterized function that, given a set of
              <paramref name="parameters"/> and an <paramref name="input"/> vector,
              produces an associated output value.
            </remarks>
            
            <param name="parameters">The function parameters, also known as weights or coefficients.</param>
            <param name="input">An input vector.</param>
            
            <returns>The output value produced given the <paramref name="input"/> vector
              using the given <paramref name="parameters"/>.</returns>
            
        </member>
        <member name="T:Accord.Math.Optimization.LeastSquaresGradientFunction">
            <summary>
              Gradient function delegate.
            </summary>
            
            <remarks>
              This delegate represents the gradient of a <see cref="T:Accord.Math.Optimization.LeastSquaresFunction">Least
              Squares objective function</see>. This function should compute the gradient vector
              in respect to the function <paramref name="parameters"/>.
            </remarks>
            
            <param name="parameters">The function parameters, also known as weights or coefficients.</param>
            <param name="input">An input vector.</param>
            <param name="result">The resulting gradient vector (w.r.t to the parameters).</param>
            
        </member>
        <member name="T:Accord.Math.Optimization.ILeastSquaresMethod">
            <summary>
              Common interface for Least Squares algorithms, i.e. algorithms
              that can be used to solve Least Squares optimization problems.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.ILeastSquaresMethod.Minimize(System.Double[][],System.Double[])">
            <summary>
              Attempts to find the best values for the parameter vector
              minimizing the discrepancy between the generated outputs
              and the expected outputs for a given set of input data.
            </summary>
            
            <param name="inputs">A set of input data.</param>
            <param name="outputs">The values associated with each 
              vector in the <paramref name="inputs"/> data.</param>
            
        </member>
        <member name="P:Accord.Math.Optimization.ILeastSquaresMethod.Function">
            <summary>
              Gets or sets a parameterized model function mapping input vectors
              into output values, whose optimum parameters must be found.
            </summary>
            
            <value>The function to be optimized.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.ILeastSquaresMethod.Gradient">
            <summary>
              Gets or sets a function that computes the gradient vector in respect
              to the function parameters, given a set of input and output values.
            </summary>
            
            <value>The gradient function.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.ILeastSquaresMethod.NumberOfVariables">
            <summary>
              Gets the number of variables (free parameters) in the optimization problem.
            </summary>
            
            <value>The number of parameters.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.ILeastSquaresMethod.Solution">
            <summary>
              Gets the solution found, the values of the parameters which
              optimizes the function, in a least squares sense.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ILeastSquaresMethod.StandardErrors">
            <summary>
              Gets standard error for each parameter in the solution.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.BinarySearch">
            <summary>
              Binary search root finding algorithm.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.BinarySearch.#ctor(System.Func{System.Int32,System.Double},System.Int32,System.Int32)">
            <summary>
              Constructs a new Binary search algorithm.
            </summary>
            
            <param name="function">The function to be searched.</param>
            <param name="a">Start of search region.</param>
            <param name="b">End of search region.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.BinarySearch.Find(System.Double)">
            <summary>
              Attempts to find a root in the interval [a;b] 
            </summary>
            
            <returns>The location of the zero value in the given interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.BinarySearch.FindRoot">
            <summary>
              Attempts to find a root in the interval [a;b] 
            </summary>
            
            <returns>The location of the zero value in the given interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.BinarySearch.Find(System.Func{System.Int32,System.Double},System.Int32,System.Int32,System.Double)">
            <summary>
              Finds a value of a function in the interval [a;b]
            </summary>
            
            <param name="function">The function to have its root computed.</param>
            <param name="lowerBound">Start of search region.</param>
            <param name="upperBound">End of search region.</param>
            <param name="value">The value to be looked for in the function.</param>
            
            <returns>The location of the zero value in the given interval.</returns>
            
        </member>
        <member name="P:Accord.Math.Optimization.BinarySearch.LowerBound">
            <summary>
              Gets or sets the lower bound for the search interval <c>a</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BinarySearch.UpperBound">
            <summary>
              Gets or sets the lower bound for the search interval <c>a</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BinarySearch.Solution">
            <summary>
              Gets the solution found in the last call
              to or <see cref="M:Accord.Math.Optimization.BinarySearch.FindRoot"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BinarySearch.Value">
            <summary>
              Gets the value at the solution found in the last call
              to <see cref="M:Accord.Math.Optimization.BinarySearch.FindRoot"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BinarySearch.Function">
            <summary>
              Gets the function to be searched.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.CobylaStatus">
            <summary>
              Cobyla exit codes.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.CobylaStatus.Success">
            <summary>
              Optimization successfully completed.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.CobylaStatus.MaxIterationsReached">
            <summary>
              Maximum number of iterations (function/constraints evaluations) reached during optimization.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.CobylaStatus.DivergingRoundingErrors">
            <summary>
              Size of rounding error is becoming damaging, terminating prematurely.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.CobylaStatus.NoPossibleSolution">
            <summary>
              The posed constraints cannot be fulfilled.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.Cobyla">
             <summary>
               Constrained optimization by linear approximation.
             </summary>
             
             <remarks>
             <para>
               Constrained optimization by linear approximation (COBYLA) is a numerical 
               optimization method for constrained problems where the derivative of the
               objective function is not known, invented by Michael J. D. Powell. </para>
            
             <para>
               COBYLA2 is an implementation of Powellâ€™s nonlinear derivativeâ€“free constrained
               optimization that uses a linear approximation approach. The algorithm is a 
               sequential trustâ€“region algorithm that employs linear approximations to the
               objective and constraint functions, where the approximations are formed by linear 
               interpolation at n + 1 points in the space of the variables and tries to maintain
               a regularâ€“shaped simplex over iterations.</para>
            
             <para>
               This algorithm is able to solve non-smooth NLP problems with a moderate number
               of variables (about 100), with inequality constraints only.</para>
               
             <para>    
               References:
               <list type="bullet">
                 <item><description><a href="http://en.wikipedia.org/wiki/COBYLA">
                   Wikipedia, The Free Encyclopedia. Cobyla. Available on:
                   http://en.wikipedia.org/wiki/COBYLA </a></description></item>
               </list></para>
             </remarks>
             
             <example>
             <para>
               Let's say we would like to optimize a function whose gradient
               we do not know or would is too difficult to compute. All we 
               have to do is to specify the function, pass it to Cobyla and
               call its Minimize() method:
             </para>
             
             <code>
             // We would like to find the minimum of min f(x) = 10 * (x+1)^2 + y^2
             Func&lt;double[], double> function = x => 10 * Math.Pow(x[0] + 1, 2) + Math.Pow(x[1], 2);
               
             // Create a cobyla method for 2 variables
             Cobyla cobyla = new Cobyla(2, function);
             
             bool success = cobyla.Minimize();
             
             double minimum = minimum = cobyla.Value; // Minimum should be 0.
             double[] solution = cobyla.Solution;     // Vector should be (-1, 0)
             </code>
             
             <para>
             Cobyla can be used even when we have constraints in our optimization problem.
             The following example can be found in Fletcher's book Practical Methods of
             Optimization, under the equation number (9.1.15).
             </para>
             
             <code>
             // We will optimize the 2-variable function f(x, y) = -x -y
             var f = new NonlinearObjectiveFunction(2, x => -x[0] - x[1]);
             
             // Under the following constraints
             var constraints = new[]
             {
                 new NonlinearConstraint(2, x =>             x[1] - x[0] * x[0] >= 0),
                 new NonlinearConstraint(2, x =>  1 - x[0] * x[0] - x[1] * x[1] >= 0),
             };
            
             // Create a Cobyla algorithm for the problem
             var cobyla = new Cobyla(function, constraints);
            
             // Optimize it
             bool success = cobyla.Minimize();
             double minimum = cobyla.Value;        // Minimum should be -2 * sqrt(0.5)
             double[] solution = cobyla.Solution;  // Vector should be [sqrt(0.5), sqrt(0.5)]
             </code>
             </example>
            
        </member>
        <member name="T:Accord.Math.Optimization.IOptimizationMethod`1">
            <summary>
              Common interface for function optimization methods.
            </summary>
            
            <seealso cref="T:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShanno"/>
            <seealso cref="T:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno"/>
            <seealso cref="T:Accord.Math.Optimization.ConjugateGradient"/>
            <seealso cref="T:Accord.Math.Optimization.ResilientBackpropagation"/>
            <seealso cref="T:Accord.Math.Optimization.GoldfarbIdnani"/>
            
        </member>
        <member name="P:Accord.Math.Optimization.IOptimizationMethod`1.Status">
            <summary>
              Get the exit code returned in the last call to the
              <see cref="M:Accord.Math.Optimization.IOptimizationMethod.Maximize"/> or 
              <see cref="M:Accord.Math.Optimization.IOptimizationMethod.Minimize"/> methods.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.Cobyla.#ctor(System.Int32)">
            <summary>
              Creates a new instance of the Cobyla optimization algorithm.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the function to be optimized.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.Cobyla.#ctor(System.Int32,System.Func{System.Double[],System.Double})">
            <summary>
              Creates a new instance of the Cobyla optimization algorithm.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the function to be optimized.</param>
            <param name="function">The function to be optimized.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.Cobyla.#ctor(Accord.Math.Optimization.NonlinearObjectiveFunction)">
            <summary>
              Creates a new instance of the Cobyla optimization algorithm.
            </summary>
            
            <param name="function">The function to be optimized.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.Cobyla.#ctor(Accord.Math.Optimization.NonlinearObjectiveFunction,System.Collections.Generic.IEnumerable{Accord.Math.Optimization.NonlinearConstraint})">
            <summary>
              Creates a new instance of the Cobyla optimization algorithm.
            </summary>
            
            <param name="function">The function to be optimized.</param>
            <param name="constraints">The constraints of the optimization problem.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.Cobyla.#ctor(Accord.Math.Optimization.NonlinearObjectiveFunction,Accord.Math.Optimization.NonlinearConstraint[])">
            <summary>
              Creates a new instance of the Cobyla optimization algorithm.
            </summary>
            
            <param name="function">The function to be optimized.</param>
            <param name="constraints">The constraints of the optimization problem.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.Cobyla.Optimize">
            <summary>
              Implements the actual optimization algorithm. This
              method should try to minimize the objective function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.Cobyla.Iterations">
            <summary>
              Gets the number of iterations performed in the last
              call to <see cref="M:Accord.Math.Optimization.IOptimizationMethod.Minimize"/>.
            </summary>
            
            <value>
              The number of iterations performed
              in the previous optimization.</value>
              
        </member>
        <member name="P:Accord.Math.Optimization.Cobyla.MaxIterations">
            <summary>
              Gets or sets the maximum number of iterations
              to be performed during optimization. Default
              is 0 (iterate until convergence).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.Cobyla.Status">
            <summary>
              Get the exit code returned in the last call to the
              <see cref="M:Accord.Math.Optimization.IOptimizationMethod.Maximize"/> or 
              <see cref="M:Accord.Math.Optimization.IOptimizationMethod.Minimize"/> methods.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.IConstraint.GetViolation(System.Double[])">
            <summary>
              Gets how much the constraint is being violated.
            </summary>
            
            <param name="input">The function point.</param>
            
            <returns>
              How much the constraint is being violated at the given point. Positive
              value means the constraint is not being violated with the returned slack, 
              while a negative value means the constraint is being violated by the returned
              amount.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Optimization.IConstraint.ShouldBe">
            <summary>
              Gets the type of the constraint.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.IConstraint.Value">
            <summary>
              Gets the value in the right hand
              side of the constraint equation.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.IConstraint.NumberOfVariables">
            <summary>
              Gets the number of variables in the constraint.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.IConstraint.Function">
            <summary>
              Gets the left hand side of 
              the constraint equation.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.IConstraint.Gradient">
            <summary>
              Gets the gradient of the left hand
              side of the constraint equation.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.LinearConstraintCollection">
            <summary>
              Linear Constraint Collection.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.LinearConstraintCollection.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.LinearConstraintCollection"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.LinearConstraintCollection.#ctor(System.Collections.Generic.IEnumerable{Accord.Math.Optimization.LinearConstraint})">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.LinearConstraintCollection"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.LinearConstraintCollection.#ctor(System.Collections.Generic.IList{Accord.Math.Optimization.LinearConstraint})">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.LinearConstraintCollection"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.LinearConstraintCollection.CreateMatrix(System.Int32,System.Double[]@,System.Int32@)">
            <summary>
              Creates a matrix of linear constraints in canonical form.
            </summary>
            
            <param name="numberOfVariables">The number of variables in the objective function.</param>
            <param name="b">The vector of independent terms (the right hand side of the constraints).</param>
            <param name="equalities">The number of equalities in the matrix.</param>
            <returns>The matrix <c>A</c> of linear constraints.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.LinearConstraintCollection.CreateMatrix(System.Int32,System.Double[]@,System.Double[]@,System.Int32@)">
            <summary>
              Creates a matrix of linear constraints in canonical form.
            </summary>
            
            <param name="numberOfVariables">The number of variables in the objective function.</param>
            <param name="b">The vector of independent terms (the right hand side of the constraints).</param>
            <param name="tolerances">The amount each constraint can be violated before the answer is declared close enough.</param>
            <param name="equalities">The number of equalities in the matrix.</param>
            <returns>The matrix <c>A</c> of linear constraints.</returns>
            
        </member>
        <member name="T:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShanno">
            <summary>
              Limited-memory Broydenâ€“Fletcherâ€“Goldfarbâ€“Shanno (L-BFGS) optimization method.
            </summary>
            
            <remarks>
            <para>
              The L-BFGS algorithm is a member of the broad family of quasi-Newton optimization
              methods. L-BFGS stands for 'Limited memory BFGS'. Indeed, L-BFGS uses a limited
              memory variation of the Broydenâ€“Fletcherâ€“Goldfarbâ€“Shanno (BFGS) update to approximate
              the inverse Hessian matrix (denoted by Hk). Unlike the original BFGS method which
              stores a dense  approximation, L-BFGS stores only a few vectors that represent the
              approximation implicitly. Due to its moderate memory requirement, L-BFGS method is
              particularly well suited for optimization problems with a large number of variables.</para>
            <para>
              L-BFGS never explicitly forms or stores Hk. Instead, it maintains a history of the past
              <c>m</c> updates of the position <c>x</c> and gradient <c>g</c>, where generally the history
              <c>m</c>can be short, often less than 10. These updates are used to implicitly do operations
              requiring the Hk-vector product.</para>
              
            <para>
              The framework implementation of this method is based on the original FORTRAN source code
              by Jorge Nocedal (see references below). The original FORTRAN source code of L-BFGS (for
              unconstrained problems) is available at http://www.netlib.org/opt/lbfgs_um.shar and had
              been made available under the public domain. </para>
            
            <para>
              References:
              <list type="bullet">
                <item><description><a href="http://www.netlib.org/opt/lbfgs_um.shar">
                   Jorge Nocedal. Limited memory BFGS method for large scale optimization (Fortran source code). 1990.
                   Available in http://www.netlib.org/opt/lbfgs_um.shar </a></description></item>
                <item><description>
                   Jorge Nocedal. Updating Quasi-Newton Matrices with Limited Storage. <i>Mathematics of Computation</i>,
                   Vol. 35, No. 151, pp. 773--782, 1980.</description></item>
                <item><description>
                   Dong C. Liu, Jorge Nocedal. On the limited memory BFGS method for large scale optimization.</description></item>
               </list></para>
            </remarks>
            
            <example>
            <para>
              The following example shows the basic usage of the L-BFGS solver
              to find the minimum of a function specifying its function and
              gradient. </para>
              
            <code>
            // Suppose we would like to find the minimum of the function
            // 
            //   f(x,y)  =  -exp{-(x-1)Â²} - exp{-(y-2)Â²/2}
            //
            
            // First we need write down the function either as a named
            // method, an anonymous method or as a lambda function:
            
            Func&lt;double[], double&gt; f = (x) =&gt;
                -Math.Exp(-Math.Pow(x[0] - 1, 2)) - Math.Exp(-0.5 * Math.Pow(x[1] - 2, 2));
            
            // Now, we need to write its gradient, which is just the
            // vector of first partial derivatives del_f / del_x, as:
            //
            //   g(x,y)  =  { del f / del x, del f / del y }
            // 
            
            Func&lt;double[], double[]&gt; g = (x) =&gt; new double[] 
            {
                // df/dx = {-2 e^(-    (x-1)^2) (x-1)}
                2 * Math.Exp(-Math.Pow(x[0] - 1, 2)) * (x[0] - 1),
            
                // df/dy = {-  e^(-1/2 (y-2)^2) (y-2)}
                Math.Exp(-0.5 * Math.Pow(x[1] - 2, 2)) * (x[1] - 2)
            };
            
            // Finally, we can create the L-BFGS solver, passing the functions as arguments
            var lbfgs = new BroydenFletcherGoldfarbShanno(numberOfVariables: 2, function: f, gradient: g);
            
            // And then minimize the function:
            bool success = lbfgs.Minimize();
            double minValue = lbfgs.Value;
            double[] solution = lbfgs.Solution;
            
            // The resultant minimum value should be -2, and the solution
            // vector should be { 1.0, 2.0 }. The answer can be checked on
            // Wolfram Alpha by clicking the following the link:
            
            // http://www.wolframalpha.com/input/?i=maximize+%28exp%28-%28x-1%29%C2%B2%29+%2B+exp%28-%28y-2%29%C2%B2%2F2%29%29
            
            </code>
            </example>
            
            <seealso cref="T:Accord.Math.Optimization.ConjugateGradient"/>
            <seealso cref="T:Accord.Math.Optimization.ResilientBackpropagation"/>
            <seealso cref="T:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno"/>
            <seealso cref="T:Accord.Math.Optimization.TrustRegionNewtonMethod"/>
            
        </member>
        <member name="M:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShanno.#ctor(System.Int32)">
            <summary>
              Creates a new instance of the L-BFGS optimization algorithm.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the optimization problem.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShanno.#ctor(System.Int32,System.Func{System.Double[],System.Double},System.Func{System.Double[],System.Double[]})">
            <summary>
              Creates a new instance of the L-BFGS optimization algorithm.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the function to be optimized.</param>
            <param name="function">The function to be optimized.</param>
            <param name="gradient">The gradient of the function.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShanno.Optimize">
            <summary>
              Implements the actual optimization algorithm. This
              method should try to minimize the objective function.
            </summary>
        </member>
        <member name="E:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShanno.Progress">
            <summary>
              Occurs when progress is made during the optimization.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShanno.Iterations">
            <summary>
              Gets the number of iterations performed in the last
              call to <see cref="M:Accord.Math.Optimization.IOptimizationMethod.Minimize"/>
              or <see cref="M:Accord.Math.Optimization.IOptimizationMethod.Maximize"/>.
            </summary>
            
            <value>
              The number of iterations performed
              in the previous optimization.</value>
              
        </member>
        <member name="P:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShanno.MaxIterations">
            <summary>
              Gets or sets the maximum number of iterations
              to be performed during optimization. Default
              is 0 (iterate until convergence).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShanno.Evaluations">
            <summary>
              Gets the number of function evaluations performed
              in the last call to <see cref="M:Accord.Math.Optimization.IOptimizationMethod.Minimize"/>
              or <see cref="M:Accord.Math.Optimization.IOptimizationMethod.Maximize"/>.
            </summary>
            
            <value>
              The number of evaluations performed
              in the previous optimization.</value>
              
        </member>
        <member name="P:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShanno.Corrections">
            <summary>
              Gets or sets the number of corrections used in the L-BFGS
              update. Recommended values are between 3 and 7. Default is 5.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShanno.UpperBounds">
            <summary>
              Gets or sets the upper bounds of the interval
              in which the solution must be found.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShanno.LowerBounds">
            <summary>
              Gets or sets the lower bounds of the interval
              in which the solution must be found.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShanno.FunctionTolerance">
            <summary>
              Gets or sets the accuracy with which the solution
              is to be found. Default value is 1e5. Smaller values
              up until zero result in higher accuracy. 
            </summary>
            
            <remarks>
            <para>
              The iteration will stop when</para>
            <code>
                     (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} &lt;= factr*epsmch </code>
            <para>
              where epsmch is the machine precision, which is automatically
              generated by the code. Typical values for this parameter are:
              1e12 for low accuracy; 1e7 for moderate accuracy; 1e1 for extremely
              high accuracy.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShanno.GradientTolerance">
            <summary>
              Gets or sets a tolerance value when detecting convergence 
              of the gradient vector steps. Default is 0.
            </summary>
            
            <remarks>
              On entry pgtol >= 0 is specified by the user.  The iteration
              will stop when
            <code>
              max{|proj g_i | i = 1, ..., n} &lt;= pgtol
            </code>
            <para>
              where pg_i is the ith component of the projected gradient. </para>
            </remarks>
            
        </member>
        <member name="P:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShanno.Status">
            <summary>
              Get the exit code returned in the last call to the
              <see cref="M:Accord.Math.Optimization.IOptimizationMethod.Maximize"/> or 
              <see cref="M:Accord.Math.Optimization.IOptimizationMethod.Minimize"/> methods.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.LBFGS.CUBIC_MINIMIZER(System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@)">
            Find a minimizer of an interpolated cubic function.
             @param  cm      The minimizer of the interpolated cubic.
             @param  u       The value of one point, u.
             @param  fu      The value of f(u).
             @param  du      The value of f'(u).
             @param  v       The value of another point, v.
             @param  fv      The value of f(v).
             @param  du      The value of f'(v).
        </member>
        <member name="M:Accord.Math.Optimization.LBFGS.CUBIC_MINIMIZER2(System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@)">
            Find a minimizer of an interpolated cubic function.
             @param  cm      The minimizer of the interpolated cubic.
             @param  u       The value of one point, u.
             @param  fu      The value of f(u).
             @param  du      The value of f'(u).
             @param  v       The value of another point, v.
             @param  fv      The value of f(v).
             @param  du      The value of f'(v).
             @param  xmin    The maximum value.
             @param  xmin    The minimum value.
        </member>
        <member name="M:Accord.Math.Optimization.LBFGS.QUARD_MINIMIZER(System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@)">
            Find a minimizer of an interpolated quadratic function.
             @param  qm      The minimizer of the interpolated quadratic.
             @param  u       The value of one point, u.
             @param  fu      The value of f(u).
             @param  du      The value of f'(u).
             @param  v       The value of another point, v.
             @param  fv      The value of f(v).
        </member>
        <member name="M:Accord.Math.Optimization.LBFGS.QUARD_MINIMIZER2(System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@)">
            Find a minimizer of an interpolated quadratic function.
             @param  qm      The minimizer of the interpolated quadratic.
             @param  u       The value of one point, u.
             @param  du      The value of f'(u).
             @param  v       The value of another point, v.
             @param  dv      The value of f'(v).
        </member>
        <member name="M:Accord.Math.Optimization.LBFGS.update_trial_interval(System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double,System.Double,System.Int32@)">
             Update a safeguarded trial value and interval for line search.
            
              The parameter x represents the step with the least function value.
              The parameter t represents the current step. This function assumes
              that the derivative at the point of x in the direction of the step.
              If the bracket is set to true, the minimizer has been bracketed in
              an interval of uncertainty with endpoints between x and y.
            
              @param  x       The pointer to the value of one endpoint.
              @param  fx      The pointer to the value of f(x).
              @param  dx      The pointer to the value of f'(x).
              @param  y       The pointer to the value of another endpoint.
              @param  fy      The pointer to the value of f(y).
              @param  dy      The pointer to the value of f'(y).
              @param  t       The pointer to the value of the trial value, t.
              @param  ft      The pointer to the value of f(t).
              @param  dt      The pointer to the value of f'(t).
              @param  tmin    The minimum value for the trial value, t.
              @param  tmax    The maximum value for the trial value, t.
              @param  brackt  The pointer to the predicate if the trial value is
                              bracketed.
              @retval int     Status value. Zero indicates a normal termination.
              
              @see
                  Jorge J. More and David J. Thuente. Line search algorithm with
                  guaranteed sufficient decrease. ACM Transactions on Mathematical
                  Software (TOMS), Vol 20, No 3, pp. 286-307, 1994.
        </member>
        <member name="T:Accord.Math.Optimization.LBFGS.Code">
            Return values of lbfgs().
            
             Roughly speaking, a negative value indicates an error.
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGS_SUCCESS">
            L-BFGS reaches convergence. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGS_ALREADY_MINIMIZED">
            The initial variables already minimize the objective function. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_UNKNOWNERROR">
            Unknown error. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_LOGICERROR">
            Logic error. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_OUTOFMEMORY">
            Insufficient memory. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_CANCELED">
            The minimization process has been canceled. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_INVALID_N">
            Invalid number of variables specified. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_INVALID_N_SSE">
            Invalid number of variables (for SSE) specified. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_INVALID_X_SSE">
            The array x must be aligned to 16 (for SSE). 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_INVALID_EPSILON">
            Invalid parameter lbfgs_parameter_t::epsilon specified. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_INVALID_TESTPERIOD">
            Invalid parameter lbfgs_parameter_t::past specified. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_INVALID_DELTA">
            Invalid parameter lbfgs_parameter_t::delta specified. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_INVALID_LINESEARCH">
            Invalid parameter lbfgs_parameter_t::linesearch specified. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_INVALID_MINSTEP">
            Invalid parameter lbfgs_parameter_t::max_step specified. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_INVALID_MAXSTEP">
            Invalid parameter lbfgs_parameter_t::max_step specified. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_INVALID_FTOL">
            Invalid parameter lbfgs_parameter_t::ftol specified. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_INVALID_WOLFE">
            Invalid parameter lbfgs_parameter_t::wolfe specified. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_INVALID_GTOL">
            Invalid parameter lbfgs_parameter_t::gtol specified. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_INVALID_XTOL">
            Invalid parameter lbfgs_parameter_t::xtol specified. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_INVALID_MAXLINESEARCH">
            Invalid parameter lbfgs_parameter_t::max_linesearch specified. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_INVALID_ORTHANTWISE">
            Invalid parameter lbfgs_parameter_t::orthantwise_c specified. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_INVALID_ORTHANTWISE_START">
            Invalid parameter lbfgs_parameter_t::orthantwise_start specified. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_INVALID_ORTHANTWISE_END">
            Invalid parameter lbfgs_parameter_t::orthantwise_end specified. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_OUTOFINTERVAL">
            The line-search step went out of the interval of uncertainty. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_INCORRECT_TMINMAX">
            A logic error occurred; alternatively, the interval of uncertainty
                            became too small. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_ROUNDING_ERROR">
            A rounding error occurred; alternatively, no line-search step
                            satisfies the sufficient decrease and curvature conditions. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_MINIMUMSTEP">
            The line-search step became smaller than lbfgs_parameter_t::min_step. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_MAXIMUMSTEP">
            The line-search step became larger than lbfgs_parameter_t::max_step. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_MAXIMUMLINESEARCH">
            The line-search routine reaches the maximum number of evaluations. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_MAXIMUMITERATION">
            The algorithm routine reaches the maximum number of iterations. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_WIDTHTOOSMALL">
            Relative width of the interval of uncertainty is at most
                            lbfgs_parameter_t::xtol. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_INVALIDPARAMETERS">
            A logic error (negative line-search step) occurred. 
        </member>
        <member name="F:Accord.Math.Optimization.LBFGS.Code.LBFGSERR_INCREASEGRADIENT">
            The current search direction increases the objective function value. 
        </member>
        <member name="T:Accord.Math.Optimization.LBFGS.lbfgs_evaluate_t">
             Callback interface to provide objective function and gradient evaluations.
            
              The lbfgs() function call this function to obtain the values of objective
              function and its gradients when needed. A client program must implement
              this function to evaluate the values of the objective function and its
              gradients, given current values of variables.
              
              @param  instance    The user data sent for lbfgs() function by the client.
              @param  x           The current values of variables.
              @param  g           The gradient vector. The callback function must compute
                                  the gradient values for the current variables.
              @param  n           The number of variables.
              @param  step        The current step of the line search routine.
              @retval double The value of the objective function for the current
                                      variables.
        </member>
        <member name="T:Accord.Math.Optimization.LBFGS.lbfgs_progress_t">
             Callback interface to receive the progress of the optimization process.
            
              The lbfgs() function call this function for each iteration. Implementing
              this function, a client program can store or display the current progress
              of the optimization process.
            
              @param  instance    The user data sent for lbfgs() function by the client.
              @param  x           The current values of variables.
              @param  g           The current gradient values of variables.
              @param  fx          The current value of the objective function.
              @param  xnorm       The Euclidean norm of the variables.
              @param  gnorm       The Euclidean norm of the gradients.
              @param  step        The line-search step used for this iteration.
              @param  n           The number of variables.
              @param  k           The iteration count.
              @param  ls          The number of evaluations called for this iteration.
              @retval int         Zero to continue the optimization process. Returning a
                                  non-zero value will cancel the optimization process.
        </member>
        <member name="T:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShannoStatus">
            <summary>
              Status codes for the <see cref="T:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShanno"/>
              function optimizer.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShannoStatus.FunctionConvergence">
            <summary>
              The function output converged to a static 
              value within the desired precision.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShannoStatus.GradientConvergence">
            <summary>
              The function gradient converged to a minimum
              value within the desired precision.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShannoStatus.LineSearchFailed">
            <summary>
              The inner line search function failed. This could be an indication 
              that there might be something wrong with the gradient function.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShannoInnerStatus">
            <summary>
              Inner status of the <see cref="T:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShanno"/>
              optimization algorithm. This class contains implementation details that
              can change at any time.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShannoInnerStatus.#ctor(System.Int32[],System.Double[],System.Boolean[],System.String,System.Double[])">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShannoInnerStatus"/> class with the inner
              status values from the original FORTRAN L-BFGS implementation.
            </summary>
            
            <param name="isave">The isave L-BFGS status argument.</param>
            <param name="dsave">The dsave L-BFGS status argument.</param>
            <param name="lsave">The lsave L-BFGS status argument.</param>
            <param name="csave">The csave L-BFGS status argument.</param>
            <param name="work">The work L-BFGS status argument.</param>
            
        </member>
        <member name="P:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShannoInnerStatus.Integers">
            <summary>
              Gets or sets the isave status from the
              original FORTRAN L-BFGS implementation.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShannoInnerStatus.Doubles">
            <summary>
              Gets or sets the dsave status from the
              original FORTRAN L-BFGS implementation.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShannoInnerStatus.Booleans">
            <summary>
              Gets or sets the lsave status from the
              original FORTRAN L-BFGS implementation.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShannoInnerStatus.Strings">
            <summary>
              Gets or sets the csave status from the
              original FORTRAN L-BFGS implementation.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShannoInnerStatus.Work">
            <summary>
              Gets or sets the work vector from the
              original FORTRAN L-BFGS implementation.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.GaussNewton">
            <summary>
              Gauss-Newton algorithm for solving Least-Squares problems.
            </summary>
            
            <remarks>
              This class isn't suitable for most real-world problems. Instead, this class
              is intended to be use as a baseline comparison to help debug and check other
              optimization methods, such as <see cref="T:Accord.Math.Optimization.LevenbergMarquardt"/>.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Optimization.GaussNewton.#ctor(System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.GaussNewton"/> class.
            </summary>
            
            <param name="parameters">The number of variables (free parameters)
              in the objective function.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.GaussNewton.Minimize(System.Double[][],System.Double[])">
            <summary>
              Attempts to find the best values for the parameter vector
              minimizing the discrepancy between the generated outputs
              and the expected outputs for a given set of input data.
            </summary>
            
            <param name="inputs">A set of input data.</param>
            <param name="outputs">The values associated with each 
              vector in the <paramref name="inputs"/> data.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.GaussNewton.ComputeError(System.Double[][],System.Double[])">
            <summary>
              Compute model error for a given data set.
            </summary>
            
            <param name="input">The input points.</param>
            <param name="output">The output points.</param>
            
            <returns>The sum of squared errors for the data.</returns>
            
        </member>
        <member name="P:Accord.Math.Optimization.GaussNewton.Function">
            <summary>
              Gets or sets a parameterized model function mapping input vectors
              into output values, whose optimum parameters must be found.
            </summary>
            
            <value>
              The function to be optimized.
            </value>
            
        </member>
        <member name="P:Accord.Math.Optimization.GaussNewton.Gradient">
            <summary>
              Gets or sets a function that computes the gradient vector in respect
              to the function parameters, given a set of input and output values.
            </summary>
            
            <value>
              The gradient function.
            </value>
            
        </member>
        <member name="P:Accord.Math.Optimization.GaussNewton.NumberOfVariables">
            <summary>
              Gets the number of variables (free parameters) in the optimization problem.
            </summary>
            
            <value>
              The number of parameters.
            </value>
            
        </member>
        <member name="P:Accord.Math.Optimization.GaussNewton.Hessian">
            <summary>
              Gets the approximate Hessian matrix of second derivatives
              created during the last algorithm iteration.
            </summary>
            
            <remarks>
            <para>
              Please note that this value is actually just an approximation to the
              actual Hessian matrix using the outer Jacobian approximation (H ~ J'J).
            </para>
            </remarks>
            
        </member>
        <member name="P:Accord.Math.Optimization.GaussNewton.Solution">
            <summary>
              Gets the solution found, the values of the parameters which
              optimizes the function, in a least squares sense.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GaussNewton.Residuals">
            <summary>
              Gets the vector of residuals computed in the last iteration.
              The residuals are computed as <c>(y - f(w, x))</c>, in which 
              <c>y</c> are the expected output values, and <c>f</c> is the
              parameterized model function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GaussNewton.Jacobian">
            <summary>
              Gets the Jacobian matrix of first derivatives computed in the
              last iteration.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GaussNewton.Deltas">
            <summary>
              Gets the vector of coefficient updates computed in the last iteration.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GaussNewton.StandardErrors">
            <summary>
              Gets standard error for each parameter in the solution.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.LevenbergMarquardt">
            <summary>
              Levenberg-Marquardt algorithm for solving Least-Squares problems.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.LevenbergMarquardt.#ctor(System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.LevenbergMarquardt"/> class.
            </summary>
            
            <param name="parameters">The number of free parameters in the optimization problem.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.LevenbergMarquardt.Minimize(System.Double[][],System.Double[])">
            <summary>
              Attempts to find the best values for the parameter vector
              minimizing the discrepancy between the generated outputs
              and the expected outputs for a given set of input data.
            </summary>
            
            <param name="inputs">A set of input data.</param>
            <param name="outputs">The values associated with each 
              vector in the <paramref name="inputs"/> data.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.LevenbergMarquardt.ComputeError(System.Double[][],System.Double[])">
            <summary>
              Compute model error for a given data set.
            </summary>
            
            <param name="input">The input points.</param>
            <param name="output">The output points.</param>
            
            <returns>The sum of squared errors for the data.</returns>
            
        </member>
        <member name="P:Accord.Math.Optimization.LevenbergMarquardt.Function">
            <summary>
              Gets or sets a parameterized model function mapping input vectors
              into output values, whose optimum parameters must be found.
            </summary>
            
            <value>
              The function to be optimized.
            </value>
            
        </member>
        <member name="P:Accord.Math.Optimization.LevenbergMarquardt.Gradient">
            <summary>
              Gets or sets a function that computes the gradient vector in respect
              to the function parameters, given a set of input and output values.
            </summary>
            
            <value>
              The gradient function.
            </value>
            
        </member>
        <member name="P:Accord.Math.Optimization.LevenbergMarquardt.Solution">
            <summary>
              Gets the solution found, the values of the parameters which
              optimizes the function, in a least squares sense.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.LevenbergMarquardt.LearningRate">
             <summary>
               Levenberg's damping factor, also known as lambda.
             </summary>
             
             <remarks><para>The value determines speed of learning.</para>
             
             <para>Default value is <b>0.1</b>.</para>
             </remarks>
            
        </member>
        <member name="P:Accord.Math.Optimization.LevenbergMarquardt.Adjustment">
             <summary>
               Learning rate adjustment. 
             </summary>
             
             <remarks><para>The value by which the learning rate
             is adjusted when searching for the minimum cost surface.</para>
             
             <para>Default value is <b>10</b>.</para>
             </remarks>
            
        </member>
        <member name="P:Accord.Math.Optimization.LevenbergMarquardt.NumberOfVariables">
            <summary>
              Gets the number of variables (free parameters) in the optimization problem.
            </summary>
            
            <value>
              The number of parameters.
            </value>
            
        </member>
        <member name="P:Accord.Math.Optimization.LevenbergMarquardt.Blocks">
            <summary>
              Gets or sets the number of blocks to divide the 
              Jacobian matrix in the Hessian calculation to
              preserve memory. Default is 1.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.LevenbergMarquardt.Hessian">
            <summary>
              Gets the approximate Hessian matrix of second derivatives 
              generated in the last algorithm iteration. The Hessian is 
              stored in the upper triangular part of this matrix. See 
              remarks for details.
              </summary>
              
            <remarks>
            <para>
              The Hessian needs only be upper-triangular, since
              it is symmetric. The Cholesky decomposition will
              make use of this fact and use the lower-triangular
              portion to hold the decomposition, conserving memory</para>
              
            <para>
              Thus said, this property will hold the Hessian matrix
              in the upper-triangular part of this matrix, and store
              its Cholesky decomposition on its lower triangular part.</para>
              
            <para>
              Please note that this value is actually just an approximation to the
              actual Hessian matrix using the outer Jacobian approximation (H ~ J'J).
            </para>
            </remarks>
             
        </member>
        <member name="P:Accord.Math.Optimization.LevenbergMarquardt.StandardErrors">
            <summary>
              Gets standard error for each parameter in the solution.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.NelderMeadStatus">
            <summary>
              <see cref="T:Accord.Math.Optimization.NelderMead"/> exit codes.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.NelderMeadStatus.ForcedStop">
            <summary>
              Optimization was canceled by the user.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.NelderMeadStatus.Success">
            <summary>
              Optimization ended successfully.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.NelderMeadStatus.MaximumTimeReached">
            <summary>
              The execution time exceeded the established limit.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.NelderMeadStatus.MinimumAllowedValueReached">
            <summary>
              The minimum desired value has been reached.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.NelderMeadStatus.MaximumEvaluationsReached">
            <summary>
              The algorithm had stopped prematurely because 
              the maximum number of evaluations was reached.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.NelderMeadStatus.Failure">
            <summary>
              The algorithm failed internally.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.NelderMeadStatus.FunctionToleranceReached">
            <summary>
              The desired output tolerance (minimum change in the function
              output between two consecutive iterations) has been reached.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.NelderMeadStatus.SolutionToleranceReached">
            <summary>
              The desired parameter tolerance (minimum change in the 
              solution vector between two iterations) has been reached.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.NelderMead">
            <summary>
              Nelder-Mead simplex algorithm with support for bound 
              constraints for non-linear, gradient-free optimization.
            </summary>
            
            <remarks>
            <para>
              The Nelderâ€“Mead method or downhill simplex method or amoeba method is a 
              commonly used nonlinear optimization technique, which is a well-defined 
              numerical method for problems for which derivatives may not be known. 
              However, the Nelderâ€“Mead technique is a heuristic search method that can
              converge to non-stationary points on problems that can be solved by 
              alternative methods.</para>
              
            <para>
              The Nelderâ€“Mead technique was proposed by John Nelder and Roger Mead (1965)
              and is a technique for minimizing an objective function in a many-dimensional
              space.</para>
              
            <para>
              The source code presented in this file has been adapted from the
              Sbplx method (based on Nelder-Mead's Simplex) given in the NLopt
              Numerical Optimization Library, created by Steven G. Johnson.</para>
              
            <para>
              References:
              <list type="bullet">
                <item><description><a href="http://ab-initio.mit.edu/nlopt">
                  Steven G. Johnson, The NLopt nonlinear-optimization package, 
                  http://ab-initio.mit.edu/nlopt </a></description></item>
                <item><description><a href="http://en.wikipedia.org/wiki/Nelder%E2%80%93Mead_method">
                  Wikipedia, The Free Encyclopedia. Nelder Mead method. Available on:
                  http://en.wikipedia.org/wiki/Nelder%E2%80%93Mead_method </a></description></item>
               </list></para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Optimization.NelderMead.#ctor(System.Int32)">
            <summary>
              Creates a new <see cref="T:Accord.Math.Optimization.NelderMead"/> non-linear optimization algorithm.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the optimization problem.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.NelderMead.#ctor(System.Int32,System.Func{System.Double[],System.Double})">
            <summary>
              Creates a new <see cref="T:Accord.Math.Optimization.NelderMead"/> non-linear optimization algorithm.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the optimization problem.</param>
            <param name="function">The objective function whose optimum values should be found.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.NelderMead.#ctor(Accord.Math.Optimization.NonlinearObjectiveFunction)">
            <summary>
              Creates a new <see cref="T:Accord.Math.Optimization.NelderMead"/> non-linear optimization algorithm.
            </summary>
            
            <param name="function">The objective function whose optimum values should be found.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.NelderMead.Minimize(System.Double)">
            <summary>
              Finds the minimum value of a function, using the function output at
              the current value, if already known. This overload can be used when
              embedding Nelder-Mead in other algorithms to avoid initial checks.
            </summary>
            
            <param name="fmin">The function output at the current values, if already known.</param>
             
        </member>
        <member name="M:Accord.Math.Optimization.NelderMead.Optimize">
            <summary>
              Implements the actual optimization algorithm. This
              method should try to minimize the objective function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.NelderMead.reflectpt(System.Int32,System.Double[],System.Double[],System.Double,System.Double[],System.Double[],System.Double[])">
            <summary>
              Performs the reflection <c>xnew = c + scale * (c - xold)</c>,
              returning 0 if <c>xnew == c</c> or <c>xnew == xold</c> (coincident
              points), and 1 otherwise.
            </summary>
            
            <remarks>
              The reflected point xnew is "pinned" to the lower and upper bounds
              (lb and ub), as suggested by J. A. Richardson and J. L. Kuester,
              "The complex method for constrained optimization," Commun. ACM
              16(8), 487-489 (1973).  This is probably a suboptimal way to handle
              bound constraints, but I don't know a better way.  The main danger
              with this is that the simplex might collapse into a
              lower-dimensional hyperplane; this danger can be ameliorated by
              restarting (as in subplex), however.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Optimization.NelderMead.close(System.Double,System.Double)">
            <summary>
              Determines whether two numbers are numerically 
              close (within current floating-point precision).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NelderMead.Capacity">
            <summary>
              Gets the maximum <see cref="P:Accord.Math.Optimization.NelderMead.NumberOfVariables">number of 
              variables</see> that can be optimized by this instance.
              This is the initial value that has been passed to this
              class constructor at the time the algorithm was created.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NelderMead.MaximumValue">
            <summary>
              Gets or sets the maximum value that the objective 
              function could produce before the algorithm could
              be terminated as if the solution was good enough.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NelderMead.StepSize">
            <summary>
              Gets the step sizes to be used by the optimization
              algorithm. Default is to initialize each with 1e-5.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NelderMead.NumberOfVariables">
            <summary>
              Gets or sets the number of variables (free parameters) in the
              optimization problem. This number can be decreased after the
              algorithm has been created so it can operate on subspaces.
            </summary>
            
            <exception cref="T:System.ArgumentOutOfRangeException"/>
            
        </member>
        <member name="P:Accord.Math.Optimization.NelderMead.Convergence">
            <summary>
              Gets or sets multiple convergence options to 
              determine when the optimization can terminate.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NelderMead.Status">
            <summary>
              Get the exit code returned in the last call to the
              <see cref="M:Accord.Math.Optimization.IOptimizationMethod.Maximize"/> or 
              <see cref="M:Accord.Math.Optimization.IOptimizationMethod.Minimize"/> methods.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NelderMead.LowerBounds">
            <summary>
              Gets the lower bounds that should be respected in this 
              optimization problem. Default is to initialize this vector
              with <see cref="F:System.Double.NegativeInfinity"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NelderMead.UpperBounds">
            <summary>
              Gets the upper bounds that should be respected in this 
              optimization problem. Default is to initialize this vector
              with <see cref="F:System.Double.PositiveInfinity"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NelderMead.DiameterTolerance">
            <summary>
              Gets or sets the by how much the simplex diameter |xl - xh| must be
              reduced before the algorithm can be terminated. Setting this value
              to a value higher than zero causes the algorithm to replace the
              standard <see cref="P:Accord.Math.Optimization.NelderMead.Convergence"/> criteria with this condition.
              Default is zero.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NelderMead.Difference">
            <summary>
              The difference between the high and low function 
              values of the last simplex in the previous call
              to the optimization function.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.ResilientBackpropagation">
            <summary>
              Resilient Backpropagation method for unconstrained optimization.
            </summary>
            
            <seealso cref="T:Accord.Math.Optimization.ConjugateGradient"/>
            <seealso cref="T:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShanno"/>
            <seealso cref="T:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno"/>
            <seealso cref="T:Accord.Math.Optimization.TrustRegionNewtonMethod"/>
            
        </member>
        <member name="M:Accord.Math.Optimization.ResilientBackpropagation.#ctor(Accord.Math.Optimization.NonlinearObjectiveFunction)">
            <summary>
              Creates a new instance of the L-BFGS optimization algorithm.
            </summary>
            
            <param name="function">The function to be optimized.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.ResilientBackpropagation.#ctor(System.Int32,System.Func{System.Double[],System.Double},System.Func{System.Double[],System.Double[]})">
            <summary>
              Creates a new instance of the L-BFGS optimization algorithm.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the function to be optimized.</param>
            <param name="function">The function to be optimized.</param>
            <param name="gradient">The gradient of the function.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.ResilientBackpropagation.#ctor(System.Int32)">
            <summary>
              Creates a new <see cref="T:Accord.Math.Optimization.ResilientBackpropagation"/> function optimizer.
            </summary>
            
            <param name="numberOfVariables">The number of parameters in the function to be optimized.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.ResilientBackpropagation.Optimize">
            <summary>
              Implements the actual optimization algorithm. This
              method should try to minimize the objective function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.ResilientBackpropagation.OnProgressChanged(System.ComponentModel.ProgressChangedEventArgs)">
            <summary>
              Raises the <see cref="E:ProgressChanged"/> event.
            </summary>
            
            <param name="args">The <see cref="T:System.ComponentModel.ProgressChangedEventArgs"/> instance containing the event data.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.ResilientBackpropagation.Reset(System.Double)">
            <summary>
              Resets the current update steps using the given learning rate.
            </summary>
            
        </member>
        <member name="E:Accord.Math.Optimization.ResilientBackpropagation.ProgressChanged">
            <summary>
              Occurs when the current learning progress has changed.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ResilientBackpropagation.UpdateUpperBound">
            <summary>
              Gets or sets the maximum possible update step,
              also referred as delta min. Default is 50.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ResilientBackpropagation.UpdateLowerBound">
            <summary>
              Gets or sets the minimum possible update step,
              also referred as delta max. Default is 1e-6.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ResilientBackpropagation.DecreaseFactor">
            <summary>
              Gets the decrease parameter, also 
              referred as eta minus. Default is 0.5.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ResilientBackpropagation.IncreaseFactor">
            <summary>
              Gets the increase parameter, also
              referred as eta plus. Default is 1.2.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ResilientBackpropagation.Tolerance">
            <summary>
              Gets or sets the maximum change in the average log-likelihood
              after an iteration of the algorithm used to detect convergence.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ResilientBackpropagation.Iterations">
            <summary>
              Gets or sets the maximum number of iterations
              performed by the learning algorithm.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.Subplex">
            <summary>
              Subplex
            </summary>
            
            <remarks>
            <para>
              The source code presented in this file has been adapted from the
              Sbplx method (based on Nelder-Mead's Simplex) given in the NLopt
              Numerical Optimization Library, created by Steven G. Johnson.</para>
              
            <para>
              References:
              <list type="bullet">
                <item><description><a href="http://ab-initio.mit.edu/nlopt">
                  Steven G. Johnson, The NLopt nonlinear-optimization package, 
                  http://ab-initio.mit.edu/nlopt </a></description></item>
                <item><description><a href="http://en.wikipedia.org/wiki/Nelder%E2%80%93Mead_method">
                  Wikipedia, The Free Encyclopedia. Nelder Mead method. Available on:
                  http://en.wikipedia.org/wiki/Nelder%E2%80%93Mead_method </a></description></item>
               </list></para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Optimization.Subplex.#ctor(System.Int32)">
            <summary>
              Creates a new <see cref="T:Accord.Math.Optimization.Subplex"/> optimization algorithm.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the optimization problem.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.Subplex.#ctor(System.Int32,System.Func{System.Double[],System.Double})">
            <summary>
              Creates a new <see cref="T:Accord.Math.Optimization.Subplex"/> optimization algorithm.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the optimization problem.</param>
            <param name="function">The objective function whose optimum values should be found.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.Subplex.#ctor(Accord.Math.Optimization.NonlinearObjectiveFunction)">
            <summary>
              Creates a new <see cref="T:Accord.Math.Optimization.Subplex"/> optimization algorithm.
            </summary>
            
            <param name="function">The objective function whose optimum values should be found.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.Subplex.Optimize">
            <summary>
              Implements the actual optimization algorithm. This
              method should try to minimize the objective function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.Subplex.subspace_func(System.Double[])">
            <summary>
              Wrapper around objective function for subspace optimization.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.Subplex.Status">
            <summary>
              Get the exit code returned in the last call to the
              <see cref="M:Accord.Math.Optimization.IOptimizationMethod.Maximize"/> or 
              <see cref="M:Accord.Math.Optimization.IOptimizationMethod.Minimize"/> methods.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.Subplex.MaximumValue">
            <summary>
              Gets or sets the maximum value that the objective 
              function could produce before the algorithm could
              be terminated as if the solution was good enough.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.Subplex.StepSize">
            <summary>
              Gets the step sizes to be used by the optimization
              algorithm. Default is to initialize each with 1e-5.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.Subplex.Convergence">
            <summary>
              Gets or sets multiple convergence options to 
              determine when the optimization can terminate.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.Subplex.LowerBounds">
            <summary>
              Gets the lower bounds that should be respected in this 
              optimization problem. Default is to initialize this vector
              with <see cref="F:System.Double.NegativeInfinity"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.Subplex.UpperBounds">
            <summary>
              Gets the upper bounds that should be respected in this 
              optimization problem. Default is to initialize this vector
              with <see cref="F:System.Double.PositiveInfinity"/>.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.TrustRegionNewtonMethod">
            <summary>
              Simplified Trust Region Newton Method (TRON) for non-linear optimization.
            </summary>
            
            <remarks>
            <para>
              Trust region is a term used in mathematical optimization to denote the subset 
              of the region of the objective function to be optimized that is approximated 
              using a model function (often a quadratic). If an adequate model of the objective
              function is found within the trust region then the region is expanded; conversely,
              if the approximation is poor then the region is contracted. Trust region methods 
              are also known as restricted step methods.</para>
            <para>
              The fit is evaluated by comparing the ratio of expected improvement from the model
              approximation with the actual improvement observed in the objective function. Simple
              thresholding of the ratio is used as the criteria for expansion and contractionâ€”a
              model function is "trusted" only in the region where it provides a reasonable 
              approximation. </para>
              
            <para>
              Trust region methods are in some sense dual to line search methods: trust region 
              methods first choose a step size (the size of the trust region) and then a step 
              direction while line search methods first choose a step direction and then a step
              size.</para>
              
            <para>
              This class implements a simplified version of Chih-Jen Lin and Jorge MorÃ©'s TRON,
              a trust region Newton method for the solution of large bound-constrained optimization 
              problems. This version was based upon liblinear's implementation.</para>
              
            <para>
              References:
              <list type="bullet">
                <item><description>
                  <a href="http://en.wikipedia.org/wiki/Trust_region">
                  Wikipedia, The Free Encyclopedia. Trust region. Available on:
                  http://en.wikipedia.org/wiki/Trust_region </a></description></item>
                <item><description>
                  <a href="http://www.mcs.anl.gov/~more/tron/index.html">
                 Chih-Jen Lin and Jorge MorÃ©, TRON. Available on: http://www.mcs.anl.gov/~more/tron/index.html
                  </a></description></item>
                <item><description>
                  <a href="http://www.cs.iastate.edu/~honavar/keerthi-svm.pdf">
                  Chih-Jen Lin and Jorge J. MorÃ©. 1999. Newton's Method for Large Bound-Constrained 
                  Optimization Problems. SIAM J. on Optimization 9, 4 (April 1999), 1100-1127. </a>
                  </description></item>
                <item><description>
                  <a href="http://www.csie.ntu.edu.tw/~cjlin/liblinear/">
                  Machine Learning Group. LIBLINEAR -- A Library for Large Linear Classification.
                  National Taiwan University. Available at: http://www.csie.ntu.edu.tw/~cjlin/liblinear/
                  </a></description></item>
                </list></para>  
            </remarks>
            
            <seealso cref="T:Accord.Math.Optimization.ConjugateGradient"/>
            <seealso cref="T:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShanno"/>
            <seealso cref="T:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno"/>
            <seealso cref="T:Accord.Math.Optimization.ResilientBackpropagation"/>
            
        </member>
        <member name="M:Accord.Math.Optimization.TrustRegionNewtonMethod.#ctor(System.Int32)">
            <summary>
              Creates a new <see cref="T:Accord.Math.Optimization.ResilientBackpropagation"/> function optimizer.
            </summary>
            
            <param name="numberOfVariables">The number of parameters in the function to be optimized.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.TrustRegionNewtonMethod.#ctor(System.Int32,System.Func{System.Double[],System.Double},System.Func{System.Double[],System.Double[]},System.Func{System.Double[],System.Double[]})">
            <summary>
              Creates a new <see cref="T:Accord.Math.Optimization.ResilientBackpropagation"/> function optimizer.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the function to be optimized.</param>
            <param name="function">The function to be optimized.</param>
            <param name="gradient">The gradient of the function.</param>
            <param name="hessian">The hessian of the function.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.TrustRegionNewtonMethod.Optimize">
            <summary>
              Implements the actual optimization algorithm. This
              method should try to minimize the objective function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.TrustRegionNewtonMethod.Tolerance">
            <summary>
              Gets or sets the tolerance under which the
              solution should be found. Default is 0.1.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.TrustRegionNewtonMethod.MaxIterations">
            <summary>
              Gets or sets the maximum number of iterations that should
               be performed until the algorithm stops. Default is 1000.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.TrustRegionNewtonMethod.Hessian">
            <summary>
              Gets or sets the Hessian estimation function.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Taylor">
            <summary>
              Taylor series expansions for common functions.
            </summary>
            
            <remarks>
            <para>
              In mathematics, a Taylor series is a representation of a function as an infinite sum of terms 
              that are calculated from the values of the function's derivatives at a single point.</para>
              
            <para>
              The concept of a Taylor series was discovered by the Scottish mathematician James Gregory and 
              formally introduced by the English mathematician Brook Taylor in 1715. If the Taylor series is 
              centered at zero, then that series is also called a Maclaurin series, named after the Scottish 
              mathematician Colin Maclaurin, who made extensive use of this special case of Taylor series in
              the 18th century.</para>
              
            <para>
              It is common practice to approximate a function by using a finite number of terms of its Taylor
              series. Taylor's theorem gives quantitative estimates on the error in this approximation. Any 
              finite number of initial terms of the Taylor series of a function is called a Taylor polynomial.
              The Taylor series of a function is the limit of that function's Taylor polynomials, provided that
              the limit exists. A function may not be equal to its Taylor series, even if its Taylor series 
              converges at every point. A function that is equal to its Taylor series in an open interval (or 
              a disc in the complex plane) is known as an analytic function in that interval.</para>
              
            <para>
              References:
              <list type="bullet">
                <item><description><a href="http://en.wikipedia.org/wiki/Taylor_series">
                  Wikipedia, The Free Encyclopedia. Taylor series. Available at: 
                  http://en.wikipedia.org/wiki/Taylor_series </a></description></item>
                <item><description><a href="http://www.haverford.edu/physics/MathAppendices/Taylor_Series.pdf">
                  Anne Fry, Amy Plofker, Sarah-marie Belcastro, Lyle Roelofs. A Set of Appendices on Mathematical 
                  Methods for Physics Students: Taylor Series Expansions and Approximations. Available at: 
                  http://www.haverford.edu/physics/MathAppendices/Taylor_Series.pdf </a></description></item>
              </list></para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Taylor.Sin(System.Double,System.Int32)">
            <summary>
              Returns the sine of a specified angle by evaluating a Taylor series.
            </summary>
            
            <param name="x">An angle, measured in radians.</param>
            <param name="nTerms">The number of terms to be evaluated.</param>
            
            <returns>The sine of the angle <paramref name="x"/>.</returns>
            
        </member>
        <member name="M:Accord.Math.Taylor.Cos(System.Double,System.Int32)">
            <summary>
              Returns the cosine of a specified angle by evaluating a Taylor series.
            </summary>
            
            <param name="x">An angle, measured in radians.</param>
            <param name="nTerms">The number of terms to be evaluated.</param>
            
            <returns>The cosine of the angle <paramref name="x"/>.</returns>
            
        </member>
        <member name="M:Accord.Math.Taylor.Sinh(System.Double,System.Int32)">
            <summary>
              Returns the hyperbolic sine of a specified angle by evaluating a Taylor series.
            </summary>
            
            <param name="x">An angle, measured in radians.</param>
            <param name="nTerms">The number of terms to be evaluated.</param>
            
            <returns>The hyperbolic sine of the angle <paramref name="x"/>.</returns>
            
        </member>
        <member name="M:Accord.Math.Taylor.Cosh(System.Double,System.Int32)">
            <summary>
              Returns the hyperbolic cosine of a specified angle by evaluating a Taylor series.
            </summary>
            
            <param name="x">An angle, measured in radians.</param>
            <param name="nTerms">The number of terms to be evaluated.</param>
            
            <returns>The hyperbolic cosine of the angle <paramref name="x"/>.</returns>
            
        </member>
        <member name="M:Accord.Math.Taylor.Exp(System.Double,System.Int32)">
            <summary>
              Returns e raised to the specified power by evaluating a Taylor series.
            </summary>
            
            <param name="d">A number specifying a power.</param>
            <param name="nTerms">The number of terms to be evaluated.</param>
            
            <returns>Euler's constant raised to the specified power <paramref name="d"/>.</returns>
            
        </member>
        <member name="T:Accord.Math.Transforms.FourierTransform2">
            <summary>
              Fourier Transform (for arbitrary size matrices).
            </summary>
            
            <remarks>
              This fourier transform accepts arbitrary-length matrices and is not
              restricted only to matrices that have dimensions which are powers of
              two. It also provides results which are more equivalent with other
              mathematical packages, such as MATLAB and Octave.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Transforms.FourierTransform2.DFT(System.Numerics.Complex[],AForge.Math.FourierTransform.Direction)">
            <summary>
              1-D Discrete Fourier Transform.
            </summary>
            
            <param name="data">The data to transform..</param>
            <param name="direction">The transformation direction.</param>
            
        </member>
        <member name="M:Accord.Math.Transforms.FourierTransform2.DFT2(System.Numerics.Complex[][],AForge.Math.FourierTransform.Direction)">
            <summary>
              2-D Discrete Fourier Transform.
            </summary>
            
            <param name="data">The data to transform.</param>
            <param name="direction">The transformation direction.</param>
            
        </member>
        <member name="M:Accord.Math.Transforms.FourierTransform2.FFT(System.Numerics.Complex[],AForge.Math.FourierTransform.Direction)">
            <summary>
              1-D Fast Fourier Transform.
            </summary>
            
            <param name="data">The data to transform..</param>
            <param name="direction">The transformation direction.</param>
            
        </member>
        <member name="M:Accord.Math.Transforms.FourierTransform2.FFT(System.Double[],System.Double[],AForge.Math.FourierTransform.Direction)">
            <summary>
              1-D Fast Fourier Transform.
            </summary>
            
            <param name="real">The real part of the complex numbers to transform.</param>
            <param name="imag">The imaginary part of the complex numbers to transform.</param>
            <param name="direction">The transformation direction.</param>
            
        </member>
        <member name="M:Accord.Math.Transforms.FourierTransform2.FFT2(System.Numerics.Complex[][],AForge.Math.FourierTransform.Direction)">
            <summary>
              2-D Fast Fourier Transform.
            </summary>
            
            <param name="data">The data to transform..</param>
            <param name="direction">The Transformation direction.</param>
            
        </member>
        <member name="M:Accord.Math.Transforms.FourierTransform2.FFT(System.Double[],System.Double[])">
            <summary>
              Computes the discrete Fourier transform (DFT) of the given complex vector, 
              storing the result back into the vector. The vector can have any length. 
              This is a wrapper function.
            </summary>
            
            <param name="real">The real.</param>
            <param name="imag">The imag.</param>
            
        </member>
        <member name="M:Accord.Math.Transforms.FourierTransform2.IDFT(System.Numerics.Complex[])">
            <summary>
              Computes the inverse discrete Fourier transform (IDFT) of the given complex 
              vector, storing the result back into the vector. The vector can have any length.
              This is a wrapper function. This transform does not perform scaling, so the 
              inverse is not a true inverse.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Transforms.FourierTransform2.IDFT(System.Double[],System.Double[])">
            <summary>
              Computes the inverse discrete Fourier transform (IDFT) of the given complex 
              vector, storing the result back into the vector. The vector can have any length.
              This is a wrapper function. This transform does not perform scaling, so the 
              inverse is not a true inverse.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Transforms.FourierTransform2.TransformRadix2(System.Double[],System.Double[])">
            <summary>
              Computes the discrete Fourier transform (DFT) of the given complex vector, storing 
              the result back into the vector. The vector's length must be a power of 2. Uses the 
              Cooley-Tukey decimation-in-time radix-2 algorithm.
            </summary>
            
            <exception cref="T:System.ArgumentException">Length is not a power of 2.</exception>
            
        </member>
        <member name="M:Accord.Math.Transforms.FourierTransform2.TransformRadix2(System.Numerics.Complex[])">
            <summary>
              Computes the discrete Fourier transform (DFT) of the given complex vector, storing 
              the result back into the vector. The vector's length must be a power of 2. Uses the 
              Cooley-Tukey decimation-in-time radix-2 algorithm.
            </summary>
            
            <exception cref="T:System.ArgumentException">Length is not a power of 2.</exception>
            
        </member>
        <member name="M:Accord.Math.Transforms.FourierTransform2.TransformBluestein(System.Double[],System.Double[])">
            <summary>
              Computes the discrete Fourier transform (DFT) of the given complex vector, storing 
              the result back into the vector. The vector can have any length. This requires the 
              convolution function, which in turn requires the radix-2 FFT function. Uses 
              Bluestein's chirp z-transform algorithm.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Transforms.FourierTransform2.Convolve(System.Double[],System.Double[],System.Double[])">
            <summary>
              Computes the circular convolution of the given real 
              vectors. All vectors must have the same length.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Transforms.FourierTransform2.Convolve(System.Numerics.Complex[],System.Numerics.Complex[],System.Numerics.Complex[])">
            <summary>
              Computes the circular convolution of the given complex 
              vectors. All vectors must have the same length.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Transforms.FourierTransform2.Convolve(System.Double[],System.Double[],System.Double[],System.Double[],System.Double[],System.Double[])">
            <summary>
              Computes the circular convolution of the given complex 
              vectors. All vectors must have the same length.
            </summary>
            
        </member>
        <member name="T:Accord.Math.HartleyTransform">
            <summary>
              Hartley Transformation.
            </summary>
            
            <para>
              In mathematics, the Hartley transform is an integral transform closely related
              to the Fourier transform, but which transforms real-valued functions to real-
              valued functions. It was proposed as an alternative to the Fourier transform by
              R. V. L. Hartley in 1942, and is one of many known Fourier-related transforms. 
              Compared to the Fourier transform, the Hartley transform has the advantages of 
              transforming real functions to real functions (as opposed to requiring complex 
              numbers) and of being its own inverse.</para>
            
            <remarks>
              References:
              <list type="bullet">
                <item><description>
                  Wikipedia contributors, "Hartley transform," Wikipedia, The Free Encyclopedia,
                  available at: http://en.wikipedia.org/w/index.php?title=Hartley_transform </description></item>
                <item><description>
                  K. R. Castleman, Digital Image Processing. Chapter 13, p.289.
                  Prentice. Hall, 1998.</description></item>
                <item><description>
                  Poularikas A. D. â€œThe Hartley Transformâ€. The Handbook of Formulas and 
                  Tables for Signal Processing. Ed. Alexander D. Poularikas, 1999.</description></item>
              </list>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.HartleyTransform.DHT(System.Double[])">
            <summary>
              Forward Hartley Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.HartleyTransform.DHT(System.Double[0:,0:])">
            <summary>
              Forward Hartley Transform.
            </summary>
            
        </member>
        <member name="T:Accord.Math.SineTransform">
            <summary>
              Discrete Sine Transform
            </summary>
            
            <remarks>
            <para>
              In mathematics, the discrete sine transform (DST) is a Fourier-related transform
              similar to the discrete Fourier transform (DFT), but using a purely real matrix. It
              is equivalent to the imaginary parts of a DFT of roughly twice the length, operating
              on real data with odd symmetry (since the Fourier transform of a real and odd function
              is imaginary and odd), where in some variants the input and/or output data are shifted
              by half a sample.</para>
              
            <para>
              References:
              <list type="bullet">
                <item><description>
                  Wikipedia contributors, "Discrete sine transform," Wikipedia, The Free Encyclopedia,
                  available at: http://en.wikipedia.org/w/index.php?title=Discrete_sine_transform </description></item>
                <item><description>
                  K. R. Castleman, Digital Image Processing. Chapter 13, p.288.
                  Prentice. Hall, 1998.</description></item>
              </list></para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.SineTransform.DST(System.Double[])">
            <summary>
              Forward Discrete Sine Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.SineTransform.IDST(System.Double[])">
            <summary>
              Inverse Discrete Sine Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.SineTransform.DST(System.Double[][])">
            <summary>
              Forward Discrete Sine Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.SineTransform.IDST(System.Double[][])">
            <summary>
              Inverse Discrete Sine Transform.
            </summary>
            
        </member>
        <member name="T:Accord.Math.CosineTransform">
            <summary>
              Discrete Cosine Transformation.
            </summary>
            
            <remarks>
            <para>
               A discrete cosine transform (DCT) expresses a finite sequence of data points
               in terms of a sum of cosine functions oscillating at different frequencies. 
               DCTs are important to numerous applications in science and engineering, from
               lossy compression of audio (e.g. MP3) and images (e.g. JPEG) (where small 
               high-frequency components can be discarded), to spectral methods for the 
               numerical solution of partial differential equations.</para>
               
            <para>
               The use of cosine rather than sine functions is critical in these applications:
               for compression, it turns out that cosine functions are much more efficient,
               whereas for differential equations the cosines express a particular choice of 
               boundary conditions.</para>
              
            <para>
              References:
              <list type="bullet">
                <item><description>
                  Wikipedia contributors, "Discrete sine transform," Wikipedia, The Free Encyclopedia,
                  available at: http://en.wikipedia.org/w/index.php?title=Discrete_sine_transform </description></item>
                <item><description>
                  K. R. Castleman, Digital Image Processing. Chapter 13, p.288.
                  Prentice. Hall, 1998.</description></item>
              </list></para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.CosineTransform.DCT(System.Double[])">
            <summary>
              Forward Discrete Cosine Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.CosineTransform.IDCT(System.Double[])">
            <summary>
              Inverse Discrete Cosine Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.CosineTransform.DCT(System.Double[0:,0:])">
            <summary>
              Forward 2D Discrete Cosine Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.CosineTransform.IDCT(System.Double[0:,0:])">
            <summary>
              Inverse 2D Discrete Cosine Transform.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition">
            <summary>
              Determines the Generalized eigenvalues and eigenvectors of two real square matrices.
            </summary>
            <remarks>
              <para>
                A generalized eigenvalue problem is the problem of finding a vector <c>v</c> that
                obeys <c>A * v = Î» * B * v</c> where <c>A</c> and <c>B</c> are matrices. If <c>v</c>
                obeys this equation, with some <c>Î»</c>, then we call <c>v</c> the generalized eigenvector
                of <c>A</c> and <c>B</c>, and <c>Î»</c> is called the generalized eigenvalue of <c>A</c>
                and <c>B</c> which corresponds to the generalized eigenvector <c>v</c>. The possible
                values of <c>Î»</c>, must obey the identity <c>det(A - Î»*B) = 0</c>.</para>
              <para>
                Part of this code has been adapted from the original EISPACK routines in Fortran.</para>
             
              <para>
                References:
                <list type="bullet">
                  <item><description>
                    <a href="http://en.wikipedia.org/wiki/Generalized_eigenvalue_problem#Generalized_eigenvalue_problem">
                    http://en.wikipedia.org/wiki/Generalized_eigenvalue_problem#Generalized_eigenvalue_problem</a>
                  </description></item>
                  <item><description>
                    <a href="http://www.netlib.org/eispack/">
                    http://www.netlib.org/eispack/</a>
                  </description></item>
                </list>
              </para>
            </remarks>
            
            <example>
            // Suppose we have the following 
            // matrices A and B shown below:
            
            double[,] A = 
            {
                { 1, 2, 3},
                { 8, 1, 4},
                { 3, 2, 3}
            };
            
             double[,] B = 
             {
                { 5, 1, 1},
                { 1, 5, 1},
                { 1, 1, 5}
            };
            
            // Now, suppose we would like to find values for Î» 
            // that are solutions for the equation det(A - Î»B) = 0
            
            // For this, we can use a Generalized Eigendecomposition
            var gevd = new GeneralizedEigenvalueDecomposition(A, B);
            
            // Now, if A and B are Hermitian and B is positive
            // -definite, then the eigenvalues Î» will be real:
            double[] lambda = gevd.RealEigenvalues;
            
            // Lets check if they are indeed a solution:
            for (int i = 0; i &lt; lambda.Length; i++)
            {
                // Compute the determinant equation show above
                double det = Matrix.Determinant(A.Subtract(lambda[i].Multiply(B))); // almost zero
            }
            </example>
            
        </member>
        <member name="M:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.#ctor(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Constructs a new generalized eigenvalue decomposition.</summary>
            <param name="a">The first matrix of the (A,B) matrix pencil.</param>
            <param name="b">The second matrix of the (A,B) matrix pencil.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.qzhes(System.Int32,System.Double[0:,0:],System.Double[0:,0:],System.Boolean,System.Double[0:,0:])">
             <summary>
               Adaptation of the original Fortran QZHES routine from EISPACK.
             </summary>
             <remarks>
               This subroutine is the first step of the qz algorithm
               for solving generalized matrix eigenvalue problems,
               Siam J. Numer. anal. 10, 241-256(1973) by Moler and Stewart.
            
               This subroutine accepts a pair of real general matrices and
               reduces one of them to upper Hessenberg form and the other
               to upper triangular form using orthogonal transformations.
               it is usually followed by  qzit,  qzval  and, possibly,  qzvec.
               
               For the full documentation, please check the original function.
             </remarks>
        </member>
        <member name="M:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.qzit(System.Int32,System.Double[0:,0:],System.Double[0:,0:],System.Double,System.Boolean,System.Double[0:,0:],System.Int32@)">
            <summary>
              Adaptation of the original Fortran QZIT routine from EISPACK.
            </summary>
            <remarks>
              This subroutine is the second step of the qz algorithm
              for solving generalized matrix eigenvalue problems,
              Siam J. Numer. anal. 10, 241-256(1973) by Moler and Stewart,
              as modified in technical note nasa tn d-7305(1973) by ward.
              
              This subroutine accepts a pair of real matrices, one of them
              in upper Hessenberg form and the other in upper triangular form.
              it reduces the Hessenberg matrix to quasi-triangular form using
              orthogonal transformations while maintaining the triangular form
              of the other matrix.  it is usually preceded by  qzhes  and
              followed by  qzval  and, possibly,  qzvec.
              
              For the full documentation, please check the original function.
            </remarks>
        </member>
        <member name="M:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.qzval(System.Int32,System.Double[0:,0:],System.Double[0:,0:],System.Double[],System.Double[],System.Double[],System.Boolean,System.Double[0:,0:])">
            <summary>
              Adaptation of the original Fortran QZVAL routine from EISPACK.
            </summary>
            <remarks>
              This subroutine is the third step of the qz algorithm
              for solving generalized matrix eigenvalue problems,
              Siam J. Numer. anal. 10, 241-256(1973) by Moler and Stewart.
              
              This subroutine accepts a pair of real matrices, one of them
              in quasi-triangular form and the other in upper triangular form.
              it reduces the quasi-triangular matrix further, so that any
              remaining 2-by-2 blocks correspond to pairs of complex
              Eigenvalues, and returns quantities whose ratios give the
              generalized eigenvalues.  it is usually preceded by  qzhes
              and  qzit  and may be followed by  qzvec.
              
              For the full documentation, please check the original function.
            </remarks>
        </member>
        <member name="M:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.qzvec(System.Int32,System.Double[0:,0:],System.Double[0:,0:],System.Double[],System.Double[],System.Double[],System.Double[0:,0:])">
            <summary>
              Adaptation of the original Fortran QZVEC routine from EISPACK.
            </summary>
            <remarks>
              This subroutine is the optional fourth step of the qz algorithm
              for solving generalized matrix eigenvalue problems,
              Siam J. Numer. anal. 10, 241-256(1973) by Moler and Stewart.
              
              This subroutine accepts a pair of real matrices, one of them in
              quasi-triangular form (in which each 2-by-2 block corresponds to
              a pair of complex eigenvalues) and the other in upper triangular
              form.  It computes the eigenvectors of the triangular problem and
              transforms the results back to the original coordinate system.
              it is usually preceded by  qzhes,  qzit, and  qzval.
              
              For the full documentation, please check the original function.
            </remarks>
        </member>
        <member name="M:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="P:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.RealAlphas">
            <summary>Returns the real parts of the alpha values.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.ImaginaryAlphas">
            <summary>Returns the imaginary parts of the alpha values.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.Betas">
            <summary>Returns the beta values.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.IsSingular">
            <summary>
              Returns true if matrix B is singular.
            </summary>
            <remarks>
              This method checks if any of the generated betas is zero. It
              does not says that the problem is singular, but only that one
              of the matrices of the pencil (A,B) is singular.
            </remarks>
        </member>
        <member name="P:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.IsDegenerate">
            <summary>
              Returns true if the eigenvalue problem is degenerate (ill-posed).
            </summary>
        </member>
        <member name="P:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.RealEigenvalues">
            <summary>Returns the real parts of the eigenvalues.</summary>
            <remarks>
              The eigenvalues are computed using the ratio alpha[i]/beta[i],
              which can lead to valid, but infinite eigenvalues.
            </remarks>
        </member>
        <member name="P:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.ImaginaryEigenvalues">
            <summary>Returns the imaginary parts of the eigenvalues.</summary>	
            <remarks>
              The eigenvalues are computed using the ratio alpha[i]/beta[i],
              which can lead to valid, but infinite eigenvalues.
            </remarks>
        </member>
        <member name="P:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.Eigenvectors">
            <summary>Returns the eigenvector matrix.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.DiagonalMatrix">
            <summary>Returns the block diagonal eigenvalue matrix.</summary>
        </member>
        <member name="T:Accord.Math.Decompositions.JaggedCholeskyDecomposition">
             <summary>
               Cholesky Decomposition of a symmetric, positive definite matrix.
             </summary>
            
             <remarks>
             <para>
               For a symmetric, positive definite matrix <c>A</c>, the Cholesky decomposition is a
               lower triangular matrix <c>L</c> so that <c>A = L * L'</c>. The presented algorithm
               only checks the upper triangular part of the matrix given as parameter and assumes
               it is symmetric. If the matrix is not positive definite, the constructor returns a 
               partial decomposition and sets two internal variables that can be queried using the
               <see cref="P:Accord.Math.Decompositions.JaggedCholeskyDecomposition.PositiveDefinite"/> properties.</para>
             <para>
               Any square matrix A with non-zero pivots can be written as the product of a
               lower triangular matrix L and an upper triangular matrix U; this is called
               the LU decomposition. However, if A is symmetric and positive definite, we
               can choose the factors such that U is the transpose of L, and this is called
               the Cholesky decomposition. Both the LU and the Cholesky decomposition are
               used to solve systems of linear equations.</para>
             <para>
               When it is applicable, the Cholesky decomposition is twice as efficient
               as the LU decomposition.</para>
             </remarks>
                
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.#ctor(System.Double[][],System.Boolean,System.Boolean)">
            <summary>
              Constructs a new Cholesky Decomposition.
            </summary>
            
            <param name="value">
              The symmetric matrix, given in upper triangular form, to be decomposed.</param>
            <param name="robust">
              True to perform a square-root free LDLt decomposition, false otherwise.</param>
            <param name="inPlace">
              True to perform the decomposition in place, storing the factorization in the
              lower triangular part of the given matrix.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.Solve(System.Double[][])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.Solve(System.Double[][],System.Boolean)">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.Solve(System.Double[])">
            <summary>
              Solves a set of equation systems of type <c>A * x = b</c>.
            </summary>
            
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Vector <c>x</c> so that <c>L * L' * x = b</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.Solve(System.Double[],System.Boolean)">
            <summary>
              Solves a set of equation systems of type <c>A * x = b</c>.
            </summary>
            
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Vector <c>x</c> so that <c>L * L' * x = b</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.InverseDiagonal(System.Boolean)">
            <summary>
              Computes the diagonal of the inverse of the decomposed matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.InverseDiagonal(System.Double[],System.Boolean)">
             <summary>
               Computes the diagonal of the inverse of the decomposed matrix.
             </summary>
            
             <param name="destroy">True to conserve memory by reusing the
                same space used to hold the decomposition, thus destroying
                it in the process. Pass false otherwise.</param>
             <param name="result">The array to hold the result of the 
                computation. Should be of same length as the the diagonal
                of the original matrix.</param>
             
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.InverseTrace(System.Boolean)">
             <summary>
               Computes the trace of the inverse of the decomposed matrix.
             </summary>
            
             <param name="destroy">True to conserve memory by reusing the
                same space used to hold the decomposition, thus destroying
                it in the process. Pass false otherwise.</param>
             
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.FromLeftTriangularMatrix(System.Double[][])">
            <summary>
              Creates a new Cholesky decomposition directly from
              an already computed left triangular matrix <c>L</c>.
            </summary>
            <param name="leftTriangular">The left triangular matrix from a Cholesky decomposition.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecomposition.PositiveDefinite">
            <summary>
              Returns <see langword="true"/> if the matrix is positive definite.
            </summary>
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecomposition.IsNotDefined">
            <summary>
              Gets a value indicating whether the LDLt factorization
              has been computed successfully or if it is undefined.
            </summary>
            
            <value>
                <c>true</c> if the factorization is not defined; otherwise, <c>false</c>.
            </value>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecomposition.LeftTriangularFactor">
            <summary>
              Returns the left (lower) triangular factor
              <c>L</c> so that <c>A = L * D * L'</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecomposition.DiagonalMatrix">
            <summary>
              Returns the block diagonal matrix of diagonal
              elements in a LDLt decomposition.
            </summary>        
              
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecomposition.Diagonal">
            <summary>
              Returns the one-dimensional array of diagonal 
              elements in a LDLt decomposition.
            </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecomposition.Determinant">
            <summary>
              Returns the determinant of
              the decomposed matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecomposition.LogDeterminant">
            <summary>
              If the matrix is positive-definite, returns the
              log-determinant of the decomposed matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecomposition.Nonsingular">
            <summary>
              Gets a value indicating whether the decomposed
              matrix is non-singular (i.e. invertible).
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.JaggedCholeskyDecompositionD">
             <summary>
               Cholesky Decomposition of a symmetric, positive definite matrix.
             </summary>
            
             <remarks>
             <para>
               For a symmetric, positive definite matrix <c>A</c>, the Cholesky decomposition is a
               lower triangular matrix <c>L</c> so that <c>A = L * L'</c>. The presented algorithm
               only checks the upper triangular part of the matrix given as parameter and assumes
               it is symmetric. If the matrix is not positive definite, the constructor returns a 
               partial decomposition and sets two internal variables that can be queried using the
               <see cref="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.PositiveDefinite"/> properties.</para>
             <para>
               Any square matrix A with non-zero pivots can be written as the product of a
               lower triangular matrix L and an upper triangular matrix U; this is called
               the LU decomposition. However, if A is symmetric and positive definite, we
               can choose the factors such that U is the transpose of L, and this is called
               the Cholesky decomposition. Both the LU and the Cholesky decomposition are
               used to solve systems of linear equations.</para>
             <para>
               When it is applicable, the Cholesky decomposition is twice as efficient
               as the LU decomposition.</para>
             </remarks>
                
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.#ctor(System.Decimal[][],System.Boolean,System.Boolean)">
            <summary>
              Constructs a new Cholesky Decomposition.
            </summary>
            
            <param name="value">
              The symmetric matrix, given in upper triangular form, to be decomposed.</param>
            <param name="robust">
              True to perform a square-root free LDLt decomposition, false otherwise.</param>
            <param name="inPlace">
              True to perform the decomposition in place, storing the factorization in the
              lower triangular part of the given matrix.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.Solve(System.Decimal[][])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.Solve(System.Decimal[][],System.Boolean)">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.Solve(System.Decimal[])">
            <summary>
              Solves a set of equation systems of type <c>A * x = b</c>.
            </summary>
            
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Vector <c>x</c> so that <c>L * L' * x = b</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.Solve(System.Decimal[],System.Boolean)">
            <summary>
              Solves a set of equation systems of type <c>A * x = b</c>.
            </summary>
            
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Vector <c>x</c> so that <c>L * L' * x = b</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.InverseDiagonal(System.Boolean)">
            <summary>
              Computes the diagonal of the inverse of the decomposed matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.InverseDiagonal(System.Decimal[],System.Boolean)">
             <summary>
               Computes the diagonal of the inverse of the decomposed matrix.
             </summary>
            
             <param name="destroy">True to conserve memory by reusing the
                same space used to hold the decomposition, thus destroying
                it in the process. Pass false otherwise.</param>
             <param name="result">The array to hold the result of the 
                computation. Should be of same length as the the diagonal
                of the original matrix.</param>
             
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.InverseTrace(System.Boolean)">
             <summary>
               Computes the trace of the inverse of the decomposed matrix.
             </summary>
            
             <param name="destroy">True to conserve memory by reusing the
                same space used to hold the decomposition, thus destroying
                it in the process. Pass false otherwise.</param>
             
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.FromLeftTriangularMatrix(System.Decimal[][])">
            <summary>
              Creates a new Cholesky decomposition directly from
              an already computed left triangular matrix <c>L</c>.
            </summary>
            <param name="leftTriangular">The left triangular matrix from a Cholesky decomposition.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.PositiveDefinite">
            <summary>
              Returns <see langword="true"/> if the matrix is positive definite.
            </summary>
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.IsNotDefined">
            <summary>
              Gets a value indicating whether the LDLt factorization
              has been computed successfully or if it is undefined.
            </summary>
            
            <value>
                <c>true</c> if the factorization is not defined; otherwise, <c>false</c>.
            </value>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.LeftTriangularFactor">
            <summary>
              Returns the left (lower) triangular factor
              <c>L</c> so that <c>A = L * D * L'</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.DiagonalMatrix">
            <summary>
              Returns the block diagonal matrix of diagonal
              elements in a LDLt decomposition.
            </summary>        
              
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.Diagonal">
            <summary>
              Returns the one-dimensional array of diagonal 
              elements in a LDLt decomposition.
            </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.Determinant">
            <summary>
              Returns the determinant of
              the decomposed matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.LogDeterminant">
            <summary>
              If the matrix is positive-definite, returns the
              log-determinant of the decomposed matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.Nonsingular">
            <summary>
              Gets a value indicating whether the decomposed
              matrix is non-singular (i.e. invertible).
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.JaggedCholeskyDecompositionF">
             <summary>
               Cholesky Decomposition of a symmetric, positive definite matrix.
             </summary>
            
             <remarks>
             <para>
               For a symmetric, positive definite matrix <c>A</c>, the Cholesky decomposition is a
               lower triangular matrix <c>L</c> so that <c>A = L * L'</c>. The presented algorithm
               only checks the upper triangular part of the matrix given as parameter and assumes
               it is symmetric. If the matrix is not positive definite, the constructor returns a 
               partial decomposition and sets two internal variables that can be queried using the
               <see cref="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.PositiveDefinite"/> properties.</para>
             <para>
               Any square matrix A with non-zero pivots can be written as the product of a
               lower triangular matrix L and an upper triangular matrix U; this is called
               the LU decomposition. However, if A is symmetric and positive definite, we
               can choose the factors such that U is the transpose of L, and this is called
               the Cholesky decomposition. Both the LU and the Cholesky decomposition are
               used to solve systems of linear equations.</para>
             <para>
               When it is applicable, the Cholesky decomposition is twice as efficient
               as the LU decomposition.</para>
             </remarks>
                
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.#ctor(System.Single[][],System.Boolean,System.Boolean)">
            <summary>
              Constructs a new Cholesky Decomposition.
            </summary>
            
            <param name="value">
              The symmetric matrix, given in upper triangular form, to be decomposed.</param>
            <param name="robust">
              True to perform a square-root free LDLt decomposition, false otherwise.</param>
            <param name="inPlace">
              True to perform the decomposition in place, storing the factorization in the
              lower triangular part of the given matrix.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.Solve(System.Single[][])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.Solve(System.Single[][],System.Boolean)">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.Solve(System.Single[])">
            <summary>
              Solves a set of equation systems of type <c>A * x = b</c>.
            </summary>
            
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Vector <c>x</c> so that <c>L * L' * x = b</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.Solve(System.Single[],System.Boolean)">
            <summary>
              Solves a set of equation systems of type <c>A * x = b</c>.
            </summary>
            
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Vector <c>x</c> so that <c>L * L' * x = b</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.InverseDiagonal(System.Boolean)">
            <summary>
              Computes the diagonal of the inverse of the decomposed matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.InverseDiagonal(System.Single[],System.Boolean)">
             <summary>
               Computes the diagonal of the inverse of the decomposed matrix.
             </summary>
            
             <param name="destroy">True to conserve memory by reusing the
                same space used to hold the decomposition, thus destroying
                it in the process. Pass false otherwise.</param>
             <param name="result">The array to hold the result of the 
                computation. Should be of same length as the the diagonal
                of the original matrix.</param>
             
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.InverseTrace(System.Boolean)">
             <summary>
               Computes the trace of the inverse of the decomposed matrix.
             </summary>
            
             <param name="destroy">True to conserve memory by reusing the
                same space used to hold the decomposition, thus destroying
                it in the process. Pass false otherwise.</param>
             
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.FromLeftTriangularMatrix(System.Single[][])">
            <summary>
              Creates a new Cholesky decomposition directly from
              an already computed left triangular matrix <c>L</c>.
            </summary>
            <param name="leftTriangular">The left triangular matrix from a Cholesky decomposition.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.PositiveDefinite">
            <summary>
              Returns <see langword="true"/> if the matrix is positive definite.
            </summary>
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.IsNotDefined">
            <summary>
              Gets a value indicating whether the LDLt factorization
              has been computed successfully or if it is undefined.
            </summary>
            
            <value>
                <c>true</c> if the factorization is not defined; otherwise, <c>false</c>.
            </value>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.LeftTriangularFactor">
            <summary>
              Returns the left (lower) triangular factor
              <c>L</c> so that <c>A = L * D * L'</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.DiagonalMatrix">
            <summary>
              Returns the block diagonal matrix of diagonal
              elements in a LDLt decomposition.
            </summary>        
              
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.Diagonal">
            <summary>
              Returns the one-dimensional array of diagonal 
              elements in a LDLt decomposition.
            </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.Determinant">
            <summary>
              Returns the determinant of
              the decomposed matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.LogDeterminant">
            <summary>
              If the matrix is positive-definite, returns the
              log-determinant of the decomposed matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.Nonsingular">
            <summary>
              Gets a value indicating whether the decomposed
              matrix is non-singular (i.e. invertible).
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.JaggedLuDecompositionD">
            <summary>
              LU decomposition of a rectangular matrix.
            </summary>
            <remarks>
              <para>
                For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the LU decomposition is an m-by-n
                unit lower triangular matrix <c>L</c>, an n-by-n upper triangular matrix <c>U</c>,
                and a permutation vector <c>piv</c> of length m so that <c>A(piv) = L*U</c>.
                If m &lt; n, then <c>L</c> is m-by-m and <c>U</c> is m-by-n.</para>
              <para>
                The LU decomposition with pivoting always exists, even if the matrix is
                singular, so the constructor will never fail.  The primary use of the
                LU decomposition is in the solution of square systems of simultaneous
                linear equations. This will fail if <see cref="P:Accord.Math.Decompositions.JaggedLuDecompositionD.Nonsingular"/> returns
                <see langword="false"/>.
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionD.#ctor(System.Decimal[][],System.Boolean,System.Boolean)">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="inPlace">True if the decomposition should be performed over the
            <paramref name="value"/> matrix rather than on a copy of it. If true, the
            matrix will be destroyed during the decomposition. Default is false.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionD.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionD.Solve(System.Decimal[][])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionD.SolveTranspose(System.Decimal[][])">
            <summary>
              Solves a set of equation systems of type <c>X * A = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>Matrix <c>X</c> so that <c>X * L * U = A</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionD.Solve(System.Decimal[])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionD.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionD.Nonsingular">
            <summary>
              Returns if the matrix is non-singular (i.e. invertible).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionD.Determinant">
            <summary>
              Returns the determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionD.LogDeterminant">
            <summary>
              Returns the log-determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionD.LowerTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionD.UpperTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionD.PivotPermutationVector">
            <summary>
              Returns the pivot permutation vector.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.JaggedLuDecompositionF">
            <summary>
              LU decomposition of a rectangular matrix.
            </summary>
            <remarks>
              <para>
                For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the LU decomposition is an m-by-n
                unit lower triangular matrix <c>L</c>, an n-by-n upper triangular matrix <c>U</c>,
                and a permutation vector <c>piv</c> of length m so that <c>A(piv) = L*U</c>.
                If m &lt; n, then <c>L</c> is m-by-m and <c>U</c> is m-by-n.</para>
              <para>
                The LU decomposition with pivoting always exists, even if the matrix is
                singular, so the constructor will never fail.  The primary use of the
                LU decomposition is in the solution of square systems of simultaneous
                linear equations. This will fail if <see cref="P:Accord.Math.Decompositions.JaggedLuDecompositionF.Nonsingular"/> returns
                <see langword="false"/>.
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionF.#ctor(System.Single[][],System.Boolean,System.Boolean)">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="inPlace">True if the decomposition should be performed over the
            <paramref name="value"/> matrix rather than on a copy of it. If true, the
            matrix will be destroyed during the decomposition. Default is false.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionF.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionF.Solve(System.Single[][])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionF.SolveTranspose(System.Single[][])">
            <summary>
              Solves a set of equation systems of type <c>X * A = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>Matrix <c>X</c> so that <c>X * L * U = A</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionF.Solve(System.Single[])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionF.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionF.Nonsingular">
            <summary>
              Returns if the matrix is non-singular (i.e. invertible).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionF.Determinant">
            <summary>
              Returns the determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionF.LogDeterminant">
            <summary>
              Returns the log-determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionF.LowerTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionF.UpperTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionF.PivotPermutationVector">
            <summary>
              Returns the pivot permutation vector.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.LuDecomposition">
            <summary>
              LU decomposition of a rectangular matrix.
            </summary>
            <remarks>
              <para>
                For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the LU decomposition is an m-by-n
                unit lower triangular matrix <c>L</c>, an n-by-n upper triangular matrix <c>U</c>,
                and a permutation vector <c>piv</c> of length m so that <c>A(piv) = L*U</c>.
                If m &lt; n, then <c>L</c> is m-by-m and <c>U</c> is m-by-n.</para>
              <para>
                The LU decomposition with pivoting always exists, even if the matrix is
                singular, so the constructor will never fail.  The primary use of the
                LU decomposition is in the solution of square systems of simultaneous
                linear equations. This will fail if <see cref="P:Accord.Math.Decompositions.LuDecomposition.Nonsingular"/> returns
                <see langword="false"/>.
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecomposition.#ctor(System.Double[0:,0:])">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecomposition.#ctor(System.Double[0:,0:],System.Boolean)">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecomposition.#ctor(System.Double[0:,0:],System.Boolean,System.Boolean)">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
            <param name="inPlace">True if the decomposition should be performed over the
            <paramref name="value"/> matrix rather than on a copy of it. If true, the
            matrix will be destroyed during the decomposition. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecomposition.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecomposition.Solve(System.Double[0:,0:])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecomposition.SolveTranspose(System.Double[0:,0:])">
            <summary>
              Solves a set of equation systems of type <c>X * A = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>Matrix <c>X</c> so that <c>X * L * U = A</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecomposition.Solve(System.Double[])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecomposition.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecomposition.Nonsingular">
            <summary>
              Returns if the matrix is non-singular (i.e. invertible).
              Please see remarks for important information regarding
              numerical stability when using this method.
            </summary>
            
            <remarks>
              Please keep in mind this is not one of the most reliable methods
              for checking singularity of a matrix. For a more reliable method,
              please use <see cref="M:Accord.Math.Matrix.IsSingular(System.Double[0:,0:])"/> or the 
              <see cref="T:Accord.Math.Decompositions.SingularValueDecomposition"/>.
            </remarks>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecomposition.Determinant">
            <summary>
              Returns the determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecomposition.LogDeterminant">
            <summary>
              Returns the log-determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecomposition.LowerTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecomposition.UpperTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecomposition.PivotPermutationVector">
            <summary>
              Returns the pivot permutation vector.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.LuDecompositionD">
            <summary>
              LU decomposition of a rectangular matrix.
            </summary>
            <remarks>
              <para>
                For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the LU decomposition is an m-by-n
                unit lower triangular matrix <c>L</c>, an n-by-n upper triangular matrix <c>U</c>,
                and a permutation vector <c>piv</c> of length m so that <c>A(piv) = L*U</c>.
                If m &lt; n, then <c>L</c> is m-by-m and <c>U</c> is m-by-n.</para>
              <para>
                The LU decomposition with pivoting always exists, even if the matrix is
                singular, so the constructor will never fail.  The primary use of the
                LU decomposition is in the solution of square systems of simultaneous
                linear equations. This will fail if <see cref="P:Accord.Math.Decompositions.LuDecompositionD.Nonsingular"/> returns
                <see langword="false"/>.
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionD.#ctor(System.Decimal[0:,0:])">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionD.#ctor(System.Decimal[0:,0:],System.Boolean)">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionD.#ctor(System.Decimal[0:,0:],System.Boolean,System.Boolean)">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
            <param name="inPlace">True if the decomposition should be performed over the
            <paramref name="value"/> matrix rather than on a copy of it. If true, the
            matrix will be destroyed during the decomposition. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionD.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionD.Solve(System.Decimal[0:,0:])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionD.SolveTranspose(System.Decimal[0:,0:])">
            <summary>
              Solves a set of equation systems of type <c>X * A = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>Matrix <c>X</c> so that <c>X * L * U = A</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionD.Solve(System.Decimal[])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionD.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionD.Nonsingular">
            <summary>
              Returns if the matrix is non-singular (i.e. invertible).
              Please see remarks for important information regarding
              numerical stability when using this method.
            </summary>
            
            <remarks>
              Please keep in mind this is not one of the most reliable methods
              for checking singularity of a matrix. For a more reliable method,
              please use <see cref="M:Accord.Math.Matrix.IsSingular(System.Double[0:,0:])"/> or the 
              <see cref="T:Accord.Math.Decompositions.SingularValueDecomposition"/>.
            </remarks>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionD.Determinant">
            <summary>
              Returns the determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionD.LogDeterminant">
            <summary>
              Returns the log-determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionD.LowerTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionD.UpperTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionD.PivotPermutationVector">
            <summary>
              Returns the pivot permutation vector.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.LuDecompositionF">
            <summary>
              LU decomposition of a rectangular matrix.
            </summary>
            <remarks>
              <para>
                For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the LU decomposition is an m-by-n
                unit lower triangular matrix <c>L</c>, an n-by-n upper triangular matrix <c>U</c>,
                and a permutation vector <c>piv</c> of length m so that <c>A(piv) = L*U</c>.
                If m &lt; n, then <c>L</c> is m-by-m and <c>U</c> is m-by-n.</para>
              <para>
                The LU decomposition with pivoting always exists, even if the matrix is
                singular, so the constructor will never fail.  The primary use of the
                LU decomposition is in the solution of square systems of simultaneous
                linear equations. This will fail if <see cref="P:Accord.Math.Decompositions.LuDecompositionF.Nonsingular"/> returns
                <see langword="false"/>.
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionF.#ctor(System.Single[0:,0:])">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionF.#ctor(System.Single[0:,0:],System.Boolean)">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionF.#ctor(System.Single[0:,0:],System.Boolean,System.Boolean)">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
            <param name="inPlace">True if the decomposition should be performed over the
            <paramref name="value"/> matrix rather than on a copy of it. If true, the
            matrix will be destroyed during the decomposition. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionF.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionF.Solve(System.Single[0:,0:])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionF.SolveTranspose(System.Single[0:,0:])">
            <summary>
              Solves a set of equation systems of type <c>X * A = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>Matrix <c>X</c> so that <c>X * L * U = A</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionF.Solve(System.Single[])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionF.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionF.Nonsingular">
            <summary>
              Returns if the matrix is non-singular (i.e. invertible).
              Please see remarks for important information regarding
              numerical stability when using this method.
            </summary>
            
            <remarks>
              Please keep in mind this is not one of the most reliable methods
              for checking singularity of a matrix. For a more reliable method,
              please use <see cref="M:Accord.Math.Matrix.IsSingular(System.Double[0:,0:])"/> or the 
              <see cref="T:Accord.Math.Decompositions.SingularValueDecomposition"/>.
            </remarks>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionF.Determinant">
            <summary>
              Returns the determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionF.LogDeterminant">
            <summary>
              Returns the log-determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionF.LowerTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionF.UpperTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionF.PivotPermutationVector">
            <summary>
              Returns the pivot permutation vector.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.NonnegativeMatrixFactorization">
            <summary>
              Nonnegative Matrix Factorization.
            </summary>
            
            <remarks>
            <para>
              Non-negative matrix factorization (NMF) is a group of algorithms in multivariate
              analysis and linear algebra where a matrix <c>X</c> is factorized into (usually)
              two matrices, <c>W</c> and <c>H</c>. The non-negative factorization enforces the
              constraint that the factors <c>W</c> and <c>H</c> must be non-negative, i.e., all
              elements must be equal to or greater than zero. The factorization is not unique.</para>
              
              <para>
                References:
                <list type="bullet">
                  <item><description>
                    <a href="http://en.wikipedia.org/wiki/Non-negative_matrix_factorization">
                    http://en.wikipedia.org/wiki/Non-negative_matrix_factorization </a>
                  </description></item>
                  <item><description>
                    Lee, D., Seung, H., 1999. Learning the Parts of Objects by Non-Negative
                    Matrix Factorization. Nature 401, 788â€“791. </description></item>
                  <item><description>
                    Michael W. Berry, et al. (June 2006). Algorithms and Applications for 
                    Approximate Nonnegative Matrix Factorization. </description></item>
                </list>
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.NonnegativeMatrixFactorization.#ctor(System.Double[0:,0:],System.Int32)">
            <summary>
              Initializes a new instance of the NMF algorithm
            </summary>
            
            <param name="value">The input data matrix (must be positive).</param>
            <param name="r">The reduced dimension.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.NonnegativeMatrixFactorization.#ctor(System.Double[0:,0:],System.Int32,System.Int32)">
            <summary>
              Initializes a new instance of the NMF algorithm
            </summary>
            
            <param name="value">The input data matrix (must be positive).</param>
            <param name="r">The reduced dimension.</param>
            <param name="maxiter">The number of iterations to perform.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.NonnegativeMatrixFactorization.compute(System.Int32)">
            <summary>
               Performs NMF using the multiplicative method
            </summary>
            
            <param name="maxiter">The maximum number of iterations</param>
            
            <remarks>
              At the end of the computation H contains the projected data
              and W contains the weights. The multiplicative method is the
              simplest factorization method.
            </remarks>
            
        </member>
        <member name="P:Accord.Math.Decompositions.NonnegativeMatrixFactorization.LeftNonnegativeFactors">
            <summary>
              Gets the nonnegative factor matrix W.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.NonnegativeMatrixFactorization.RightNonnegativeFactors">
            <summary>
              Gets the nonnegative factor matrix H.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Distance">
            <summary>
              Static class Distance. Defines a set of extension methods defining distance measures.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Distance.BrayCurtis(System.Double[],System.Double[])">
            <summary>
            Gets the Bray Curtis distance between two points.
            </summary>
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            <returns>The Bray Curtis distance between x and y.</returns>
        </member>
        <member name="M:Accord.Math.Distance.Canberra(System.Double[],System.Double[])">
            <summary>
            Gets the Canberra distance between two points.
            </summary>
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            <returns>The Canberra distance between x and y.</returns>
        </member>
        <member name="M:Accord.Math.Distance.Chessboard(System.Double[],System.Double[])">
            <summary>
            Gets the Chessboard distance between two points.
            </summary>
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            <returns>The Chessboard distance between x and y.</returns>
        </member>
        <member name="M:Accord.Math.Distance.Correlation(System.Double[],System.Double[])">
            <summary>
            Gets the Correlation distance between two points.
            </summary>
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            <returns>The Correlation distance between x and y.</returns>
        </member>
        <member name="M:Accord.Math.Distance.Cosine(System.Double[],System.Double[])">
            <summary>
            Gets the Cosine distance between two points.
            </summary>
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            <returns>The Cosine distance between x and y.</returns>
        </member>
        <member name="M:Accord.Math.Distance.SquareMahalanobis(System.Double[],System.Double[],System.Double[0:,0:])">
            <summary>
              Gets the Square Mahalanobis distance between two points.
            </summary>
            
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            <param name="precision">
              The inverse of the covariance matrix of the distribution for the two points x and y.
            </param>
            
            <returns>The Square Mahalanobis distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.SquareMahalanobis(System.Double[],System.Double[],Accord.Math.Decompositions.SingularValueDecomposition)">
            <summary>
              Gets the Square Mahalanobis distance between two points.
            </summary>
            
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            <param name="covariance">
              The <see cref="T:Accord.Math.Decompositions.SingularValueDecomposition"/> of the covariance 
              matrix of the distribution for the two points x and y.
            </param>
            
            <returns>The Square Mahalanobis distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Mahalanobis(System.Double[],System.Double[],System.Double[0:,0:])">
            <summary>
              Gets the Mahalanobis distance between two points.
            </summary>
            
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            <param name="precision">
              The inverse of the covariance matrix of the distribution for the two points x and y.
            </param>
            
            <returns>The Mahalanobis distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Mahalanobis(System.Double[],System.Double[],Accord.Math.Decompositions.SingularValueDecomposition)">
            <summary>
              Gets the Mahalanobis distance between two points.
            </summary>
            
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            <param name="covariance">
              The <see cref="T:Accord.Math.Decompositions.SingularValueDecomposition"/> of the covariance 
              matrix of the distribution for the two points x and y.
            </param>
            
            <returns>The Mahalanobis distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Manhattan(System.Double[],System.Double[])">
            <summary>
              Gets the Manhattan distance between two points.
            </summary>
            
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            
            <returns>The Manhattan distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Manhattan(System.Int32[],System.Int32[])">
            <summary>
              Gets the Manhattan distance between two points.
            </summary>
            
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            
            <returns>The Manhattan distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Minkowski(System.Double[],System.Double[],System.Int32)">
            <summary>
              Gets the Minkowski distance between two points.
            </summary>
            
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            <param name="r">Factor.</param>
            
            <returns>The Minkowski distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Chebyshev(System.Double[],System.Double[])">
            <summary>
              Gets the Chebyshev distance between two points.
            </summary>
            
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            
            <returns>The Chebyshev distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.SquareEuclidean(System.Double[],System.Double[])">
            <summary>
              Gets the Square Euclidean distance between two points.
            </summary>
            
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            
            <returns>The Square Euclidean distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.SquareEuclidean(System.Double,System.Double,System.Double,System.Double)">
            <summary>
              Gets the Square Euclidean distance between two points.
            </summary>
            
            <param name="x1">The first coordinate of first point in space.</param>
            <param name="y1">The second coordinate of first point in space.</param>
            <param name="x2">The first coordinate of second point in space.</param>
            <param name="y2">The second coordinate of second point in space.</param>
            
            <returns>The Square Euclidean distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Euclidean(System.Double[],System.Double[])">
            <summary>
              Gets the Euclidean distance between two points.
            </summary>
            
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            
            <returns>The Euclidean distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Euclidean(System.Double,System.Double,System.Double,System.Double)">
            <summary>
              Gets the Euclidean distance between two points.
            </summary>
            
            <param name="x1">The first coordinate of first point in space.</param>
            <param name="y1">The second coordinate of first point in space.</param>
            <param name="x2">The first coordinate of second point in space.</param>
            <param name="y2">The second coordinate of second point in space.</param>
            
            <returns>The Euclidean distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Modular(System.Int32,System.Int32,System.Int32)">
            <summary>
              Gets the Modulo-m distance between two integers <c>a</c> and <c>b</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Distance.Modular(System.Double,System.Double,System.Double)">
            <summary>
              Gets the Modulo-m distance between two real values <c>a</c> and <c>b</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Distance.Bhattacharyya(System.Double[],System.Double[])">
            <summary>
              Bhattacharyya distance between two normalized histograms.
            </summary>
            
            <param name="histogram1">A normalized histogram.</param>
            <param name="histogram2">A normalized histogram.</param>
            <returns>The Bhattacharyya distance between the two histograms.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Hellinger(System.Double[],System.Double[])">
            <summary>
              Hellinger distance between two normalized histograms.
            </summary>
            
            <param name="histogram1">A normalized histogram.</param>
            <param name="histogram2">A normalized histogram.</param>
            <returns>The Hellinger distance between the two histograms.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Bhattacharyya(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Bhattacharyya distance between two matrices.
            </summary>
            
            <param name="x">The first matrix <c>x</c>.</param>
            <param name="y">The first matrix <c>y</c>.</param>
            
            <returns>The Bhattacharyya distance between the two matrices.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Bhattacharyya(System.Double[],System.Double[0:,0:],System.Double[],System.Double[0:,0:])">
            <summary>
              Bhattacharyya distance between two Gaussian distributions.
            </summary>
            
            <param name="meanX">Mean for the first distribution.</param>
            <param name="covX">Covariance matrix for the first distribution.</param>
            <param name="meanY">Mean for the second distribution.</param>
            <param name="covY">Covariance matrix for the second distribution.</param>
            
            <returns>The Bhattacharyya distance between the two distributions.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Bhattacharyya(System.Double[],System.Double[0:,0:],System.Double,System.Double[],System.Double[0:,0:],System.Double)">
            <summary>
              Bhattacharyya distance between two Gaussian distributions.
            </summary>
            
            <param name="meanX">Mean for the first distribution.</param>
            <param name="covX">Covariance matrix for the first distribution.</param>
            <param name="meanY">Mean for the second distribution.</param>
            <param name="covY">Covariance matrix for the second distribution.</param>
            <param name="lnDetCovX">The logarithm of the determinant for 
              the covariance matrix of the first distribution.</param>
            <param name="lnDetCovY">The logarithm of the determinant for 
              the covariance matrix of the second distribution.</param>
            
            <returns>The Bhattacharyya distance between the two distributions.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Levenshtein(System.String,System.String)">
            <summary>
              Levenshtein distance between two strings.
            </summary>
            
            <param name="x">The first string <c>x</c>.</param>
            <param name="y">The first string <c>y</c>.</param>
            
            <remarks>
              Based on the standard implementation available on Wikibooks:
              http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance
            </remarks>
            
            <returns></returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Levenshtein``1(``0[],``0[])">
            <summary>
              Levenshtein distance between two strings.
            </summary>
            
            <param name="x">The first string <c>x</c>.</param>
            <param name="y">The first string <c>y</c>.</param>
            
            <remarks>
              Based on the standard implementation available on Wikibooks:
              http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance
            </remarks>
            
            <returns></returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Hamming(System.Boolean[],System.Boolean[])">
            <summary>
              Hamming distance between two Boolean vectors.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Distance.Hamming(System.Double[],System.Double[])">
            <summary>
              Hamming distance between two double vectors
              containing only 0 (false) or 1 (true) values.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Distance.BitwiseHamming(System.Byte[],System.Byte[])">
            <summary>
              Bitwise hamming distance between two sequences of bytes.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Distance.BitwiseHamming(System.Collections.BitArray,System.Collections.BitArray)">
            <summary>
              Bitwise hamming distance between two bit arrays.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Distance.IsMetric(System.Func{System.Double[],System.Double[],System.Double})">
            <summary>
              Checks whether a function is a real metric distance, i.e. respects
              the triangle inequality. Please note that a function can still pass
              this test and not respect the triangle inequality.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Distance.IsMetric(System.Func{System.Int32[],System.Int32[],System.Double})">
            <summary>
              Checks whether a function is a real metric distance, i.e. respects
              the triangle inequality. Please note that a function can still pass
              this test and not respect the triangle inequality.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Environments.OctaveEnvironment">
             <summary>
               Programming environment for Octave.
             </summary>
            
             <remarks>
             <para>
               This class implements a Domain Specific Language (DSL) for
               C# which is remarkably similar to Octave. Please take a loook
               on what is possible to do using this class in the examples
               section.</para>
               
             <para>
               To use this class, inherit from <see cref="T:Accord.Math.Environments.OctaveEnvironment"/>.
               After this step, all code written inside your child class will
               be able to use the syntax below:</para>
             </remarks>
             
             <example>
             <para>
               Using the <c>mat</c> and <c>ret</c> keywords, it is possible
               to replicate most of the Octave environment inside plain C#
               code. The example below demonstrates how to compute the 
               Singular Value Decomposition of a matrix, which in turn was
               generated using <see cref="M:Accord.Math.Matrix.Magic(System.Int32)"/>.</para>
               
             <code>
               // Declare local matrices
               mat u = _, s = _, v = _; 
               
               // Compute a new mat
               mat M = magic(3) * 5;
               
               // Compute the SVD
               ret [u, s, v] = svd(M);
               
               // Write the matrix
               string str = u;
               
               /*
                    0.577350269189626 -0.707106781186548     0.408248290463863 
               u =  0.577350269189626 -1.48007149071427E-16 -0.816496580927726 
                    0.577350269189626  0.707106781186548     0.408248290463863
               */
             </code>
             
             <para>
               It is also possible to ignore certain parameters by
               providing a wildcard in the return structure:</para>
               
             <code>
               // Declare local matrices
               mat u = _, v = _; 
               
               // Compute a new mat
               mat M = magic(3) * 5;
               
               // Compute the SVD
               ret [u, _, v] = svd(M); // the second argument is omitted
             </code>
             
             <para>
               Standard matrix operations are also supported: </para>
               
             <code>
               
               mat I = eye(3); // 3x3 identity matrix
               
               mat A = I * 2;  // matrix-scalar multiplication
               
               Console.WriteLine(A);
               //
               //        2 0 0
               //    A = 0 2 0
               //        0 0 2
               
               mat B = ones(3, 6); // 3x6 unit matrix
               
               Console.WriteLine(B);
               //
               //        1 1 1 1 1 1
               //    B = 1 1 1 1 1 1
               //        1 1 1 1 1 1
               
               mat C = new double[,]
               {
                   { 2, 2, 2, 2, 2, 2 },
                   { 2, 0, 0, 0, 0, 2 },
                   { 2, 2, 2, 2, 2, 2 },
               };
               
               mat D = A * B - C;
               
               Console.WriteLine(D);
               //
               //        0 0 0 0 0 0
               //    C = 0 2 2 2 2 0
               //        0 0 0 0 0 0
             </code>
             </example>
             
             <seealso cref="T:Accord.Math.Matrix"/>
            
        </member>
        <member name="F:Accord.Math.Environments.OctaveEnvironment.pi">
            <summary>Pi.</summary>
        </member>
        <member name="F:Accord.Math.Environments.OctaveEnvironment.eps">
            <summary>Machine epsilon.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.eye(System.Int32)">
            <summary>Creates an identity matrix.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.inv(System.Double[0:,0:])">
            <summary>Inverts a matrix.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.pinv(System.Double[0:,0:])">
            <summary>Inverts a matrix.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.ones(System.Int32)">
            <summary>Creates a unit matrix.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.ones(System.Int32,System.Int32)">
            <summary>Creates a unit matrix.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.zeros(System.Int32)">
            <summary>Creates a unit matrix.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.zeros(System.Int32,System.Int32)">
            <summary>Creates a unit matrix.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.rand(System.Int32,System.Int32)">
            <summary>Random vector.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.size(System.Double[0:,0:])">
            <summary>Size of a matrix.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.rank(System.Double[0:,0:])">
            <summary>Rank of a matrix.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.sum(System.Double[0:,0:])">
            <summary>Matrix sum vector.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.sum(System.Double[])">
            <summary>Sum of vector elements.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.prod(System.Double[])">
            <summary>Product of vector elements.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.sum(System.Double[0:,0:],System.Int32)">
            <summary>Matrix sum vector.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.round(System.Double)">
            <summary>Rounding.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.ceil(System.Double)">
            <summary>Ceiling.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.floor(System.Double)">
            <summary>Flooring.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.round(System.Double[])">
            <summary>Rounding.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.ceil(System.Double[])">
            <summary>Ceiling.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.floor(System.Double[])">
            <summary>Flooring.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.round(System.Double[0:,0:])">
            <summary>Rounding.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.ceil(System.Double[0:,0:])">
            <summary>Ceiling.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.floor(System.Double[0:,0:])">
            <summary>Flooring.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.sin(System.Double)">
            <summary>Sin.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.cos(System.Double)">
            <summary>Cos.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.exp(System.Double)">
            <summary>Exponential value.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.abs(System.Double)">
            <summary>Absolute value.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.log(System.Double)">
            <summary>Logarithm.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.sin(System.Double[])">
            <summary>Sin.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.cos(System.Double[])">
            <summary>Cos.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.exp(System.Double[])">
            <summary>Exponential value.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.abs(System.Double[])">
            <summary>Absolute value.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.log(System.Double[])">
            <summary>Logarithm.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.sin(System.Double[0:,0:])">
            <summary>Sin.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.cos(System.Double[0:,0:])">
            <summary>Cos.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.exp(System.Double[0:,0:])">
            <summary>Exponential value.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.abs(System.Double[0:,0:])">
            <summary>Absolute value.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.log(System.Double[0:,0:])">
            <summary>Logarithm.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.magic(System.Int32)">
            <summary>Creates a magic square matrix.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.svd(System.Double[0:,0:])">
            <summary>Singular value decomposition.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.qr(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@)">
            <summary>QR decomposition.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.qr(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[]@)">
            <summary>QR decomposition.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.eig(System.Double[0:,0:],System.Double[0:,0:]@)">
            <summary>Eigenvalue decomposition.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.eig(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[]@)">
            <summary>Eigenvalue decomposition.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.eig(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:]@)">
            <summary>Eigenvalue decomposition.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.eig(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:]@,System.Double[]@)">
            <summary>Eigenvalue decomposition.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.eig(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:]@,System.Double[]@,System.Double[]@)">
            <summary>Eigenvalue decomposition.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.eig(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:]@,System.Double[]@,System.Double[]@,System.Double[]@,System.Double[]@)">
            <summary>Eigenvalue decomposition.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.chol(System.Double[0:,0:])">
            <summary>Cholesky decomposition.</summary>
        </member>
        <member name="F:Accord.Math.Environments.OctaveEnvironment.ret">
            <summary>
              Return setter keyword.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Environments.OctaveEnvironment"/> class.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Environments.OctaveEnvironment.UseOctaveDimensionIndexing">
            <summary>
              Whether to use octave indexing or not.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Environments.OctaveEnvironment._">
            <summary>
              Matrix placeholder.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Environments.OctaveEnvironment.retm">
            <summary>
              Return definition operator.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Environments.OctaveEnvironment.retm.Item(Accord.Math.Environments.OctaveEnvironment.mat[])">
            <summary>
              Can be used to set output arguments
              to the output of another function.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Environments.OctaveEnvironment.mat">
            <summary>
              Matrix definition operator.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Environments.OctaveEnvironment.mat.matrix">
            <summary>
              Inner matrix object.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.#ctor(System.Double[0:,0:])">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Environments.OctaveEnvironment.mat"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Multiply(Accord.Math.Environments.OctaveEnvironment.mat,Accord.Math.Environments.OctaveEnvironment.mat)">
            <summary>
              Multiplication operator
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Multiply(Accord.Math.Environments.OctaveEnvironment.mat,System.Double)">
            <summary>
              Multiplication operator
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Multiply(System.Double,Accord.Math.Environments.OctaveEnvironment.mat)">
            <summary>
              Multiplication operator
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Addition(Accord.Math.Environments.OctaveEnvironment.mat,System.Double)">
            <summary>
              Addition operator
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Addition(System.Double,Accord.Math.Environments.OctaveEnvironment.mat)">
            <summary>
              Addition operator
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Addition(Accord.Math.Environments.OctaveEnvironment.mat,Accord.Math.Environments.OctaveEnvironment.mat)">
            <summary>
              Addition operator
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Subtraction(Accord.Math.Environments.OctaveEnvironment.mat,Accord.Math.Environments.OctaveEnvironment.mat)">
            <summary>
              Subtraction operator
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Subtraction(Accord.Math.Environments.OctaveEnvironment.mat,System.Double)">
            <summary>
              Subtraction operator
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Subtraction(System.Double,Accord.Math.Environments.OctaveEnvironment.mat)">
            <summary>
              Subtraction operator
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Equality(Accord.Math.Environments.OctaveEnvironment.mat,Accord.Math.Environments.OctaveEnvironment.mat)">
            <summary>
              Equality operator.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Inequality(Accord.Math.Environments.OctaveEnvironment.mat,Accord.Math.Environments.OctaveEnvironment.mat)">
            <summary>
              Inequality operator.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Implicit(System.Double[0:,0:])~Accord.Math.Environments.OctaveEnvironment.mat">
            <summary>
              Implicit conversion from double[,].
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Implicit(Accord.Math.Environments.OctaveEnvironment.mat)~System.Double[0:,0:]">
            <summary>
              Implicit conversion to double[,].
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Implicit(Accord.Math.Environments.OctaveEnvironment.mat)~System.String">
            <summary>
              Implicit conversion to string.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Implicit(System.Collections.Generic.List{Accord.Math.Environments.OctaveEnvironment.mat})~Accord.Math.Environments.OctaveEnvironment.mat">
            <summary>
              Implicit conversion from list.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.Equals(System.Object)">
            <summary>
              Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.GetHashCode">
            <summary>
              Returns a hash code for this instance.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Environments.OctaveEnvironment.mat.t">
            <summary>
              Transpose operator.
            </summary>
            
        </member>
        <member name="T:Accord.Math.IMatrixFormatProvider">
            <summary>
              Common interface for Matrix format providers.
            </summary>
            
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.FormatMatrixStart">
            <summary>A string denoting the start of the matrix to be used in formatting.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.FormatMatrixEnd">
            <summary>A string denoting the end of the matrix to be used in formatting.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.FormatRowStart">
            <summary>A string denoting the start of a matrix row to be used in formatting.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.FormatRowEnd">
            <summary>A string denoting the end of a matrix row to be used in formatting.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.FormatColStart">
            <summary>A string denoting the start of a matrix column to be used in formatting.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.FormatColEnd">
            <summary>A string denoting the end of a matrix column to be used in formatting.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.FormatRowDelimiter">
            <summary>A string containing the row delimiter for a matrix to be used in formatting.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.FormatColDelimiter">
            <summary>A string containing the column delimiter for a matrix to be used in formatting.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.ParseMatrixStart">
            <summary>A string denoting the start of the matrix to be used in parsing.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.ParseMatrixEnd">
            <summary>A string denoting the end of the matrix to be used in parsing.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.ParseRowStart">
            <summary>A string denoting the start of a matrix row to be used in parsing.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.ParseRowEnd">
            <summary>A string denoting the end of a matrix row to be used in parsing.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.ParseColStart">
            <summary>A string denoting the start of a matrix column to be used in parsing.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.ParseColEnd">
            <summary>A string denoting the end of a matrix column to be used in parsing.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.ParseRowDelimiter">
            <summary>A string containing the row delimiter for a matrix to be used in parsing.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.ParseColDelimiter">
            <summary>A string containing the column delimiter for a matrix to be used in parsing.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.InnerProvider">
            <summary>
              Gets the culture specific formatting information
              to be used during parsing or formatting.
            </summary>
        </member>
        <member name="T:Accord.Math.MatrixFormatProviderBase">
            <summary>
              Base class for IMatrixFormatProvider implementers.
            </summary>
            
        </member>
        <member name="M:Accord.Math.MatrixFormatProviderBase.#ctor(System.IFormatProvider)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.MatrixFormatProviderBase"/> class.
            </summary>
            
            <param name="innerProvider">The inner format provider.</param>
            
        </member>
        <member name="M:Accord.Math.MatrixFormatProviderBase.GetFormat(System.Type)">
            <summary>
              Returns an object that provides formatting services for the specified
              type. Currently, only <see cref="T:Accord.Math.IMatrixFormatProvider"/> is supported.
            </summary>
            <param name="formatType">
              An object that specifies the type of format
              object to return. </param>
            <returns>
              An instance of the object specified by formatType, if the
              <see cref="T:System.IFormatProvider">IFormatProvider</see> implementation
              can supply that type of object; otherwise, null.</returns>
              
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.FormatMatrixStart">
            <summary>
            A string denoting the start of the matrix to be used in formatting.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.FormatMatrixEnd">
            <summary>
            A string denoting the end of the matrix to be used in formatting.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.FormatRowStart">
            <summary>
            A string denoting the start of a matrix row to be used in formatting.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.FormatRowEnd">
            <summary>
            A string denoting the end of a matrix row to be used in formatting.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.FormatColStart">
            <summary>
            A string denoting the start of a matrix column to be used in formatting.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.FormatColEnd">
            <summary>
            A string denoting the end of a matrix column to be used in formatting.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.FormatRowDelimiter">
            <summary>
            A string containing the row delimiter for a matrix to be used in formatting.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.FormatColDelimiter">
            <summary>
            A string containing the column delimiter for a matrix to be used in formatting.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.ParseMatrixStart">
            <summary>
            A string denoting the start of the matrix to be used in parsing.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.ParseMatrixEnd">
            <summary>
            A string denoting the end of the matrix to be used in parsing.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.ParseRowStart">
            <summary>
            A string denoting the start of a matrix row to be used in parsing.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.ParseRowEnd">
            <summary>
            A string denoting the end of a matrix row to be used in parsing.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.ParseColStart">
            <summary>
            A string denoting the start of a matrix column to be used in parsing.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.ParseColEnd">
            <summary>
            A string denoting the end of a matrix column to be used in parsing.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.ParseRowDelimiter">
            <summary>
            A string containing the row delimiter for a matrix to be used in parsing.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.ParseColDelimiter">
            <summary>
            A string containing the column delimiter for a matrix to be used in parsing.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.InnerProvider">
            <summary>
              Gets the culture specific formatting information
              to be used during parsing or formatting.
            </summary>
            
        </member>
        <member name="T:Accord.Math.OctaveArrayFormatProvider">
            <summary>
              Format provider for the matrix format used by Octave.
            </summary>
            
            <example>
            <para>
              Converting from a multidimensional matrix to a 
              string representation:</para>
              
            <code>
              // Declare a number array
              double[,] x = 
              {
                 { 1, 2, 3, 4 },
                 { 5, 6, 7, 8 },
              };
              
              // Convert the aforementioned array to a string representation:
              string str = x.ToString(OctaveArrayFormatProvider.CurrentCulture);
              
              // the final result will be equivalent to
              "[ 1, 2, 3, 4]"
            </code>
            
            <para>
              Converting from strings to actual matrices:</para>
            
            <code>
              // Declare an input string
              string str = "[ 1, 2, 3, 4]";
              
              // Convert the string representation to an actual number array:
              double[] array = Matrix.Parse(str, OctaveArrayFormatProvider.InvariantCulture);
              
              // array will now contain the actual number 
              // array representation of the given string.
            </code>
            </example>
            
            <seealso cref="T:Accord.Math.Matrix"/>
            <seealso cref="T:Accord.Math.CSharpMatrixFormatProvider"/>
            
            <seealso cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>
            <seealso cref="T:Accord.Math.CSharpArrayFormatProvider"/>
            
            <seealso cref="T:Accord.Math.OctaveMatrixFormatProvider"/>
            <seealso cref="T:Accord.Math.OctaveArrayFormatProvider"/>
            
        </member>
        <member name="M:Accord.Math.OctaveArrayFormatProvider.#ctor(System.IFormatProvider)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.OctaveMatrixFormatProvider"/> class.
            </summary>
            
        </member>
        <member name="P:Accord.Math.OctaveArrayFormatProvider.CurrentCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the CultureInfo used by the current thread.
            </summary>
            
        </member>
        <member name="P:Accord.Math.OctaveArrayFormatProvider.InvariantCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the invariant system culture.
            </summary>
            
        </member>
        <member name="T:Accord.Math.DefaultArrayFormatProvider">
            <summary>
              Gets the default matrix representation, where each row
              is separated by a new line, and columns are separated by spaces.
            </summary>
            
            <remarks>
              This class can be used to convert to and from C#
              arrays and their string representation. Please 
              see the example for details.
            </remarks>
            
            <example>
            <para>
              Converting from an array matrix to a 
              string representation:</para>
              
            <code>
              // Declare a number array
              double[] x = { 5, 6, 7, 8 };
              
              // Convert the aforementioned array to a string representation:
              string str = x.ToString(DefaultArrayFormatProvider.CurrentCulture);
              
              // the final result will be equivalent to
              "5, 6, 7, 8"
            </code>
            
            <para>
              Converting from strings to actual matrices:</para>
            
            <code>
              // Declare an input string
              string str = "5, 6, 7, 8";
              
              // Convert the string representation to an actual number array:
              double[] array = Matrix.Parse(str, DefaultArrayFormatProvider.InvariantCulture);
              
              // array will now contain the actual number 
              // array representation of the given string.
            </code>
            </example>
            
            <seealso cref="T:Accord.Math.Matrix"/>
            <seealso cref="T:Accord.Math.CSharpMatrixFormatProvider"/>
            
            <seealso cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>
            <seealso cref="T:Accord.Math.CSharpArrayFormatProvider"/>
            
            <seealso cref="T:Accord.Math.OctaveMatrixFormatProvider"/>
            <seealso cref="T:Accord.Math.OctaveArrayFormatProvider"/>
            
        </member>
        <member name="M:Accord.Math.DefaultArrayFormatProvider.#ctor(System.IFormatProvider)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.DefaultArrayFormatProvider"/> class.
            </summary>
            
        </member>
        <member name="P:Accord.Math.DefaultArrayFormatProvider.CurrentCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the CultureInfo used by the current thread.
            </summary>
            
        </member>
        <member name="P:Accord.Math.DefaultArrayFormatProvider.InvariantCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the invariant system culture.
            </summary>
            
        </member>
        <member name="T:Accord.Math.CSharpArrayFormatProvider">
            <summary>
              Gets the matrix representation used in C# multi-dimensional arrays.
            </summary>
            
            <remarks>
              This class can be used to convert to and from C#
              arrays and their string representation. Please 
              see the example for details.
            </remarks>
            
            <example>
            <para>
              Converting from an array to a string representation:</para>
              
            <code>
              // Declare a number array
              double[] x = { 1, 2, 3, 4 };
              
              // Convert the aforementioned array to a string representation:
              string str = x.ToString(CSharpArrayFormatProvider.CurrentCulture);
              
              // the final result will be
              "double[] x = { 1, 2, 3, 4 }"
            </code>
            
            <para>
              Converting from strings to actual arrays:</para>
            
            <code>
              // Declare an input string
              string str = "double[] { 1, 2, 3, 4 }";
              
              // Convert the string representation to an actual number array:
              double[] array = Matrix.Parse(str, CSharpArrayFormatProvider.InvariantCulture);
              
              // array will now contain the actual number 
              // array representation of the given string.
            </code>
            </example>
            
            <seealso cref="T:Accord.Math.Matrix"/>
            <seealso cref="T:Accord.Math.CSharpMatrixFormatProvider"/>
            
            <seealso cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>
            <seealso cref="T:Accord.Math.CSharpArrayFormatProvider"/>
            
            <seealso cref="T:Accord.Math.OctaveMatrixFormatProvider"/>
            <seealso cref="T:Accord.Math.OctaveArrayFormatProvider"/>
            
        </member>
        <member name="M:Accord.Math.CSharpArrayFormatProvider.#ctor(System.IFormatProvider,System.Boolean,System.Boolean)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/> class.
            </summary>
            
        </member>
        <member name="P:Accord.Math.CSharpArrayFormatProvider.CurrentCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the CultureInfo used by the current thread.
            </summary>
            
        </member>
        <member name="P:Accord.Math.CSharpArrayFormatProvider.InvariantCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the invariant system culture.
            </summary>
            
        </member>
        <member name="T:Accord.Math.CSharpMatrixFormatProvider">
            <summary>
              Gets the matrix representation used in C# multi-dimensional arrays.
            </summary>
            
            <remarks>
              This class can be used to convert to and from C#
              matrices and their string representation. Please 
              see the example for details.
            </remarks>
            
            <example>
            <para>
              Converting from a multidimensional matrix to a 
              string representation:</para>
              
            <code>
              // Declare a number array
              double[,] x = 
              {
                 { 1, 2, 3, 4 },
                 { 5, 6, 7, 8 },
              };
              
              // Convert the aforementioned array to a string representation:
              string str = x.ToString(CSharpMatrixFormatProvider.CurrentCulture);
              
              // the final result will be equivalent to
              "double[,] x =      " +
              "{                  " +
              "   { 1, 2, 3, 4 }, " +
              "   { 5, 6, 7, 8 }, " +
              "}"
            </code>
            
            <para>
              Converting from strings to actual matrices:</para>
            
            <code>
              // Declare an input string
              string str = "double[,] x = " +
              "{                          " +
              "   { 1, 2, 3, 4 },         " +
              "   { 5, 6, 7, 8 },         " +
              "}";
              
              // Convert the string representation to an actual number array:
              double[,] matrix = Matrix.Parse(str, CSharpMatrixFormatProvider.InvariantCulture);
              
              // matrix will now contain the actual multidimensional 
              // matrix representation of the given string.
            </code>
            </example>
            
            <seealso cref="T:Accord.Math.Matrix"/>
            <seealso cref="T:Accord.Math.CSharpMatrixFormatProvider"/>
            
            <seealso cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>
            <seealso cref="T:Accord.Math.CSharpArrayFormatProvider"/>
            
            <seealso cref="T:Accord.Math.OctaveMatrixFormatProvider"/>
            <seealso cref="T:Accord.Math.OctaveArrayFormatProvider"/>
            
        </member>
        <member name="M:Accord.Math.CSharpMatrixFormatProvider.#ctor(System.IFormatProvider)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/> class.
            </summary>
            
        </member>
        <member name="P:Accord.Math.CSharpMatrixFormatProvider.CurrentCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the CultureInfo used by the current thread.
            </summary>
            
        </member>
        <member name="P:Accord.Math.CSharpMatrixFormatProvider.InvariantCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the invariant system culture.
            </summary>
            
        </member>
        <member name="T:Accord.Math.CSharpJaggedMatrixFormatProvider">
            <summary>
              Gets the matrix representation used in C# jagged arrays.
            </summary>
            
            <remarks>
              This class can be used to convert to and from C#
              arrays and their string representation. Please 
              see the example for details.
            </remarks>
            
            <example>
            <para>
              Converting from a jagged matrix to a string representation:</para>
              
            <code>
              // Declare a number array
              double[][] x = 
              {
                 new double[] { 1, 2, 3, 4 },
                 new double[] { 5, 6, 7, 8 },
              };
              
              // Convert the aforementioned array to a string representation:
              string str = x.ToString(CSharpJaggedMatrixFormatProvider.CurrentCulture);
              
              // the final result will be equivalent to
              "double[][] x =                  " +
              "{                               " +
              "   new double[] { 1, 2, 3, 4 }, " +
              "   new double[] { 5, 6, 7, 8 }, " +
              "}"
            </code>
            
            <para>
              Converting from strings to actual arrays:</para>
            
            <code>
              // Declare an input string
              string str = "double[][] x =     " +
              "{                               " +
              "   new double[] { 1, 2, 3, 4 }, " +
              "   new double[] { 5, 6, 7, 8 }, " +
              "}";
              
              // Convert the string representation to an actual number array:
              double[][] array = Matrix.Parse(str, CSharpJaggedMatrixFormatProvider.InvariantCulture);
              
              // array will now contain the actual jagged 
              // array representation of the given string.
            </code>
            </example>
            
            <seealso cref="T:Accord.Math.Matrix"/>
            <seealso cref="T:Accord.Math.CSharpMatrixFormatProvider"/>
            
            <seealso cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>
            <seealso cref="T:Accord.Math.CSharpArrayFormatProvider"/>
            
            <seealso cref="T:Accord.Math.OctaveMatrixFormatProvider"/>
            <seealso cref="T:Accord.Math.OctaveArrayFormatProvider"/>
            
        </member>
        <member name="M:Accord.Math.CSharpJaggedMatrixFormatProvider.#ctor(System.IFormatProvider)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/> class.
            </summary>
            
        </member>
        <member name="P:Accord.Math.CSharpJaggedMatrixFormatProvider.CurrentCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the CultureInfo used by the current thread.
            </summary>
            
        </member>
        <member name="P:Accord.Math.CSharpJaggedMatrixFormatProvider.InvariantCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the invariant system culture.
            </summary>
            
        </member>
        <member name="T:Accord.Math.DefaultMatrixFormatProvider">
            <summary>
              Gets the default matrix representation, where each row
              is separated by a new line, and columns are separated by spaces.
            </summary>
            
            <remarks>
              This class can be used to convert to and from C#
              matrices and their string representation. Please 
              see the example for details.
            </remarks>
            
            <example>
            <para>
              Converting from a multidimensional matrix to a 
              string representation:</para>
              
            <code>
              // Declare a number array
              double[,] x = 
              {
                 { 1, 2, 3, 4 },
                 { 5, 6, 7, 8 },
              };
              
              // Convert the aforementioned array to a string representation:
              string str = x.ToString(DefaultMatrixFormatProvider.CurrentCulture);
              
              // the final result will be equivalent to
              @"1, 2, 3, 4
                5, 6, 7, 8";
            </code>
            
            <para>
              Converting from strings to actual matrices:</para>
            
            <code>
              // Declare an input string
              string str = @"1, 2, 3, 4
                            "5, 6, 7, 8";
              
              // Convert the string representation to an actual number array:
              double[,] matrix = Matrix.Parse(str, DefaultMatrixFormatProvider.InvariantCulture);
              
              // matrix will now contain the actual multidimensional 
              // matrix representation of the given string.
            </code>
            </example>
            
            <seealso cref="T:Accord.Math.Matrix"/>
            <seealso cref="T:Accord.Math.CSharpMatrixFormatProvider"/>
            
            <seealso cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>
            <seealso cref="T:Accord.Math.CSharpArrayFormatProvider"/>
            
            <seealso cref="T:Accord.Math.OctaveMatrixFormatProvider"/>
            <seealso cref="T:Accord.Math.OctaveArrayFormatProvider"/>
            
        </member>
        <member name="M:Accord.Math.DefaultMatrixFormatProvider.#ctor(System.IFormatProvider)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.DefaultMatrixFormatProvider"/> class.
            </summary>
            
        </member>
        <member name="P:Accord.Math.DefaultMatrixFormatProvider.CurrentCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the CultureInfo used by the current thread.
            </summary>
            
        </member>
        <member name="P:Accord.Math.DefaultMatrixFormatProvider.InvariantCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the invariant system culture.
            </summary>
            
        </member>
        <member name="T:Accord.Math.MatrixFormatter">
            <summary>
              Defines how matrices are formatted and displayed, depending on the
              chosen format representation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.MatrixFormatter.Format(System.String,System.Object,System.IFormatProvider)">
            <summary>
              Converts the value of a specified object to an equivalent string
              representation using specified formatting information.
            </summary>
            <param name="format">A format string containing formatting specifications.</param>
            <param name="arg">An object to format.</param>
            <param name="formatProvider">
              An <see cref="T:System.IFormatProvider"/> object that supplies
              format information about the current instance.</param>
            <returns>
              The string representation of the value of <paramref name="arg"/>,
              formatted as specified by <paramref name="format"/> and
              <paramref name="formatProvider"/>.
            </returns>
            
        </member>
        <member name="M:Accord.Math.MatrixFormatter.Format(System.String,System.Array,Accord.Math.IMatrixFormatProvider)">
            <summary>
              Converts a jagged or multidimensional array into a <a cref="T:System.String">System.String</a> representation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.MatrixFormatter.parseOptions(System.String,System.String@,System.String@)">
            <summary>
              Parses a format string containing the format options for the matrix representation.
            </summary>
        </member>
        <member name="M:Accord.Math.MatrixFormatter.handleOtherFormats(System.String,System.Object,System.IFormatProvider)">
            <summary>
              Handles formatting for objects other than matrices.
            </summary>
        </member>
        <member name="M:Accord.Math.MatrixFormatter.ParseJagged(System.String,Accord.Math.IMatrixFormatProvider)">
            <summary>
              Converts a matrix represented in a System.String into a jagged array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.MatrixFormatter.ParseMultidimensional(System.String,Accord.Math.IMatrixFormatProvider)">
            <summary>
              Converts a matrix represented in a System.String into a multi-dimensional array.
            </summary>
            
        </member>
        <member name="T:Accord.Math.OctaveMatrixFormatProvider">
            <summary>
              Format provider for the matrix format used by Octave.
            </summary>
            
            <remarks>
              This class can be used to convert to and from C#
              matrices and their string representation. Please 
              see the example for details.
            </remarks>
            
            <remarks>
              This class can be used to convert to and from C#
              matrices and their string representation. Please 
              see the example for details.
            </remarks>
            
            <example>
            <para>
              Converting from a multidimensional matrix to a 
              string representation:</para>
              
            <code>
              // Declare a number array
              double[,] x = 
              {
                 { 1, 2, 3, 4 },
                 { 5, 6, 7, 8 },
              };
              
              // Convert the aforementioned array to a string representation:
              string str = x.ToString(OctaveMatrixFormatProvider.CurrentCulture);
              
              // the final result will be equivalent to
              "[ 1, 2, 3, 4; 5, 6, 7, 8 ]"
            </code>
            
            <para>
              Converting from strings to actual matrices:</para>
            
            <code>
              // Declare an input string
              string str = "[ 1, 2, 3, 4; 5, 6, 7, 8 ]";
              
              // Convert the string representation to an actual number array:
              double[,] matrix = Matrix.Parse(str, OctaveMatrixFormatProvider.InvariantCulture);
              
              // matrix will now contain the actual multidimensional 
              // matrix representation of the given string.
            </code>
            </example>
            
            <seealso cref="T:Accord.Math.Matrix"/>
            <seealso cref="T:Accord.Math.CSharpMatrixFormatProvider"/>
            
            <seealso cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>
            <seealso cref="T:Accord.Math.CSharpArrayFormatProvider"/>
            
            <seealso cref="T:Accord.Math.OctaveMatrixFormatProvider"/>
            <seealso cref="T:Accord.Math.OctaveArrayFormatProvider"/>
            
        </member>
        <member name="M:Accord.Math.OctaveMatrixFormatProvider.#ctor(System.IFormatProvider)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.OctaveMatrixFormatProvider"/> class.
            </summary>
            
        </member>
        <member name="P:Accord.Math.OctaveMatrixFormatProvider.CurrentCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the CultureInfo used by the current thread.
            </summary>
            
        </member>
        <member name="P:Accord.Math.OctaveMatrixFormatProvider.InvariantCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the invariant system culture.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Normal">
            <summary>
              Normal distribution functions.
            </summary>
             
            <remarks>
              References:
              <list type="bullet">
                <item><description>
                  Cephes Math Library, http://www.netlib.org/cephes/ </description></item>
                <item><description>
                  George Marsaglia, Evaluating the Normal Distribution, 2004.
                  Available in: http://www.jstatsoft.org/v11/a05/paper </description></item>
              </list>
            </remarks>
            
            <example>
            <para>
              The following example shows the normal usages for the Normal functions:
            </para>
            
            <code>
              // Compute standard precision functions
              double phi  = Normal.Function(0.42);     //  0.66275727315175048
              double phic = Normal.Complemented(0.42); //  0.33724272684824952
              double inv  = Normal.Inverse(0.42);      // -0.20189347914185085
              
              // Compute at the limits
              double phi  = Normal.Function(16.6);     //  1.0
              double phic = Normal.Complemented(16.6); //  3.4845465199504055E-62
            </code>
            
            </example>
            
        </member>
        <member name="M:Accord.Math.Normal.Function(System.Double)">
            <summary>
              Normal cumulative distribution function.
            </summary>
            
            <returns>
              The area under the Gaussian p.d.f. integrated
              from minus infinity to the given value.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Normal.Complemented(System.Double)">
            <summary>
              Complemented cumulative distribution function.
            </summary>
            
            <returns>
              The area under the Gaussian p.d.f. integrated
              from the given value to positive infinity.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Normal.Inverse(System.Double)">
            <summary>
               Normal (Gaussian) inverse cumulative distribution function.
            </summary>
            
            <remarks>
            <para>
               For small arguments <c>0 &lt; y &lt; exp(-2)</c>, the program computes <c>z =
               sqrt( -2.0 * log(y) )</c>;  then the approximation is <c>x = z - log(z)/z  - 
               (1/z) P(1/z) / Q(1/z)</c>.</para>
            <para>
               There are two rational functions P/Q, one for <c>0 &lt; y &lt; exp(-32)</c> and
               the other for <c>y</c> up to <c>exp(-2)</c>. For larger arguments, <c>w = y - 0.5</c>,
               and  <c>x/sqrt(2pi) = w + w^3 * R(w^2)/S(w^2))</c>.</para>
            </remarks>
            
            <returns>
               Returns the value, <c>x</c>, for which the area under the Normal (Gaussian)
               probability density function (integrated from minus infinity to <c>x</c>) is
               equal to the argument <c>y</c> (assumes mean is zero, variance is one).
            </returns>
            
        </member>
        <member name="M:Accord.Math.Normal.HighAccuracyFunction(System.Double)">
            <summary>
              High-accuracy Normal cumulative distribution function.
            </summary>
            
            <remarks>
            <para>
              The following formula provide probabilities with an absolute error
              less than 8e-16.</para>
            <para>
              References:
               - George Marsaglia, Evaluating the Normal Distribution, 2004.
                 Available in: http://www.jstatsoft.org/v11/a05/paper </para>  
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Normal.HighAccuracyComplemented(System.Double)">
            <summary>
              High-accuracy Complementary normal distribution function.
            </summary>
            
            <remarks>
            <para>
              This function uses 9 tabled values to provide tail values of the
              normal distribution, also known as complementary Phi, with an
              absolute error of 1e-14 ~ 1e-16.
            </para>
              References:
               - George Marsaglia, Evaluating the Normal Distribution, 2004.
                 Available in: http://www.jstatsoft.org/v11/a05/paper
            </remarks>
            
            <returns>
              The area under the Gaussian p.d.f. integrated
              from the given value to positive infinity.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Normal.Bivariate(System.Double,System.Double,System.Double)">
            <summary>
              Bivariate normal cumulative distribution function.
            </summary>
            
            <param name="x">The value of the first variate.</param>
            <param name="y">The value of the second variate.</param>
            <param name="rho">The correlation coefficient between x and y. This can be computed
            from a covariance matrix C as  <code>rho = C_12 / (sqrt(C_11) * sqrt(C_22))</code>.</param>
            <returns></returns>
            
        </member>
        <member name="M:Accord.Math.Normal.BivariateComplemented(System.Double,System.Double,System.Double)">
            <summary>
              Complemented bivariate normal cumulative distribution function.
            </summary>
            
            <param name="x">The value of the first variate.</param>
            <param name="y">The value of the second variate.</param>
            <param name="rho">The correlation coefficient between x and y. This can be computed
            from a covariance matrix C as  <code>rho = C_12 / (sqrt(C_11) * sqrt(C_22))</code>.</param>
            <returns></returns>
            
        </member>
        <member name="M:Accord.Math.Normal.BVND(System.Double,System.Double,System.Double)">
            <summary>
              A function for computing bivariate normal probabilities. 
              BVND calculates the probability that X > DH and Y > DK.
            </summary>
            
            <remarks>
            <para>
              This method is based on the work done by Alan Genz, Department of 
              Mathematics, Washington State University. Pullman, WA 99164-3113
              Email: alangenz@wsu.edu. This work was shared under a 3-clause BSD
              license. Please see source file for more details and the actual
              license text.</para>
              
            <para>
              This function is based on the method described by Drezner, Z and G.O.
              Wesolowsky, (1989), On the computation of the bivariate normal integral,
              Journal of Statist. Comput. Simul. 35, pp. 101-107, with major modifications
              for double precision, and for |R| close to 1.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Normal.Derivative(System.Double)">
            <summary>
              First derivative of <see cref="M:Accord.Math.Normal.Function(System.Double)">Normal cumulative 
              distribution function</see>, also known as the Normal density
              function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Normal.LogDerivative(System.Double)">
            <summary>
              Log of the first derivative of <see cref="M:Accord.Math.Normal.Function(System.Double)">Normal cumulative 
              distribution function</see>, also known as the Normal density function.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Geometry.ConvexHullDefects">
            <summary>
              Convex Hull Defects Extractor.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Geometry.ConvexHullDefects.#ctor(System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Geometry.ConvexHullDefects"/> class.
            </summary>
            
            <param name="minDepth">The minimum depth which characterizes a convexity defect.</param>
            
        </member>
        <member name="M:Accord.Math.Geometry.ConvexHullDefects.FindDefects(System.Collections.Generic.List{AForge.IntPoint},System.Collections.Generic.List{AForge.IntPoint})">
            <summary>
              Finds the convexity defects in a contour given a convex hull.
            </summary>
            
            <param name="contour">The contour.</param>
            <param name="convexHull">The convex hull of the contour.</param>
            <returns>A list of <see cref="T:Accord.Math.Geometry.ConvexityDefect"/>s containing each of the
            defects found considering the convex hull of the contour.</returns>
            
        </member>
        <member name="P:Accord.Math.Geometry.ConvexHullDefects.MinimumDepth">
            <summary>
            Gets or sets the minimum depth which characterizes a convexity defect.
            </summary>
            
            <value>The minimum depth.</value>
            
        </member>
        <member name="T:Accord.Math.Geometry.ConvexityDefect">
            <summary>
              Convexity defect.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Geometry.ConvexityDefect.#ctor(System.Int32,System.Int32,System.Int32,System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Geometry.ConvexityDefect"/> class.
            </summary>
            
            <param name="point">The most distant point from the hull.</param>
            <param name="start">The starting index of the defect in the contour.</param>
            <param name="end">The ending index of the defect in the contour.</param>
            <param name="depth">The depth of the defect (highest distance from the hull to
            any of the contour points).</param>
            
        </member>
        <member name="P:Accord.Math.Geometry.ConvexityDefect.Start">
            <summary>
              Gets or sets the starting index of the defect in the contour.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Geometry.ConvexityDefect.End">
            <summary>
              Gets or sets the ending index of the defect in the contour.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Geometry.ConvexityDefect.Point">
            <summary>
              Gets or sets the most distant point from the hull characterizing the defect.
            </summary>
            
            <value>The point.</value>
            
        </member>
        <member name="P:Accord.Math.Geometry.ConvexityDefect.Depth">
            <summary>
              Gets or sets the depth of the defect (highest distance
              from the hull to any of the points in the contour).
            </summary>
            
        </member>
        <member name="T:Accord.Math.Geometry.KCurvature">
            <summary>
              K-curvatures algorithm for local maximum contour detection.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Geometry.KCurvature.#ctor(System.Int32,AForge.DoubleRange)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Geometry.KCurvature"/> class.
            </summary>
            <param name="k">The number K of previous and posterior
              points to consider when find local extremum points.</param>
            <param name="theta">The theta angle range (in
              degrees) used to define extremum points..</param>
        </member>
        <member name="M:Accord.Math.Geometry.KCurvature.FindPeaks(System.Collections.Generic.List{AForge.IntPoint})">
            <summary>
              Finds local extremum points in the contour.
            </summary>
            <param name="contour">A list of <see cref="T:AForge.IntPoint">
            integer points</see> defining the contour.</param>
            
        </member>
        <member name="P:Accord.Math.Geometry.KCurvature.K">
            <summary>
              Gets or sets the number K of previous and posterior
              points to consider when find local extremum points.
            </summary>
        </member>
        <member name="P:Accord.Math.Geometry.KCurvature.Theta">
            <summary>
              Gets or sets the theta angle range (in
              degrees) used to define extremum points.
            </summary>
        </member>
        <member name="P:Accord.Math.Geometry.KCurvature.Suppression">
            <summary>
              Gets or sets the suppression radius to
              use during non-minimum suppression.
            </summary>
        </member>
        <member name="T:Accord.Math.ReducedRowEchelonForm">
            <summary>
              Reduced row Echelon form
            </summary>
            
        </member>
        <member name="M:Accord.Math.ReducedRowEchelonForm.#ctor(System.Double[0:,0:],System.Boolean)">
            <summary>
              Reduces a matrix to reduced row Echelon form.
            </summary>
            
            <param name="value">The matrix to be reduced.</param>
            <param name="inPlace">
              Pass <see langword="true"/> to perform the reduction in place. The matrix
              <paramref name="value"/> will be destroyed in the process, resulting in less
              memory consumption.</param>
              
        </member>
        <member name="P:Accord.Math.ReducedRowEchelonForm.Pivot">
            <summary>
              Gets the pivot indicating the position
              of the original rows before the swap.
            </summary>
            
        </member>
        <member name="P:Accord.Math.ReducedRowEchelonForm.Result">
            <summary>
              Gets the matrix in row reduced Echelon form.
            </summary>
        </member>
        <member name="P:Accord.Math.ReducedRowEchelonForm.FreeVariables">
            <summary>
              Gets the number of free variables (linear
              dependent rows) in the given matrix.
            </summary>
        </member>
        <member name="T:Accord.Math.ComplexMatrix">
            <summary>
             Static class ComplexExtensions. Defines a set of extension methods
             that operates mainly on multidimensional arrays and vectors of
             AForge.NET's <seealso cref="T:System.Numerics.Complex"/> data type.
            </summary>
            
        </member>
        <member name="M:Accord.Math.ComplexMatrix.Abs(System.Numerics.Complex[])">
            <summary>
              Computes the absolute value of an array of complex numbers.
            </summary>
            
        </member>
        <member name="M:Accord.Math.ComplexMatrix.Sum(System.Numerics.Complex[])">
            <summary>
              Computes the sum of an array of complex numbers.
            </summary>
            
        </member>
        <member name="M:Accord.Math.ComplexMatrix.Multiply(System.Numerics.Complex[],System.Numerics.Complex[])">
            <summary>
              Elementwise multiplication of two complex vectors.
            </summary>
            
        </member>
        <member name="M:Accord.Math.ComplexMatrix.Magnitude(System.Numerics.Complex[])">
            <summary>
              Gets the magnitude of every complex number in an array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.ComplexMatrix.Magnitude(System.Numerics.Complex[0:,0:])">
            <summary>
              Gets the magnitude of every complex number in a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.ComplexMatrix.Phase(System.Numerics.Complex[])">
            <summary>
              Gets the phase of every complex number in an array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.ComplexMatrix.Re(System.Numerics.Complex[])">
            <summary>
              Returns the real vector part of the complex vector c.
            </summary>
            
            <param name="c">A vector of complex numbers.</param>
            
            <returns>A vector of scalars with the real part of the complex numbers.</returns>
            
        </member>
        <member name="M:Accord.Math.ComplexMatrix.Re(System.Numerics.Complex[0:,0:])">
            <summary>
              Returns the real matrix part of the complex matrix c.
            </summary>
            
            <param name="c">A matrix of complex numbers.</param>
            
            <returns>A matrix of scalars with the real part of the complex numbers.</returns>
            
        </member>
        <member name="M:Accord.Math.ComplexMatrix.Im(System.Numerics.Complex[])">
            <summary>
              Returns the imaginary vector part of the complex vector c.
            </summary>
            
            <param name="c">A vector of complex numbers.</param>
            
            <returns>A vector of scalars with the imaginary part of the complex numbers.</returns>
            
        </member>
        <member name="M:Accord.Math.ComplexMatrix.Im(System.Numerics.Complex[0:,0:])">
            <summary>
            Returns the imaginary matrix part of the complex matrix c.
            </summary>
            <param name="c">A matrix of complex numbers.</param>
            <returns>A matrix of scalars with the imaginary part of the complex numbers.</returns>
        </member>
        <member name="M:Accord.Math.ComplexMatrix.ToArray(System.Numerics.Complex[])">
            <summary>
              Converts a complex number to a matrix of scalar values
              in which the first column contains the real values and 
              the second column contains the imaginary values.
            </summary>
            <param name="c">An array of complex numbers.</param>
        </member>
        <member name="M:Accord.Math.ComplexMatrix.ToComplex(System.Double[])">
            <summary>
              Converts a vector of real numbers to complex numbers.
            </summary>
            
            <param name="real">The real numbers to be converted.</param>
            
            <returns>
              A vector of complex number with the given 
              real numbers as their real components.
            </returns>
            
        </member>
        <member name="M:Accord.Math.ComplexMatrix.ToComplex(System.Double[],System.Double[])">
            <summary>
              Combines a vector of real and a vector of
              imaginary numbers to form complex numbers.
            </summary>
            
            <param name="real">The real part of the complex numbers.</param>
            <param name="imag">The imaginary part of the complex numbers</param>
            
            <returns>
              A vector of complex number with the given 
              real numbers as their real components and
              imaginary numbers as their imaginary parts.
            </returns>
            
        </member>
        <member name="M:Accord.Math.ComplexMatrix.Range(System.Numerics.Complex[])">
            <summary>
              Gets the range of the magnitude values in a complex number vector.
            </summary>
            
            <param name="array">A complex number vector.</param>
            <returns>The range of magnitude values in the complex vector.</returns>
            
        </member>
        <member name="M:Accord.Math.ComplexMatrix.IsEqual(System.Numerics.Complex[][],System.Numerics.Complex[][],System.Double)">
            <summary>
              Compares two matrices for equality, considering an acceptance threshold.
            </summary>
        </member>
        <member name="M:Accord.Math.ComplexMatrix.IsEqual(System.Numerics.Complex[],System.Numerics.Complex[],System.Double)">
            <summary>
              Compares two vectors for equality, considering an acceptance threshold.
            </summary>
        </member>
        <member name="M:Accord.Math.ComplexMatrix.SquaredMagnitude(System.Numerics.Complex)">
            <summary>
              Gets the squared magnitude of a complex number.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Norm">
            <summary>
              Static class Norm. Defines a set of extension methods defining norms measures.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Norm1(System.Double[0:,0:])">
            <summary>
              Returns the maximum column sum of the given matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Norm1(System.Double[][])">
            <summary>
              Returns the maximum column sum of the given matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Norm2(System.Double[0:,0:])">
            <summary>
              Returns the maximum singular value of the given matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Norm2(System.Double[][])">
            <summary>
              Returns the maximum singular value of the given matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Frobenius(System.Double[0:,0:])">
            <summary>
              Gets the square root of the sum of squares for all elements in a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Frobenius(System.Double[][])">
            <summary>
              Gets the square root of the sum of squares for all elements in a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.SquareEuclidean(System.Single[])">
            <summary>
              Gets the Squared Euclidean norm for a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.SquareEuclidean(System.Double[])">
            <summary>
              Gets the Squared Euclidean norm for a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Euclidean(System.Single[])">
            <summary>
              Gets the Euclidean norm for a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Euclidean(System.Double[])">
            <summary>
              Gets the Euclidean norm for a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.SquareEuclidean(System.Double[0:,0:])">
            <summary>
              Gets the Squared Euclidean norm vector for a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.SquareEuclidean(System.Double[][])">
            <summary>
              Gets the Squared Euclidean norm vector for a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.SquareEuclidean(System.Double[0:,0:],System.Int32)">
            <summary>
              Gets the Squared Euclidean norm vector for a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.SquareEuclidean(System.Double[][],System.Int32)">
            <summary>
              Gets the Squared Euclidean norm vector for a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Euclidean(System.Double[0:,0:])">
            <summary>
              Gets the Euclidean norm for a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Euclidean(System.Double[0:,0:],System.Int32)">
            <summary>
              Gets the Euclidean norm for a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.SquareEuclidean(System.Single[0:,0:],System.Int32)">
            <summary>
              Gets the Squared Euclidean norm vector for a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Euclidean(System.Single[0:,0:])">
            <summary>
              Gets the Euclidean norm for a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Euclidean(System.Single[0:,0:],System.Int32)">
            <summary>
              Gets the Euclidean norm for a matrix.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.AugmentedLagrangian">
             <summary>
               Augmented Lagrangian method for constrained non-linear optimization.
             </summary>
             
             <remarks>
             <para>
               References:
               <list type="bullet">
                 <item><description><a href="http://ab-initio.mit.edu/nlopt">
                   Steven G. Johnson, The NLopt nonlinear-optimization package, http://ab-initio.mit.edu/nlopt </a></description></item>
                 <item><description><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.72.6121">
                   E. G. Birgin and J. M. Martinez, "Improving ultimate convergence of an augmented Lagrangian
                   method," Optimization Methods and Software vol. 23, no. 2, p. 177-195 (2008). </a></description></item>
               </list>
             </para>   
             </remarks>
             
             <example>
             <para>
               In this framework, it is possible to state a non-linear programming problem
               using either symbolic processing or vector-valued functions. The following 
               example demonstrates the former.</para>
               
             <code>
             // Suppose we would like to minimize the following function:
             //
             //    f(x,y) = min 100(y-xÂ²)Â²+(1-x)Â²
             //
             // Subject to the constraints
             //
             //    x >= 0  (x must be positive)
             //    y >= 0  (y must be positive)
             //
            
             // In this example we will be using some symbolic processing. 
             // The following variables could be initialized to any value.
            
             double x = 0, y = 0;
            
            
             // First, we create our objective function
             var f = new NonlinearObjectiveFunction(
            
                 // This is the objective function:  f(x,y) = min 100(y-xÂ²)Â²+(1-x)Â²
                 function: () => 100 * Math.Pow(y - x * x, 2) + Math.Pow(1 - x, 2),
            
                 // The gradient vector:
                 gradient: () => new[] 
                 {
                     2 * (200 * Math.Pow(x, 3) - 200 * x * y + x - 1), // df/dx = 2(200xÂ³-200xy+x-1)
                     200 * (y - x*x)                                   // df/dy = 200(y-xÂ²)
                 }
            
             );
            
            
             // Now we can start stating the constraints
             var constraints = new List&lt;NonlinearConstraint>();
            
             // Add the non-negativity constraint for x
             constraints.Add(new NonlinearConstraint(f,
            
                 // 1st constraint: x should be greater than or equal to 0
                 function: () => x, shouldBe: ConstraintType.GreaterThanOrEqualTo, value: 0,
            
                 gradient: () => new[] { 1.0, 0.0 }
             ));
            
             // Add the non-negativity constraint for y
             constraints.Add(new NonlinearConstraint(f,
            
                 // 2nd constraint: y should be greater than or equal to 0
                 function: () => y, shouldBe: ConstraintType.GreaterThanOrEqualTo, value: 0,
            
                 gradient: () => new[] { 0.0, 1.0 }
             ));
            
            
             // Finally, we create the non-linear programming solver
             var solver = new AugmentedLagrangianSolver(2, constraints);
            
             // And attempt to solve the problem
             double minValue = solver.Minimize(f);
             </code>
             </example>
             
        </member>
        <member name="M:Accord.Math.Optimization.AugmentedLagrangian.#ctor(System.Int32,System.Collections.Generic.IEnumerable{Accord.Math.Optimization.NonlinearConstraint})">
            <summary>
              Creates a new instance of the Augmented Lagrangian algorithm.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the optimization problem.</param>
            <param name="constraints">
              The <see cref="T:Accord.Math.Optimization.NonlinearConstraint"/>s to which the solution must be subjected.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.AugmentedLagrangian.#ctor(Accord.Math.Optimization.NonlinearObjectiveFunction,System.Collections.Generic.IEnumerable{Accord.Math.Optimization.NonlinearConstraint})">
            <summary>
              Creates a new instance of the Augmented Lagrangian algorithm.
            </summary>
            
            <param name="function">The objective function to be optimized.</param>
            <param name="constraints">
              The <see cref="T:Accord.Math.Optimization.NonlinearConstraint"/>s to which the solution must be subjected.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.AugmentedLagrangian.#ctor(Accord.Math.Optimization.IGradientOptimizationMethod,Accord.Math.Optimization.NonlinearObjectiveFunction,System.Collections.Generic.IEnumerable{Accord.Math.Optimization.NonlinearConstraint})">
            <summary>
              Creates a new instance of the Augmented Lagrangian algorithm.
            </summary>
            
            <param name="innerSolver">The <see cref="T:Accord.Math.Optimization.IGradientOptimizationMethod">unconstrained 
              optimization method</see> used internally to solve the dual of this optimization 
              problem.</param>
            <param name="function">The objective function to be optimized.</param>
            <param name="constraints">
              The <see cref="T:Accord.Math.Optimization.NonlinearConstraint"/>s to which the solution must be subjected.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.AugmentedLagrangian.#ctor(Accord.Math.Optimization.IGradientOptimizationMethod,System.Collections.Generic.IEnumerable{Accord.Math.Optimization.NonlinearConstraint})">
            <summary>
              Creates a new instance of the Augmented Lagrangian algorithm.
            </summary>
            
            <param name="innerSolver">The <see cref="T:Accord.Math.Optimization.IGradientOptimizationMethod">unconstrained 
              optimization method</see> used internally to solve the dual of this optimization 
              problem.</param>
            <param name="constraints">
              The <see cref="T:Accord.Math.Optimization.NonlinearConstraint"/>s to which the solution must be subjected.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.AugmentedLagrangian.Optimize">
            <summary>
              Implements the actual optimization algorithm. This
              method should try to minimize the objective function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.AugmentedLagrangian.Iterations">
            <summary>
              Gets the number of iterations performed in the
              last call to the <see cref="M:Accord.Math.Optimization.IOptimizationMethod.Minimize"/> or
              <see cref="M:Accord.Math.Optimization.IOptimizationMethod.Maximize"/> methods.
            </summary>
            
            <value>
              The number of iterations performed
              in the previous optimization.</value>
              
        </member>
        <member name="P:Accord.Math.Optimization.AugmentedLagrangian.Evaluations">
            <summary>
              Gets the number of function evaluations performed
              in the last call to the <see cref="M:Accord.Math.Optimization.IOptimizationMethod.Minimize"/> or
              <see cref="M:Accord.Math.Optimization.IOptimizationMethod.Maximize"/> methods.
            </summary>
            
            <value>
              The number of evaluations performed
              in the previous optimization.</value>
              
        </member>
        <member name="P:Accord.Math.Optimization.AugmentedLagrangian.MaxEvaluations">
            <summary>
              Gets or sets the maximum number of evaluations
              to be performed during optimization. Default
              is 0 (evaluate until convergence).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.AugmentedLagrangian.Optimizer">
            <summary>
              Gets the inner dual problem optimization algorithm.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.QuadraticConstraint">
            <summary>
              Constraint with only quadratic terms.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.NonlinearConstraint">
            <summary>
              Constraint with only linear terms.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearConstraint.GetViolation(System.Double[])">
            <summary>
              Gets how much the constraint is being violated.
            </summary>
            
            <param name="input">The function point.</param>
            
            <returns>
              How much the constraint is being violated at the given point. Positive
              value means the constraint is not being violated with the returned slack, 
              while a negative value means the constraint is being violated by the returned
              amount.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearConstraint.IsViolated(System.Double[])">
            <summary>
              Gets whether this constraint is being violated 
              (within the current tolerance threshold).
            </summary>
            
            <param name="input">The function point.</param>
            
            <returns>True if the constraint is being violated, false otherwise.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearConstraint.#ctor(Accord.Math.Optimization.IObjectiveFunction,System.Linq.Expressions.Expression{System.Func{System.Double}},Accord.Math.Optimization.ConstraintType,System.Double,System.Linq.Expressions.Expression{System.Func{System.Double[]}},System.Double)">
            <summary>
              Constructs a new nonlinear constraint.
            </summary>
            
            <param name="objective">The objective function to which this constraint refers.</param>
            <param name="function">A lambda expression defining the left hand side of the constraint equation.</param>
            <param name="gradient">A lambda expression defining the gradient of the <paramref name="function">
              left hand side of the constraint equation</paramref>.</param>
            <param name="shouldBe">How the left hand side of the constraint 
              should be compared to the given <paramref name="value"/>.</param>
            <param name="value">The right hand side of the constraint equation.</param>
            <param name="withinTolerance">The tolerance for violations of the constraint. Equality
              constraints should set this to a small positive value. Default is 1e-8.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearConstraint.#ctor(Accord.Math.Optimization.IObjectiveFunction,System.Func{System.Double[],System.Double},Accord.Math.Optimization.ConstraintType,System.Double)">
            <summary>
              Constructs a new nonlinear constraint.
            </summary>
            
            <param name="objective">The objective function to which this constraint refers.</param>
            <param name="function">A lambda expression defining the left hand side of the 
              constraint equation.</param>
            <param name="shouldBe">How the left hand side of the constraint should be 
              compared to the given <paramref name="value"/>.</param>
            <param name="value">The right hand side of the constraint equation. Default is 0.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearConstraint.#ctor(Accord.Math.Optimization.IObjectiveFunction,System.Func{System.Double[],System.Double},Accord.Math.Optimization.ConstraintType,System.Double,System.Func{System.Double[],System.Double[]})">
            <summary>
              Constructs a new nonlinear constraint.
            </summary>
            
            <param name="objective">The objective function to which this constraint refers.</param>
            <param name="function">A lambda expression defining the left hand side of the 
              constraint equation.</param>
            <param name="gradient">A lambda expression defining the gradient of the <paramref name="function">
              left hand side of the constraint equation</paramref>.</param>
            <param name="shouldBe">How the left hand side of the constraint should be 
              compared to the given <paramref name="value"/>.</param>
            <param name="value">The right hand side of the constraint equation. Default is 0.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearConstraint.#ctor(System.Int32,System.Func{System.Double[],System.Double},Accord.Math.Optimization.ConstraintType,System.Double)">
            <summary>
              Constructs a new nonlinear constraint.
            </summary>
            
            <param name="numberOfVariables">The number of variables in the constraint.</param>
            <param name="function">A lambda expression defining the left hand side of the constraint equation.</param>
            <param name="shouldBe">How the left hand side of the constraint should be compared to 
              the given <paramref name="value"/>. Default is <see cref="F:Accord.Math.Optimization.ConstraintType.GreaterThanOrEqualTo"/>.</param>
            <param name="value">The right hand side of the constraint equation. Default is 0.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearConstraint.#ctor(Accord.Math.Optimization.IObjectiveFunction,System.Linq.Expressions.Expression{System.Func{System.Double[],System.Boolean}})">
            <summary>
              Constructs a new nonlinear constraint.
            </summary>
            
            <param name="objective">The objective function to which this constraint refers.</param>
            <param name="constraint">A boolean lambda expression expressing the constraint. Please 
              see examples for details.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearConstraint.#ctor(System.Int32,System.Linq.Expressions.Expression{System.Func{System.Double[],System.Boolean}})">
            <summary>
              Constructs a new nonlinear constraint.
            </summary>
            
            <param name="numberOfVariables">The number of variables in the constraint.</param>
            <param name="constraint">A boolean lambda expression expressing the constraint. Please 
              see examples for details.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearConstraint.#ctor(Accord.Math.Optimization.IObjectiveFunction,System.Func{System.Double[],System.Double})">
            <summary>
              Constructs a new nonlinear constraint.
            </summary>
            
            <param name="objective">The objective function to which this constraint refers.</param>
            <param name="function">A lambda expression defining the left hand side of the constraint.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearConstraint.#ctor(Accord.Math.Optimization.IObjectiveFunction,System.Func{System.Double[],System.Double},System.Func{System.Double[],System.Double[]})">
            <summary>
              Constructs a new nonlinear constraint.
            </summary>
            
            <param name="objective">The objective function to which this constraint refers.</param>
            <param name="function">A lambda expression defining the left hand side of the 
              constraint equation.</param>
            <param name="gradient">A lambda expression defining the gradient of the <paramref name="function">
              left hand side of the constraint equation.</paramref>.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearConstraint.#ctor(System.Int32,System.Func{System.Double[],System.Double},System.Func{System.Double[],System.Double[]},Accord.Math.Optimization.ConstraintType,System.Double,System.Double)">
            <summary>
              Constructs a new nonlinear constraint.
            </summary>
            
            <param name="numberOfVariables">The number of variables in the constraint.</param>
            <param name="function">A lambda expression defining the left hand side of the 
              constraint equation.</param>
            <param name="gradient">A lambda expression defining the gradient of the <paramref name="function">
              left hand side of the constraint equation</paramref>.</param>
            <param name="shouldBe">How the left hand side of the constraint should be 
              compared to the given <paramref name="value"/>.</param>
            <param name="value">The right hand side of the constraint equation. Default is 0.</param>
            <param name="withinTolerance">The tolerance for violations of the constraint. Equality
              constraints should set this to a small positive value. Default is 1e-8.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearConstraint.#ctor(System.Int32,System.Func{System.Double[],System.Double})">
            <summary>
              Constructs a new nonlinear constraint.
            </summary>
            
            <param name="numberOfVariables">The number of variables in the constraint.</param>
            <param name="function">A lambda expression defining the left hand side of the 
              constraint equation.</param>
              
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearConstraint.#ctor(Accord.Math.Optimization.IObjectiveFunction,System.Func{System.Double[],System.Double},Accord.Math.Optimization.ConstraintType,System.Double,System.Func{System.Double[],System.Double[]},System.Double)">
            <summary>
              Constructs a new nonlinear constraint.
            </summary>
            
            <param name="objective">The objective function to which this constraint refers.</param>
            <param name="function">A lambda expression defining the left hand side of the constraint equation.</param>
            <param name="gradient">A lambda expression defining the gradient of the <paramref name="function">
            left hand side of the constraint equation</paramref>.</param>
            <param name="shouldBe">How the left hand side of the constraint should be compared to the given <paramref name="value"/>.</param>
            <param name="value">The right hand side of the constraint equation. Default is 0.</param>
            <param name="withinTolerance">The tolerance for violations of the constraint. Equality
              constraints should set this to a small positive value. Default is 1e-8.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearConstraint.#ctor(System.Int32,System.Func{System.Double[],System.Double},Accord.Math.Optimization.ConstraintType,System.Double,System.Func{System.Double[],System.Double[]},System.Double)">
            <summary>
              Constructs a new nonlinear constraint.
            </summary>
            
            <param name="numberOfVariables">The number of variables in the constraint.</param>
            <param name="function">A lambda expression defining the left hand side of the constraint equation.</param>
            <param name="gradient">A lambda expression defining the gradient of the <paramref name="function">
            left hand side of the constraint equation</paramref>.</param>
            <param name="shouldBe">How the left hand side of the constraint should be compared to the given <paramref name="value"/>.</param>
            <param name="value">The right hand side of the constraint equation. Default is 0.</param>
            <param name="withinTolerance">The tolerance for violations of the constraint. Equality
              constraints should set this to a small positive value. Default is 1e-8.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearConstraint.#ctor">
            <summary>
              Creates an empty nonlinear constraint.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearConstraint.Create(System.Int32,System.Func{System.Double[],System.Double},Accord.Math.Optimization.ConstraintType,System.Double,System.Func{System.Double[],System.Double[]},System.Double)">
            <summary>
               Creates a nonlinear constraint.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearConstraint.ToString">
            <summary>
              Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearConstraint.ToString(System.String,System.IFormatProvider)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            
            <param name="format">The format.</param>
            <param name="formatProvider">The format provider.</param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearConstraint.NumberOfVariables">
            <summary>
              Gets the number of variables in the constraint.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearConstraint.Function">
            <summary>
              Gets the left hand side of 
              the constraint equation.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearConstraint.Gradient">
            <summary>
              Gets the gradient of the left hand
              side of the constraint equation.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearConstraint.ShouldBe">
            <summary>
              Gets the type of the constraint.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearConstraint.Value">
            <summary>
              Gets the value in the right hand side of 
              the constraint equation. Default is 0.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearConstraint.Tolerance">
            <summary>
              Gets the violation tolerance for the constraint. Equality
              constraints should set this to a small positive value. 
              Default is 1e-8.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.QuadraticConstraint.#ctor(Accord.Math.Optimization.IObjectiveFunction,System.Double[0:,0:],System.Double[],Accord.Math.Optimization.ConstraintType,System.Double,System.Double)">
             <summary>
               Constructs a new quadratic constraint in the form <c>x'Ax + x'b</c>.
             </summary>
             
             <param name="objective">The objective function to which this constraint refers.</param>
             <param name="quadraticTerms">The matrix of <c>A</c> quadratic terms.</param>
             <param name="linearTerms">The vector <c>b</c> of linear terms.</param>
             <param name="shouldBe">How the left hand side of the constraint should be compared to 
               the given <paramref name="value"/>.</param>
             <param name="value">The right hand side of the constraint equation.</param>
             <param name="withinTolerance">The tolerance for violations of the constraint. Equality
               constraints should set this to a small positive value. Default is 0.</param>
            
        </member>
        <member name="P:Accord.Math.Optimization.QuadraticConstraint.QuadraticTerms">
            <summary>
              Gets the matrix of <c>A</c> quadratic terms
              for the constraint <c>x'Ax + x'b</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.QuadraticConstraint.LinearTerms">
            <summary>
              Gets the vector <c>b</c> of linear terms
              for the constraint <c>x'Ax + x'b</c>.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.NonlinearObjectiveFunction">
            <summary>
              Quadratic objective function.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.IObjectiveFunction">
            <summary>
              Common interface for specifying objective functions.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.IObjectiveFunction.Variables">
            <summary>
              Gets input variable's labels for the function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.IObjectiveFunction.Indices">
            <summary>
              Gets the index of each input variable in the function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.IObjectiveFunction.NumberOfVariables">
            <summary>
              Gets the number of input variables for the function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.IObjectiveFunction.Function">
            <summary>
              Gets the objective function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearObjectiveFunction.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.NonlinearObjectiveFunction"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearObjectiveFunction.#ctor(System.Int32,System.Func{System.Double[],System.Double})">
            <summary>
              Creates a new objective function specified through a string.
            </summary>
            
            <param name="numberOfVariables">The number of parameters in the <paramref name="function"/>.</param>
            <param name="function">A lambda expression defining the objective
              function.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearObjectiveFunction.#ctor(System.Int32,System.Func{System.Double[],System.Double},System.Func{System.Double[],System.Double[]})">
            <summary>
              Creates a new objective function specified through a string.
            </summary>
            
            <param name="numberOfVariables">The number of parameters in the <paramref name="function"/>.</param>
            <param name="function">A lambda expression defining the objective
              function.</param>
            <param name="gradient">A lambda expression defining the gradient
              of the <paramref name="function">objective function</paramref>.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearObjectiveFunction.#ctor(System.Linq.Expressions.Expression{System.Func{System.Double}},System.Linq.Expressions.Expression{System.Func{System.Double[]}})">
            <summary>
              Creates a new objective function specified through a lambda expression.
            </summary>
            
            <param name="function">A <see cref="T:System.Linq.Expressions.Expression`1"/> containing 
              the function in the form of a lambda expression.</param>
            <param name="gradient">A <see cref="T:System.Linq.Expressions.Expression`1"/> containing 
              the gradient of the <paramref name="function">objective function</paramref>.</param>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearObjectiveFunction.Variables">
            <summary>
              Gets the name of each input variable.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearObjectiveFunction.Indices">
            <summary>
              Gets the index of each input variable in the function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearObjectiveFunction.InnerVariables">
            <summary>
              Gets the name of each input variable.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearObjectiveFunction.InnerIndices">
            <summary>
              Gets the index of each input variable in the function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearObjectiveFunction.Function">
            <summary>
              Gets the objective function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearObjectiveFunction.Gradient">
            <summary>
              Gets the gradient of the <see cref="P:Accord.Math.Optimization.NonlinearObjectiveFunction.Function">objective function</see>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearObjectiveFunction.NumberOfVariables">
            <summary>
              Gets the number of input variables for the function.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.ConjugateGradientMethod">
            <summary>
              Conjugate gradient direction update formula.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.ConjugateGradientMethod.FletcherReeves">
            <summary>
              Fletcher-Reeves formula.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.ConjugateGradientMethod.PolakRibiere">
            <summary>
              Polak-RibiÃ¨re formula.
            </summary>
            
            <remarks>
              The Polak-RibiÃ¨re is known to perform better for non-quadratic functions.
            </remarks>
            
        </member>
        <member name="F:Accord.Math.Optimization.ConjugateGradientMethod.PositivePolakRibiere">
            <summary>
              Polak-RibiÃ¨re formula.
            </summary>
            
            <remarks>
              The Polak-RibiÃ¨re is known to perform better for non-quadratic functions.
              The positive version B=max(0,Bpr) provides a direction reset automatically.
            </remarks>
            
        </member>
        <member name="T:Accord.Math.Optimization.ConjugateGradientCode">
            <summary>
              Conjugate Gradient exit codes.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.ConjugateGradientCode.Success">
            <summary>
              Success.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.ConjugateGradientCode.StepSize">
            <summary>
              Invalid step size.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.ConjugateGradientCode.DescentNotObtained">
            <summary>
              Descent direction was not obtained.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.ConjugateGradientCode.RoundingErrors">
            <summary>
              Rounding errors prevent further progress. There may not be a step 
              which satisfies the sufficient decrease and curvature conditions. 
              Tolerances may be too small.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.ConjugateGradientCode.StepHigh">
            <summary>
              The step size has reached the upper bound.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.ConjugateGradientCode.StepLow">
            <summary>
              The step size has reached the lower bound.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.ConjugateGradientCode.MaximumEvaluations">
            <summary>
              Maximum number of function evaluations has been reached.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.ConjugateGradientCode.Precision">
            <summary>
              Relative width of the interval of uncertainty is at machine precision.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.ConjugateGradient">
            <summary>
              Conjugate Gradient (CG) optimization method.
            </summary>
            
            <remarks>
            <para>
              In mathematics, the conjugate gradient method is an algorithm for the numerical solution of
              particular systems of linear equations, namely those whose matrix is symmetric and positive-
              definite. The conjugate gradient method is an iterative method, so it can be applied to sparse
              systems that are too large to be handled by direct methods. Such systems often arise when
              numerically solving partial differential equations. The nonlinear conjugate gradient method 
              generalizes the conjugate gradient method to nonlinear optimization (Wikipedia, 2011).</para>
            <para>
              T</para>
            <para>
              The framework implementation of this method is based on the original FORTRAN source code
              by Jorge Nocedal (see references below). The original FORTRAN source code of CG+ (for large
              scale unconstrained problems) is available at http://users.eecs.northwestern.edu/~nocedal/CG+.html
              and had been made freely available for educational or commercial use. The original authors
              expect that all publications describing work using this software quote the (Gilbert and Nocedal, 1992)
              reference given below.</para>
            
            <para>
              References:
              <list type="bullet">
                <item><description><a href="http://users.eecs.northwestern.edu/~nocedal/CG+.html">
                   J. C. Gilbert and J. Nocedal. Global Convergence Properties of Conjugate Gradient
                   Methods for Optimization, (1992) SIAM J. on Optimization, 2, 1.</a></description></item>
                <item><description>
                   Wikipedia contributors, "Nonlinear conjugate gradient method," Wikipedia, The Free 
                   Encyclopedia, http://en.wikipedia.org/w/index.php?title=Nonlinear_conjugate_gradient_method
                   (accessed December 22, 2011).</description></item>
                <item><description>
                   Wikipedia contributors, "Conjugate gradient method," Wikipedia, The Free Encyclopedia,
                   http://en.wikipedia.org/w/index.php?title=Conjugate_gradient_method 
                   (accessed December 22, 2011).</description></item>
               </list></para>
            </remarks>
            
            <seealso cref="T:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno"/>
            <seealso cref="T:Accord.Math.Optimization.ResilientBackpropagation"/>
            <seealso cref="T:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShanno"/>
            <seealso cref="T:Accord.Math.Optimization.TrustRegionNewtonMethod"/>
            
        </member>
        <member name="M:Accord.Math.Optimization.ConjugateGradient.#ctor(System.Int32)">
            <summary>
              Creates a new instance of the CG optimization algorithm.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the optimization problem.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.ConjugateGradient.#ctor(System.Int32,System.Func{System.Double[],System.Double},System.Func{System.Double[],System.Double[]})">
            <summary>
              Creates a new instance of the CG optimization algorithm.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the function to be optimized.</param>
            <param name="function">The function to be optimized.</param>
            <param name="gradient">The gradient of the function.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.ConjugateGradient.Optimize">
            <summary>
              Implements the actual optimization algorithm. This
              method should try to minimize the objective function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ConjugateGradient.Tolerance">
            <summary>
              Gets or sets the relative difference threshold
              to be used as stopping criteria between two
              iterations. Default is 0 (iterate until convergence). 
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ConjugateGradient.MaxIterations">
            <summary>
              Gets or sets the maximum number of iterations
              to be performed during optimization. Default
              is 0 (iterate until convergence).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ConjugateGradient.Method">
            <summary>
              Gets or sets the conjugate gradient update 
              method to be used during optimization.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ConjugateGradient.Iterations">
            <summary>
              Gets the number of iterations performed 
              in the last call to <see cref="M:Accord.Math.Optimization.IOptimizationMethod.Minimize"/>.
            </summary>
            
            <value>
              The number of iterations performed
              in the previous optimization.</value>
              
        </member>
        <member name="P:Accord.Math.Optimization.ConjugateGradient.Evaluations">
            <summary>
              Gets the number of function evaluations performed
              in the last call to <see cref="M:Accord.Math.Optimization.IOptimizationMethod.Minimize"/>.
            </summary>
            
            <value>
              The number of evaluations performed
              in the previous optimization.</value>
              
        </member>
        <member name="P:Accord.Math.Optimization.ConjugateGradient.Searches">
            <summary>
              Gets the number of linear searches performed
              in the last call to <see cref="M:Accord.Math.Optimization.IOptimizationMethod.Minimize"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ConjugateGradient.Status">
            <summary>
              Get the exit code returned in the last call to the
              <see cref="M:Accord.Math.Optimization.IOptimizationMethod.Maximize"/> or 
              <see cref="M:Accord.Math.Optimization.IOptimizationMethod.Minimize"/> methods.
            </summary>
            
        </member>
        <member name="E:Accord.Math.Optimization.ConjugateGradient.Progress">
            <summary>
              Occurs when progress is made during the optimization.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.ConstraintType">
            <summary>
              Constraint type.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.ConstraintType.EqualTo">
            <summary>
              Equality constraint.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.ConstraintType.GreaterThanOrEqualTo">
            <summary>
              Inequality constraint specifying a greater than or equal to relationship.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.ConstraintType.LesserThanOrEqualTo">
            <summary>
              Inequality constraint specifying a lesser than or equal to relationship.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.LinearConstraint">
            <summary>
              Constraint with only linear terms.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.LinearConstraint.#ctor(System.Int32)">
            <summary>
              Constructs a new linear constraint.
            </summary>
            
            <param name="numberOfVariables">The number of variables in the constraint.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.LinearConstraint.#ctor(System.Double[])">
            <summary>
              Constructs a new linear constraint.
            </summary>
            
            <param name="coefficients">The scalar coefficients specifying 
            how variables should be combined in the constraint.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.LinearConstraint.#ctor(Accord.Math.Optimization.IObjectiveFunction,System.String,System.Globalization.CultureInfo)">
            <summary>
              Constructs a new linear constraint.
            </summary>
            
            <param name="function">The objective function to which
              this constraint refers to.</param>
            <param name="constraint">A <see cref="T:System.String"/> 
              specifying this constraint, such as "ax + b = c".</param>
            <param name="format">The culture information specifying how
              numbers written in the <paramref name="constraint"/> should
              be parsed. Default is CultureInfo.InvariantCulture.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.LinearConstraint.#ctor(Accord.Math.Optimization.IObjectiveFunction,System.String)">
            <summary>
              Constructs a new linear constraint.
            </summary>
            
            <param name="function">The objective function to which
              this constraint refers to.</param>
            <param name="constraint">A <see cref="T:System.String"/> 
              specifying this constraint, such as "ax + b = c".</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.LinearConstraint.#ctor(Accord.Math.Optimization.IObjectiveFunction,System.Linq.Expressions.Expression{System.Func{System.Boolean}})">
            <summary>
              Constructs a new linear constraint.
            </summary>
            
            <param name="function">The objective function to which this 
              constraint refers to.</param>
            <param name="constraint">A <see cref="T:System.Linq.Expressions.Expression`1"/> specifying
              this constraint in the form of a lambda expression.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.LinearConstraint.GetViolation(System.Double[])">
            <summary>
              Gets how much the constraint is being violated.
            </summary>
            
            <param name="input">The function point.</param>
            
            <returns>
              How much the constraint is being violated at the given point. Positive
              value means the constraint is not being violated with the returned slack, 
              while a negative value means the constraint is being violated by the returned
              amount.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.LinearConstraint.IsViolated(System.Double[])">
            <summary>
              Gets whether this constraint is being violated 
              (within the current tolerance threshold).
            </summary>
            
            <param name="input">The function point.</param>
            
            <returns>True if the constraint is being violated, false otherwise.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.LinearConstraint.TryParse(System.String,Accord.Math.Optimization.IObjectiveFunction,Accord.Math.Optimization.LinearConstraint@)">
            <summary>
              Attempts to create a <see cref="T:Accord.Math.Optimization.LinearConstraint"/>
              from a <see cref="T:System.String"/> representation.
            </summary>
            
            <param name="str">The string containing the constraint in textual form.</param>
            <param name="function">The objective function to which this constraint refers to.</param>
            <param name="constraint">The resulting constraint, if it could be parsed.</param>
            
            <returns><c>true</c> if the function could be parsed
              from the string, <c>false</c> otherwise.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.LinearConstraint.TryParse(System.String,System.Globalization.CultureInfo,Accord.Math.Optimization.IObjectiveFunction,Accord.Math.Optimization.LinearConstraint@)">
            <summary>
              Attempts to create a <see cref="T:Accord.Math.Optimization.LinearConstraint"/>
              from a <see cref="T:System.String"/> representation.
            </summary>
            
            <param name="str">The string containing the constraint in textual form.</param>
            <param name="function">The objective function to which this constraint refers to.</param>
            <param name="constraint">The resulting constraint, if it could be parsed.</param>
            <param name="culture">The culture information specifying how
              numbers written in the <paramref name="constraint"/> should
              be parsed. Default is CultureInfo.InvariantCulture.</param>
            
            <returns><c>true</c> if the function could be parsed
              from the string, <c>false</c> otherwise.</returns>
            
        </member>
        <member name="P:Accord.Math.Optimization.LinearConstraint.NumberOfVariables">
            <summary>
              Gets the number of variables in the constraint.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.LinearConstraint.VariablesAtIndices">
            <summary>
              Gets the index of the variables (in respective to the
              object function index) of the variables participating
              in this constraint.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.LinearConstraint.CombinedAs">
            <summary>
              Gets the scalar coefficients combining the <see cref="P:Accord.Math.Optimization.LinearConstraint.VariablesAtIndices">
              variables</see> specified by the constraints.
            </summary>
        </member>
        <member name="P:Accord.Math.Optimization.LinearConstraint.ShouldBe">
            <summary>
              Gets the type of the constraint.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.LinearConstraint.Value">
            <summary>
              Gets the value to be compared to the combined values
              of the variables.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.LinearConstraint.Tolerance">
            <summary>
              Gets the violation tolerance for the constraint. Equality
              constraints should set this to a small positive value.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.LinearConstraint.Function">
            <summary>
              Gets the left hand side of the constraint equation.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.LinearConstraint.Gradient">
            <summary>
              Gets the gradient of the left hand side of the constraint equation.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.QuadraticObjectiveFunction">
            <summary>
              Quadratic objective function.
            </summary>
            
            <remarks>
            <para>
              In mathematics, a quadratic function, a quadratic polynomial, a polynomial 
              of degree 2, or simply a quadratic, is a polynomial function in one or more 
              variables in which the highest-degree term is of the second degree. For example,
              a quadratic function in three variables x, y, and z contains exclusively terms
              xÂ², yÂ², zÂ², xy, xz, yz, x, y, z, and a constant:
            </para>
            
            <code>
              f(x,y,z) = axÂ² + byÂ² +czÂ² + dxy + exz + fyz + gx + hy + iz + j
            </code>
            
            <para>
              Please note that the function's constructor expects the function
              expression to be given on this form. Scalar values must be located
              on the left of the variables, and no term should be duplicated in
              the quadratic expression. Please take a look on the examples section
              of this page for some examples of expected functions.</para>
            
            <para>    
              References:
              <list type="bullet">
                <item><description><a href="https://en.wikipedia.org/wiki/Quadratic_function">
                  Wikipedia, The Free Encyclopedia. Quadratic Function. Available on:
                  https://en.wikipedia.org/wiki/Quadratic_function </a></description></item>
              </list></para>
            </remarks>
            
            
            <example>
            <para>
              Examples of valid quadratic functions are:</para>
              
            <code>
              var f1 = new QuadraticObjectiveFunction("xÂ² + 1");
              var f2 = new QuadraticObjectiveFunction("-x*y + y*z");
              var f3 = new QuadraticObjectiveFunction("-2xÂ² + xy - yÂ² - 10xz + zÂ²");
              var f4 = new QuadraticObjectiveFunction("-2xÂ² + xy - yÂ² + 5y");
            </code>
            
            <para>
              It is also possible to specify quadratic functions using lambda expressions.
              In this case, it is first necessary to create some dummy symbol variables to
              act as placeholders in the quadratic expressions. Their value is not important,
              as they will only be used to parse the form of the expression, not its value.
            </para>
            
            <code>
              // Declare symbol variables
              double x = 0, y = 0, z = 0;
            
              var g1 = new QuadraticObjectiveFunction(() =&gt; x * x + 1);
              var g2 = new QuadraticObjectiveFunction(() =&gt; -x * y + y * z);
              var g3 = new QuadraticObjectiveFunction(() =&gt; -2 * x * x + x * y - y * y - 10 * x * z + z * z);
              var g4 = new QuadraticObjectiveFunction(() =&gt; -2 * x * x + x * y - y * y + 5 * y);
            </code>
            
            <para>
              After those functions are created, you can either query their values
              using</para>
              
            <code>
              f1.Function(new [] { 5.0 }); // x*x+1 = xÂ² + 1 = 25 + 1 = 26
            </code>
            
            <para>
              Or you can pass it to a quadratic optimization method such
              as Goldfarb-Idnani to explore its minimum or maximal points:</para>
            
            <code>
              // Declare symbol variables
              double x = 0, y = 0, z = 0;
            
              // Create the function to be optimized
              var f = new QuadraticObjectiveFunction(() =&gt; x * x - 2 * x * y + 3 * y * y + z * z - 4 * x - 5 * y - z);
            
              // Create some constraints for the solution
              var constraints = new List&lt;LinearConstraint&gt;();
              constraints.Add(new LinearConstraint(f, () =&gt; 6 * x - 7 * y &lt;= 8));
              constraints.Add(new LinearConstraint(f, () =&gt; 9 * x + 1 * y &lt;= 11));
              constraints.Add(new LinearConstraint(f, () =&gt; 9 * x - y &lt;= 11));
              constraints.Add(new LinearConstraint(f, () =&gt; -z - y == 12));
            
              // Create the Quadratic Programming solver
              GoldfarbIdnani solver = new GoldfarbIdnani(f, constraints);
            
              // Minimize the function
              bool success = solver.Minimize();
              
              double value = solver.Value;
              double[] solutions = solver.Solution;
            </code>
            </example>
            
            <seealso cref="T:Accord.Math.Optimization.GoldfarbIdnani"/>
            
        </member>
        <member name="M:Accord.Math.Optimization.QuadraticObjectiveFunction.#ctor(System.Double[0:,0:],System.Double[],System.String[])">
            <summary>
              Creates a new objective function specified through a string.
            </summary>
            
            <param name="quadraticTerms">A Hessian matrix of quadratic terms defining the quadratic objective function.</param>
            <param name="linearTerms">The vector of linear terms associated with <paramref name="quadraticTerms"/>.</param>
            <param name="variables">The name for each variable in the problem.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.QuadraticObjectiveFunction.#ctor(System.String)">
            <summary>
              Creates a new objective function specified through a string.
            </summary>
            
            <param name="function">A <see cref="T:System.String"/> containing
            the function in the form similar to "axÂ²+b".</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.QuadraticObjectiveFunction.#ctor(System.String,System.Globalization.CultureInfo)">
            <summary>
              Creates a new objective function specified through a string.
            </summary>
            
            <param name="function">A <see cref="T:System.String"/> containing
              the function in the form similar to "axÂ²+b".</param>
            <param name="culture">The culture information specifying how
              numbers written in the <paramref name="function"/> should
              be parsed. Default is CultureInfo.InvariantCulture.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.QuadraticObjectiveFunction.#ctor(System.Linq.Expressions.Expression{System.Func{System.Double}})">
            <summary>
              Creates a new objective function specified through a string.
            </summary>
            
            <param name="function">A <see cref="T:System.Linq.Expressions.Expression`1"/> containing 
            the function in the form of a lambda expression.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.QuadraticObjectiveFunction.ToString">
            <summary>
              Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.QuadraticObjectiveFunction.TryParse(System.String,Accord.Math.Optimization.QuadraticObjectiveFunction@)">
            <summary>
              Attempts to create a <see cref="T:Accord.Math.Optimization.QuadraticObjectiveFunction"/>
              from a <see cref="T:System.String"/> representation.
            </summary>
            
            <param name="str">The string containing the function in textual form.</param>
            <param name="function">The resulting function, if it could be parsed.</param>
            
            <returns><c>true</c> if the function could be parsed
              from the string, <c>false</c> otherwise.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.QuadraticObjectiveFunction.TryParse(System.String,System.Globalization.CultureInfo,Accord.Math.Optimization.QuadraticObjectiveFunction@)">
            <summary>
              Attempts to create a <see cref="T:Accord.Math.Optimization.QuadraticObjectiveFunction"/>
              from a <see cref="T:System.String"/> representation.
            </summary>
            
            <param name="str">The string containing the function in textual form.</param>
            <param name="function">The resulting function, if it could be parsed.</param>
            <param name="culture">The culture information specifying how
              numbers written in the <paramref name="function"/> should
              be parsed. Default is CultureInfo.InvariantCulture.</param>
              
            <returns><c>true</c> if the function could be parsed
              from the string, <c>false</c> otherwise.</returns>
            
        </member>
        <member name="P:Accord.Math.Optimization.QuadraticObjectiveFunction.QuadraticTerms">
            <summary>
              Gets the quadratic terms of the quadratic function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.QuadraticObjectiveFunction.LinearTerms">
            <summary>
              Gets the vector of linear terms of the quadratic function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.QuadraticObjectiveFunction.ConstantTerm">
            <summary>
              Gets the constant term in the quadratic function.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.BroydenFletcherGoldfarbShannoStatus">
            <summary>
              Status codes for the <see cref="T:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno"/>
              function optimizer.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.BroydenFletcherGoldfarbShannoStatus.Success">
            <summary>
              Convergence was attained.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.BroydenFletcherGoldfarbShannoStatus.Stop">
            <summary>
              The optimization stopped before convergence; maximum
              number of iterations could have been reached.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.BroydenFletcherGoldfarbShannoStatus.AlreadyMinimized">
            <summary>
              The function is already at a minimum.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.BroydenFletcherGoldfarbShannoStatus.UnknownError">
            <summary>
              Unknown error.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.BroydenFletcherGoldfarbShannoStatus.OutOfInterval">
            <summary>
              The line-search step went out of the interval of uncertainty.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.BroydenFletcherGoldfarbShannoStatus.IncorrectMinMax">
            <summary>
              A logic error occurred; alternatively, the interval of uncertainty became too small.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.BroydenFletcherGoldfarbShannoStatus.RoundingError">
            <summary>
              A rounding error occurred; alternatively, no line-search step satisfies
              the sufficient decrease and curvature conditions. The line search routine
              will terminate with this code if the relative width of the interval of 
              uncertainty is less than <see cref="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.FunctionTolerance"/>.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.BroydenFletcherGoldfarbShannoStatus.MinimumStep">
            <summary>
              The line-search step became smaller than <see cref="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.MinStep"/>.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.BroydenFletcherGoldfarbShannoStatus.MaximumStep">
            <summary>
               The line-search step became larger than <see cref="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.MaxStep"/>.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.BroydenFletcherGoldfarbShannoStatus.MaximumLineSearch">
            <summary>
              The line-search routine reaches the maximum number of evaluations.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.BroydenFletcherGoldfarbShannoStatus.MaximumIterations">
            <summary>
              Maximum number of iterations was reached.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.BroydenFletcherGoldfarbShannoStatus.IntervalWidthTooSmall">
             <summary>
               Relative width of the interval of uncertainty is at most 
               <see cref="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.FunctionTolerance"/>.
             </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.BroydenFletcherGoldfarbShannoStatus.InvalidParameters">
            <summary>
              A logic error (negative line-search step) occurred. This
              could be an indication that something could be wrong with
              the gradient function.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.BroydenFletcherGoldfarbShannoStatus.IncreaseGradient">
            <summary>
              The current search direction increases the objective function value.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.LineSearch">
            <summary>
              Line search algorithms.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.LineSearch.Default">
            <summary>
              More-Thuente method.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.LineSearch.BacktrackingArmijo">
            <summary>
              Backtracking method with the Armijo condition.
            </summary>
            
            <remarks>
            <para>
              The backtracking method finds the step length such that it satisfies
              the sufficient decrease (Armijo) condition,</para>
            <code>
              -f(x + a * d) â‰¤ f(x) + FunctionTolerance * a * g(x)^T d,</code>
            <para>
              where x is the current point, d is the current search direction, and
              a is the step length.</para>
            </remarks>
            
        </member>
        <member name="F:Accord.Math.Optimization.LineSearch.RegularWolfe">
            <summary>
              Backtracking method with regular Wolfe condition. 
            </summary>
            
            <remarks>
            <para>
              The backtracking method finds the step length such that it satisfies
              both the Armijo condition (LineSearch.LBFGS_LINESEARCH_BACKTRACKING_ARMIJO)
              and the curvature condition,</para>
             <code>
              - g(x + a * d)^T d â‰¥ lbfgs_parameter_t::wolfe * g(x)^T d,
             </code>
               where x is the current point, d is the current search direction, and
               a is the step length.
            </remarks>
            
        </member>
        <member name="F:Accord.Math.Optimization.LineSearch.StrongWolfe">
            <summary>
              Backtracking method with strong Wolfe condition. 
            </summary>
            
            <remarks>
            <para>
              The backtracking method finds the step length such that it satisfies
              both the Armijo condition (LineSearch.LBFGS_LINESEARCH_BACKTRACKING_ARMIJO)
              and the following condition,</para>
            <code>
                - |g(x + a * d)^T d| â‰¤ lbfgs_parameter_t::wolfe * |g(x)^T d|,</code>
            <para>
              where x is the current point, d is the current search direction, and
              a is the step length.</para>
            </remarks>
            
        </member>
        <member name="T:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno">
            <summary>
              Limited-memory Broydenâ€“Fletcherâ€“Goldfarbâ€“Shanno (L-BFGS) optimization method.
            </summary>
            
            <remarks>
            <para>
              The L-BFGS algorithm is a member of the broad family of quasi-Newton optimization
              methods. L-BFGS stands for 'Limited memory BFGS'. Indeed, L-BFGS uses a limited
              memory variation of the Broydenâ€“Fletcherâ€“Goldfarbâ€“Shanno (BFGS) update to approximate
              the inverse Hessian matrix (denoted by Hk). Unlike the original BFGS method which
              stores a dense  approximation, L-BFGS stores only a few vectors that represent the
              approximation implicitly. Due to its moderate memory requirement, L-BFGS method is
              particularly well suited for optimization problems with a large number of variables.</para>
            <para>
              L-BFGS never explicitly forms or stores Hk. Instead, it maintains a history of the past
              <c>m</c> updates of the position <c>x</c> and gradient <c>g</c>, where generally the history
              <c>m</c>can be short, often less than 10. These updates are used to implicitly do operations
              requiring the Hk-vector product.</para>
              
            <para>
              The framework implementation of this method is based on the original FORTRAN source code
              by Jorge Nocedal (see references below). The original FORTRAN source code of L-BFGS (for
              unconstrained problems) is available at http://www.netlib.org/opt/lbfgs_um.shar and had
              been made available under the public domain. </para>
            
            <para>
              References:
              <list type="bullet">
                <item><description><a href="http://www.netlib.org/opt/lbfgs_um.shar">
                   Jorge Nocedal. Limited memory BFGS method for large scale optimization (Fortran source code). 1990.
                   Available in http://www.netlib.org/opt/lbfgs_um.shar </a></description></item>
                <item><description>
                   Jorge Nocedal. Updating Quasi-Newton Matrices with Limited Storage. <i>Mathematics of Computation</i>,
                   Vol. 35, No. 151, pp. 773--782, 1980.</description></item>
                <item><description>
                   Dong C. Liu, Jorge Nocedal. On the limited memory BFGS method for large scale optimization.</description></item>
               </list></para>
            </remarks>
            
            <example>
            <para>
              The following example shows the basic usage of the L-BFGS solver
              to find the minimum of a function specifying its function and
              gradient. </para>
              
            <code>
            // Suppose we would like to find the minimum of the function
            // 
            //   f(x,y)  =  -exp{-(x-1)Â²} - exp{-(y-2)Â²/2}
            //
            
            // First we need write down the function either as a named
            // method, an anonymous method or as a lambda function:
            
            Func&lt;double[], double&gt; f = (x) =&gt;
                -Math.Exp(-Math.Pow(x[0] - 1, 2)) - Math.Exp(-0.5 * Math.Pow(x[1] - 2, 2));
            
            // Now, we need to write its gradient, which is just the
            // vector of first partial derivatives del_f / del_x, as:
            //
            //   g(x,y)  =  { del f / del x, del f / del y }
            // 
            
            Func&lt;double[], double[]&gt; g = (x) =&gt; new double[] 
            {
                // df/dx = {-2 e^(-    (x-1)^2) (x-1)}
                2 * Math.Exp(-Math.Pow(x[0] - 1, 2)) * (x[0] - 1),
            
                // df/dy = {-  e^(-1/2 (y-2)^2) (y-2)}
                Math.Exp(-0.5 * Math.Pow(x[1] - 2, 2)) * (x[1] - 2)
            };
            
            // Finally, we can create the L-BFGS solver, passing the functions as arguments
            var lbfgs = new BroydenFletcherGoldfarbShanno(numberOfVariables: 2, function: f, gradient: g);
            
            // And then minimize the function:
            bool success = lbfgs.Minimize();
            double minValue = lbfgs.Value;
            double[] solution = lbfgs.Solution;
            
            // The resultant minimum value should be -2, and the solution
            // vector should be { 1.0, 2.0 }. The answer can be checked on
            // Wolfram Alpha by clicking the following the link:
            
            // http://www.wolframalpha.com/input/?i=maximize+%28exp%28-%28x-1%29%C2%B2%29+%2B+exp%28-%28y-2%29%C2%B2%2F2%29%29
            
            </code>
            </example>
            
            <seealso cref="T:Accord.Math.Optimization.ConjugateGradient"/>
            <seealso cref="T:Accord.Math.Optimization.ResilientBackpropagation"/>
            <seealso cref="T:Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShanno"/>
            <seealso cref="T:Accord.Math.Optimization.TrustRegionNewtonMethod"/>
            
        </member>
        <member name="M:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.#ctor(System.Int32)">
            <summary>
              Creates a new instance of the L-BFGS optimization algorithm.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the optimization problem.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.#ctor(Accord.Math.Optimization.NonlinearObjectiveFunction)">
            <summary>
              Creates a new instance of the L-BFGS optimization algorithm.
            </summary>
            
            <param name="function">The function to be optimized.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.#ctor(System.Int32,System.Func{System.Double[],System.Double},System.Func{System.Double[],System.Double[]})">
            <summary>
              Creates a new instance of the L-BFGS optimization algorithm.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the function to be optimized.</param>
            <param name="function">The function to be optimized.</param>
            <param name="gradient">The gradient of the function.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Optimize">
            <summary>
              Implements the actual optimization algorithm. This
              method should try to minimize the objective function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Corrections">
            <summary>
              The number of corrections to approximate the inverse Hessian matrix.
              Default is 6. Values less than 3 are not recommended. Large values 
              will result in excessive computing time.
            </summary>
            
            <remarks>
              The L-BFGS routine stores the computation results of the previous <c>m</c>
              iterations to approximate the inverse Hessian matrix of the current
              iteration. This parameter controls the size of the limited memories
              (corrections). The default value is 6. Values less than 3 are not 
              recommended. Large values will result in excessive computing time.
            </remarks>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Epsilon">
            <summary>
              Epsilon for convergence test.
            </summary>
            
            <remarks>
            <para>
              This parameter determines the accuracy with which the solution is to
              be found. A minimization terminates when</para>
            <code>
                  ||g|| &lt; epsilon * max(1, ||x||),</code>
            <para>
              where ||.|| denotes the Euclidean (L2) norm. The default value is 1e-5.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Past">
            <summary>
              Distance for delta-based convergence test.
            </summary>
            
            <remarks>
              This parameter determines the distance, in iterations, to compute
              the rate of decrease of the objective function. If the value of this
              parameter is zero, the library does not perform the delta-based
              convergence test. The default value is 0.
            </remarks>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Delta">
            <summary>
              Delta for convergence test.
            </summary>
            
            <remarks>
            <para>
              This parameter determines the minimum rate of decrease of the
              objective function. The library stops iterations when the
              following condition is met:</para>
              <code>
                 (f' - f) / f &lt;  delta
              </code>
              <para>
              where f' is the objective value of <see cref="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Past">past iterations</see>
              ago, and f is the objective value of the current iteration. Default value 
              is 0.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.MaxIterations">
            <summary>
               The maximum number of iterations.
            </summary>
            
            <remarks>
              The minimize function terminates an optimization process with 
              <see cref="F:Accord.Math.Optimization.BroydenFletcherGoldfarbShannoStatus.MaximumIterations"/> status
              code when the iteration count exceeds this parameter. Setting this parameter
              to zero continues an optimization process until a convergence or error. The
              default value is 0.</remarks>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.LineSearch">
            <summary>
              The line search algorithm. 
            </summary>
            
            <remarks>
              This parameter specifies a line search 
              algorithm to be used by the L-BFGS routine.
            </remarks>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.MaxLineSearch">
            <summary>
              The maximum number of trials for the line search.
            </summary>
              
            <remarks>
              This parameter controls the number of function and gradients evaluations 
              per iteration for the line search routine. The default value is <c>20</c>.
            </remarks>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.MinStep">
            <summary>
              The minimum step of the line search routine.
            </summary>
             
            <remarks>
              The default value is <c>1e-20</c>. This value need not be modified unless 
              the exponents are too large for the machine being used, or unless the problem
              is extremely badly scaled (in which case the exponents should be increased).
            </remarks>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.MaxStep">
            <summary>
              The maximum step of the line search.
            </summary>
            
            <remarks>
              The default value is <c>1e+20</c>. This value need not be modified unless the
              exponents are too large for the machine being used, or unless the problem is 
              extremely badly scaled (in which case the exponents should be increased).
            </remarks>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.ParameterTolerance">
            <summary>
             A parameter to control the accuracy of the line search routine. The default 
             value is <c>1e-4</c>. This parameter should be greater than zero and smaller 
             than <c>0.5</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Wolfe">
            <summary>
              A coefficient for the Wolfe condition.
            </summary>
            
            <remarks>
              This parameter is valid only when the backtracking line-search algorithm is used 
              with the Wolfe condition, <see cref="F:Accord.Math.Optimization.LineSearch.StrongWolfe"/> 
              or <see cref="F:Accord.Math.Optimization.LineSearch.RegularWolfe"/>. The default value 
              is <c>0.9</c>. This parameter should be greater the <see cref="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.ParameterTolerance"/> 
              and smaller than <c>1.0</c>.
            </remarks>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.GradientTolerance">
            <summary>
              A parameter to control the accuracy of the line search routine.
            </summary>
            
            <remarks>
              The default value is <c>0.9</c>. If the function and gradient evaluations are
              inexpensive with respect to the cost of the iteration (which is sometimes the
              case when solving very large problems) it may be advantageous to set this parameter
              to a small value. A typical small value is <c>0.1</c>. This parameter should be
              greater than the <see cref="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.ParameterTolerance"/> (<c>1e-4</c>) and smaller than
              <c>1.0.</c>
            </remarks>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.FunctionTolerance">
            <summary>
              The machine precision for floating-point values.
            </summary>
            
            <remarks>
              This parameter must be a positive value set by a client program to
              estimate the machine precision. The line search routine will terminate
              with the status code (::LBFGSERR_ROUNDING_ERROR) if the relative width
              of the interval of uncertainty is less than this parameter.
            </remarks>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.OrthantwiseC">
            <summary>
              Coefficient for the L1 norm of variables.
            </summary>
            
            <remarks>
            <para>
              This parameter should be set to zero for standard minimization problems. Setting this
              parameter to a positive value activates Orthant-Wise Limited-memory Quasi-Newton (OWL-QN)
              method, which minimizes the objective function F(x) combined with the L1 norm |x| of the
              variables, <c>{F(x) + C |x|}</c>. This parameter is the coefficient for the |x|, i.e., C.</para>
              
            <para>
              As the L1 norm |x| is not differentiable at zero, the library modifies function and 
              gradient evaluations from a client program suitably; a client program thus have only 
              to return the function value F(x) and gradients G(x) as usual. The default value is zero.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.OrthantwiseStart">
            <summary>
               Start index for computing L1 norm of the variables.
            </summary>
            
            <remarks>
            <para>
              This parameter is valid only for OWL-QN method (i.e., <see cref="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.OrthantwiseC"/> != 0).
              This parameter b (0 &lt;= b &lt; N) specifies the index number from which the library 
              computes the L1 norm of the variables x,</para>
            <code>
                |x| := |x_{b}| + |x_{b+1}| + ... + |x_{N}|.</code>
            <para>
              In other words, variables x_1, ..., x_{b-1} are not used for
              computing the L1 norm. Setting b (0 &lt; b &lt; N), one can protect
              variables, x_1, ..., x_{b-1} (e.g., a bias term of logistic
              regression) from being regularized. The default value is zero.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.OrthantwiseEnd">
            <summary>
              End index for computing L1 norm of the variables.
            </summary>
            
            <remarks>
              This parameter is valid only for OWL-QN method (i.e., <see cref="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.OrthantwiseC"/> != 0).
              This parameter e (0 &lt; e &lt;= N) specifies the index number at which the library stops
              computing the L1 norm of the variables x,
            <code>
                |x| := |x_{b}| + |x_{b+1}| + ... + |x_{N}|.</code>
            </remarks>
            
        </member>
        <member name="E:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Progress">
            <summary>
              Occurs when progress is made during the optimization.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Status">
            <summary>
              Get the exit code returned in the last call to the
              <see cref="M:Accord.Math.Optimization.IOptimizationMethod.Maximize"/> or 
              <see cref="M:Accord.Math.Optimization.IOptimizationMethod.Minimize"/> methods.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.LineSearchFailedException">
            <summary>
              Line Search Failed Exception.
            </summary>
            
            <remarks>
              This exception may be thrown by the <see cref="T:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno">L-BFGS Optimizer</see>
              when the line search routine used by the optimization method fails.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Optimization.LineSearchFailedException.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.LineSearchFailedException"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.LineSearchFailedException.#ctor(System.Int32,System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.LineSearchFailedException"/> class.
            </summary>
            
            <param name="info">The error code information of the line search routine.</param>
            <param name="message">Message providing some additional information.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.LineSearchFailedException.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.LineSearchFailedException"/> class.
            </summary>
            
            <param name="message">Message providing some additional information.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.LineSearchFailedException.#ctor(System.String,System.Exception)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.LineSearchFailedException"/> class.
            </summary>
            
            <param name="message">Message providing some additional information.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.LineSearchFailedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.LineSearchFailedException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="info"/> parameter is null.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            The class name is null or <see cref="P:System.Exception.HResult"/> is zero (0).
            </exception>
            
        </member>
        <member name="M:Accord.Math.Optimization.LineSearchFailedException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              When overridden in a derived class, sets the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with information about the exception.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="info"/> parameter is a null reference (Nothing in Visual Basic).
            </exception>
            <PermissionSet>
            	<IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Read="*AllFiles*" PathDiscovery="*AllFiles*"/>
            	<IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="SerializationFormatter"/>
            </PermissionSet>
            
        </member>
        <member name="P:Accord.Math.Optimization.LineSearchFailedException.Information">
            <summary>
              Gets the error code information returned by the line search routine.
            </summary>
            
            <value>The error code information returned by the line search routine.</value>
            
        </member>
        <member name="T:Accord.Math.Optimization.OptimizationProgressEventArgs">
            <summary>
              Optimization progress event arguments.
            </summary>
        </member>
        <member name="M:Accord.Math.Optimization.OptimizationProgressEventArgs.#ctor(System.Int32,System.Int32,System.Double[],System.Double,System.Double[],System.Double,System.Double,System.Double,System.Boolean)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.OptimizationProgressEventArgs"/> class.
            </summary>
            
            <param name="iteration">The current iteration of the optimization method.</param>
            <param name="evaluations">The number of function evaluations performed.</param>
            <param name="gradient">The current gradient of the function.</param>
            <param name="gnorm">The norm of the current gradient</param>
            <param name="xnorm">The norm of the current parameter vector.</param>
            <param name="solution">The current solution parameters.</param>
            <param name="value">The value of the function evaluated at the current solution.</param>
            <param name="stp">The current step size.</param>
            <param name="finished"><c>True</c> if the method is about to terminate, <c>false</c> otherwise.</param>
            
        </member>
        <member name="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Iteration">
            <summary>
              Gets the current iteration of the method.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Evaluations">
            <summary>
              Gets the number of function evaluations performed.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Gradient">
            <summary>
              Gets the current gradient of the function being optimized.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.OptimizationProgressEventArgs.GradientNorm">
            <summary>
              Gets the norm of the current <see cref="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Gradient"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Solution">
            <summary>
              Gets the current solution parameters for the problem.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.OptimizationProgressEventArgs.SolutionNorm">
            <summary>
              Gets the norm of the current <see cref="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Solution"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Value">
            <summary>
              Gets the value of the function to be optimized
              at the current proposed <see cref="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Solution"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Step">
            <summary>
              Gets the current step size.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Finished">
            <summary>
              Gets or sets a value indicating whether the
              optimization process is about to terminate.
            </summary>
            
            <value><c>true</c> if finished; otherwise, <c>false</c>.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Tag">
            <summary>
              An user-defined value associated with this object.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.GoldfarbIdnaniStatus">
            <summary>
              Status codes for the <see cref="T:Accord.Math.Optimization.GoldfarbIdnani"/>
              constrained quadratic programming solver.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.GoldfarbIdnaniStatus.Success">
            <summary>
              Convergence was attained.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.GoldfarbIdnaniStatus.NonPositiveDefinite">
            <summary>
              The quadratic problem matrix is not positive definite.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.GoldfarbIdnaniStatus.NoPossibleSolution">
            <summary>
              The posed constraints cannot be fulfilled.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.GoldfarbIdnani">
             <summary>
               Goldfarb-Idnani Quadratic Programming Solver.
             </summary>
             
             <remarks>
             <para>
               References:
               <list type="bullet">
                 <item><description><a href="http://www.javaquant.net/papers/GoldfarbIdnani.pdf">
                   Goldfarb D., Idnani A. (1982) Dual and Primal-Dual Methods for Solving Strictly Convex Quadratic Programs.
                   Available on: http://www.javaquant.net/papers/GoldfarbIdnani.pdf .</a></description></item>
                 <item><description><a href="http://www.javaquant.net/papers/GoldfarbIdnani.pdf">
                   Berwin A Turlach. QuadProg, Quadratic Programming Solver (implementation in Fortran).
                   Available on:  http://school.maths.uwa.edu.au/~berwin/software/quadprog.html .</a></description></item>
               </list>
             </para>   
             </remarks>
             
             <example>
             <para>
               There are three ways to state a quadratic programming problem in this framework.</para>
               
             <list type="bullet">
               <item><description>
               The first is to state the problem in its canonical form, explicitly stating the
               matrix Q and vector d specifying the quadratic function and the matrices A and
               vector b specifying the problem constraints.</description></item>
               <item><description>
               The second is to state the problem with lambda expressions using symbolic variables.</description></item>
               <item><description>
               The third is to state the problem using text strings.</description></item>
             </list>
               
             <para>  
               In the following section we will provide examples for those ways. 
             </para>
             
             <para>
               This is an example stating the problem using lambdas:</para>
             <code>
             // Solve the following optimization problem:
             //
             //  min f(x) = 2xÂ² - xy + 4yÂ² - 5x - 6y
             // 
             //  s.t.   x - y  ==   5  (x minus y should be equal to 5)
             //             x  >=  10  (x should be greater than or equal to 10)
             //
            
             // In this example we will be using some symbolic processing. 
             // The following variables could be initialized to any value.
             double x = 0, y = 0;
            
             // Create our objective function using a lambda expression
             var f = new QuadraticObjectiveFunction(() => 2 * (x * x) - (x * y) + 4 * (y * y) - 5 * x - 6 * y);
            
             // Now, create the constraints
             List&lt;LinearConstraint> constraints = new List&lt;LinearConstraint>();
             constraints.Add(new LinearConstraint(f, () => x - y == 5));
             constraints.Add(new LinearConstraint(f, () => x >= 10));
            
             // Now we create the quadratic programming solver for 2 variables, using the constraints.
             GoldfarbIdnani solver = new GoldfarbIdnani(f, constraints);
            
             // And attempt to solve it.
             double minimumValue = solver.Minimize();
             </code>
             
             <para>
               This is an example stating the problem using strings:</para>
             <code>
             // Solve the following optimization problem:
             //
             //  max f(x) = -2xÂ² + xy - yÂ² + 5y
             // 
             //  s.t.   x - y  ==   5  (x minus y should be equal to 5)
             //             x  >=  10  (x should be greater than or equal to 10)
             //
             //
            
             // Create our objective function using a text string
             var f = new QuadraticObjectiveFunction("-2xÂ² + xy - yÂ² + 5y");
            
             // Now, create the constraints
             List&lt;LinearConstraint> constraints = new List&lt;LinearConstraint>();
             constraints.Add(new LinearConstraint(f, "x - y ==  5"));
             constraints.Add(new LinearConstraint(f, "    x >= 10"));
            
             // Now we create the quadratic programming solver for 2 variables, using the constraints.
             GoldfarbIdnani solver = new GoldfarbIdnani(f, constraints);
            
             // And attempt to solve it.
             double maxValue = solver.Maximize();
             </code>
               
             <para>
               And finally, an example stating the problem using matrices:</para>
             <code>
             // Solve the following optimization problem:
             //
             //  min f(x) = 2xÂ² - xy + 4yÂ² - 5x - 6y
             // 
             //  s.t.   x - y  ==   5  (x minus y should be equal to 5)
             //             x  >=  10  (x should be greater than or equal to 10)
             //
             
             // Lets first group the quadratic and linear terms. The
             // quadratic terms are +2xÂ², +3yÂ² and -4xy. The linear 
             // terms are -2x and +1y. So our matrix of quadratic
             // terms can be expressed as:
            
             double[,] Q = // 2xÂ² -1xy +4yÂ²
             {   
                 /*           x              y      */
                 /*x*/ { +2 /*xx*/ *2,  -1 /*xy*/    }, 
                 /*y*/ { -1 /*xy*/   ,  +4 /*yy*/ *2 },
             };
            
             // Accordingly, our vector of linear terms is given by:
            
             double[] d = { -5 /*x*/, -6 /*y*/ }; // -5x -6y
            
             // We have now to express our constraints. We can do it
             // either by directly specifying a matrix A in which each
             // line refers to one of the constraints, expressing the
             // relationship between the different variables in the
             // constraint, like this:
            
             double[,] A = 
             {
                 { 1, -1 }, // This line says that x + (-y) ... (a)
                 { 1,  0 }, // This line says that x alone  ... (b)
             };
            
             double[] b = 
             {
                  5, // (a) ... should be equal to 5.
                 10, // (b) ... should be greater than or equal to 10.
             };
            
             // Equalities must always come first, and in this case
             // we have to specify how many of the constraints are
             // actually equalities:
            
             int numberOfEqualities = 1;
            
            
             // Alternatively, we may use a more explicitly form:
             List&lt;LinearConstraint> list = new List&lt;LinearConstraint>();
            
             // Define the first constraint, which involves only x
             list.Add(new LinearConstraint(numberOfVariables: 1)
                 {
                     // x is the first variable, thus located at
                     // index 0. We are specifying that x >= 10:
            
                     VariablesAtIndices = new[] { 0 }, // index 0 (x)
                     ShouldBe = ConstraintType.GreaterThanOrEqualTo,
                     Value = 10
                 });
            
             // Define the second constraint, which involves x and y
             list.Add(new LinearConstraint(numberOfVariables: 2)
                 {
                     // x is the first variable, located at index 0, and y is
                     // the second, thus located at 1. We are specifying that
                     // x - y = 5 by saying that the variable at position 0 
                     // times 1 plus the variable at position 1 times -1 
                     // should be equal to 5.
            
                     VariablesAtIndices = new int[] { 0, 1 }, // index 0 (x) and index 1 (y)
                     CombinedAs = new double[] { 1, -1 }, // when combined as x - y
                     ShouldBe = ConstraintType.EqualTo,
                     Value = 5
                 });
            
            
             // Now we can finally create our optimization problem
             var target = new GoldfarbIdnani(Q, d, constraints: list);
            
             // And attempt to solve it.
             double minimumValue = target.Minimize();
             </code>
             </example>
             
        </member>
        <member name="M:Accord.Math.Optimization.GoldfarbIdnani.#ctor(Accord.Math.Optimization.QuadraticObjectiveFunction,System.Collections.Generic.IEnumerable{Accord.Math.Optimization.LinearConstraint})">
            <summary>
              Constructs a new <see cref="T:Accord.Math.Optimization.GoldfarbIdnani"/> class.
            </summary>
            
            <param name="function">The objective function to be optimized.</param>
            <param name="constraints">The problem's constraints.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.GoldfarbIdnani.#ctor(Accord.Math.Optimization.QuadraticObjectiveFunction,Accord.Math.Optimization.LinearConstraintCollection)">
            <summary>
              Constructs a new <see cref="T:Accord.Math.Optimization.GoldfarbIdnani"/> class.
            </summary>
            
            <param name="function">The objective function to be optimized.</param>
            <param name="constraints">The problem's constraints.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.GoldfarbIdnani.#ctor(Accord.Math.Optimization.QuadraticObjectiveFunction,System.Double[0:,0:],System.Double[],System.Int32)">
            <summary>
              Constructs a new instance of the <see cref="T:Accord.Math.Optimization.GoldfarbIdnani"/> class.
            </summary>
            
            <param name="function">The objective function to be optimized.</param>
            <param name="constraintMatrix">The constraints matrix <c>A</c>.</param>
            <param name="constraintValues">The constraints values <c>b</c>.</param>
            <param name="numberOfEqualities">The number of equalities in the constraints.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.GoldfarbIdnani.#ctor(System.Double[0:,0:],System.Double[],System.Double[0:,0:],System.Double[],System.Int32)">
            <summary>
              Constructs a new instance of the <see cref="T:Accord.Math.Optimization.GoldfarbIdnani"/> class.
            </summary>
            
            <param name="quadratic">The symmetric matrix of quadratic terms defining the objective function.</param>
            <param name="linear">The vector of linear terms defining the objective function.</param>
            <param name="constraintMatrix">The constraints matrix <c>A</c>.</param>
            <param name="constraintValues">The constraints values <c>b</c>.</param>
            <param name="numberOfEqualities">The number of equalities in the constraints.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.GoldfarbIdnani.Minimize">
            <summary>
              Finds the minimum value of a function. The solution vector
              will be made available at the <see cref="P:Accord.Math.Optimization.IOptimizationMethod.Solution"/> property.
            </summary>
            
            <returns>
              Returns <c>true</c> if the method converged to a <see cref="P:Accord.Math.Optimization.IOptimizationMethod.Solution"/>.
              In this case, the found value will also be available at the <see cref="P:Accord.Math.Optimization.IOptimizationMethod.Value"/>
              property.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.GoldfarbIdnani.Maximize">
            <summary>
              Finds the maximum value of a function. The solution vector
              will be made available at the <see cref="P:Accord.Math.Optimization.IOptimizationMethod.Solution"/> property.
            </summary>
            <returns>
              Returns <c>true</c> if the method converged to a <see cref="P:Accord.Math.Optimization.IOptimizationMethod.Solution"/>.
              In this case, the found value will also be available at the <see cref="P:Accord.Math.Optimization.IOptimizationMethod.Value"/>
              property.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.GoldfarbIdnani.Optimize">
            <summary>
              Not available.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnani.NumberOfConstraints">
            <summary>
              Gets the total number of constraints in the problem.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnani.NumberOfEqualities">
            <summary>
              Gets how many constraints are inequality constraints.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnani.Iterations">
            <summary>
              Gets the total number of iterations performed on the
              last call to the <see cref="M:Accord.Math.Optimization.GoldfarbIdnani.Minimize"/> or <see cref="M:Accord.Math.Optimization.GoldfarbIdnani.Maximize"/> methods.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnani.MaxIterations">
            <summary>
              Gets or sets the maximum number of iterations that should be 
              performed before the method terminates. If set to zero, the 
              method will run to completion. Default is 0.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnani.Deletions">
            <summary>
              Gets the total number of constraint removals performed
              on the last call to the <see cref="M:Accord.Math.Optimization.GoldfarbIdnani.Minimize"/> or <see cref="M:Accord.Math.Optimization.GoldfarbIdnani.Maximize"/> methods.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnani.Lagrangian">
            <summary>
              Gets the Lagrangian multipliers for the
              last solution found.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnani.ActiveConstraints">
            <summary>
              Gets the indices of the active constraints
              found during the last call of the 
              <see cref="M:Accord.Math.Optimization.GoldfarbIdnani.Minimize"/> or <see cref="M:Accord.Math.Optimization.GoldfarbIdnani.Maximize"/>
              methods.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnani.ConstraintMatrix">
            <summary>
              Gets the constraint matrix <c>A</c> for the problem.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnani.ConstraintValues">
            <summary>
              Gets the constraint values <c>b</c> for the problem.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnani.ConstraintTolerances">
            <summary>
              Gets the constraint tolerances <c>b</c> for the problem.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnani.QuadraticTerms">
            <summary>
              Gets the matrix of quadratic terms of
              the quadratic optimization problem.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnani.LinearTerms">
            <summary>
              Gets the vector of linear terms of the
              quadratic optimization problem.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnani.Status">
            <summary>
              Get the exit code returned in the last call to the
              <see cref="M:Accord.Math.Optimization.IOptimizationMethod.Maximize"/> or 
              <see cref="M:Accord.Math.Optimization.IOptimizationMethod.Minimize"/> methods.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.BrentSearch">
            <summary>
              Brent's root finding and minimization algorithms.
            </summary>
            
            <remarks>
            <para>
              In numerical analysis, Brent's method is a complicated but popular root-finding 
              algorithm combining the bisection method, the secant method and inverse quadratic
              interpolation. It has the reliability of bisection but it can be as quick as some
              of the less reliable methods. The idea is to use the secant method or inverse quadratic 
              interpolation if possible, because they converge faster, but to fall back to the more
              robust bisection method if necessary. Brent's method is due to Richard Brent (1973)
              and builds on an earlier algorithm of Theodorus Dekker (1969).</para>
              
            <para>
              The algorithms implemented in this class are based on the original C source code
              available in Netlib (http://www.netlib.org/c/brent.shar) by Oleg Keselyov, 1991.</para>
              
            <para>
              References:
              <list type="bullet">
                <item><description>
                  R.P. Brent (1973). Algorithms for Minimization without Derivatives, Chapter 4. 
                  Prentice-Hall, Englewood Cliffs, NJ. ISBN 0-13-022335-2. </description></item>
                <item><description><a href="http://en.wikipedia.org/wiki/Brent's_method">
                  Wikipedia contributors. "Brent's method." Wikipedia, The Free Encyclopedia.
                  Wikipedia, The Free Encyclopedia, 11 May. 2012. Web. 22 Jun. 2012. </a></description></item>
              </list>
            </para>   
            
            </remarks>
            
            <example>
            <para>
              The following example shows how to compute the maximum,
              minimum and a single root of a univariate function.</para>
              
            <code>
            // Suppose we were given the function xÂ³ + 2xÂ² - 10x and 
            // we have to find its root, maximum and minimum inside 
            // the interval [-4,3]. First, we express this function
            // as a lambda expression:
            Func&lt;double, double> function = x => x * x * x + 2 * x * x - 10 * x;
            
            // And now we can create the search algorithm:
            BrentSearch search = new BrentSearch(function, -4, 3);
            
            // Finally, we can query the information we need
            double max = search.Maximize();  // occurs at -2.61
            double min = search.Minimize();  // occurs at  1.27
            double root = search.FindRoot(); // occurs at  0.50
            </code>
            </example>
            
            
        </member>
        <member name="M:Accord.Math.Optimization.BrentSearch.#ctor(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>
              Constructs a new Brent search algorithm.
            </summary>
            
            <param name="function">The function to be searched.</param>
            <param name="a">Start of search region.</param>
            <param name="b">End of search region.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.BrentSearch.FindRoot">
            <summary>
              Attempts to find a root in the interval [a;b] 
            </summary>
            
            <returns>The location of the zero value in the given interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.BrentSearch.Find(System.Double)">
            <summary>
              Attempts to find a value in the interval [a;b] 
            </summary>
            
            <returns>The location of the zero value in the given interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.BrentSearch.Minimize">
            <summary>
              Finds the minimum of the function in the interval [a;b]
            </summary>
            
            <returns>The location of the minimum of the function in the given interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.BrentSearch.Maximize">
            <summary>
              Finds the maximum of the function in the interval [a;b]
            </summary>
            
            <returns>The location of the maximum of the function in the given interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.BrentSearch.Minimize(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>
              Finds the minimum of a function in the interval [a;b]
            </summary>
            
            <param name="function">The function to be minimized.</param>
            <param name="lowerBound">Start of search region.</param>
            <param name="upperBound">End of search region.</param>
            <param name="tol">The tolerance for determining the solution.</param>
            
            <returns>The location of the minimum of the function in the given interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.BrentSearch.Maximize(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>
              Finds the maximum of a function in the interval [a;b]
            </summary>
            
            <param name="function">The function to be maximized.</param>
            <param name="lowerBound">Start of search region.</param>
            <param name="upperBound">End of search region.</param>
            <param name="tol">The tolerance for determining the solution.</param>
            
            <returns>The location of the maximum of the function in the given interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.BrentSearch.FindRoot(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>
              Finds the root of a function in the interval [a;b]
            </summary>
            
            <param name="function">The function to have its root computed.</param>
            <param name="lowerBound">Start of search region.</param>
            <param name="upperBound">End of search region.</param>
            <param name="tol">The tolerance for determining the solution.</param>
            
            <returns>The location of the zero value in the given interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.BrentSearch.Find(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>
              Finds a value of a function in the interval [a;b]
            </summary>
            
            <param name="function">The function to have its root computed.</param>
            <param name="lowerBound">Start of search region.</param>
            <param name="upperBound">End of search region.</param>
            <param name="tol">The tolerance for determining the solution.</param>
            <param name="value">The value to be looked for in the function.</param>
            
            <returns>The location of the zero value in the given interval.</returns>
            
        </member>
        <member name="P:Accord.Math.Optimization.BrentSearch.NumberOfVariables">
            <summary>
              Gets the number of variables (free parameters)
              in the optimization problem.
            </summary>
            
            <value>
              The number of parameters.
            </value>
            
        </member>
        <member name="P:Accord.Math.Optimization.BrentSearch.Tolerance">
            <summary>
              Gets or sets the tolerance margin when
              looking for an answer. Default is 1e-6.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BrentSearch.LowerBound">
            <summary>
              Gets or sets the lower bound for the search interval <c>a</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BrentSearch.UpperBound">
            <summary>
              Gets or sets the lower bound for the search interval <c>a</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BrentSearch.Solution">
            <summary>
              Gets the solution found in the last call
              to <see cref="M:Accord.Math.Optimization.BrentSearch.Minimize"/>, <see cref="M:Accord.Math.Optimization.BrentSearch.Maximize"/>
              or <see cref="M:Accord.Math.Optimization.BrentSearch.FindRoot"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BrentSearch.Accord#Math#Optimization#IOptimizationMethod#Solution">
            <summary>
              Gets the value at the solution found in the last call
              to <see cref="M:Accord.Math.Optimization.BrentSearch.Minimize"/>, <see cref="M:Accord.Math.Optimization.BrentSearch.Maximize"/>
              or <see cref="M:Accord.Math.Optimization.BrentSearch.FindRoot"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BrentSearch.Value">
            <summary>
              Gets the value at the solution found in the last call
              to <see cref="M:Accord.Math.Optimization.BrentSearch.Minimize"/>, <see cref="M:Accord.Math.Optimization.BrentSearch.Maximize"/>
              or <see cref="M:Accord.Math.Optimization.BrentSearch.FindRoot"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BrentSearch.Function">
            <summary>
              Gets the function to be searched.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Special">
            <summary>
              Set of special mathematic functions.
            </summary>
             
            <remarks>
              References:
              <list type="bullet">
                <item><description>
                  Cephes Math Library, http://www.netlib.org/cephes/ </description></item>
                <item><description>
                  John D. Cook, http://www.johndcook.com/ </description></item>
              </list>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Special.Erfc(System.Double)">
            <summary>
              Complementary error function of the specified value.
            </summary>
            
            <remarks>
              http://mathworld.wolfram.com/Erfc.html
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Special.Erf(System.Double)">
            <summary>
              Error function of the specified value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.Ierf(System.Double)">
            <summary>
              Inverse error function (<see cref="M:Accord.Math.Special.Erf(System.Double)"/>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.Ierfc(System.Double)">
            <summary>
              Inverse complemented error function (<see cref="M:Accord.Math.Special.Erfc(System.Double)"/>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.Polevl(System.Double,System.Double[],System.Int32)">
            <summary>
              Evaluates polynomial of degree N
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.P1evl(System.Double,System.Double[],System.Int32)">
            <summary>
              Evaluates polynomial of degree N with assumption that coef[N] = 1.0
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.BSpline(System.Int32,System.Double)">
            <summary>
              Computes the Basic Spline of order <c>n</c>
            </summary>
        </member>
        <member name="M:Accord.Math.Special.Binomial(System.Int32,System.Int32)">
            <summary>
              Computes the binomial coefficients C(n,k).
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.Binomial(System.Double,System.Double)">
            <summary>
              Computes the binomial coefficients C(n,k).
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.LogBinomial(System.Int32,System.Int32)">
            <summary>
              Computes the log binomial Coefficients Log[C(n,k)].
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.LogBinomial(System.Double,System.Double)">
            <summary>
              Computes the log binomial Coefficients Log[C(n,k)].
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.Factorial(System.Double)">
            <summary>
              Returns the extended factorial definition of a real number.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.LogFactorial(System.Double)">
            <summary>
              Returns the log factorial of a number (ln(n!))
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.LogFactorial(System.Int32)">
            <summary>
              Returns the log factorial of a number (ln(n!))
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.Factorial(System.Int32)">
            <summary>
              Computes the factorial of a number (n!)
            </summary>
        </member>
        <member name="M:Accord.Math.Special.Log1m(System.Double)">
            <summary>
              Computes log(1-x) without losing precision for small values of x.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.Log1p(System.Double)">
            <summary>
              Computes log(1+x) without losing precision for small values of x.
            </summary>
            
            <remarks>
              References:
              - http://www.johndcook.com/csharp_log_one_plus_x.html
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Special.Expm1(System.Double)">
            <summary>
              Compute exp(x) - 1 without loss of precision for small values of x.
            </summary>
            <remarks>
              References:
              - http://www.johndcook.com/cpp_expm1.html
            </remarks>
        </member>
        <member name="M:Accord.Math.Special.Epslon(System.Double)">
            <summary>
              Estimates unit round-off in quantities of size x.
            </summary>
            <remarks>
              This is a port of the epslon function from EISPACK.
            </remarks>
        </member>
        <member name="M:Accord.Math.Special.Sign(System.Double,System.Double)">
            <summary>
              Returns <paramref name="a"/> with the sign of <paramref name="b"/>. 
            </summary>
            
            <remarks>
              This is a port of the sign transfer function from EISPACK,
              and is is equivalent to C++'s std::copysign function.
            </remarks>
            
            <returns>If B > 0 then the result is ABS(A), else it is -ABS(A).</returns>
            
        </member>
        <member name="M:Accord.Math.Special.LogDiff(System.Double,System.Double)">
            <summary>
              Computes x + y without losing precision using ln(x) and ln(y).
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.LogSum(System.Double,System.Double)">
            <summary>
              Computes x + y without losing precision using ln(x) and ln(y).
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.LogSum(System.Single,System.Single)">
            <summary>
              Computes x + y without losing precision using ln(x) and ln(y).
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.Sec(System.Double)">
            <summary>
              Secant.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.Cosec(System.Double)">
            <summary>
              Cosecant.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.Cotan(System.Double)">
            <summary>
              Cotangent.
            </summary>
        </member>
        <member name="M:Accord.Math.Special.Asec(System.Double)">
            <summary>
              Inverse secant.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.Acosec(System.Double)">
            <summary>
              Inverse cosecant.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.Acotan(System.Double)">
            <summary>
              Inverse cotangent.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.Sech(System.Double)">
            <summary>
              Hyperbolic secant.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.Cosech(System.Double)">
            <summary>
              Hyperbolic secant.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.Cotanh(System.Double)">
            <summary>
              Hyperbolic cotangent.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.Asinh(System.Double)">
            <summary>
              Inverse hyperbolic sin.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.Acosh(System.Double)">
            <summary>
              Inverse hyperbolic cos.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.Atanh(System.Double)">
            <summary>
              Inverse hyperbolic tangent.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.Asech(System.Double)">
            <summary>
              Inverse hyperbolic secant.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.Acosech(System.Double)">
            <summary>
              Inverse hyperbolic cosecant.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.Acotanh(System.Double)">
            <summary>
              Inverse hyperbolic cotangent.
            </summary>
            
        </member>
        <member name="T:Accord.Math.HilbertTransform">
            <summary>
              Discrete Hilbert Transformation.
            </summary>
            
            <remarks>
            <para>
              The discrete Hilbert transform is a transformation operating on the time
              domain. It performs a 90 degree phase shift, shifting positive frequencies
              by +90 degrees and negative frequencies by -90 degrees. It is useful to
              create analytic representation of signals. </para>
              
            <para>
              The Hilbert transform can be implemented efficiently by using the Fast
              Fourier Transform. After transforming a signal from the time-domain to
              the frequency domain, one can zero its negative frequency components and
              revert the signal back to obtain the phase shifting.</para>
              
             <para>
               By applying the Hilbert transform to a signal twice, the negative of
               the original signal is recovered.</para>
            
              <para>
                References:
                <list type="bullet">
                  <item><description>
                   Marple, S.L., "Computing the discrete-time analytic signal via FFT," IEEE 
                   Transactions on Signal Processing, Vol. 47, No.9 (September 1999). Available on:
                   http://classes.engr.oregonstate.edu/eecs/winter2009/ece464/AnalyticSignal_Sept1999_SPTrans.pdf </description></item>
                  <item><description>
                   J. F. Culling, Online, cross-indexed dictionary of DSP terms. Available on:
                   http://www.cardiff.ac.uk/psych/home2/CullingJ/frames_dict.html </description></item>
                </list>
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.HilbertTransform.FHT(System.Double[],AForge.Math.FourierTransform.Direction)">
            <summary>
              Performs the Fast Hilbert Transform over a double[] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.HilbertTransform.FHT(System.Numerics.Complex[],AForge.Math.FourierTransform.Direction)">
            <summary>
              Performs the Fast Hilbert Transform over a complex[] array.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Beta">
            <summary>
              Beta functions.
            </summary>
            
            <remarks>
            <para>
              This class offers implementations for the many Beta functions,
              such as the <see cref="M:Accord.Math.Beta.Function(System.Double,System.Double)">Beta function itself</see>, 
              <see cref="M:Accord.Math.Beta.Log(System.Double,System.Double)">its logarithm</see>, the <see cref="M:Accord.Math.Beta.Incomplete(System.Double,System.Double,System.Double)"/>
              incomplete regularized functions and others</para>
              
            <para>
              The beta function was studied by Euler and Legendre and was given
              its name by Jacques Binet; its symbol Î’ is a Greek capital Î² rather
              than the similar Latin capital B.</para>
              
            <para>
              References:
              <list type="bullet">
                <item><description>
                  Cephes Math Library, http://www.netlib.org/cephes/ </description></item>
                <item><description>
                  Wikipedia contributors, "Beta function,". Wikipedia, The Free 
                  Encyclopedia. Available at: http://en.wikipedia.org/wiki/Beta_function 
                  </description></item>
              </list></para>
            </remarks>
            
            <example>
            <code>
              Beta.Function(4, 0.42);       // 1.2155480852832423
              Beta.Log(4, 15.2);            // -9.46087817876467
              Beta.Incbcf(4, 2, 4.2);       // -0.23046874999999992
              Beta.Incbd(4, 2, 4.2);        // 0.7375
              Beta.PowerSeries(4, 2, 4.2);  // -3671.801280000001
              
              Beta.Incomplete(a: 5, b: 4, x: 0.5);   // 0.36328125
              Beta.IncompleteInverse(0.5, 0.6, 0.1); // 0.019145979066925722
              Beta.Multinomial(0.42, 0.5, 5.2 );     // 0.82641912952987062
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.Beta.Function(System.Double,System.Double)">
            <summary>
              Beta function as gamma(a) * gamma(b) / gamma(a+b).
            </summary>
            
            <example>
              Please see <see cref="T:Accord.Math.Beta"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Beta.Log(System.Double,System.Double)">
            <summary>
              Natural logarithm of the Beta function.
            </summary>
            
            <example>
              Please see <see cref="T:Accord.Math.Beta"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Beta.Incomplete(System.Double,System.Double,System.Double)">
            <summary>
              Incomplete (regularized) Beta function Ix(a, b).
            </summary>
            
            <example>
              Please see <see cref="T:Accord.Math.Beta"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Beta.Incbcf(System.Double,System.Double,System.Double)">
            <summary>
              Continued fraction expansion #1 for incomplete beta integral.
            </summary>
            
            <example>
              Please see <see cref="T:Accord.Math.Beta"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Beta.Incbd(System.Double,System.Double,System.Double)">
            <summary>
              Continued fraction expansion #2 for incomplete beta integral.
            </summary>
            
            <example>
              Please see <see cref="T:Accord.Math.Beta"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Beta.IncompleteInverse(System.Double,System.Double,System.Double)">
            <summary>
              Inverse of incomplete beta integral.
            </summary>
            
            <example>
              Please see <see cref="T:Accord.Math.Beta"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Beta.PowerSeries(System.Double,System.Double,System.Double)">
            <summary>
              Power series for incomplete beta integral. Use when b*x
              is small and x not too close to 1.
            </summary>
            
            <example>
              Please see <see cref="T:Accord.Math.Beta"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Beta.Multinomial(System.Double[])">
            <summary>
              Multinomial Beta function.
            </summary>
            
            <example>
              Please see <see cref="T:Accord.Math.Beta"/>
            </example>
            
        </member>
        <member name="T:Accord.Math.Gamma">
             <summary>
               Gamma Î“(x) functions.
             </summary>
              
             <remarks>
             <para>
               In mathematics, the gamma function (represented by the capital Greek 
               letter Î“) is an extension of the factorial function, with its argument
               shifted down by 1, to real and complex numbers. That is, if <c>n</c> is
               a positive integer:</para>
             <code>
               Î“(n) = (n-1)!</code>
             <para>
               The gamma function is defined for all complex numbers except the negative
               integers and zero. For complex numbers with a positive real part, it is 
               defined via an improper integral that converges:</para>
             <code>
                      âˆž
               Î“(z) = âˆ«  t^(z-1)e^(-t) dt
                      0
             </code>     
             <para>
               This integral function is extended by analytic continuation to all 
               complex numbers except the non-positive integers (where the function 
               has simple poles), yielding the meromorphic function we call the gamma
               function.</para>
             <para>
               The gamma function is a component in various probability-distribution 
               functions, and as such it is applicable in the fields of probability 
               and statistics, as well as combinatorics.</para>
               
             <para>
               References:
               <list type="bullet">
                 <item><description>
                   Wikipedia contributors, "Gamma function,". Wikipedia, The Free 
                   Encyclopedia. Available at: http://en.wikipedia.org/wiki/Gamma_function 
                   </description></item>
                 <item><description>
                   Cephes Math Library, http://www.netlib.org/cephes/ </description></item>
               </list></para>
             </remarks>
             
             <example>
             <code>
               double x = 0.17;
               
               // Compute main Gamma function and variants
               double gamma = Gamma.Function(x); // 5.4511741801042106
               double gammap = Gamma.Function(x, p: 2); // -39.473585841300675
               double log = Gamma.Log(x);        // 1.6958310313607003
               double logp = Gamma.Log(x, p: 2); // 3.6756317353404273
               double stir = Gamma.Stirling(x);  // 24.040352622960743
               double psi = Gamma.Digamma(x);    // -6.2100942259248626
               double tri = Gamma.Trigamma(x);   // 35.915302055854525
            
               double a = 4.2;
               
               // Compute the incomplete regularized Gamma functions P and Q:
               double lower = Gamma.LowerIncomplete(a, x); // 0.000015685073063633753
               double upper = Gamma.UpperIncomplete(a, x); // 0.9999843149269364
             </code>
             </example>
             
        </member>
        <member name="F:Accord.Math.Gamma.GammaMax">
            <summary>Maximum gamma on the machine.</summary>
        </member>
        <member name="M:Accord.Math.Gamma.Function(System.Double)">
            <summary>
              Gamma function of the specified value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gamma.Multivariate(System.Double,System.Int32)">
            <summary>
              Multivariate Gamma function
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gamma.Digamma(System.Double)">
            <summary>
              Digamma function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gamma.Trigamma(System.Double)">
            <summary>
              Trigamma function.
            </summary>
            
            <remarks>
              This code has been adapted from the FORTRAN77 and subsequent
              C code by B. E. Schneider and John Burkardt. The code had been
              made public under the GNU LGPL license.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Gamma.Stirling(System.Double)">
            <summary>
              Gamma function as computed by Stirling's formula.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gamma.UpperIncomplete(System.Double,System.Double)">
            <summary>
              Upper incomplete regularized Gamma function Q
              (a.k.a the incomplete complemented Gamma function)
            </summary>
            
            <remarks>
              This function is equivalent to Q(x) = Î“(s, x) / Î“(s).
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Gamma.LowerIncomplete(System.Double,System.Double)">
            <summary>
              Lower incomplete regularized gamma function P
              (a.k.a. the incomplete Gamma function).
            </summary>
            
            <remarks>
              This function is equivalent to P(x) = Î³(s, x) / Î“(s).
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Gamma.Log(System.Double)">
            <summary>
              Natural logarithm of the gamma function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gamma.Log(System.Double,System.Int32)">
            <summary>
              Natural logarithm of the multivariate Gamma function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gamma.InverseLowerIncomplete(System.Double,System.Double)">
            <summary>
              Inverse of the <see cref="M:Accord.Math.Gamma.LowerIncomplete(System.Double,System.Double)"> 
              incomplete Gamma integral (LowerIncomplete, P)</see>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gamma.InverseUpperIncomplete(System.Double,System.Double)">
            <summary>
              Inverse of the <see cref="M:Accord.Math.Gamma.UpperIncomplete(System.Double,System.Double)">complemented 
              incomplete Gamma integral (UpperIncomplete, Q)</see>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gamma.Inverse(System.Double,System.Double)">
            <summary>
              Inverse of the <see cref="M:Accord.Math.Gamma.UpperIncomplete(System.Double,System.Double)">complemented 
              incomplete Gamma integral (UpperIncomplete, Q)</see>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gamma.Random(System.Double,System.Double)">
            <summary>
              Random Gamma-distribution number generation 
              based on Marsaglia's Simple Method (2000).
            </summary>
            
        </member>
        <member name="T:Accord.Math.Constants">
            <summary>
              Common mathematical constants.
            </summary>
             
            <remarks>
              References:
              <list type="bullet">
                <item><description>
                  Cephes Math Library, http://www.netlib.org/cephes/ </description></item>
                <item><description>
                  http://www.johndcook.com/cpp_expm1.html </description></item>
              </list>
            </remarks>
            
        </member>
        <member name="F:Accord.Math.Constants.EulerGamma">
            <summary>
              Euler-Mascheroni constant.
            </summary>
            
            <remarks>
              This constant is defined as 0.5772156649015328606065120.
            </remarks>
            
        </member>
        <member name="F:Accord.Math.Constants.DoubleEpsilon">
            <summary>
              Double-precision machine round-off error.
            </summary>
            
            <remarks>
              This value is actually different from Double.Epsilon. It
              is defined as 1.11022302462515654042E-16.
            </remarks>
            
        </member>
        <member name="F:Accord.Math.Constants.SingleEpsilon">
            <summary>
              Single-precision machine round-off error.
            </summary>
            
            <remarks>
              This value is actually different from Single.Epsilon. It
              is defined as 1.1920929E-07f.
            </remarks>
            
        </member>
        <member name="F:Accord.Math.Constants.DoubleSmall">
            <summary>
              Double-precision small value.
            </summary>
            
            <remarks>
              This constant is defined as 1.493221789605150e-300.
            </remarks>
            
        </member>
        <member name="F:Accord.Math.Constants.SingleSmall">
            <summary>
              Single-precision small value.
            </summary>
            
            <remarks>
              This constant is defined as 1.493221789605150e-40f.
            </remarks>
            
        </member>
        <member name="F:Accord.Math.Constants.LogMax">
            <summary>
              Maximum log on the machine.
            </summary>
            
            <remarks>
              This constant is defined as 7.09782712893383996732E2.
            </remarks>
            
        </member>
        <member name="F:Accord.Math.Constants.LogMin">
            <summary>
              Minimum log on the machine.
            </summary>
            
            <remarks>
              This constant is defined as -7.451332191019412076235E2.
            </remarks>
            
        </member>
        <member name="F:Accord.Math.Constants.Catalan">
            <summary>
              Catalan's constant. 
            </summary>
            
        </member>
        <member name="F:Accord.Math.Constants.LogPI">
            <summary>
              Log of number pi: log(pi).
            </summary>
            
            <remarks>
              This constant has the value 1.14472988584940017414.
            </remarks>
            
        </member>
        <member name="F:Accord.Math.Constants.Log2">
            <summary>
              Log of two: log(2).
            </summary>
            
            <remarks>
              This constant has the value 0.69314718055994530941.
            </remarks>
            
        </member>
        <member name="F:Accord.Math.Constants.Log3">
            <summary>
              Log of three: log(3).
            </summary>
            
            <remarks>
              This constant has the value 1.098612288668109691395.
            </remarks>
            
        </member>
        <member name="F:Accord.Math.Constants.LogSqrt2PI">
            <summary>
              Log of square root of twice number pi: sqrt(log(2*Ï€).
            </summary>
            
            <remarks>
              This constant has the value 0.91893853320467274178032973640562.
            </remarks>
            
        </member>
        <member name="F:Accord.Math.Constants.Log2PI">
            <summary>
              Log of twice number pi: log(2*pi).
            </summary>
            
            
            <remarks>
              This constant has the value 1.837877066409345483556.
            </remarks>
            
        </member>
        <member name="F:Accord.Math.Constants.Sqrt2PI">
            <summary>
              Square root of twice number pi: sqrt(2*Ï€).
            </summary>
            
            <remarks>
              This constant has the value 2.50662827463100050242E0.
            </remarks>
            
        </member>
        <member name="F:Accord.Math.Constants.SqrtHalfPI">
            <summary>
              Square root of half number Ï€: sqrt(Ï€/2).
            </summary>
            
            <remarks>
              This constant has the value 1.25331413731550025121E0.
            </remarks>
            
        </member>
        <member name="F:Accord.Math.Constants.Sqrt2">
            <summary>
              Square root of 2: sqrt(2).
            </summary>
            
            <remarks>
              This constant has the value 1.4142135623730950488016887.
            </remarks>
            
        </member>
        <member name="F:Accord.Math.Constants.Sqrt2H">
            <summary>
              Half square root of 2: sqrt(2)/2.
            </summary>
            
            <remarks>
              This constant has the value 7.07106781186547524401E-1.
            </remarks>
            
        </member>
        <member name="T:Accord.Math.Bessel">
            <summary>
              Bessel functions.
            </summary>
             
            <remarks>
            <para>
              Bessel functions, first defined by the mathematician Daniel 
              Bernoulli and generalized by Friedrich Bessel, are the canonical
              solutions y(x) of Bessel's differential equation.</para>
              
            <para>
              Bessel's equation arises when finding separable solutions to Laplace's
              equation and the Helmholtz equation in cylindrical or spherical coordinates.
              Bessel functions are therefore especially important for many problems of wave 
              propagation and static potentials. In solving problems in cylindrical coordinate
              systems, one obtains Bessel functions of integer order (Î± = n); in spherical 
              problems, one obtains half-integer orders (Î± = n+1/2). For example:</para>
              
              <list type="bullet">
                <item><description>
                  Electromagnetic waves in a cylindrical waveguide</description></item>
                <item><description>
                  Heat conduction in a cylindrical object</description></item>
                <item><description>
                  Modes of vibration of a thin circular (or annular) artificial 
                  membrane (such as a drum or other membranophone)</description></item>
                <item><description>
                  Diffusion problems on a lattice</description></item>
                <item><description>
                  Solutions to the radial SchrÃ¶dinger equation (in spherical and
                  cylindrical coordinates) for a free particle
                <item><description>
                  Solving for patterns of acoustical radiation</description></item>
                <item><description>
                  Frequency-dependent friction in circular pipelines</description></item>
                  </description></item>
            </list>
                  
            <para>
              Bessel functions also appear in other problems, such as signal processing
              (e.g., see FM synthesis, Kaiser window, or Bessel filter).</para>
            
            <para>
              This class offers implementations of Bessel's first and second kind
              functions, with special cases for zero and for arbitrary <c>n</c>.
            </para>
            
            <para>
              References:
              <list type="bullet">
                <item><description>
                  Cephes Math Library, http://www.netlib.org/cephes/ </description></item>
                <item><description>
                  Wikipedia contributors, "Bessel function,". Wikipedia, The Free 
                  Encyclopedia. Available at: http://en.wikipedia.org/wiki/Bessel_function 
                  </description></item>
              </list></para>  
            </remarks>
            
            <example>
            <code>
              // Bessel function of order 0
              actual = Bessel.J0(1);  //  0.765197686557967
              actual = Bessel.J0(5);  // -0.177596771314338
              
              // Bessel function of order n
              double j2  = Bessel.J(2, 17.3); // 0.117351128521774
              double j01 = Bessel.J(0, 1);    // 0.765197686557967
              double j05 = Bessel.J(0, 5);    // -0.177596771314338
              
            
              // Bessel function of the second kind, of order 0.
              double y0 = Bessel.Y0(64);   // 0.037067103232088
              
              // Bessel function of the second kind, of order n.
              double y2 = Bessel.Y(2, 4);  // 0.215903594603615
              double y0 = Bessel.Y(0, 64); // 0.037067103232088
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.Bessel.J0(System.Double)">
            <summary>
              Bessel function of order 0.
            </summary>
            
            <example>
              See <see cref="T:Accord.Math.Bessel"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Bessel.J(System.Double)">
            <summary>
              Bessel function of order 1.
            </summary>
            
            <example>
              See <see cref="T:Accord.Math.Bessel"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Bessel.J(System.Int32,System.Double)">
            <summary>
              Bessel function of order <c>n</c>.
            </summary>
            
            <example>
              See <see cref="T:Accord.Math.Bessel"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Bessel.Y0(System.Double)">
            <summary>
              Bessel function of the second kind, of order 0.
            </summary>
            
            <example>
              See <see cref="T:Accord.Math.Bessel"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Bessel.Y(System.Double)">
            <summary>
              Bessel function of the second kind, of order 1.
            </summary>
            
            <example>
              See <see cref="T:Accord.Math.Bessel"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Bessel.Y(System.Int32,System.Double)">
            <summary>
              Bessel function of the second kind, of order <c>n</c>.
            </summary>
            
            <example>
              See <see cref="T:Accord.Math.Bessel"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Bessel.I0(System.Double)">
            <summary>
              Bessel function of the first kind, of order 0.
            </summary>
            
            <example>
              See <see cref="T:Accord.Math.Bessel"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Bessel.I(System.Double)">
            <summary>
              Bessel function of the first kind, of order 1.
            </summary>
            
            <example>
              See <see cref="T:Accord.Math.Bessel"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Bessel.I(System.Int32,System.Double)">
            <summary>
              Bessel function of the first kind, of order <c>n</c>.
            </summary>
            
            <example>
              See <see cref="T:Accord.Math.Bessel"/>
            </example>
            
        </member>
        <member name="T:Accord.Math.Tools">
            <summary>
              Set of mathematical tools.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.SetupGenerator(System.Nullable{System.Int32})">
             <summary>
               Sets a random seed for the framework's main 
               <see cref="P:Accord.Math.Tools.Random">internal number generator</see>.
             </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Angle(System.Single,System.Single)">
            <summary>
              Gets the angle formed by the vector [x,y].
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Angle(System.Double,System.Double)">
            <summary>
              Gets the angle formed by the vector [x,y].
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Angle(AForge.IntPoint,AForge.IntPoint)">
            <summary>
              Gets the displacement angle between two points.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Direction(AForge.IntPoint,AForge.IntPoint)">
            <summary>
              Gets the displacement angle between two points, coded
              as an integer varying from 0 to 20.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.GreatestCommonDivisor(System.Int32,System.Int32)">
            <summary>
              Gets the greatest common divisor between two integers.
            </summary>
            
            <param name="a">First value.</param>
            <param name="b">Second value.</param>
            
            <returns>The greatest common divisor.</returns>
            
        </member>
        <member name="M:Accord.Math.Tools.NextPowerOf2(System.Int32)">
            <summary>
              Returns the next power of 2 after the input value x.
            </summary>
            
            <param name="x">Input value x.</param>
            
            <returns>Returns the next power of 2 after the input value x.</returns>
            
        </member>
        <member name="M:Accord.Math.Tools.PreviousPowerOf2(System.Int32)">
            <summary>
              Returns the previous power of 2 after the input value x.
            </summary>
            
            <param name="x">Input value x.</param>
            
            <returns>Returns the previous power of 2 after the input value x.</returns>
            
        </member>
        <member name="M:Accord.Math.Tools.Hypotenuse(System.Double,System.Double)">
            <summary>
              Hypotenuse calculus without overflow/underflow
            </summary>
            
            <param name="a">First value</param>
            <param name="b">Second value</param>
            
            <returns>The hypotenuse Sqrt(a^2 + b^2)</returns>
            
        </member>
        <member name="M:Accord.Math.Tools.Hypotenuse(System.Decimal,System.Decimal)">
            <summary>
              Hypotenuse calculus without overflow/underflow
            </summary>
            
            <param name="a">first value</param>
            <param name="b">second value</param>
            
            <returns>The hypotenuse Sqrt(a^2 + b^2)</returns>
            
        </member>
        <member name="M:Accord.Math.Tools.Hypotenuse(System.Single,System.Single)">
            <summary>
              Hypotenuse calculus without overflow/underflow
            </summary>
            
            <param name="a">first value</param>
            <param name="b">second value</param>
            
            <returns>The hypotenuse Sqrt(a^2 + b^2)</returns>
            
        </member>
        <member name="M:Accord.Math.Tools.Mod(System.Int32,System.Int32)">
            <summary>
              Gets the proper modulus operation for
              an integer value x and modulo m.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Mod(System.Double,System.Double)">
            <summary>
              Gets the proper modulus operation for
              a real value x and modulo m.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(AForge.IntRange,AForge.IntRange,System.Int32)">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(AForge.DoubleRange,AForge.DoubleRange,System.Double)">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Double,System.Double,System.Double,System.Double,System.Double[])">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32[])">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(AForge.IntRange,AForge.IntRange,System.Int32[])">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(AForge.DoubleRange,AForge.DoubleRange,System.Double[])">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Single,System.Single,System.Single,System.Single,System.Single[])">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(AForge.Range,AForge.Range,System.Single[])">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Double,System.Double,System.Double[])">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Double[],System.Double[],System.Double[],System.Double[],System.Double[][])">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Double,System.Double,System.Double,System.Double,System.Double[][])">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Double[],System.Double[],System.Double,System.Double,System.Double[][])">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Double[],System.Double[],System.Double[][])">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Double,System.Double,System.Double[][])">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(AForge.IntRange,AForge.DoubleRange,System.Int32)">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Acosh(System.Double)">
            <summary>
              Returns the hyperbolic arc cosine of the specified value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Asinh(System.Double)">
            <summary>
            Returns the hyperbolic arc sine of the specified value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Atanh(System.Double)">
            <summary>
            Returns the hyperbolic arc tangent of the specified value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.FactorialPower(System.Int32,System.Int32)">
            <summary>
              Returns the factorial falling power of the specified value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.TruncatedPower(System.Double,System.Double)">
            <summary>
              Truncated power function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.InvSqrt(System.Single)">
            <summary>
              Fast inverse floating-point square root.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.StableSort``1(``0[],System.Comparison{``0})">
            <summary>
              Sorts the elements of an entire one-dimensional array using the given comparison.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.StableSort``1(``0[])">
            <summary>
              Sorts the elements of an entire one-dimensional array using the given comparison.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.StableSort``1(``0[],System.Int32[]@)">
            <summary>
              Sorts the elements of an entire one-dimensional array using the given comparison.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Interpolate1D(System.Double,System.Double[],System.Double[],System.Double,System.Double)">
            <summary>
              Interpolates data using a piece-wise linear function.
            </summary>
            
            <param name="value">The value to be calculated.</param>
            <param name="x">The input data points <c>x</c>. Those values need to be sorted.</param>
            <param name="y">The output data points <c>y</c>.</param>
            <param name="lower">
              The value to be returned for values before the first point in <paramref name="x"/>.</param>
            <param name="upper">
              The value to be returned for values after the last point in <paramref name="x"/>.</param>
              
            <returns>Computes the output for f(value) by using a piecewise linear
              interpolation of the data points <paramref name="x"/> and <paramref name="y"/>.</returns>
            
        </member>
        <member name="M:Accord.Math.Tools.Max(System.Double,System.Double,System.Double)">
            <summary>
              Gets the maximum value among three values.
            </summary>
            
            <param name="a">The first value <c>a</c>.</param>
            <param name="b">The second value <c>b</c>.</param>
            <param name="c">The third value <c>c</c>.</param>
            
            <returns>The maximum value among <paramref name="a"/>, 
              <paramref name="b"/> and <paramref name="c"/>.</returns>
            
        </member>
        <member name="M:Accord.Math.Tools.Min(System.Double,System.Double,System.Double)">
            <summary>
              Gets the minimum value among three values.
            </summary>
            
            <param name="a">The first value <c>a</c>.</param>
            <param name="b">The second value <c>b</c>.</param>
            <param name="c">The third value <c>c</c>.</param>
            
            <returns>The minimum value among <paramref name="a"/>, 
              <paramref name="b"/> and <paramref name="c"/>.</returns>
            
        </member>
        <member name="P:Accord.Math.Tools.Random">
            <summary>
              Gets a reference to the random number generator used
              internally by the Accord.NET classes and methods.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Jagged.Identity(System.Int32)">
            <summary>
              Returns the Identity matrix of the given size.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Jagged.Magic(System.Int32)">
            <summary>
              Creates a jagged magic square matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Jagged.Diagonal``1(System.Int32,``0)">
            <summary>
              Returns a square diagonal matrix of the given size.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Jagged.Diagonal``1(``0[])">
            <summary>
              Return a jagged matrix with a vector of values on its diagonal.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Vector.Shuffle``1(``0[])">
            <summary>
              Shuffles an array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Vector.Shuffle``1(System.Collections.Generic.IList{``0})">
            <summary>
              Shuffles a collection.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Vector.Sort``1(``0[],System.Comparison{``0},System.Boolean)">
            <summary>
              Sorts the elements of an entire one-dimensional array using the given comparison.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Vector.Sort``1(``0[],System.Boolean)">
            <summary>
              Sorts the elements of an entire one-dimensional array using the given comparison.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Vector.Sort``1(``0[],System.Int32[]@,System.Boolean,Accord.Math.Comparers.ComparerDirection)">
            <summary>
              Sorts the elements of an entire one-dimensional array using the given comparison.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Vector.Zeros``1(System.Int32)">
            <summary>
              Creates a zero-valued vector.
            </summary>
            
            <typeparam name="T">The type of the vector to be created.</typeparam>
            <param name="size">The number of elements in the vector.</param>
            
            <returns>A vector of the specified size.</returns>
            
        </member>
        <member name="M:Accord.Math.Vector.Ones``1(System.Int32)">
            <summary>
              Creates a zero-valued vector.
            </summary>
            
            <typeparam name="T">The type of the vector to be created.</typeparam>
            <param name="size">The number of elements in the vector.</param>
            
            <returns>A vector of the specified size.</returns>
            
        </member>
        <member name="M:Accord.Math.Vector.Zeros(System.Int32)">
            <summary>
              Creates a zero-valued vector.
            </summary>
            
            <param name="size">The number of elements in the vector.</param>
            
            <returns>A vector of the specified size.</returns>
            
        </member>
        <member name="M:Accord.Math.Vector.Ones(System.Int32)">
            <summary>
              Creates a zero-valued vector.
            </summary>
            
            <param name="size">The number of elements in the vector.</param>
            
            <returns>A vector of the specified size.</returns>
            
        </member>
        <member name="M:Accord.Math.Vector.Create``1(System.Int32,``0[])">
            <summary>
              Creates a vector with the given dimension and starting values.
            </summary>
            
            <param name="size">The number of elements in the vector.</param>
            <param name="values">The initial values for the vector.</param>
            
        </member>
        <member name="M:Accord.Math.Vector.Create``1(System.Int32)">
            <summary>
              Creates a vector with the given dimension default value.
            </summary>
            
            <param name="size">The number of elements in the vector.</param>
            
        </member>
        <member name="M:Accord.Math.Vector.Create``1(System.Int32,``0)">
            <summary>
              Creates a vector with the given dimension and starting values.
            </summary>
            
            <param name="size">The number of elements in the vector.</param>
            <param name="value">The initial value for the elements in the vector.</param>
            
        </member>
        <member name="M:Accord.Math.Vector.Random(System.Int32)">
            <summary>
              Creates a vector with uniformly distributed random data.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Vector.Random(System.Int32,System.Double,System.Double)">
            <summary>
              Creates a vector with uniformly distributed random data.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Vector.Random(System.Int32,System.Single,System.Single)">
            <summary>
              Creates a vector with uniformly distributed random data.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Vector.Interval(System.Int32,System.Int32)">
            <summary>
              Creates an interval vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Vector.Interval``1(``0,``0,System.Double)">
            <summary>
              Creates an interval vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Vector.Interval``1(``0,``0,System.Int32)">
            <summary>
              Creates an interval vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Vector.Interval(AForge.DoubleRange,System.Int32)">
            <summary>
              Creates an interval vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Vector.Interval(AForge.IntRange,System.Int32)">
            <summary>
              Creates an interval vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Vector.Interval(AForge.Range,System.Int32)">
            <summary>
              Creates an interval vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Vector.Interval(AForge.DoubleRange,System.Double)">
            <summary>
              Creates an interval vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Vector.Interval(AForge.IntRange,System.Double)">
            <summary>
              Creates an interval vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Vector.Interval(AForge.Range,System.Double)">
            <summary>
              Creates an interval vector.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Wavelets.CDF97">
            <summary>
              Cohen-Daubechies-Feauveau Wavelet Transform
            </summary>
            
        </member>
        <member name="T:Accord.Math.Wavelets.IWavelet">
            <summary>
              Common interface for wavelets algorithms.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.IWavelet.Forward(System.Double[])">
            <summary>
              1-D Forward Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.IWavelet.Forward(System.Double[0:,0:])">
            <summary>
              2-D Forward Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.IWavelet.Backward(System.Double[])">
            <summary>
              1-D Backward (Inverse) Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.IWavelet.Backward(System.Double[0:,0:])">
            <summary>
              2-D Backward (Inverse) Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.CDF97.#ctor(System.Int32)">
            <summary>
              Constructs a new Cohen-Daubechies-Feauveau Wavelet Transform.
            </summary>
            
            <param name="levels">The number of iterations for the 2D transform.</param>
            
        </member>
        <member name="M:Accord.Math.Wavelets.CDF97.Forward(System.Double[])">
            <summary>
              1-D Forward Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.CDF97.Forward(System.Double[0:,0:])">
            <summary>
              2-D Forward Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.CDF97.Backward(System.Double[])">
            <summary>
              1-D Backward (Inverse) Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.CDF97.Backward(System.Double[0:,0:])">
            <summary>
              2-D Backward (Inverse) Discrete Wavelet Transform.
            </summary>
        </member>
        <member name="M:Accord.Math.Wavelets.CDF97.FWT97(System.Double[])">
            <summary>
              Forward biorthogonal 9/7 wavelet transform
            </summary>
        </member>
        <member name="M:Accord.Math.Wavelets.CDF97.IWT97(System.Double[])">
            <summary>
              Inverse biorthogonal 9/7 wavelet transform
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.CDF97.FWT97(System.Double[0:,0:],System.Int32)">
            <summary>
              Forward biorthogonal 9/7 2D wavelet transform
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.CDF97.IWT97(System.Double[0:,0:],System.Int32)">
            <summary>
              Inverse biorthogonal 9/7 2D wavelet transform
            </summary>
            
        </member>
        <member name="T:Accord.Math.Wavelets.Haar">
            <summary>
              Haar Wavelet Transform.
            </summary>
            
            <remarks>
            <para>
              References:
              <list type="bullet">
                <item><description>
                  Musawir Ali, An Introduction to Wavelets and the Haar Transform.
                  Available on: http://www.cs.ucf.edu/~mali/haar/ </description></item>
              </list>
            </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Wavelets.Haar.#ctor(System.Int32)">
            <summary>
              Constructs a new Haar Wavelet Transform.
            </summary>
            <param name="levels">The number of iterations for the 2D transform.</param>
            
        </member>
        <member name="M:Accord.Math.Wavelets.Haar.Forward(System.Double[])">
            <summary>
              1-D Forward Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.Haar.Backward(System.Double[])">
            <summary>
              1-D Backward (Inverse) Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.Haar.Forward(System.Double[0:,0:])">
            <summary>
              2-D Forward Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.Haar.Backward(System.Double[0:,0:])">
            <summary>
              2-D Backward (Inverse) Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.Haar.FWT(System.Double[])">
            <summary>
              Discrete Haar Wavelet Transform
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.Haar.IWT(System.Double[])">
            <summary>
              Inverse Haar Wavelet Transform
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.Haar.FWT(System.Double[0:,0:],System.Int32)">
            <summary>
              Discrete Haar Wavelet 2D Transform
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.Haar.IWT(System.Double[0:,0:],System.Int32)">
            <summary>
              Inverse Haar Wavelet 2D Transform
            </summary>
            
        </member>
    </members>
</doc>
