<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ output extension=".txt"#>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating"#>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="T4Toolbox.tt"#>
<#
    new MatrixOperationTemplate("Add", "Elementwise addition between", "and", "To", "+", true).RenderToFile("Matrix.Add.Generated.cs");
    new MatrixOperationTemplate("Subtract", "Elementwise subtraction between", "and", "From", "-", true).RenderToFile("Matrix.Subtract.Generated.cs");
    new MatrixOperationTemplate("Multiply", "Elementwise multiplication (note: this is not a dot or matrix product) between", "and", "With", "*", false).RenderToFile("Matrix.Multiply.Generated.cs");
    new MatrixOperationTemplate("Divide", "Elementwise division between", "and", "By", "/", false).RenderToFile("Matrix.Divide.Generated.cs");
#>
<#+
public class MatrixOperationTemplate : Template
{
    public string name;
    public string act;
    public string com;
    public string Com;
    public string op;
    public string ext;

    public MatrixOperationTemplate(string name, string act, string com, string Com, string op, bool ext) 
    { 
        this.name = name;
        this.act  = act;
        this.com  = com;
        this.Com = Com;
        this.op   = op;
    }

    public override string TransformText()
    {
        string[] types =
        { 
            "int", 
            "float", "double", 
            "byte", 
            //"sbyte", 
            "decimal",
            "short",
            // "long",
            // "uint", "ulong", "ushort"
        };

        string dim_doc = @"		/// <param name=""dimension"">
        ///   The type of the vector being passed to the function. If the vector
        ///   is a <see href=""VectorType.RowVector""/>, then the operation will
        ///   be applied between each row of the matrix and the given vector. If
        ///   the vector is a <see href=""VectorType.ColumnVector""/>, then the 
        ///   operation will be applied between each column of the matrix and the
        ///   given vector.
        /// </param>";

#>
// Accord Math Library
// The Accord.NET Framework
// http://accord-framework.net
//
// Copyright © César Souza, 2009-2017
// cesarsouza at gmail.com
//
//    This library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    This library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with this library; if not, write to the Free Software
//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
//

// ======================================================================
// This code has been generated by a tool; do not edit manually. Instead,
// edit the T4 template Matrix.Elementwise2.tt so this file can be regenerated. 
// ======================================================================

namespace Accord.Math
{
    using System;
    using Accord.Math;
    using System.Runtime.CompilerServices;

    public static partial class Elementwise
    {
#pragma warning disable 1591
<#+ 
        foreach (string a in types)
        {
            foreach (string b in types)
            {       
                string r = null;
                if (a == b)
                    r = a;
                else if (a == "double" || b == "double")
                    r = "double";
                else if (a == "float" || b == "float")
                    r = "float";
                else if (a == "int" || b == "int")
                    r = "int";
                else if (a == "uint" || b == "uint")
                    r = "uint";
                else 
                    continue;

                if (name == "Divide")
                {
                    if (a == "int" && b == "int")
                        r = "double";
                }
#>

        /// <summary>
        ///   <#=act#> a matrix <c>A</c> <#=com#> a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] <#=name#>(this <#=a#>[,] a, <#=b#> b)
        {
            return <#=name#>(a, b, new <#=r#>[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   <#=act#> a matrix <c>A</c> <#=com#> a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] <#=name#>(this <#=a#>[][] a, <#=b#> b)
        {
            return <#=name#>(a, b, JaggedCreateAs<<#=a#>, <#=r#>>(a));
        }

        /// <summary>
        ///   <#=act#> a vector <c>a</c> <#=com#> a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static <#=r#>[] <#=name#>(this <#=a#>[] a, <#=b#> b)
        {
            return <#=name#>(a, b, new <#=r#>[a.Length]);
        }

        /// <summary>
        ///   <#=act#> a vector <c>a</c> <#=com#> a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] <#=name#>(this <#=a#>[] a, <#=b#>[] b)
        {
            return <#=name#>(a, b, new <#=r#>[a.Length]);
        }     

        /// <summary>
        ///   <#=act#> a matrix <c>A</c> <#=com#> a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] <#=name#>(this <#=a#>[][] a, <#=b#>[][] b)
        {
            return <#=name#>(a, b, JaggedCreateAs<<#=a#>, <#=r#>>(a));
        }     

        /// <summary>
        ///   <#=act#> a matrix <c>A</c> <#=com#> a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] <#=name#>(this <#=a#>[,] a, <#=b#>[,] b)
        {
            return <#=name#>(a, b, MatrixCreateAs<<#=a#>, <#=r#>>(a));
        }     

        /// <summary>
        ///   <#=act#> a scalar <c>a</c> <#=com#> a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] <#=name#>(this <#=a#> a, <#=b#>[,] b)
        {
            return <#=name#>(a, b, MatrixCreateAs<<#=b#>, <#=r#>>(b));
        }     

        /// <summary>
        ///   <#=act#> a scalar <c>a</c> <#=com#> a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] <#=name#>(this <#=a#> a, <#=b#>[][] b)
        {
            return <#=name#>(a, b, JaggedCreateAs<<#=b#>, <#=r#>>(b));
        }     

        /// <summary>
        ///   <#=act#> a scalar <c>a</c> <#=com#> a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] <#=name#>(this <#=a#> a, <#=b#>[] b)
        {
            return <#=name#>(a, b, new <#=r#>[b.Length]);
        }







        

        /// <summary>
        ///   <#=act#> a matrix <c>A</c> <#=com#> a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
<#=dim_doc#>
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] <#=name#>(this <#=a#>[,] a, <#=b#>[] b, VectorType dimension)
        {
            return <#=name#>(a, b, dimension, MatrixCreateAs<<#=a#>, <#=r#>>(a));
        }

        /// <summary>
        ///   <#=act#> a matrix <c>A</c> <#=com#> a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
<#=dim_doc#>
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] <#=name#>(this <#=a#>[][] a, <#=b#>[] b, VectorType dimension)
        {
            return <#=name#>(a, b, dimension, JaggedCreateAs<<#=a#>, <#=r#>>(a));
        }

                /// <summary>
        ///   <#=act#> a matrix <c>A</c> <#=com#> a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
<#=dim_doc#>
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] <#=name#>(this <#=a#>[] a, <#=b#>[,] b, VectorType dimension)
        {
            return <#=name#>(a, b, dimension, MatrixCreateAs<<#=b#>, <#=r#>>(b));
        }

        /// <summary>
        ///   <#=act#> a matrix <c>A</c> <#=com#> a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
<#=dim_doc#>
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] <#=name#>(this <#=a#>[] a, <#=b#>[][] b, VectorType dimension)
        {
            return <#=name#>(a, b, dimension, JaggedCreateAs<<#=b#>, <#=r#>>(b));
        }




        /// <summary>
        ///   Obsolete. Please specify a <see cref="VectorType"/> in place of an integer in the dimension argument.
        /// </summary>
        ///
        [Obsolete("Please specify a VectorType instead of an integer for the dimension argument")]
        public static <#=r#>[,] <#=name#>(this <#=a#>[,] a, <#=b#>[] b, int dimension)
        {
            return <#=name#>(a, b, dimension, MatrixCreateAs<<#=a#>, <#=r#>>(a));
        }

        /// <summary>
        ///   Obsolete. Please specify a <see cref="VectorType"/> in place of an integer in the dimension argument.
        /// </summary>
        ///
        [Obsolete("Please specify a VectorType instead of an integer for the dimension argument")]
        public static <#=r#>[][] <#=name#>(this <#=a#>[][] a, <#=b#>[] b, int dimension)
        {
            return <#=name#>(a, b, dimension, JaggedCreateAs<<#=a#>, <#=r#>>(a));
        }

        /// <summary>
        ///   Obsolete. Please specify a <see cref="VectorType"/> in place of an integer in the dimension argument.
        /// </summary>
        ///
        [Obsolete("Please specify a VectorType instead of an integer for the dimension argument")]
        public static <#=r#>[,] <#=name#>(this <#=a#>[] a, <#=b#>[,] b, int dimension)
        {
            return <#=name#>(a, b, dimension, MatrixCreateAs<<#=b#>, <#=r#>>(b));
        }

        /// <summary>
        ///   Obsolete. Please specify a <see cref="VectorType"/> in place of an integer in the dimension argument.
        /// </summary>
        ///
        [Obsolete("Please specify a VectorType instead of an integer for the dimension argument")]
        public static <#=r#>[][] <#=name#>(this <#=a#>[] a, <#=b#>[][] b, int dimension)
        {
            return <#=name#>(a, b, dimension, JaggedCreateAs<<#=b#>, <#=r#>>(b));
        }






        /// <summary>
        ///   <#=act#> a scalar <c>a</c> <#=com#> to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=b#>[,] <#=name#><#=Com#>Diagonal(this <#=a#> a, <#=b#>[,] b)
        {
            return <#=name#><#=Com#>Diagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   <#=act#> a scalar <c>a</c> <#=com#> to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=b#>[][] <#=name#><#=Com#>Diagonal(this <#=a#> a, <#=b#>[][] b)
        {
            return <#=name#><#=Com#>Diagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   <#=act#> a scalar <c>a</c> <#=com#> to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=b#>[,] <#=name#><#=Com#>Diagonal(this <#=a#>[] a, <#=b#>[,] b)
        {
            return <#=name#><#=Com#>Diagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   <#=act#> a scalar <c>a</c> <#=com#> to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=b#>[][] <#=name#><#=Com#>Diagonal(this <#=a#>[] a, <#=b#>[][] b)
        {
            return <#=name#><#=Com#>Diagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   <#=act#> a scalar <c>a</c> <#=com#> to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=a#>[,] <#=name#><#=Com#>Diagonal(this <#=a#>[,] a, <#=b#> b)
        {
            return <#=name#><#=Com#>Diagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   <#=act#> a scalar <c>a</c> <#=com#> to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=a#>[][] <#=name#><#=Com#>Diagonal(this <#=a#>[][] a, <#=b#> b)
        {
            return <#=name#><#=Com#>Diagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   <#=act#> a scalar <c>a</c> <#=com#> to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=a#>[,] <#=name#><#=Com#>Diagonal(this <#=a#>[,] a, <#=b#>[] b)
        {
            return <#=name#><#=Com#>Diagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   <#=act#> a scalar <c>a</c> <#=com#> to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=a#>[][] <#=name#><#=Com#>Diagonal(this <#=a#>[][] a, <#=b#>[] b)
        {
            return <#=name#><#=Com#>Diagonal(a, b, a.MemberwiseClone());
        }
 
<#+
            }
        }


















        foreach (string a in types)
        {
            foreach (string b in types)
            {
                var resultTypes = new HashSet<string>() { a, b, "double" };

                foreach (string r in resultTypes)
                {
#>

        #region Matrix matrix

        /// <summary>
        ///   <#=act#> a matrix <c>A</c> <#=com#> a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] <#=name#>(this <#=a#>[][] a, <#=b#>[][] b, <#=r#>[][] result)
        {
            check<<#=a#>, <#=b#>, <#=r#>>(a: a, b: b, result: result);
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (<#=r#>)((<#=r#>)(a[i][j]) <#=op#> (<#=r#>)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   <#=act#> a matrix <c>A</c> <#=com#> a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] <#=name#>(this <#=a#>[,] a, <#=b#>[,] b, <#=r#>[,] result)
        {
            check<<#=a#>, <#=b#>, <#=r#>>(a: a, b: b, result: result);
            unsafe
            {
                fixed (<#=a#>* ptrA = a)
                fixed (<#=b#>* ptrB = b)
                fixed (<#=r#>* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (<#=r#>)((<#=r#>)(*pa) <#=op#> (<#=r#>)(*pb));
                }
            }

            return result;
        }
#endregion


























        #region Matrix with scalar

        /// <summary>
        ///   <#=act#> a matrix <c>A</c> <#=com#> a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] <#=name#>(this <#=a#>[][] a, <#=b#> b, <#=r#>[][] result)
        {
            check<<#=a#>, <#=b#>, <#=r#>>(a: a, b: b, result: result);
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (<#=r#>)((<#=r#>)a[i][j] <#=op#> (<#=r#>)b);
            return result;
        }

        /// <summary>
        ///   <#=act#> a scalar <c>a</c> <#=com#> a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] <#=name#>(this <#=a#> a, <#=b#>[][] b, <#=r#>[][] result)
        {
            check<<#=a#>, <#=b#>, <#=r#>>(a: a, b: b, result: result);
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (<#=r#>)((<#=r#>)a <#=op#> (<#=r#>)b[i][j]);
            return result;
        }

        /// <summary>
        ///   <#=act#> a scalar <c>a</c> <#=com#> a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] <#=name#>(this <#=a#> a, <#=b#>[,] b, <#=r#>[,] result)
        {
            check<<#=a#>, <#=b#>, <#=r#>>(a: a, b: b, result: result);
            unsafe
            {
                fixed (<#=b#>* ptrB = b)        
                fixed (<#=r#>* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (<#=r#>)((<#=r#>)a <#=op#> (<#=r#>)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   <#=act#> a matrix <c>A</c> <#=com#> a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] <#=name#>(this <#=a#>[,] a, <#=b#> b, <#=r#>[,] result)
        {
            check<<#=a#>, <#=b#>, <#=r#>>(a: a, b: b, result: result);
            unsafe
            {
                fixed (<#=a#>* ptrA = a)
                fixed (<#=r#>* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (<#=r#>)((<#=r#>)(*pa) <#=op#> (<#=r#>)b);
                }
            }

            return result;
        }
        #endregion
























        #region vector vector

        /// <summary>
        ///   <#=act#> a vector <c>a</c> <#=com#> a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] <#=name#>(this <#=a#>[] a, <#=b#>[] b, <#=r#>[] result)
        {
            check<<#=a#>, <#=b#>, <#=r#>>(a: a, b: b, result: result);
            for (int i = 0; i < a.Length; i++)
                result[i] = (<#=r#>)((<#=r#>)a[i] <#=op#> (<#=r#>)b[i]);
            return result;
        }
        #endregion






        #region Vector with scalar

        /// <summary>
        ///   <#=act#> a vector <c>a</c> <#=com#> a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] <#=name#>(this <#=a#>[] a, <#=b#> b, <#=r#>[] result)
        {
            check<<#=a#>, <#=b#>, <#=r#>>(a: a, b: b, result: result);
            for (int i = 0; i < a.Length; i++)
                result[i] = (<#=r#>)((<#=r#>)a[i] <#=op#> (<#=r#>)b);
            return result;
        }

        /// <summary>
        ///   <#=act#> a scalar <c>a</c> <#=com#> a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] <#=name#>(this <#=a#> a, <#=b#>[] b, <#=r#>[] result)
        {
            check<<#=a#>, <#=b#>, <#=r#>>(a: a, b: b, result: result);
            for (int i = 0; i < b.Length; i++)
                result[i] = (<#=r#>)((<#=r#>)a <#=op#> (<#=r#>)b[i]);
            return result;
        }
        #endregion






        #region Matrix vector (dimension)
        /// <summary>
        ///   Obsolete. Please specify a <see cref="VectorType"/> in place of an integer in the dimension argument.
        /// </summary>
        ///
        [Obsolete("Please specify a VectorType instead of an integer for the dimension argument")]
        public static <#=r#>[,] <#=name#>(this <#=a#>[] a, <#=b#>[,] b, int dimension, <#=r#>[,] result)
        {
            return <#=name#>(a, b, (VectorType)dimension, result);
        }

        /// <summary>
        ///   Obsolete. Please specify a <see cref="VectorType"/> in place of an integer in the dimension argument.
        /// </summary>
        ///
        [Obsolete("Please specify a VectorType instead of an integer for the dimension argument")]
        public static <#=r#>[][] <#=name#>(this <#=a#>[] a, <#=b#>[][] b, int dimension, <#=r#>[][] result)
        {
            return <#=name#>(a, b, (VectorType)dimension, result);
        }

        /// <summary>
        ///   Obsolete. Please specify a <see cref="VectorType"/> in place of an integer in the dimension argument.
        /// </summary>
        ///
        [Obsolete("Please specify a VectorType instead of an integer for the dimension argument")]
        public static <#=r#>[,] <#=name#>(this <#=a#>[,] a, <#=b#>[] b, int dimension, <#=r#>[,] result)
        {
            return <#=name#>(a, b, (VectorType)dimension, result);
        }

        /// <summary>
        ///   Obsolete. Please specify a <see cref="VectorType"/> in place of an integer in the dimension argument.
        /// </summary>
        ///
        [Obsolete("Please specify a VectorType instead of an integer for the dimension argument")]
        public static <#=r#>[][] <#=name#>(this <#=a#>[][] a, <#=b#>[] b, int dimension, <#=r#>[][] result)
        {
            return <#=name#>(a, b, (VectorType)dimension, result);
        }
        #endregion




        #region Matrix vector (enumeration)
        /// <summary>
        ///   <#=act#> a matrix <c>A</c> <#=com#> a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
<#=dim_doc#>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] <#=name#>(this <#=a#>[] a, <#=b#>[,] b, VectorType dimension, <#=r#>[,] result)
        {
            return <#=name#>(b, a, dimension, result);
        }

        /// <summary>
        ///   <#=act#> a matrix <c>A</c> <#=com#> a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
<#=dim_doc#>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] <#=name#>(this <#=a#>[] a, <#=b#>[][] b, VectorType dimension, <#=r#>[][] result)
        {
            return <#=name#>(b, a, dimension, result);
        }

        /// <summary>
        ///   <#=act#> a matrix <c>A</c> <#=com#> a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
<#=dim_doc#>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] <#=name#>(this <#=a#>[,] a, <#=b#>[] b, VectorType dimension, <#=r#>[,] result)
        {
            check<<#=a#>, <#=b#>, <#=r#>>(d: dimension, a: a, b: b, result: result);
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (<#=r#>)((<#=r#>)a[i, j] <#=op#> (<#=r#>)b[j]);
            }
            else
            {
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (<#=r#>)((<#=r#>)a[i, j] <#=op#> (<#=r#>)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   <#=act#> a matrix <c>A</c> <#=com#> a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
<#=dim_doc#>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] <#=name#>(this <#=a#>[][] a, <#=b#>[] b, VectorType dimension, <#=r#>[][] result)
        {
            check<<#=a#>, <#=b#>, <#=r#>>(d: dimension, a: a, b: b, result: result);
            if (dimension == 0)
            {
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (<#=r#>)((<#=r#>)a[i][j] <#=op#> (<#=r#>)b[j]);
            }
            else
            {
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (<#=r#>)((<#=r#>)a[i][j] <#=op#> (<#=r#>)b[i]);
            }

            return result;
        }
        #endregion










        #region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] <#=name#><#=Com#>Diagonal(this <#=a#> a, <#=b#>[,] b, <#=r#>[,] result)
        {
            check<<#=a#>, <#=b#>, <#=r#>>(a: a, b: b, result: result);
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (<#=b#>* ptrB = b)        
                fixed (<#=r#>* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (<#=r#>)((<#=r#>)a <#=op#> (<#=r#>)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] <#=name#><#=Com#>Diagonal(this <#=a#> a, <#=b#>[][] b, <#=r#>[][] result)
        {
            check<<#=a#>, <#=b#>, <#=r#>>(a: a, b: b, result: result);
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (<#=r#>)((<#=r#>)a <#=op#> (<#=r#>)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] <#=name#><#=Com#>Diagonal(this <#=a#>[] a, <#=b#>[,] b, <#=r#>[,] result)
        {
            check<<#=a#>, <#=b#>, <#=r#>>(a: a, b: b, result: result);
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (<#=b#>* ptrB = b)        
                fixed (<#=r#>* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (<#=r#>)((<#=r#>)a[j] <#=op#> (<#=r#>)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] <#=name#><#=Com#>Diagonal(this <#=a#>[] a, <#=b#>[][] b, <#=r#>[][] result)
        {
            check<<#=a#>, <#=b#>, <#=r#>>(a: a, b: b, result: result);
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (<#=r#>)((<#=r#>)a[i] <#=op#> (<#=r#>)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] <#=name#><#=Com#>Diagonal(this <#=a#>[,] a, <#=b#> b, <#=r#>[,] result)
        {
            check<<#=a#>, <#=b#>, <#=r#>>(a: a, b: b, result: result);
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (<#=a#>* ptrA = a)        
                fixed (<#=r#>* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (<#=r#>)((<#=r#>)(*pa) <#=op#> (<#=r#>)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] <#=name#><#=Com#>Diagonal(this <#=a#>[][] a, <#=b#> b, <#=r#>[][] result)
        {
            check<<#=a#>, <#=b#>, <#=r#>>(a: a, b: b, result: result);
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (<#=r#>)((<#=r#>)a[i][i] <#=op#> (<#=r#>)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] <#=name#><#=Com#>Diagonal(this <#=a#>[,] a, <#=b#>[] b, <#=r#>[,] result)
        {
            check<<#=a#>, <#=b#>, <#=r#>>(a: a, b: b, result: result);
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (<#=a#>* ptrA = a)        
                fixed (<#=r#>* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (<#=r#>)((<#=r#>)(*pa) <#=op#> (<#=r#>)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] <#=name#><#=Com#>Diagonal(this <#=a#>[][] a, <#=b#>[] b, <#=r#>[][] result)
        {
            check<<#=a#>, <#=b#>, <#=r#>>(a: a, b: b, result: result);
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (<#=r#>)((<#=r#>)a[i][i] <#=op#> (<#=r#>)b[i]);
            return result;
        }
 
        #endregion
     
<#+
                }
            }
        }
#>
#pragma warning restore 1591
    }
}
<#+
        return this.GenerationEnvironment.ToString();
    }
}
#>