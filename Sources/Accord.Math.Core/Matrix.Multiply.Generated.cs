// Accord Math Library
// The Accord.NET Framework
// http://accord-framework.net
//
// Copyright © César Souza, 2009-2017
// cesarsouza at gmail.com
//
//    This library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    This library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with this library; if not, write to the Free Software
//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
//

// ======================================================================
// This code has been generated by a tool; do not edit manually. Instead,
// edit the T4 template Matrix.Elementwise2.tt so this file can be regenerated. 
// ======================================================================

namespace Accord.Math
{
#if DEBUG
    #define CHECK
#endif

    using System;
    using Accord.Math;
    using System.Runtime.CompilerServices;

    public static partial class Elementwise
    {
#pragma warning disable 1591

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[,] a, int b)
        {
            return Multiply(a, b, new int[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a, int b)
        {
            return Multiply(a, b, JaggedCreateAs<int, int>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static int[] Multiply(this int[] a, int b)
        {
            return Multiply(a, b, new int[a.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this int[] a, int[] b)
        {
            return Multiply(a, b, new int[a.Length]);
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a, int[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<int, int>(a));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[,] a, int[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<int, int>(a));
        }     
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a, int[,] b)
        {
            return Multiply(a, b, JaggedCreateAs<int, int>(a));
        }      
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int a, int[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<int, int>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int a, int[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<int, int>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this int a, int[] b)
        {
            return Multiply(a, b, new int[b.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[,] a,  int[] b, int dimension)
        {
            return Multiply(a, b, dimension, MatrixCreateAs<int, int>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a,  int[] b, int dimension)
        {
            return Multiply(a, b, dimension, JaggedCreateAs<int, int>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int a, int[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int a, int[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int[] a, int[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int[] a, int[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int[,] a, int b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int[][] a, int b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int[,] a, int[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int[][] a, int[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this int[,] a, float b)
        {
            return Multiply(a, b, new float[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this int[][] a, float b)
        {
            return Multiply(a, b, JaggedCreateAs<int, float>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static float[] Multiply(this int[] a, float b)
        {
            return Multiply(a, b, new float[a.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this int[] a, float[] b)
        {
            return Multiply(a, b, new float[a.Length]);
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this int[][] a, float[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<int, float>(a));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this int[,] a, float[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<int, float>(a));
        }     
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this int[][] a, float[,] b)
        {
            return Multiply(a, b, JaggedCreateAs<int, float>(a));
        }      
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this int a, float[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<float, float>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this int a, float[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<float, float>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this int a, float[] b)
        {
            return Multiply(a, b, new float[b.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this int[,] a,  float[] b, int dimension)
        {
            return Multiply(a, b, dimension, MatrixCreateAs<int, float>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this int[][] a,  float[] b, int dimension)
        {
            return Multiply(a, b, dimension, JaggedCreateAs<int, float>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this int a, float[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this int a, float[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this int[] a, float[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this int[] a, float[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int[,] a, float b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int[][] a, float b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int[,] a, float[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int[][] a, float[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[,] a, double b)
        {
            return Multiply(a, b, new double[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[][] a, double b)
        {
            return Multiply(a, b, JaggedCreateAs<int, double>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static double[] Multiply(this int[] a, double b)
        {
            return Multiply(a, b, new double[a.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this int[] a, double[] b)
        {
            return Multiply(a, b, new double[a.Length]);
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[][] a, double[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<int, double>(a));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[,] a, double[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<int, double>(a));
        }     
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[][] a, double[,] b)
        {
            return Multiply(a, b, JaggedCreateAs<int, double>(a));
        }      
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int a, double[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<double, double>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int a, double[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<double, double>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this int a, double[] b)
        {
            return Multiply(a, b, new double[b.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[,] a,  double[] b, int dimension)
        {
            return Multiply(a, b, dimension, MatrixCreateAs<int, double>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[][] a,  double[] b, int dimension)
        {
            return Multiply(a, b, dimension, JaggedCreateAs<int, double>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this int a, double[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this int a, double[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this int[] a, double[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this int[] a, double[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int[,] a, double b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int[][] a, double b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int[,] a, double[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int[][] a, double[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[,] a, byte b)
        {
            return Multiply(a, b, new int[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a, byte b)
        {
            return Multiply(a, b, JaggedCreateAs<int, int>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static int[] Multiply(this int[] a, byte b)
        {
            return Multiply(a, b, new int[a.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this int[] a, byte[] b)
        {
            return Multiply(a, b, new int[a.Length]);
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a, byte[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<int, int>(a));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[,] a, byte[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<int, int>(a));
        }     
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a, byte[,] b)
        {
            return Multiply(a, b, JaggedCreateAs<int, int>(a));
        }      
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int a, byte[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<byte, int>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int a, byte[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<byte, int>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this int a, byte[] b)
        {
            return Multiply(a, b, new int[b.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[,] a,  byte[] b, int dimension)
        {
            return Multiply(a, b, dimension, MatrixCreateAs<int, int>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a,  byte[] b, int dimension)
        {
            return Multiply(a, b, dimension, JaggedCreateAs<int, int>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this int a, byte[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this int a, byte[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this int[] a, byte[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this int[] a, byte[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int[,] a, byte b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int[][] a, byte b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int[,] a, byte[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int[][] a, byte[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[,] a, decimal b)
        {
            return Multiply(a, b, new int[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a, decimal b)
        {
            return Multiply(a, b, JaggedCreateAs<int, int>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static int[] Multiply(this int[] a, decimal b)
        {
            return Multiply(a, b, new int[a.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this int[] a, decimal[] b)
        {
            return Multiply(a, b, new int[a.Length]);
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a, decimal[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<int, int>(a));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[,] a, decimal[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<int, int>(a));
        }     
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a, decimal[,] b)
        {
            return Multiply(a, b, JaggedCreateAs<int, int>(a));
        }      
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int a, decimal[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<decimal, int>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int a, decimal[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<decimal, int>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this int a, decimal[] b)
        {
            return Multiply(a, b, new int[b.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[,] a,  decimal[] b, int dimension)
        {
            return Multiply(a, b, dimension, MatrixCreateAs<int, int>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a,  decimal[] b, int dimension)
        {
            return Multiply(a, b, dimension, JaggedCreateAs<int, int>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this int a, decimal[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this int a, decimal[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this int[] a, decimal[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this int[] a, decimal[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int[,] a, decimal b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int[][] a, decimal b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int[,] a, decimal[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int[][] a, decimal[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a, int b)
        {
            return Multiply(a, b, new float[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a, int b)
        {
            return Multiply(a, b, JaggedCreateAs<float, float>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static float[] Multiply(this float[] a, int b)
        {
            return Multiply(a, b, new float[a.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this float[] a, int[] b)
        {
            return Multiply(a, b, new float[a.Length]);
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a, int[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<float, float>(a));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a, int[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<float, float>(a));
        }     
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a, int[,] b)
        {
            return Multiply(a, b, JaggedCreateAs<float, float>(a));
        }      
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float a, int[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<int, float>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float a, int[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<int, float>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this float a, int[] b)
        {
            return Multiply(a, b, new float[b.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a,  int[] b, int dimension)
        {
            return Multiply(a, b, dimension, MatrixCreateAs<float, float>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a,  int[] b, int dimension)
        {
            return Multiply(a, b, dimension, JaggedCreateAs<float, float>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this float a, int[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this float a, int[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this float[] a, int[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this float[] a, int[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float[,] a, int b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float[][] a, int b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float[,] a, int[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float[][] a, int[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a, float b)
        {
            return Multiply(a, b, new float[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a, float b)
        {
            return Multiply(a, b, JaggedCreateAs<float, float>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static float[] Multiply(this float[] a, float b)
        {
            return Multiply(a, b, new float[a.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this float[] a, float[] b)
        {
            return Multiply(a, b, new float[a.Length]);
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a, float[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<float, float>(a));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a, float[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<float, float>(a));
        }     
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a, float[,] b)
        {
            return Multiply(a, b, JaggedCreateAs<float, float>(a));
        }      
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float a, float[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<float, float>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float a, float[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<float, float>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this float a, float[] b)
        {
            return Multiply(a, b, new float[b.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a,  float[] b, int dimension)
        {
            return Multiply(a, b, dimension, MatrixCreateAs<float, float>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a,  float[] b, int dimension)
        {
            return Multiply(a, b, dimension, JaggedCreateAs<float, float>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float a, float[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float a, float[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float[] a, float[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float[] a, float[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float[,] a, float b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float[][] a, float b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float[,] a, float[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float[][] a, float[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[,] a, double b)
        {
            return Multiply(a, b, new double[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[][] a, double b)
        {
            return Multiply(a, b, JaggedCreateAs<float, double>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static double[] Multiply(this float[] a, double b)
        {
            return Multiply(a, b, new double[a.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this float[] a, double[] b)
        {
            return Multiply(a, b, new double[a.Length]);
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[][] a, double[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<float, double>(a));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[,] a, double[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<float, double>(a));
        }     
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[][] a, double[,] b)
        {
            return Multiply(a, b, JaggedCreateAs<float, double>(a));
        }      
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float a, double[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<double, double>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float a, double[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<double, double>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this float a, double[] b)
        {
            return Multiply(a, b, new double[b.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[,] a,  double[] b, int dimension)
        {
            return Multiply(a, b, dimension, MatrixCreateAs<float, double>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[][] a,  double[] b, int dimension)
        {
            return Multiply(a, b, dimension, JaggedCreateAs<float, double>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this float a, double[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this float a, double[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this float[] a, double[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this float[] a, double[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float[,] a, double b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float[][] a, double b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float[,] a, double[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float[][] a, double[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a, byte b)
        {
            return Multiply(a, b, new float[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a, byte b)
        {
            return Multiply(a, b, JaggedCreateAs<float, float>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static float[] Multiply(this float[] a, byte b)
        {
            return Multiply(a, b, new float[a.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this float[] a, byte[] b)
        {
            return Multiply(a, b, new float[a.Length]);
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a, byte[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<float, float>(a));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a, byte[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<float, float>(a));
        }     
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a, byte[,] b)
        {
            return Multiply(a, b, JaggedCreateAs<float, float>(a));
        }      
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float a, byte[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<byte, float>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float a, byte[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<byte, float>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this float a, byte[] b)
        {
            return Multiply(a, b, new float[b.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a,  byte[] b, int dimension)
        {
            return Multiply(a, b, dimension, MatrixCreateAs<float, float>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a,  byte[] b, int dimension)
        {
            return Multiply(a, b, dimension, JaggedCreateAs<float, float>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this float a, byte[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this float a, byte[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this float[] a, byte[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this float[] a, byte[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float[,] a, byte b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float[][] a, byte b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float[,] a, byte[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float[][] a, byte[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a, decimal b)
        {
            return Multiply(a, b, new float[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a, decimal b)
        {
            return Multiply(a, b, JaggedCreateAs<float, float>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static float[] Multiply(this float[] a, decimal b)
        {
            return Multiply(a, b, new float[a.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this float[] a, decimal[] b)
        {
            return Multiply(a, b, new float[a.Length]);
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a, decimal[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<float, float>(a));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a, decimal[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<float, float>(a));
        }     
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a, decimal[,] b)
        {
            return Multiply(a, b, JaggedCreateAs<float, float>(a));
        }      
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float a, decimal[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<decimal, float>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float a, decimal[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<decimal, float>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this float a, decimal[] b)
        {
            return Multiply(a, b, new float[b.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a,  decimal[] b, int dimension)
        {
            return Multiply(a, b, dimension, MatrixCreateAs<float, float>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a,  decimal[] b, int dimension)
        {
            return Multiply(a, b, dimension, JaggedCreateAs<float, float>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this float a, decimal[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this float a, decimal[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this float[] a, decimal[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this float[] a, decimal[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float[,] a, decimal b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float[][] a, decimal b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float[,] a, decimal[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float[][] a, decimal[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a, int b)
        {
            return Multiply(a, b, new double[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, int b)
        {
            return Multiply(a, b, JaggedCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static double[] Multiply(this double[] a, int b)
        {
            return Multiply(a, b, new double[a.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this double[] a, int[] b)
        {
            return Multiply(a, b, new double[a.Length]);
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, int[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<double, double>(a));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a, int[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<double, double>(a));
        }     
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, int[,] b)
        {
            return Multiply(a, b, JaggedCreateAs<double, double>(a));
        }      
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double a, int[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<int, double>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double a, int[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<int, double>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this double a, int[] b)
        {
            return Multiply(a, b, new double[b.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a,  int[] b, int dimension)
        {
            return Multiply(a, b, dimension, MatrixCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a,  int[] b, int dimension)
        {
            return Multiply(a, b, dimension, JaggedCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this double a, int[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this double a, int[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this double[] a, int[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this double[] a, int[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double[,] a, int b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double[][] a, int b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double[,] a, int[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double[][] a, int[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a, float b)
        {
            return Multiply(a, b, new double[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, float b)
        {
            return Multiply(a, b, JaggedCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static double[] Multiply(this double[] a, float b)
        {
            return Multiply(a, b, new double[a.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this double[] a, float[] b)
        {
            return Multiply(a, b, new double[a.Length]);
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, float[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<double, double>(a));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a, float[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<double, double>(a));
        }     
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, float[,] b)
        {
            return Multiply(a, b, JaggedCreateAs<double, double>(a));
        }      
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double a, float[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<float, double>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double a, float[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<float, double>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this double a, float[] b)
        {
            return Multiply(a, b, new double[b.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a,  float[] b, int dimension)
        {
            return Multiply(a, b, dimension, MatrixCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a,  float[] b, int dimension)
        {
            return Multiply(a, b, dimension, JaggedCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this double a, float[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this double a, float[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this double[] a, float[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this double[] a, float[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double[,] a, float b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double[][] a, float b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double[,] a, float[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double[][] a, float[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a, double b)
        {
            return Multiply(a, b, new double[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, double b)
        {
            return Multiply(a, b, JaggedCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static double[] Multiply(this double[] a, double b)
        {
            return Multiply(a, b, new double[a.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this double[] a, double[] b)
        {
            return Multiply(a, b, new double[a.Length]);
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, double[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<double, double>(a));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a, double[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<double, double>(a));
        }     
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, double[,] b)
        {
            return Multiply(a, b, JaggedCreateAs<double, double>(a));
        }      
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double a, double[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<double, double>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double a, double[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<double, double>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this double a, double[] b)
        {
            return Multiply(a, b, new double[b.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a,  double[] b, int dimension)
        {
            return Multiply(a, b, dimension, MatrixCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a,  double[] b, int dimension)
        {
            return Multiply(a, b, dimension, JaggedCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double a, double[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double a, double[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double[] a, double[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double[] a, double[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double[,] a, double b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double[][] a, double b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double[,] a, double[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double[][] a, double[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a, byte b)
        {
            return Multiply(a, b, new double[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, byte b)
        {
            return Multiply(a, b, JaggedCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static double[] Multiply(this double[] a, byte b)
        {
            return Multiply(a, b, new double[a.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this double[] a, byte[] b)
        {
            return Multiply(a, b, new double[a.Length]);
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, byte[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<double, double>(a));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a, byte[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<double, double>(a));
        }     
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, byte[,] b)
        {
            return Multiply(a, b, JaggedCreateAs<double, double>(a));
        }      
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double a, byte[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<byte, double>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double a, byte[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<byte, double>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this double a, byte[] b)
        {
            return Multiply(a, b, new double[b.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a,  byte[] b, int dimension)
        {
            return Multiply(a, b, dimension, MatrixCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a,  byte[] b, int dimension)
        {
            return Multiply(a, b, dimension, JaggedCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this double a, byte[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this double a, byte[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this double[] a, byte[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this double[] a, byte[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double[,] a, byte b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double[][] a, byte b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double[,] a, byte[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double[][] a, byte[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a, decimal b)
        {
            return Multiply(a, b, new double[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, decimal b)
        {
            return Multiply(a, b, JaggedCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static double[] Multiply(this double[] a, decimal b)
        {
            return Multiply(a, b, new double[a.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this double[] a, decimal[] b)
        {
            return Multiply(a, b, new double[a.Length]);
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, decimal[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<double, double>(a));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a, decimal[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<double, double>(a));
        }     
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, decimal[,] b)
        {
            return Multiply(a, b, JaggedCreateAs<double, double>(a));
        }      
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double a, decimal[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<decimal, double>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double a, decimal[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<decimal, double>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this double a, decimal[] b)
        {
            return Multiply(a, b, new double[b.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a,  decimal[] b, int dimension)
        {
            return Multiply(a, b, dimension, MatrixCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a,  decimal[] b, int dimension)
        {
            return Multiply(a, b, dimension, JaggedCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this double a, decimal[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this double a, decimal[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this double[] a, decimal[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this double[] a, decimal[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double[,] a, decimal b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double[][] a, decimal b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double[,] a, decimal[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double[][] a, decimal[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this byte[,] a, int b)
        {
            return Multiply(a, b, new int[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this byte[][] a, int b)
        {
            return Multiply(a, b, JaggedCreateAs<byte, int>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static int[] Multiply(this byte[] a, int b)
        {
            return Multiply(a, b, new int[a.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this byte[] a, int[] b)
        {
            return Multiply(a, b, new int[a.Length]);
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this byte[][] a, int[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<byte, int>(a));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this byte[,] a, int[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<byte, int>(a));
        }     
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this byte[][] a, int[,] b)
        {
            return Multiply(a, b, JaggedCreateAs<byte, int>(a));
        }      
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this byte a, int[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<int, int>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this byte a, int[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<int, int>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this byte a, int[] b)
        {
            return Multiply(a, b, new int[b.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this byte[,] a,  int[] b, int dimension)
        {
            return Multiply(a, b, dimension, MatrixCreateAs<byte, int>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this byte[][] a,  int[] b, int dimension)
        {
            return Multiply(a, b, dimension, JaggedCreateAs<byte, int>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this byte a, int[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this byte a, int[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this byte[] a, int[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this byte[] a, int[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte[,] a, int b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte[][] a, int b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte[,] a, int[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte[][] a, int[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this byte[,] a, float b)
        {
            return Multiply(a, b, new float[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this byte[][] a, float b)
        {
            return Multiply(a, b, JaggedCreateAs<byte, float>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static float[] Multiply(this byte[] a, float b)
        {
            return Multiply(a, b, new float[a.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this byte[] a, float[] b)
        {
            return Multiply(a, b, new float[a.Length]);
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this byte[][] a, float[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<byte, float>(a));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this byte[,] a, float[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<byte, float>(a));
        }     
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this byte[][] a, float[,] b)
        {
            return Multiply(a, b, JaggedCreateAs<byte, float>(a));
        }      
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this byte a, float[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<float, float>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this byte a, float[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<float, float>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this byte a, float[] b)
        {
            return Multiply(a, b, new float[b.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this byte[,] a,  float[] b, int dimension)
        {
            return Multiply(a, b, dimension, MatrixCreateAs<byte, float>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this byte[][] a,  float[] b, int dimension)
        {
            return Multiply(a, b, dimension, JaggedCreateAs<byte, float>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this byte a, float[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this byte a, float[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this byte[] a, float[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this byte[] a, float[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte[,] a, float b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte[][] a, float b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte[,] a, float[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte[][] a, float[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[,] a, double b)
        {
            return Multiply(a, b, new double[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[][] a, double b)
        {
            return Multiply(a, b, JaggedCreateAs<byte, double>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static double[] Multiply(this byte[] a, double b)
        {
            return Multiply(a, b, new double[a.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this byte[] a, double[] b)
        {
            return Multiply(a, b, new double[a.Length]);
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[][] a, double[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<byte, double>(a));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[,] a, double[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<byte, double>(a));
        }     
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[][] a, double[,] b)
        {
            return Multiply(a, b, JaggedCreateAs<byte, double>(a));
        }      
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte a, double[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<double, double>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte a, double[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<double, double>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this byte a, double[] b)
        {
            return Multiply(a, b, new double[b.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[,] a,  double[] b, int dimension)
        {
            return Multiply(a, b, dimension, MatrixCreateAs<byte, double>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[][] a,  double[] b, int dimension)
        {
            return Multiply(a, b, dimension, JaggedCreateAs<byte, double>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this byte a, double[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this byte a, double[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this byte[] a, double[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this byte[] a, double[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte[,] a, double b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte[][] a, double b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte[,] a, double[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte[][] a, double[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[,] a, byte b)
        {
            return Multiply(a, b, new byte[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[][] a, byte b)
        {
            return Multiply(a, b, JaggedCreateAs<byte, byte>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static byte[] Multiply(this byte[] a, byte b)
        {
            return Multiply(a, b, new byte[a.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Multiply(this byte[] a, byte[] b)
        {
            return Multiply(a, b, new byte[a.Length]);
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[][] a, byte[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<byte, byte>(a));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[,] a, byte[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<byte, byte>(a));
        }     
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[][] a, byte[,] b)
        {
            return Multiply(a, b, JaggedCreateAs<byte, byte>(a));
        }      
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte a, byte[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<byte, byte>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte a, byte[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<byte, byte>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Multiply(this byte a, byte[] b)
        {
            return Multiply(a, b, new byte[b.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[,] a,  byte[] b, int dimension)
        {
            return Multiply(a, b, dimension, MatrixCreateAs<byte, byte>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[][] a,  byte[] b, int dimension)
        {
            return Multiply(a, b, dimension, JaggedCreateAs<byte, byte>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte a, byte[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte a, byte[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte[] a, byte[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte[] a, byte[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte[,] a, byte b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte[][] a, byte b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte[,] a, byte[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte[][] a, byte[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this decimal[,] a, int b)
        {
            return Multiply(a, b, new int[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this decimal[][] a, int b)
        {
            return Multiply(a, b, JaggedCreateAs<decimal, int>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static int[] Multiply(this decimal[] a, int b)
        {
            return Multiply(a, b, new int[a.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this decimal[] a, int[] b)
        {
            return Multiply(a, b, new int[a.Length]);
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this decimal[][] a, int[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<decimal, int>(a));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this decimal[,] a, int[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<decimal, int>(a));
        }     
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this decimal[][] a, int[,] b)
        {
            return Multiply(a, b, JaggedCreateAs<decimal, int>(a));
        }      
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this decimal a, int[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<int, int>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this decimal a, int[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<int, int>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this decimal a, int[] b)
        {
            return Multiply(a, b, new int[b.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this decimal[,] a,  int[] b, int dimension)
        {
            return Multiply(a, b, dimension, MatrixCreateAs<decimal, int>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this decimal[][] a,  int[] b, int dimension)
        {
            return Multiply(a, b, dimension, JaggedCreateAs<decimal, int>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this decimal a, int[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this decimal a, int[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this decimal[] a, int[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this decimal[] a, int[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal[,] a, int b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal[][] a, int b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal[,] a, int[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal[][] a, int[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this decimal[,] a, float b)
        {
            return Multiply(a, b, new float[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this decimal[][] a, float b)
        {
            return Multiply(a, b, JaggedCreateAs<decimal, float>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static float[] Multiply(this decimal[] a, float b)
        {
            return Multiply(a, b, new float[a.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this decimal[] a, float[] b)
        {
            return Multiply(a, b, new float[a.Length]);
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this decimal[][] a, float[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<decimal, float>(a));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this decimal[,] a, float[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<decimal, float>(a));
        }     
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this decimal[][] a, float[,] b)
        {
            return Multiply(a, b, JaggedCreateAs<decimal, float>(a));
        }      
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this decimal a, float[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<float, float>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this decimal a, float[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<float, float>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this decimal a, float[] b)
        {
            return Multiply(a, b, new float[b.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this decimal[,] a,  float[] b, int dimension)
        {
            return Multiply(a, b, dimension, MatrixCreateAs<decimal, float>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this decimal[][] a,  float[] b, int dimension)
        {
            return Multiply(a, b, dimension, JaggedCreateAs<decimal, float>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this decimal a, float[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this decimal a, float[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this decimal[] a, float[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this decimal[] a, float[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal[,] a, float b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal[][] a, float b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal[,] a, float[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal[][] a, float[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[,] a, double b)
        {
            return Multiply(a, b, new double[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[][] a, double b)
        {
            return Multiply(a, b, JaggedCreateAs<decimal, double>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static double[] Multiply(this decimal[] a, double b)
        {
            return Multiply(a, b, new double[a.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this decimal[] a, double[] b)
        {
            return Multiply(a, b, new double[a.Length]);
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[][] a, double[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<decimal, double>(a));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[,] a, double[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<decimal, double>(a));
        }     
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[][] a, double[,] b)
        {
            return Multiply(a, b, JaggedCreateAs<decimal, double>(a));
        }      
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal a, double[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<double, double>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal a, double[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<double, double>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this decimal a, double[] b)
        {
            return Multiply(a, b, new double[b.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[,] a,  double[] b, int dimension)
        {
            return Multiply(a, b, dimension, MatrixCreateAs<decimal, double>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[][] a,  double[] b, int dimension)
        {
            return Multiply(a, b, dimension, JaggedCreateAs<decimal, double>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this decimal a, double[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this decimal a, double[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this decimal[] a, double[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this decimal[] a, double[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal[,] a, double b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal[][] a, double b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal[,] a, double[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal[][] a, double[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[,] a, decimal b)
        {
            return Multiply(a, b, new decimal[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[][] a, decimal b)
        {
            return Multiply(a, b, JaggedCreateAs<decimal, decimal>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static decimal[] Multiply(this decimal[] a, decimal b)
        {
            return Multiply(a, b, new decimal[a.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Multiply(this decimal[] a, decimal[] b)
        {
            return Multiply(a, b, new decimal[a.Length]);
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[][] a, decimal[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<decimal, decimal>(a));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[,] a, decimal[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<decimal, decimal>(a));
        }     
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[][] a, decimal[,] b)
        {
            return Multiply(a, b, JaggedCreateAs<decimal, decimal>(a));
        }      
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal a, decimal[,] b)
        {
            return Multiply(a, b, MatrixCreateAs<decimal, decimal>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal a, decimal[][] b)
        {
            return Multiply(a, b, JaggedCreateAs<decimal, decimal>(b));
        }     

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Multiply(this decimal a, decimal[] b)
        {
            return Multiply(a, b, new decimal[b.Length]);
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[,] a,  decimal[] b, int dimension)
        {
            return Multiply(a, b, dimension, MatrixCreateAs<decimal, decimal>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[][] a,  decimal[] b, int dimension)
        {
            return Multiply(a, b, dimension, JaggedCreateAs<decimal, decimal>(a));
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal a, decimal[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal a, decimal[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal[] a, decimal[,] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal[] a, decimal[][] b)
        {
            return MultiplyWithDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal[,] a, decimal b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal[][] a, decimal b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal[,] a, decimal[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal[][] a, decimal[] b)
        {
            return MultiplyWithDiagonal(a, b, a.MemberwiseClone());
        }
 

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[][] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (int)((int)a[i][j] * (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[,] a, int[][] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (int)((int)(*pa) * (int)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[,] a, int[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (int* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (int)((int)(*pa) * (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a, int[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)(a[i][j]) * (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[,] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (int)((int)(*pa) * (int)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (int)((int)(a[i][j]) * (int)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[,] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (int* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (int)((int)(*pa) * (int)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[,] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) *  (int)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (int)((int)a[i][j] * (int)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[][] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] * (int)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int a, int[,] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)a *  (int)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (int)((int)a * (int)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int a, int[][] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (int)((int)a * (int)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (int)((int)a * (int)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[,] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (int)((int)(*pa) * (int)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[,] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) *  (int)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[][] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] * (int)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this int[] a, int[] b, int[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] * (int)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this int[] a, int b, int[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] * (int)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this int a, int[] b, int[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (int)((int)a * (int)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[,] a,  int[] b, int dimension, int[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] * (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] * (int)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a,  int[] b, int dimension, int[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] * (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] * (int)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a * (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a * (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int[] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a[j] * (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int[] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i] * (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int[,] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) * (int)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int[][] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (int)((int)a[i][i] * (int)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int[,] a, int[] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) * (int)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int[][] a, int[] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i][i] * (int)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[][] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[,] a, int[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[,] a, int[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (int* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[][] a, int[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[,] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[][] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) * (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[,] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (int* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[,] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[][] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[][] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int a, int[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a *  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a * (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int a, int[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a * (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[,] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[,] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[][] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this int[] a, int[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this int[] a, int b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this int a, int[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a * (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[,] a,  int[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[][] a,  int[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this int a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this int a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this int[] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this int[] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this int[,] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this int[][] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this int[,] a, int[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this int[][] a, int[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[][] a, float[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (int)((int)a[i][j] * (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[,] a, float[][] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (int)((int)(*pa) * (int)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[,] a, float[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (float* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (int)((int)(*pa) * (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a, float[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)(a[i][j]) * (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[,] a, float[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (int)((int)(*pa) * (int)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a, float[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (int)((int)(a[i][j]) * (int)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[,] a, float[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (float* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (int)((int)(*pa) * (int)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[,] a, float b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) *  (int)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a, float b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (int)((int)a[i][j] * (int)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[][] a, float b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] * (int)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int a, float[,] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)a *  (int)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int a, float[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (int)((int)a * (int)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int a, float[][] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (int)((int)a * (int)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int a, float[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (int)((int)a * (int)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[,] a, float b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (int)((int)(*pa) * (int)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[,] a, float b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) *  (int)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[][] a, float b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] * (int)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this int[] a, float[] b, int[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] * (int)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this int[] a, float b, int[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] * (int)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this int a, float[] b, int[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (int)((int)a * (int)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[,] a,  float[] b, int dimension, int[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] * (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] * (int)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a,  float[] b, int dimension, int[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] * (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] * (int)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int a, float[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a * (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int a, float[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a * (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int[] a, float[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a[j] * (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int[] a, float[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i] * (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int[,] a, float b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) * (int)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int[][] a, float b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (int)((int)a[i][i] * (int)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int[,] a, float[] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) * (int)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int[][] a, float[] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i][i] * (int)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this int[][] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (float)((float)a[i][j] * (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this int[,] a, float[][] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (float)((float)(*pa) * (float)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this int[,] a, float[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (float* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (float)((float)(*pa) * (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this int[][] a, float[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)(a[i][j]) * (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this int[,] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (float)((float)(*pa) * (float)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this int[][] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (float)((float)(a[i][j]) * (float)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this int[,] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (float* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (float)((float)(*pa) * (float)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this int[,] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) *  (float)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this int[][] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (float)((float)a[i][j] * (float)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this int[][] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] * (float)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this int a, float[,] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)a *  (float)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this int a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (float)((float)a * (float)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this int a, float[][] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (float)((float)a * (float)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this int a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (float)((float)a * (float)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this int[,] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (float)((float)(*pa) * (float)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this int[,] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) *  (float)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this int[][] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] * (float)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this int[] a, float[] b, float[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] * (float)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this int[] a, float b, float[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] * (float)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this int a, float[] b, float[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (float)((float)a * (float)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this int[,] a,  float[] b, int dimension, float[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] * (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] * (float)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this int[][] a,  float[] b, int dimension, float[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] * (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] * (float)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this int a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a * (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this int a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a * (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this int[] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a[j] * (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this int[] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i] * (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this int[,] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) * (float)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this int[][] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (float)((float)a[i][i] * (float)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this int[,] a, float[] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) * (float)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this int[][] a, float[] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i][i] * (float)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[][] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[,] a, float[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[,] a, float[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (float* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[][] a, float[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[,] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[][] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) * (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[,] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (float* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[,] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[][] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[][] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int a, float[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a *  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a * (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int a, float[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a * (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[,] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[,] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[][] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this int[] a, float[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this int[] a, float b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this int a, float[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a * (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[,] a,  float[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[][] a,  float[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this int a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this int a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this int[] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this int[] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this int[,] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this int[][] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this int[,] a, float[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this int[][] a, float[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[][] a, double[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (int)((int)a[i][j] * (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[,] a, double[][] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (int)((int)(*pa) * (int)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[,] a, double[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (double* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (int)((int)(*pa) * (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a, double[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)(a[i][j]) * (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[,] a, double[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (int)((int)(*pa) * (int)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a, double[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (int)((int)(a[i][j]) * (int)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[,] a, double[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (double* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (int)((int)(*pa) * (int)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[,] a, double b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) *  (int)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a, double b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (int)((int)a[i][j] * (int)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[][] a, double b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] * (int)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int a, double[,] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)a *  (int)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int a, double[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (int)((int)a * (int)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int a, double[][] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (int)((int)a * (int)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int a, double[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (int)((int)a * (int)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[,] a, double b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (int)((int)(*pa) * (int)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[,] a, double b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) *  (int)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[][] a, double b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] * (int)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this int[] a, double[] b, int[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] * (int)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this int[] a, double b, int[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] * (int)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this int a, double[] b, int[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (int)((int)a * (int)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[,] a,  double[] b, int dimension, int[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] * (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] * (int)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a,  double[] b, int dimension, int[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] * (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] * (int)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int a, double[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a * (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int a, double[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a * (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int[] a, double[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a[j] * (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int[] a, double[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i] * (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int[,] a, double b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) * (int)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int[][] a, double b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (int)((int)a[i][i] * (int)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int[,] a, double[] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) * (int)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int[][] a, double[] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i][i] * (int)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[][] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[,] a, double[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[,] a, double[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (double* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[][] a, double[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[,] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[][] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) * (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[,] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (double* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[,] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[][] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[][] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int a, double[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a *  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a * (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int a, double[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a * (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[,] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[,] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[][] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this int[] a, double[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this int[] a, double b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this int a, double[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a * (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[,] a,  double[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[][] a,  double[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this int a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this int a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this int[] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this int[] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this int[,] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this int[][] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this int[,] a, double[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this int[][] a, double[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[][] a, byte[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (int)((int)a[i][j] * (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[,] a, byte[][] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (int)((int)(*pa) * (int)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[,] a, byte[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (byte* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (int)((int)(*pa) * (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a, byte[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)(a[i][j]) * (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[,] a, byte[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (int)((int)(*pa) * (int)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a, byte[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (int)((int)(a[i][j]) * (int)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[,] a, byte[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (byte* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (int)((int)(*pa) * (int)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[,] a, byte b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) *  (int)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a, byte b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (int)((int)a[i][j] * (int)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[][] a, byte b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] * (int)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int a, byte[,] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)a *  (int)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int a, byte[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (int)((int)a * (int)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int a, byte[][] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (int)((int)a * (int)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int a, byte[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (int)((int)a * (int)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[,] a, byte b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (int)((int)(*pa) * (int)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[,] a, byte b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) *  (int)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[][] a, byte b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] * (int)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this int[] a, byte[] b, int[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] * (int)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this int[] a, byte b, int[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] * (int)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this int a, byte[] b, int[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (int)((int)a * (int)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[,] a,  byte[] b, int dimension, int[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] * (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] * (int)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a,  byte[] b, int dimension, int[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] * (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] * (int)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int a, byte[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a * (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int a, byte[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a * (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int[] a, byte[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a[j] * (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int[] a, byte[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i] * (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int[,] a, byte b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) * (int)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int[][] a, byte b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (int)((int)a[i][i] * (int)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int[,] a, byte[] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) * (int)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int[][] a, byte[] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i][i] * (int)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this int[][] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (byte)((byte)a[i][j] * (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this int[,] a, byte[][] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (byte)((byte)(*pa) * (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this int[,] a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (byte* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (byte)((byte)(*pa) * (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this int[][] a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)(a[i][j]) * (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this int[,] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (byte)((byte)(*pa) * (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this int[][] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (byte)((byte)(a[i][j]) * (byte)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this int[,] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (byte* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (byte)((byte)(*pa) * (byte)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this int[,] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) *  (byte)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this int[][] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (byte)((byte)a[i][j] * (byte)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this int[][] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] * (byte)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this int a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)a *  (byte)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this int a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (byte)((byte)a * (byte)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this int a, byte[][] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (byte)((byte)a * (byte)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this int a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (byte)((byte)a * (byte)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this int[,] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (byte)((byte)(*pa) * (byte)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this int[,] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) *  (byte)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this int[][] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] * (byte)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Multiply(this int[] a, byte[] b, byte[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] * (byte)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Multiply(this int[] a, byte b, byte[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] * (byte)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Multiply(this int a, byte[] b, byte[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (byte)((byte)a * (byte)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this int[,] a,  byte[] b, int dimension, byte[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] * (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] * (byte)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this int[][] a,  byte[] b, int dimension, byte[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] * (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] * (byte)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this int a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a * (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this int a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a * (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this int[] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a[j] * (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this int[] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i] * (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this int[,] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) * (byte)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this int[][] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] * (byte)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this int[,] a, byte[] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) * (byte)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this int[][] a, byte[] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] * (byte)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[][] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[,] a, byte[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[,] a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (byte* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[][] a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[,] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[][] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) * (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[,] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (byte* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[,] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[][] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[][] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a *  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a * (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int a, byte[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a * (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[,] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[,] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[][] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this int[] a, byte[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this int[] a, byte b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this int a, byte[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a * (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[,] a,  byte[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[][] a,  byte[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this int a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this int a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this int[] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this int[] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this int[,] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this int[][] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this int[,] a, byte[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this int[][] a, byte[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[][] a, decimal[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (int)((int)a[i][j] * (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[,] a, decimal[][] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (int)((int)(*pa) * (int)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[,] a, decimal[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (decimal* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (int)((int)(*pa) * (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a, decimal[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)(a[i][j]) * (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[,] a, decimal[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (int)((int)(*pa) * (int)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a, decimal[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (int)((int)(a[i][j]) * (int)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[,] a, decimal[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (decimal* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (int)((int)(*pa) * (int)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[,] a, decimal b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) *  (int)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a, decimal b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (int)((int)a[i][j] * (int)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[][] a, decimal b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] * (int)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int a, decimal[,] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)a *  (int)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int a, decimal[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (int)((int)a * (int)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int a, decimal[][] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (int)((int)a * (int)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int a, decimal[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (int)((int)a * (int)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[,] a, decimal b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (int)((int)(*pa) * (int)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[,] a, decimal b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) *  (int)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[][] a, decimal b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] * (int)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this int[] a, decimal[] b, int[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] * (int)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this int[] a, decimal b, int[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] * (int)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this int a, decimal[] b, int[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (int)((int)a * (int)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this int[,] a,  decimal[] b, int dimension, int[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] * (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] * (int)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this int[][] a,  decimal[] b, int dimension, int[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] * (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] * (int)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int a, decimal[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a * (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int a, decimal[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a * (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int[] a, decimal[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a[j] * (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int[] a, decimal[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i] * (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int[,] a, decimal b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) * (int)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int[][] a, decimal b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (int)((int)a[i][i] * (int)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this int[,] a, decimal[] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) * (int)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this int[][] a, decimal[] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i][i] * (int)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this int[][] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (decimal)((decimal)a[i][j] * (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this int[,] a, decimal[][] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (decimal)((decimal)(*pa) * (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this int[,] a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (decimal* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (decimal)((decimal)(*pa) * (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this int[][] a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)(a[i][j]) * (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this int[,] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (decimal)((decimal)(*pa) * (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this int[][] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (decimal)((decimal)(a[i][j]) * (decimal)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this int[,] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (decimal* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (decimal)((decimal)(*pa) * (decimal)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this int[,] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) *  (decimal)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this int[][] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a[i][j] * (decimal)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this int[][] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] * (decimal)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this int a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)a *  (decimal)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this int a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a * (decimal)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this int a, decimal[][] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (decimal)((decimal)a * (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this int a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (decimal)((decimal)a * (decimal)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this int[,] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (decimal)((decimal)(*pa) * (decimal)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this int[,] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) *  (decimal)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this int[][] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] * (decimal)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Multiply(this int[] a, decimal[] b, decimal[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] * (decimal)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Multiply(this int[] a, decimal b, decimal[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] * (decimal)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Multiply(this int a, decimal[] b, decimal[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (decimal)((decimal)a * (decimal)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this int[,] a,  decimal[] b, int dimension, decimal[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] * (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] * (decimal)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this int[][] a,  decimal[] b, int dimension, decimal[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] * (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] * (decimal)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this int a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a * (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this int a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a * (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this int[] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a[j] * (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this int[] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i] * (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this int[,] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) * (decimal)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this int[][] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] * (decimal)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this int[,] a, decimal[] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) * (decimal)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this int[][] a, decimal[] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] * (decimal)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[][] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[,] a, decimal[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[,] a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (decimal* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[][] a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[,] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[][] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) * (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[,] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (decimal* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[,] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[][] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[][] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a *  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a * (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int a, decimal[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a * (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[,] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[,] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[][] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this int[] a, decimal[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this int[] a, decimal b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this int a, decimal[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a * (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this int[,] a,  decimal[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this int[][] a,  decimal[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this int a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this int a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this int[] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this int[] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this int[,] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this int[][] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this int[,] a, decimal[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this int[][] a, decimal[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[][] a, int[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (float)((float)a[i][j] * (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a, int[][] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (float)((float)(*pa) * (float)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[,] a, int[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (int* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (float)((float)(*pa) * (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a, int[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)(a[i][j]) * (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[,] a, int[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (float)((float)(*pa) * (float)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a, int[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (float)((float)(a[i][j]) * (float)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a, int[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (int* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (float)((float)(*pa) * (float)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[,] a, int b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) *  (float)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a, int b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (float)((float)a[i][j] * (float)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[][] a, int b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] * (float)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float a, int[,] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)a *  (float)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float a, int[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (float)((float)a * (float)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float a, int[][] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (float)((float)a * (float)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float a, int[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (float)((float)a * (float)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a, int b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (float)((float)(*pa) * (float)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[,] a, int b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) *  (float)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[][] a, int b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] * (float)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this float[] a, int[] b, float[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] * (float)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this float[] a, int b, float[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] * (float)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this float a, int[] b, float[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (float)((float)a * (float)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a,  int[] b, int dimension, float[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] * (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] * (float)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a,  int[] b, int dimension, float[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] * (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] * (float)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float a, int[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a * (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float a, int[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a * (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float[] a, int[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a[j] * (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float[] a, int[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i] * (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float[,] a, int b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) * (float)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float[][] a, int b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (float)((float)a[i][i] * (float)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float[,] a, int[] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) * (float)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float[][] a, int[] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i][i] * (float)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this float[][] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (int)((int)a[i][j] * (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this float[,] a, int[][] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (int)((int)(*pa) * (int)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this float[,] a, int[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (int* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (int)((int)(*pa) * (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this float[][] a, int[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)(a[i][j]) * (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this float[,] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (int)((int)(*pa) * (int)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this float[][] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (int)((int)(a[i][j]) * (int)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this float[,] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (int* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (int)((int)(*pa) * (int)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this float[,] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) *  (int)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this float[][] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (int)((int)a[i][j] * (int)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this float[][] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] * (int)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this float a, int[,] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)a *  (int)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this float a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (int)((int)a * (int)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this float a, int[][] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (int)((int)a * (int)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this float a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (int)((int)a * (int)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this float[,] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (int)((int)(*pa) * (int)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this float[,] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) *  (int)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this float[][] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] * (int)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this float[] a, int[] b, int[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] * (int)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this float[] a, int b, int[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] * (int)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this float a, int[] b, int[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (int)((int)a * (int)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this float[,] a,  int[] b, int dimension, int[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] * (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] * (int)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this float[][] a,  int[] b, int dimension, int[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] * (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] * (int)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this float a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a * (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this float a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a * (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this float[] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a[j] * (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this float[] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i] * (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this float[,] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) * (int)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this float[][] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (int)((int)a[i][i] * (int)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this float[,] a, int[] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) * (int)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this float[][] a, int[] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i][i] * (int)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[][] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[,] a, int[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[,] a, int[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (int* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[][] a, int[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[,] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[][] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) * (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[,] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (int* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[,] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[][] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[][] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float a, int[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a *  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a * (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float a, int[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a * (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[,] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[,] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[][] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this float[] a, int[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this float[] a, int b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this float a, int[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a * (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[,] a,  int[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[][] a,  int[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this float a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this float a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this float[] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this float[] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this float[,] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this float[][] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this float[,] a, int[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this float[][] a, int[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[][] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (float)((float)a[i][j] * (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a, float[][] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (float)((float)(*pa) * (float)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[,] a, float[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (float* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (float)((float)(*pa) * (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a, float[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)(a[i][j]) * (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[,] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (float)((float)(*pa) * (float)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (float)((float)(a[i][j]) * (float)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (float* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (float)((float)(*pa) * (float)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[,] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) *  (float)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (float)((float)a[i][j] * (float)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[][] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] * (float)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float a, float[,] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)a *  (float)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (float)((float)a * (float)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float a, float[][] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (float)((float)a * (float)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (float)((float)a * (float)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (float)((float)(*pa) * (float)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[,] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) *  (float)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[][] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] * (float)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this float[] a, float[] b, float[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] * (float)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this float[] a, float b, float[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] * (float)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this float a, float[] b, float[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (float)((float)a * (float)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a,  float[] b, int dimension, float[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] * (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] * (float)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a,  float[] b, int dimension, float[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] * (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] * (float)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a * (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a * (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float[] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a[j] * (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float[] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i] * (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float[,] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) * (float)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float[][] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (float)((float)a[i][i] * (float)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float[,] a, float[] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) * (float)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float[][] a, float[] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i][i] * (float)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[][] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[,] a, float[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[,] a, float[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (float* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[][] a, float[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[,] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[][] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) * (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[,] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (float* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[,] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[][] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[][] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float a, float[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a *  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a * (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float a, float[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a * (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[,] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[,] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[][] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this float[] a, float[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this float[] a, float b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this float a, float[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a * (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[,] a,  float[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[][] a,  float[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this float a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this float a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this float[] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this float[] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this float[,] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this float[][] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this float[,] a, float[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this float[][] a, float[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[][] a, double[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (float)((float)a[i][j] * (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a, double[][] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (float)((float)(*pa) * (float)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[,] a, double[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (double* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (float)((float)(*pa) * (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a, double[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)(a[i][j]) * (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[,] a, double[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (float)((float)(*pa) * (float)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a, double[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (float)((float)(a[i][j]) * (float)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a, double[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (double* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (float)((float)(*pa) * (float)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[,] a, double b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) *  (float)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a, double b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (float)((float)a[i][j] * (float)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[][] a, double b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] * (float)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float a, double[,] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)a *  (float)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float a, double[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (float)((float)a * (float)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float a, double[][] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (float)((float)a * (float)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float a, double[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (float)((float)a * (float)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a, double b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (float)((float)(*pa) * (float)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[,] a, double b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) *  (float)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[][] a, double b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] * (float)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this float[] a, double[] b, float[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] * (float)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this float[] a, double b, float[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] * (float)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this float a, double[] b, float[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (float)((float)a * (float)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a,  double[] b, int dimension, float[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] * (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] * (float)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a,  double[] b, int dimension, float[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] * (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] * (float)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float a, double[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a * (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float a, double[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a * (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float[] a, double[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a[j] * (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float[] a, double[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i] * (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float[,] a, double b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) * (float)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float[][] a, double b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (float)((float)a[i][i] * (float)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float[,] a, double[] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) * (float)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float[][] a, double[] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i][i] * (float)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[][] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[,] a, double[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[,] a, double[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (double* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[][] a, double[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[,] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[][] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) * (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[,] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (double* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[,] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[][] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[][] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float a, double[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a *  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a * (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float a, double[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a * (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[,] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[,] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[][] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this float[] a, double[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this float[] a, double b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this float a, double[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a * (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[,] a,  double[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[][] a,  double[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this float a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this float a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this float[] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this float[] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this float[,] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this float[][] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this float[,] a, double[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this float[][] a, double[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[][] a, byte[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (float)((float)a[i][j] * (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a, byte[][] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (float)((float)(*pa) * (float)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[,] a, byte[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (byte* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (float)((float)(*pa) * (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a, byte[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)(a[i][j]) * (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[,] a, byte[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (float)((float)(*pa) * (float)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a, byte[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (float)((float)(a[i][j]) * (float)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a, byte[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (byte* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (float)((float)(*pa) * (float)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[,] a, byte b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) *  (float)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a, byte b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (float)((float)a[i][j] * (float)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[][] a, byte b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] * (float)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float a, byte[,] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)a *  (float)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float a, byte[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (float)((float)a * (float)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float a, byte[][] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (float)((float)a * (float)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float a, byte[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (float)((float)a * (float)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a, byte b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (float)((float)(*pa) * (float)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[,] a, byte b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) *  (float)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[][] a, byte b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] * (float)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this float[] a, byte[] b, float[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] * (float)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this float[] a, byte b, float[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] * (float)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this float a, byte[] b, float[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (float)((float)a * (float)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a,  byte[] b, int dimension, float[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] * (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] * (float)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a,  byte[] b, int dimension, float[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] * (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] * (float)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float a, byte[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a * (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float a, byte[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a * (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float[] a, byte[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a[j] * (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float[] a, byte[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i] * (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float[,] a, byte b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) * (float)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float[][] a, byte b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (float)((float)a[i][i] * (float)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float[,] a, byte[] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) * (float)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float[][] a, byte[] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i][i] * (float)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this float[][] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (byte)((byte)a[i][j] * (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this float[,] a, byte[][] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (byte)((byte)(*pa) * (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this float[,] a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (byte* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (byte)((byte)(*pa) * (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this float[][] a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)(a[i][j]) * (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this float[,] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (byte)((byte)(*pa) * (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this float[][] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (byte)((byte)(a[i][j]) * (byte)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this float[,] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (byte* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (byte)((byte)(*pa) * (byte)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this float[,] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) *  (byte)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this float[][] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (byte)((byte)a[i][j] * (byte)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this float[][] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] * (byte)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this float a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)a *  (byte)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this float a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (byte)((byte)a * (byte)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this float a, byte[][] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (byte)((byte)a * (byte)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this float a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (byte)((byte)a * (byte)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this float[,] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (byte)((byte)(*pa) * (byte)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this float[,] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) *  (byte)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this float[][] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] * (byte)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Multiply(this float[] a, byte[] b, byte[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] * (byte)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Multiply(this float[] a, byte b, byte[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] * (byte)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Multiply(this float a, byte[] b, byte[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (byte)((byte)a * (byte)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this float[,] a,  byte[] b, int dimension, byte[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] * (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] * (byte)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this float[][] a,  byte[] b, int dimension, byte[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] * (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] * (byte)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this float a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a * (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this float a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a * (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this float[] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a[j] * (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this float[] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i] * (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this float[,] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) * (byte)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this float[][] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] * (byte)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this float[,] a, byte[] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) * (byte)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this float[][] a, byte[] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] * (byte)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[][] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[,] a, byte[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[,] a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (byte* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[][] a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[,] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[][] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) * (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[,] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (byte* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[,] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[][] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[][] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a *  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a * (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float a, byte[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a * (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[,] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[,] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[][] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this float[] a, byte[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this float[] a, byte b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this float a, byte[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a * (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[,] a,  byte[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[][] a,  byte[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this float a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this float a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this float[] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this float[] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this float[,] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this float[][] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this float[,] a, byte[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this float[][] a, byte[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[][] a, decimal[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (float)((float)a[i][j] * (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a, decimal[][] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (float)((float)(*pa) * (float)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[,] a, decimal[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (decimal* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (float)((float)(*pa) * (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a, decimal[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)(a[i][j]) * (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[,] a, decimal[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (float)((float)(*pa) * (float)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a, decimal[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (float)((float)(a[i][j]) * (float)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a, decimal[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (decimal* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (float)((float)(*pa) * (float)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[,] a, decimal b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) *  (float)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a, decimal b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (float)((float)a[i][j] * (float)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[][] a, decimal b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] * (float)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float a, decimal[,] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)a *  (float)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float a, decimal[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (float)((float)a * (float)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float a, decimal[][] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (float)((float)a * (float)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float a, decimal[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (float)((float)a * (float)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a, decimal b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (float)((float)(*pa) * (float)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[,] a, decimal b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) *  (float)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[][] a, decimal b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] * (float)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this float[] a, decimal[] b, float[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] * (float)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this float[] a, decimal b, float[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] * (float)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this float a, decimal[] b, float[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (float)((float)a * (float)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this float[,] a,  decimal[] b, int dimension, float[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] * (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] * (float)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this float[][] a,  decimal[] b, int dimension, float[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] * (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] * (float)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float a, decimal[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a * (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float a, decimal[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a * (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float[] a, decimal[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a[j] * (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float[] a, decimal[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i] * (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float[,] a, decimal b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) * (float)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float[][] a, decimal b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (float)((float)a[i][i] * (float)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this float[,] a, decimal[] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) * (float)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this float[][] a, decimal[] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i][i] * (float)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this float[][] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (decimal)((decimal)a[i][j] * (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this float[,] a, decimal[][] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (decimal)((decimal)(*pa) * (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this float[,] a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (decimal* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (decimal)((decimal)(*pa) * (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this float[][] a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)(a[i][j]) * (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this float[,] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (decimal)((decimal)(*pa) * (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this float[][] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (decimal)((decimal)(a[i][j]) * (decimal)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this float[,] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (decimal* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (decimal)((decimal)(*pa) * (decimal)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this float[,] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) *  (decimal)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this float[][] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a[i][j] * (decimal)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this float[][] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] * (decimal)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this float a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)a *  (decimal)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this float a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a * (decimal)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this float a, decimal[][] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (decimal)((decimal)a * (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this float a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (decimal)((decimal)a * (decimal)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this float[,] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (decimal)((decimal)(*pa) * (decimal)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this float[,] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) *  (decimal)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this float[][] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] * (decimal)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Multiply(this float[] a, decimal[] b, decimal[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] * (decimal)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Multiply(this float[] a, decimal b, decimal[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] * (decimal)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Multiply(this float a, decimal[] b, decimal[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (decimal)((decimal)a * (decimal)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this float[,] a,  decimal[] b, int dimension, decimal[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] * (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] * (decimal)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this float[][] a,  decimal[] b, int dimension, decimal[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] * (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] * (decimal)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this float a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a * (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this float a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a * (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this float[] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a[j] * (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this float[] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i] * (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this float[,] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) * (decimal)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this float[][] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] * (decimal)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this float[,] a, decimal[] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) * (decimal)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this float[][] a, decimal[] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] * (decimal)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[][] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[,] a, decimal[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[,] a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (decimal* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[][] a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[,] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[][] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) * (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[,] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (decimal* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[,] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[][] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[][] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a *  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a * (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float a, decimal[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a * (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[,] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[,] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[][] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this float[] a, decimal[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this float[] a, decimal b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this float a, decimal[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a * (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this float[,] a,  decimal[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this float[][] a,  decimal[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this float a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this float a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this float[] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this float[] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this float[,] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this float[][] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this float[,] a, decimal[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this float[][] a, decimal[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[][] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a, int[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[,] a, int[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (int* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, int[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[,] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) * (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (int* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[,] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[][] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double a, int[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a *  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a * (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double a, int[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a * (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[,] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[][] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this double[] a, int[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this double[] a, int b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this double a, int[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a * (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a,  int[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a,  int[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double[] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double[] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double[,] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double[][] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double[,] a, int[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double[][] a, int[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this double[][] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (int)((int)a[i][j] * (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this double[,] a, int[][] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (int)((int)(*pa) * (int)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this double[,] a, int[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (int* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (int)((int)(*pa) * (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this double[][] a, int[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)(a[i][j]) * (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this double[,] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (int)((int)(*pa) * (int)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this double[][] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (int)((int)(a[i][j]) * (int)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this double[,] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (int* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (int)((int)(*pa) * (int)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this double[,] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) *  (int)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this double[][] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (int)((int)a[i][j] * (int)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this double[][] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] * (int)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this double a, int[,] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)a *  (int)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this double a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (int)((int)a * (int)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this double a, int[][] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (int)((int)a * (int)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this double a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (int)((int)a * (int)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this double[,] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (int)((int)(*pa) * (int)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this double[,] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) *  (int)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this double[][] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] * (int)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this double[] a, int[] b, int[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] * (int)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this double[] a, int b, int[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] * (int)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this double a, int[] b, int[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (int)((int)a * (int)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this double[,] a,  int[] b, int dimension, int[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] * (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] * (int)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this double[][] a,  int[] b, int dimension, int[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] * (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] * (int)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this double a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a * (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this double a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a * (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this double[] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a[j] * (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this double[] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i] * (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this double[,] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) * (int)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this double[][] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (int)((int)a[i][i] * (int)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this double[,] a, int[] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) * (int)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this double[][] a, int[] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i][i] * (int)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[][] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a, float[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[,] a, float[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (float* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, float[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[,] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) * (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (float* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[,] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[][] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double a, float[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a *  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a * (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double a, float[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a * (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[,] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[][] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this double[] a, float[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this double[] a, float b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this double a, float[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a * (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a,  float[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a,  float[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double[] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double[] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double[,] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double[][] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double[,] a, float[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double[][] a, float[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this double[][] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (float)((float)a[i][j] * (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this double[,] a, float[][] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (float)((float)(*pa) * (float)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this double[,] a, float[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (float* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (float)((float)(*pa) * (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this double[][] a, float[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)(a[i][j]) * (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this double[,] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (float)((float)(*pa) * (float)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this double[][] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (float)((float)(a[i][j]) * (float)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this double[,] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (float* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (float)((float)(*pa) * (float)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this double[,] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) *  (float)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this double[][] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (float)((float)a[i][j] * (float)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this double[][] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] * (float)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this double a, float[,] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)a *  (float)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this double a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (float)((float)a * (float)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this double a, float[][] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (float)((float)a * (float)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this double a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (float)((float)a * (float)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this double[,] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (float)((float)(*pa) * (float)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this double[,] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) *  (float)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this double[][] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] * (float)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this double[] a, float[] b, float[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] * (float)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this double[] a, float b, float[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] * (float)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this double a, float[] b, float[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (float)((float)a * (float)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this double[,] a,  float[] b, int dimension, float[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] * (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] * (float)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this double[][] a,  float[] b, int dimension, float[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] * (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] * (float)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this double a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a * (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this double a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a * (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this double[] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a[j] * (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this double[] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i] * (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this double[,] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) * (float)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this double[][] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (float)((float)a[i][i] * (float)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this double[,] a, float[] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) * (float)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this double[][] a, float[] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i][i] * (float)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[][] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a, double[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[,] a, double[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (double* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, double[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[,] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) * (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (double* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[,] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[][] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double a, double[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a *  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a * (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double a, double[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a * (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[,] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[][] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this double[] a, double[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this double[] a, double b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this double a, double[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a * (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a,  double[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a,  double[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double[] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double[] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double[,] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double[][] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double[,] a, double[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double[][] a, double[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[][] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a, byte[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[,] a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (byte* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[,] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) * (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (byte* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[,] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[][] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a *  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a * (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double a, byte[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a * (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[,] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[][] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this double[] a, byte[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this double[] a, byte b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this double a, byte[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a * (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a,  byte[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a,  byte[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double[] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double[] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double[,] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double[][] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double[,] a, byte[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double[][] a, byte[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this double[][] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (byte)((byte)a[i][j] * (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this double[,] a, byte[][] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (byte)((byte)(*pa) * (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this double[,] a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (byte* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (byte)((byte)(*pa) * (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this double[][] a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)(a[i][j]) * (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this double[,] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (byte)((byte)(*pa) * (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this double[][] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (byte)((byte)(a[i][j]) * (byte)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this double[,] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (byte* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (byte)((byte)(*pa) * (byte)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this double[,] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) *  (byte)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this double[][] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (byte)((byte)a[i][j] * (byte)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this double[][] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] * (byte)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this double a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)a *  (byte)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this double a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (byte)((byte)a * (byte)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this double a, byte[][] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (byte)((byte)a * (byte)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this double a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (byte)((byte)a * (byte)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this double[,] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (byte)((byte)(*pa) * (byte)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this double[,] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) *  (byte)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this double[][] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] * (byte)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Multiply(this double[] a, byte[] b, byte[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] * (byte)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Multiply(this double[] a, byte b, byte[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] * (byte)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Multiply(this double a, byte[] b, byte[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (byte)((byte)a * (byte)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this double[,] a,  byte[] b, int dimension, byte[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] * (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] * (byte)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this double[][] a,  byte[] b, int dimension, byte[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] * (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] * (byte)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this double a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a * (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this double a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a * (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this double[] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a[j] * (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this double[] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i] * (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this double[,] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) * (byte)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this double[][] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] * (byte)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this double[,] a, byte[] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) * (byte)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this double[][] a, byte[] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] * (byte)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[][] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a, decimal[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[,] a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (decimal* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[,] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) * (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (decimal* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[,] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[][] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a *  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a * (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double a, decimal[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a * (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[,] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[][] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this double[] a, decimal[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this double[] a, decimal b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this double a, decimal[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a * (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this double[,] a,  decimal[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this double[][] a,  decimal[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double[] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double[] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double[,] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double[][] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this double[,] a, decimal[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this double[][] a, decimal[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this double[][] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (decimal)((decimal)a[i][j] * (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this double[,] a, decimal[][] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (decimal)((decimal)(*pa) * (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this double[,] a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (decimal* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (decimal)((decimal)(*pa) * (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this double[][] a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)(a[i][j]) * (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this double[,] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (decimal)((decimal)(*pa) * (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this double[][] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (decimal)((decimal)(a[i][j]) * (decimal)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this double[,] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (decimal* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (decimal)((decimal)(*pa) * (decimal)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this double[,] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) *  (decimal)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this double[][] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a[i][j] * (decimal)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this double[][] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] * (decimal)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this double a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)a *  (decimal)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this double a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a * (decimal)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this double a, decimal[][] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (decimal)((decimal)a * (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this double a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (decimal)((decimal)a * (decimal)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this double[,] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (decimal)((decimal)(*pa) * (decimal)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this double[,] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) *  (decimal)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this double[][] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] * (decimal)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Multiply(this double[] a, decimal[] b, decimal[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] * (decimal)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Multiply(this double[] a, decimal b, decimal[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] * (decimal)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Multiply(this double a, decimal[] b, decimal[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (decimal)((decimal)a * (decimal)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this double[,] a,  decimal[] b, int dimension, decimal[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] * (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] * (decimal)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this double[][] a,  decimal[] b, int dimension, decimal[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] * (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] * (decimal)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this double a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a * (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this double a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a * (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this double[] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a[j] * (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this double[] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i] * (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this double[,] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) * (decimal)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this double[][] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] * (decimal)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this double[,] a, decimal[] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) * (decimal)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this double[][] a, decimal[] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] * (decimal)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[][] a, int[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (byte)((byte)a[i][j] * (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[,] a, int[][] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (byte)((byte)(*pa) * (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[,] a, int[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (int* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (byte)((byte)(*pa) * (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[][] a, int[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)(a[i][j]) * (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[,] a, int[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (byte)((byte)(*pa) * (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[][] a, int[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (byte)((byte)(a[i][j]) * (byte)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[,] a, int[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (int* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (byte)((byte)(*pa) * (byte)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[,] a, int b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) *  (byte)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[][] a, int b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (byte)((byte)a[i][j] * (byte)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[][] a, int b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] * (byte)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte a, int[,] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)a *  (byte)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte a, int[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (byte)((byte)a * (byte)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte a, int[][] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (byte)((byte)a * (byte)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte a, int[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (byte)((byte)a * (byte)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[,] a, int b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (byte)((byte)(*pa) * (byte)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[,] a, int b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) *  (byte)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[][] a, int b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] * (byte)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Multiply(this byte[] a, int[] b, byte[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] * (byte)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Multiply(this byte[] a, int b, byte[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] * (byte)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Multiply(this byte a, int[] b, byte[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (byte)((byte)a * (byte)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[,] a,  int[] b, int dimension, byte[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] * (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] * (byte)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[][] a,  int[] b, int dimension, byte[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] * (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] * (byte)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte a, int[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a * (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte a, int[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a * (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte[] a, int[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a[j] * (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte[] a, int[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i] * (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte[,] a, int b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) * (byte)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte[][] a, int b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] * (byte)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte[,] a, int[] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) * (byte)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte[][] a, int[] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] * (byte)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this byte[][] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (int)((int)a[i][j] * (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this byte[,] a, int[][] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (int)((int)(*pa) * (int)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this byte[,] a, int[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (int* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (int)((int)(*pa) * (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this byte[][] a, int[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)(a[i][j]) * (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this byte[,] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (int)((int)(*pa) * (int)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this byte[][] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (int)((int)(a[i][j]) * (int)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this byte[,] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (int* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (int)((int)(*pa) * (int)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this byte[,] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) *  (int)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this byte[][] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (int)((int)a[i][j] * (int)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this byte[][] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] * (int)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this byte a, int[,] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)a *  (int)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this byte a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (int)((int)a * (int)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this byte a, int[][] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (int)((int)a * (int)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this byte a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (int)((int)a * (int)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this byte[,] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (int)((int)(*pa) * (int)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this byte[,] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) *  (int)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this byte[][] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] * (int)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this byte[] a, int[] b, int[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] * (int)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this byte[] a, int b, int[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] * (int)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this byte a, int[] b, int[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (int)((int)a * (int)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this byte[,] a,  int[] b, int dimension, int[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] * (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] * (int)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this byte[][] a,  int[] b, int dimension, int[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] * (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] * (int)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this byte a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a * (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this byte a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a * (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this byte[] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a[j] * (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this byte[] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i] * (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this byte[,] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) * (int)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this byte[][] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (int)((int)a[i][i] * (int)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this byte[,] a, int[] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) * (int)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this byte[][] a, int[] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i][i] * (int)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[][] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[,] a, int[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[,] a, int[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (int* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[][] a, int[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[,] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[][] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) * (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[,] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (int* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[,] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[][] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[][] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte a, int[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a *  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a * (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte a, int[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a * (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[,] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[,] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[][] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this byte[] a, int[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this byte[] a, int b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this byte a, int[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a * (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[,] a,  int[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[][] a,  int[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this byte a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this byte a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this byte[] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this byte[] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this byte[,] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this byte[][] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this byte[,] a, int[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this byte[][] a, int[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[][] a, float[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (byte)((byte)a[i][j] * (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[,] a, float[][] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (byte)((byte)(*pa) * (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[,] a, float[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (float* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (byte)((byte)(*pa) * (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[][] a, float[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)(a[i][j]) * (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[,] a, float[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (byte)((byte)(*pa) * (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[][] a, float[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (byte)((byte)(a[i][j]) * (byte)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[,] a, float[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (float* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (byte)((byte)(*pa) * (byte)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[,] a, float b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) *  (byte)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[][] a, float b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (byte)((byte)a[i][j] * (byte)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[][] a, float b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] * (byte)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte a, float[,] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)a *  (byte)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte a, float[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (byte)((byte)a * (byte)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte a, float[][] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (byte)((byte)a * (byte)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte a, float[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (byte)((byte)a * (byte)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[,] a, float b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (byte)((byte)(*pa) * (byte)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[,] a, float b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) *  (byte)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[][] a, float b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] * (byte)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Multiply(this byte[] a, float[] b, byte[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] * (byte)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Multiply(this byte[] a, float b, byte[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] * (byte)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Multiply(this byte a, float[] b, byte[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (byte)((byte)a * (byte)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[,] a,  float[] b, int dimension, byte[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] * (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] * (byte)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[][] a,  float[] b, int dimension, byte[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] * (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] * (byte)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte a, float[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a * (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte a, float[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a * (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte[] a, float[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a[j] * (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte[] a, float[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i] * (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte[,] a, float b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) * (byte)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte[][] a, float b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] * (byte)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte[,] a, float[] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) * (byte)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte[][] a, float[] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] * (byte)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this byte[][] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (float)((float)a[i][j] * (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this byte[,] a, float[][] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (float)((float)(*pa) * (float)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this byte[,] a, float[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (float* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (float)((float)(*pa) * (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this byte[][] a, float[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)(a[i][j]) * (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this byte[,] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (float)((float)(*pa) * (float)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this byte[][] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (float)((float)(a[i][j]) * (float)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this byte[,] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (float* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (float)((float)(*pa) * (float)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this byte[,] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) *  (float)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this byte[][] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (float)((float)a[i][j] * (float)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this byte[][] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] * (float)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this byte a, float[,] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)a *  (float)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this byte a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (float)((float)a * (float)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this byte a, float[][] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (float)((float)a * (float)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this byte a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (float)((float)a * (float)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this byte[,] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (float)((float)(*pa) * (float)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this byte[,] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) *  (float)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this byte[][] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] * (float)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this byte[] a, float[] b, float[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] * (float)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this byte[] a, float b, float[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] * (float)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this byte a, float[] b, float[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (float)((float)a * (float)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this byte[,] a,  float[] b, int dimension, float[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] * (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] * (float)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this byte[][] a,  float[] b, int dimension, float[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] * (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] * (float)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this byte a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a * (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this byte a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a * (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this byte[] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a[j] * (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this byte[] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i] * (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this byte[,] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) * (float)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this byte[][] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (float)((float)a[i][i] * (float)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this byte[,] a, float[] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) * (float)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this byte[][] a, float[] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i][i] * (float)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[][] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[,] a, float[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[,] a, float[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (float* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[][] a, float[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[,] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[][] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) * (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[,] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (float* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[,] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[][] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[][] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte a, float[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a *  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a * (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte a, float[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a * (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[,] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[,] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[][] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this byte[] a, float[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this byte[] a, float b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this byte a, float[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a * (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[,] a,  float[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[][] a,  float[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this byte a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this byte a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this byte[] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this byte[] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this byte[,] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this byte[][] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this byte[,] a, float[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this byte[][] a, float[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[][] a, double[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (byte)((byte)a[i][j] * (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[,] a, double[][] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (byte)((byte)(*pa) * (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[,] a, double[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (double* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (byte)((byte)(*pa) * (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[][] a, double[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)(a[i][j]) * (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[,] a, double[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (byte)((byte)(*pa) * (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[][] a, double[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (byte)((byte)(a[i][j]) * (byte)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[,] a, double[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (double* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (byte)((byte)(*pa) * (byte)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[,] a, double b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) *  (byte)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[][] a, double b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (byte)((byte)a[i][j] * (byte)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[][] a, double b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] * (byte)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte a, double[,] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)a *  (byte)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte a, double[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (byte)((byte)a * (byte)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte a, double[][] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (byte)((byte)a * (byte)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte a, double[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (byte)((byte)a * (byte)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[,] a, double b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (byte)((byte)(*pa) * (byte)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[,] a, double b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) *  (byte)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[][] a, double b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] * (byte)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Multiply(this byte[] a, double[] b, byte[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] * (byte)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Multiply(this byte[] a, double b, byte[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] * (byte)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Multiply(this byte a, double[] b, byte[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (byte)((byte)a * (byte)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[,] a,  double[] b, int dimension, byte[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] * (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] * (byte)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[][] a,  double[] b, int dimension, byte[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] * (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] * (byte)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte a, double[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a * (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte a, double[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a * (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte[] a, double[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a[j] * (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte[] a, double[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i] * (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte[,] a, double b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) * (byte)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte[][] a, double b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] * (byte)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte[,] a, double[] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) * (byte)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte[][] a, double[] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] * (byte)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[][] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[,] a, double[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[,] a, double[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (double* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[][] a, double[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[,] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[][] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) * (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[,] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (double* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[,] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[][] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[][] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte a, double[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a *  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a * (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte a, double[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a * (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[,] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[,] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[][] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this byte[] a, double[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this byte[] a, double b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this byte a, double[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a * (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[,] a,  double[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[][] a,  double[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this byte a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this byte a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this byte[] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this byte[] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this byte[,] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this byte[][] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this byte[,] a, double[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this byte[][] a, double[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[][] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (byte)((byte)a[i][j] * (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[,] a, byte[][] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (byte)((byte)(*pa) * (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[,] a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (byte* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (byte)((byte)(*pa) * (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[][] a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)(a[i][j]) * (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[,] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (byte)((byte)(*pa) * (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[][] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (byte)((byte)(a[i][j]) * (byte)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[,] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (byte* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (byte)((byte)(*pa) * (byte)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[,] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) *  (byte)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[][] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (byte)((byte)a[i][j] * (byte)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[][] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] * (byte)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)a *  (byte)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (byte)((byte)a * (byte)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte a, byte[][] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (byte)((byte)a * (byte)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (byte)((byte)a * (byte)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[,] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (byte)((byte)(*pa) * (byte)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[,] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) *  (byte)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[][] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] * (byte)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Multiply(this byte[] a, byte[] b, byte[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] * (byte)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Multiply(this byte[] a, byte b, byte[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] * (byte)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Multiply(this byte a, byte[] b, byte[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (byte)((byte)a * (byte)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[,] a,  byte[] b, int dimension, byte[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] * (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] * (byte)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[][] a,  byte[] b, int dimension, byte[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] * (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] * (byte)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a * (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a * (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte[] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a[j] * (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte[] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i] * (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte[,] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) * (byte)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte[][] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] * (byte)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte[,] a, byte[] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) * (byte)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte[][] a, byte[] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] * (byte)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[][] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[,] a, byte[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[,] a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (byte* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[][] a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[,] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[][] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) * (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[,] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (byte* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[,] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[][] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[][] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a *  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a * (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte a, byte[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a * (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[,] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[,] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[][] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this byte[] a, byte[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this byte[] a, byte b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this byte a, byte[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a * (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[,] a,  byte[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[][] a,  byte[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this byte a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this byte a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this byte[] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this byte[] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this byte[,] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this byte[][] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this byte[,] a, byte[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this byte[][] a, byte[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[][] a, decimal[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (byte)((byte)a[i][j] * (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[,] a, decimal[][] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (byte)((byte)(*pa) * (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[,] a, decimal[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (decimal* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (byte)((byte)(*pa) * (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[][] a, decimal[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)(a[i][j]) * (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[,] a, decimal[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (byte)((byte)(*pa) * (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[][] a, decimal[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (byte)((byte)(a[i][j]) * (byte)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[,] a, decimal[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (decimal* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (byte)((byte)(*pa) * (byte)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[,] a, decimal b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) *  (byte)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[][] a, decimal b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (byte)((byte)a[i][j] * (byte)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[][] a, decimal b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] * (byte)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte a, decimal[,] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)a *  (byte)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte a, decimal[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (byte)((byte)a * (byte)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte a, decimal[][] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (byte)((byte)a * (byte)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte a, decimal[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (byte)((byte)a * (byte)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[,] a, decimal b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (byte)((byte)(*pa) * (byte)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[,] a, decimal b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) *  (byte)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[][] a, decimal b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] * (byte)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Multiply(this byte[] a, decimal[] b, byte[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] * (byte)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Multiply(this byte[] a, decimal b, byte[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] * (byte)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Multiply(this byte a, decimal[] b, byte[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (byte)((byte)a * (byte)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this byte[,] a,  decimal[] b, int dimension, byte[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] * (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] * (byte)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this byte[][] a,  decimal[] b, int dimension, byte[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] * (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] * (byte)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte a, decimal[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a * (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte a, decimal[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a * (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte[] a, decimal[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a[j] * (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte[] a, decimal[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i] * (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte[,] a, decimal b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) * (byte)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte[][] a, decimal b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] * (byte)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this byte[,] a, decimal[] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) * (byte)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this byte[][] a, decimal[] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] * (byte)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this byte[][] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (decimal)((decimal)a[i][j] * (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this byte[,] a, decimal[][] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (decimal)((decimal)(*pa) * (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this byte[,] a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (decimal* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (decimal)((decimal)(*pa) * (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this byte[][] a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)(a[i][j]) * (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this byte[,] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (decimal)((decimal)(*pa) * (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this byte[][] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (decimal)((decimal)(a[i][j]) * (decimal)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this byte[,] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (decimal* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (decimal)((decimal)(*pa) * (decimal)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this byte[,] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) *  (decimal)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this byte[][] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a[i][j] * (decimal)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this byte[][] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] * (decimal)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this byte a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)a *  (decimal)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this byte a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a * (decimal)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this byte a, decimal[][] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (decimal)((decimal)a * (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this byte a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (decimal)((decimal)a * (decimal)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this byte[,] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (decimal)((decimal)(*pa) * (decimal)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this byte[,] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) *  (decimal)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this byte[][] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] * (decimal)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Multiply(this byte[] a, decimal[] b, decimal[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] * (decimal)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Multiply(this byte[] a, decimal b, decimal[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] * (decimal)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Multiply(this byte a, decimal[] b, decimal[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (decimal)((decimal)a * (decimal)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this byte[,] a,  decimal[] b, int dimension, decimal[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] * (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] * (decimal)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this byte[][] a,  decimal[] b, int dimension, decimal[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] * (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] * (decimal)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this byte a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a * (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this byte a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a * (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this byte[] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a[j] * (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this byte[] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i] * (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this byte[,] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) * (decimal)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this byte[][] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] * (decimal)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this byte[,] a, decimal[] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) * (decimal)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this byte[][] a, decimal[] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] * (decimal)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[][] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[,] a, decimal[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[,] a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (decimal* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[][] a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[,] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[][] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) * (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[,] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (decimal* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[,] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[][] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[][] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a *  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a * (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte a, decimal[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a * (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[,] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[,] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[][] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this byte[] a, decimal[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this byte[] a, decimal b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this byte a, decimal[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a * (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this byte[,] a,  decimal[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this byte[][] a,  decimal[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this byte a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this byte a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this byte[] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this byte[] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this byte[,] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this byte[][] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this byte[,] a, decimal[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this byte[][] a, decimal[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[][] a, int[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (decimal)((decimal)a[i][j] * (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[,] a, int[][] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (decimal)((decimal)(*pa) * (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[,] a, int[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (int* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (decimal)((decimal)(*pa) * (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[][] a, int[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)(a[i][j]) * (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[,] a, int[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (decimal)((decimal)(*pa) * (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[][] a, int[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (decimal)((decimal)(a[i][j]) * (decimal)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[,] a, int[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (int* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (decimal)((decimal)(*pa) * (decimal)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[,] a, int b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) *  (decimal)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[][] a, int b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a[i][j] * (decimal)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[][] a, int b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] * (decimal)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal a, int[,] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)a *  (decimal)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal a, int[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a * (decimal)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal a, int[][] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (decimal)((decimal)a * (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal a, int[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (decimal)((decimal)a * (decimal)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[,] a, int b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (decimal)((decimal)(*pa) * (decimal)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[,] a, int b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) *  (decimal)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[][] a, int b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] * (decimal)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Multiply(this decimal[] a, int[] b, decimal[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] * (decimal)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Multiply(this decimal[] a, int b, decimal[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] * (decimal)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Multiply(this decimal a, int[] b, decimal[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (decimal)((decimal)a * (decimal)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[,] a,  int[] b, int dimension, decimal[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] * (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] * (decimal)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[][] a,  int[] b, int dimension, decimal[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] * (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] * (decimal)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal a, int[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a * (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal a, int[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a * (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal[] a, int[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a[j] * (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal[] a, int[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i] * (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal[,] a, int b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) * (decimal)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal[][] a, int b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] * (decimal)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal[,] a, int[] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) * (decimal)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal[][] a, int[] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] * (decimal)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this decimal[][] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (int)((int)a[i][j] * (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this decimal[,] a, int[][] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (int)((int)(*pa) * (int)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this decimal[,] a, int[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (int* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (int)((int)(*pa) * (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this decimal[][] a, int[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)(a[i][j]) * (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this decimal[,] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (int)((int)(*pa) * (int)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this decimal[][] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (int)((int)(a[i][j]) * (int)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this decimal[,] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (int* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (int)((int)(*pa) * (int)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this decimal[,] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) *  (int)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this decimal[][] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (int)((int)a[i][j] * (int)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this decimal[][] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] * (int)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this decimal a, int[,] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)a *  (int)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this decimal a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (int)((int)a * (int)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this decimal a, int[][] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (int)((int)a * (int)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this decimal a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (int)((int)a * (int)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this decimal[,] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (int)((int)(*pa) * (int)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this decimal[,] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) *  (int)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this decimal[][] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] * (int)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this decimal[] a, int[] b, int[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] * (int)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this decimal[] a, int b, int[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] * (int)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Multiply(this decimal a, int[] b, int[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (int)((int)a * (int)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Multiply(this decimal[,] a,  int[] b, int dimension, int[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] * (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] * (int)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Multiply(this decimal[][] a,  int[] b, int dimension, int[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] * (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] * (int)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this decimal a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a * (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this decimal a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a * (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this decimal[] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a[j] * (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this decimal[] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i] * (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this decimal[,] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) * (int)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this decimal[][] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (int)((int)a[i][i] * (int)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] MultiplyWithDiagonal(this decimal[,] a, int[] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) * (int)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] MultiplyWithDiagonal(this decimal[][] a, int[] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i][i] * (int)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[][] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[,] a, int[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[,] a, int[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (int* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[][] a, int[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[,] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[][] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) * (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[,] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (int* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[,] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[][] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[][] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal a, int[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a *  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a * (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal a, int[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a * (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[,] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[,] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[][] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this decimal[] a, int[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this decimal[] a, int b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this decimal a, int[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a * (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[,] a,  int[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[][] a,  int[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this decimal a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this decimal a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this decimal[] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this decimal[] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this decimal[,] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this decimal[][] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this decimal[,] a, int[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this decimal[][] a, int[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[][] a, float[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (decimal)((decimal)a[i][j] * (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[,] a, float[][] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (decimal)((decimal)(*pa) * (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[,] a, float[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (float* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (decimal)((decimal)(*pa) * (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[][] a, float[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)(a[i][j]) * (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[,] a, float[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (decimal)((decimal)(*pa) * (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[][] a, float[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (decimal)((decimal)(a[i][j]) * (decimal)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[,] a, float[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (float* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (decimal)((decimal)(*pa) * (decimal)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[,] a, float b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) *  (decimal)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[][] a, float b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a[i][j] * (decimal)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[][] a, float b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] * (decimal)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal a, float[,] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)a *  (decimal)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal a, float[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a * (decimal)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal a, float[][] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (decimal)((decimal)a * (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal a, float[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (decimal)((decimal)a * (decimal)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[,] a, float b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (decimal)((decimal)(*pa) * (decimal)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[,] a, float b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) *  (decimal)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[][] a, float b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] * (decimal)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Multiply(this decimal[] a, float[] b, decimal[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] * (decimal)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Multiply(this decimal[] a, float b, decimal[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] * (decimal)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Multiply(this decimal a, float[] b, decimal[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (decimal)((decimal)a * (decimal)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[,] a,  float[] b, int dimension, decimal[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] * (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] * (decimal)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[][] a,  float[] b, int dimension, decimal[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] * (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] * (decimal)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal a, float[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a * (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal a, float[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a * (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal[] a, float[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a[j] * (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal[] a, float[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i] * (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal[,] a, float b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) * (decimal)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal[][] a, float b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] * (decimal)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal[,] a, float[] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) * (decimal)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal[][] a, float[] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] * (decimal)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this decimal[][] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (float)((float)a[i][j] * (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this decimal[,] a, float[][] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (float)((float)(*pa) * (float)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this decimal[,] a, float[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (float* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (float)((float)(*pa) * (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this decimal[][] a, float[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)(a[i][j]) * (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this decimal[,] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (float)((float)(*pa) * (float)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this decimal[][] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (float)((float)(a[i][j]) * (float)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this decimal[,] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (float* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (float)((float)(*pa) * (float)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this decimal[,] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) *  (float)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this decimal[][] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (float)((float)a[i][j] * (float)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this decimal[][] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] * (float)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this decimal a, float[,] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)a *  (float)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this decimal a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (float)((float)a * (float)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this decimal a, float[][] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (float)((float)a * (float)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this decimal a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (float)((float)a * (float)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this decimal[,] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (float)((float)(*pa) * (float)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this decimal[,] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) *  (float)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this decimal[][] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] * (float)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this decimal[] a, float[] b, float[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] * (float)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this decimal[] a, float b, float[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] * (float)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Multiply(this decimal a, float[] b, float[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (float)((float)a * (float)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Multiply(this decimal[,] a,  float[] b, int dimension, float[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] * (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] * (float)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Multiply(this decimal[][] a,  float[] b, int dimension, float[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] * (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] * (float)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this decimal a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a * (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this decimal a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a * (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this decimal[] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a[j] * (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this decimal[] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i] * (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this decimal[,] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) * (float)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this decimal[][] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (float)((float)a[i][i] * (float)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] MultiplyWithDiagonal(this decimal[,] a, float[] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) * (float)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] MultiplyWithDiagonal(this decimal[][] a, float[] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i][i] * (float)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[][] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[,] a, float[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[,] a, float[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (float* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[][] a, float[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[,] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[][] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) * (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[,] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (float* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[,] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[][] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[][] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal a, float[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a *  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a * (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal a, float[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a * (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[,] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[,] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[][] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this decimal[] a, float[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this decimal[] a, float b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this decimal a, float[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a * (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[,] a,  float[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[][] a,  float[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this decimal a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this decimal a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this decimal[] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this decimal[] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this decimal[,] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this decimal[][] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this decimal[,] a, float[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this decimal[][] a, float[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[][] a, double[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (decimal)((decimal)a[i][j] * (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[,] a, double[][] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (decimal)((decimal)(*pa) * (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[,] a, double[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (double* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (decimal)((decimal)(*pa) * (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[][] a, double[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)(a[i][j]) * (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[,] a, double[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (decimal)((decimal)(*pa) * (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[][] a, double[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (decimal)((decimal)(a[i][j]) * (decimal)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[,] a, double[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (double* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (decimal)((decimal)(*pa) * (decimal)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[,] a, double b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) *  (decimal)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[][] a, double b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a[i][j] * (decimal)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[][] a, double b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] * (decimal)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal a, double[,] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)a *  (decimal)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal a, double[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a * (decimal)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal a, double[][] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (decimal)((decimal)a * (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal a, double[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (decimal)((decimal)a * (decimal)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[,] a, double b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (decimal)((decimal)(*pa) * (decimal)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[,] a, double b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) *  (decimal)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[][] a, double b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] * (decimal)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Multiply(this decimal[] a, double[] b, decimal[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] * (decimal)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Multiply(this decimal[] a, double b, decimal[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] * (decimal)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Multiply(this decimal a, double[] b, decimal[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (decimal)((decimal)a * (decimal)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[,] a,  double[] b, int dimension, decimal[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] * (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] * (decimal)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[][] a,  double[] b, int dimension, decimal[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] * (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] * (decimal)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal a, double[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a * (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal a, double[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a * (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal[] a, double[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a[j] * (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal[] a, double[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i] * (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal[,] a, double b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) * (decimal)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal[][] a, double b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] * (decimal)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal[,] a, double[] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) * (decimal)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal[][] a, double[] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] * (decimal)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[][] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[,] a, double[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[,] a, double[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (double* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[][] a, double[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[,] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[][] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) * (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[,] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (double* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[,] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[][] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[][] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal a, double[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a *  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a * (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal a, double[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a * (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[,] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[,] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[][] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this decimal[] a, double[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this decimal[] a, double b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this decimal a, double[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a * (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[,] a,  double[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[][] a,  double[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this decimal a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this decimal a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this decimal[] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this decimal[] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this decimal[,] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this decimal[][] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this decimal[,] a, double[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this decimal[][] a, double[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[][] a, byte[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (decimal)((decimal)a[i][j] * (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[,] a, byte[][] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (decimal)((decimal)(*pa) * (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[,] a, byte[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (byte* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (decimal)((decimal)(*pa) * (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[][] a, byte[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)(a[i][j]) * (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[,] a, byte[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (decimal)((decimal)(*pa) * (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[][] a, byte[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (decimal)((decimal)(a[i][j]) * (decimal)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[,] a, byte[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (byte* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (decimal)((decimal)(*pa) * (decimal)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[,] a, byte b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) *  (decimal)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[][] a, byte b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a[i][j] * (decimal)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[][] a, byte b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] * (decimal)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal a, byte[,] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)a *  (decimal)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal a, byte[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a * (decimal)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal a, byte[][] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (decimal)((decimal)a * (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal a, byte[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (decimal)((decimal)a * (decimal)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[,] a, byte b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (decimal)((decimal)(*pa) * (decimal)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[,] a, byte b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) *  (decimal)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[][] a, byte b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] * (decimal)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Multiply(this decimal[] a, byte[] b, decimal[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] * (decimal)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Multiply(this decimal[] a, byte b, decimal[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] * (decimal)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Multiply(this decimal a, byte[] b, decimal[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (decimal)((decimal)a * (decimal)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[,] a,  byte[] b, int dimension, decimal[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] * (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] * (decimal)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[][] a,  byte[] b, int dimension, decimal[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] * (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] * (decimal)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal a, byte[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a * (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal a, byte[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a * (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal[] a, byte[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a[j] * (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal[] a, byte[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i] * (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal[,] a, byte b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) * (decimal)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal[][] a, byte b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] * (decimal)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal[,] a, byte[] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) * (decimal)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal[][] a, byte[] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] * (decimal)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this decimal[][] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (byte)((byte)a[i][j] * (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this decimal[,] a, byte[][] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (byte)((byte)(*pa) * (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this decimal[,] a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (byte* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (byte)((byte)(*pa) * (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this decimal[][] a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)(a[i][j]) * (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this decimal[,] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (byte)((byte)(*pa) * (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this decimal[][] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (byte)((byte)(a[i][j]) * (byte)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this decimal[,] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (byte* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (byte)((byte)(*pa) * (byte)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this decimal[,] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) *  (byte)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this decimal[][] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (byte)((byte)a[i][j] * (byte)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this decimal[][] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] * (byte)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this decimal a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)a *  (byte)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this decimal a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (byte)((byte)a * (byte)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this decimal a, byte[][] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (byte)((byte)a * (byte)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this decimal a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (byte)((byte)a * (byte)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this decimal[,] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (byte)((byte)(*pa) * (byte)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this decimal[,] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) *  (byte)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this decimal[][] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] * (byte)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Multiply(this decimal[] a, byte[] b, byte[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] * (byte)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Multiply(this decimal[] a, byte b, byte[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] * (byte)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Multiply(this decimal a, byte[] b, byte[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (byte)((byte)a * (byte)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Multiply(this decimal[,] a,  byte[] b, int dimension, byte[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] * (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] * (byte)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Multiply(this decimal[][] a,  byte[] b, int dimension, byte[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] * (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] * (byte)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this decimal a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a * (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this decimal a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a * (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this decimal[] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a[j] * (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this decimal[] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i] * (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this decimal[,] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) * (byte)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this decimal[][] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] * (byte)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] MultiplyWithDiagonal(this decimal[,] a, byte[] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) * (byte)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] MultiplyWithDiagonal(this decimal[][] a, byte[] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] * (byte)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[][] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[,] a, byte[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[,] a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (byte* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[][] a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[,] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[][] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) * (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[,] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (byte* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[,] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[][] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[][] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a *  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a * (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal a, byte[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a * (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[,] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[,] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[][] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this decimal[] a, byte[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this decimal[] a, byte b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this decimal a, byte[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a * (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[,] a,  byte[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[][] a,  byte[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this decimal a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this decimal a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this decimal[] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this decimal[] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this decimal[,] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this decimal[][] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this decimal[,] a, byte[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this decimal[][] a, byte[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[][] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (decimal)((decimal)a[i][j] * (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[,] a, decimal[][] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (decimal)((decimal)(*pa) * (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[,] a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (decimal* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (decimal)((decimal)(*pa) * (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[][] a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)(a[i][j]) * (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[,] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (decimal)((decimal)(*pa) * (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[][] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (decimal)((decimal)(a[i][j]) * (decimal)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[,] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (decimal* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (decimal)((decimal)(*pa) * (decimal)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[,] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) *  (decimal)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[][] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a[i][j] * (decimal)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[][] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] * (decimal)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)a *  (decimal)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a * (decimal)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal a, decimal[][] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (decimal)((decimal)a * (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (decimal)((decimal)a * (decimal)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[,] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (decimal)((decimal)(*pa) * (decimal)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[,] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) *  (decimal)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[][] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] * (decimal)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Multiply(this decimal[] a, decimal[] b, decimal[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] * (decimal)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Multiply(this decimal[] a, decimal b, decimal[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] * (decimal)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Multiply(this decimal a, decimal[] b, decimal[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (decimal)((decimal)a * (decimal)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Multiply(this decimal[,] a,  decimal[] b, int dimension, decimal[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] * (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] * (decimal)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Multiply(this decimal[][] a,  decimal[] b, int dimension, decimal[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] * (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] * (decimal)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a * (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a * (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal[] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a[j] * (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal[] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i] * (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal[,] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) * (decimal)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal[][] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] * (decimal)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] MultiplyWithDiagonal(this decimal[,] a, decimal[] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) * (decimal)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] MultiplyWithDiagonal(this decimal[][] a, decimal[] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] * (decimal)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[][] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[,] a, decimal[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[,] a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (decimal* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[][] a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) * (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[,] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) * (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[][] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) * (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[,] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (decimal* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) * (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[,] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[][] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[][] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a *  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a * (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal a, decimal[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a * (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[,] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[,] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) *  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[][] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] * (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this decimal[] a, decimal[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this decimal[] a, decimal b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] * (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Multiply(this decimal a, decimal[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a * (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Multiply(this decimal[,] a,  decimal[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] * (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise multiplication (note: this is not a dot or matrix product) between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Multiply(this decimal[][] a,  decimal[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] * (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this decimal a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this decimal a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this decimal[] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] * (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this decimal[] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] * (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this decimal[,] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this decimal[][] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] MultiplyWithDiagonal(this decimal[,] a, decimal[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) * (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] MultiplyWithDiagonal(this decimal[][] a, decimal[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] * (double)b[i]);
            return result;
        }
 
#endregion
     
#pragma warning restore 1591
    }
}
