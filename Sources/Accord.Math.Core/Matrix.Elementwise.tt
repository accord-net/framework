<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension="Generated.cs" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ include file="T4Toolbox.tt" #>
// Accord Math Library
// The Accord.NET Framework
// http://accord-framework.net
//
// Copyright © César Souza, 2009-2017
// cesarsouza at gmail.com
//
//    This library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    This library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with this library; if not, write to the Free Software
//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
//

// ======================================================================
// This code has been generated by a tool; do not edit manually. Instead,
// edit the T4 template Matrix.Elementwise.tt so this file can be regenerated. 
// ======================================================================

namespace Accord.Math
{
    using System;
    using System.CodeDom.Compiler;
    using Accord.Math;
    using System.Runtime.CompilerServices;

    public static partial class Elementwise
    {
        private static TOutput[] VectorCreateAs<TInput, TOutput>(TInput[] vector)
        {
            return new TOutput[vector.Length];
        }

        private static TOutput[,] MatrixCreateAs<TInput, TOutput>(TInput[,] matrix)
        {
            return new TOutput[matrix.GetLength(0), matrix.GetLength(1)];
        }

        private static TOutput[][] JaggedCreateAs<TInput, TOutput>(TInput[][] matrix)
        {
            var r = new TOutput[matrix.Length][];
            for (int i = 0; i < r.Length; i++)
                r[i] = new TOutput[matrix[i].Length];
            return r;
        }

        private static TOutput[,] MatrixCreateAs<TInput, TOutput>(TInput[][] matrix)
        {
            return new TOutput[matrix.Length, matrix[0].Length];
        }

        private static TOutput[][] JaggedCreateAs<TInput, TOutput>(TInput[,] matrix)
        {
            var r = new TOutput[matrix.GetLength(0)][];
            for (int i = 0; i < r.Length; i++)
                r[i] = new TOutput[matrix.GetLength(1)];
            return r;
        }

        private static T[,] MemberwiseClone<T>(this T[,] matrix)
        {
            return (T[,])matrix.Clone();
        }

        private static T[][] MemberwiseClone<T>(this T[][] matrix)
        {
            T[][] r = new T[matrix.Length][];
            for (int i = 0; i < matrix.Length; i++)
                r[i] = (T[])matrix[i].Clone();
            return r;
        }

<# 
    string[] types =
    { 
        "int", "short",
        "float", "double", 
        "long", "decimal",
        //"byte", "sbyte", 
    };

    string[][] operations =
    {
        new string[] { "Exp", "exponential",  "Math.Exp((double)v)", "double" },
        new string[] { "Log", "logarithm", "Math.Log((double)v)", "double" },        
        new string[] { "Sign", "sign", "Math.Sign(v)" },
        new string[] { "Abs", "absolute value", "Math.Abs(v)" },
        new string[] { "Sqrt", "square-root", "Math.Sqrt((double)v)", "double" },
        new string[] { "SignSqrt", "signed square-root", "Math.Sign(v) * Math.Sqrt((double)v)", "double" },

        new string[] { "Floor", "floor", "Math.Floor((double)v)", "double" },
        new string[] { "Ceiling", "ceiling", "Math.Ceiling((double)v)", "double" },
        new string[] { "Round", "round", "Math.Round((double)v)", "double" },
    };

    foreach (string a in types)
    {
        foreach (string[] opt in operations)
        {
            string method = opt[0];
            string name   = opt[1];
            string code   = opt[2];
            string r = a;
            if (opt.Length >= 4)
                r = opt[3];
#>
        /// <summary>
        ///   Elementwise <#=name#>.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] <#=method#>(this <#=a#>[] value)
        {
            return <#=method#>(value, new <#=r#>[value.Length]);
        }

        /// <summary>
        ///   Elementwise <#=name#>.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] <#=method#>(this <#=a#>[,] value)
        {
            return <#=method#>(value, MatrixCreateAs<<#=a#>, <#=r#>>(value));
        }

        /// <summary>
        ///   Elementwise <#=name#>.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] <#=method#>(this <#=a#>[][] value)
        {
            return <#=method#>(value, JaggedCreateAs<<#=a#>, <#=r#>>(value));
        }
<#
        }
    }

    foreach (string a in types)
    {
        foreach (string r in types)
        {
            foreach (string[] opt in operations)
            {
                string method = opt[0];
                string name   = opt[1];
                string code   = opt[2];
#>
        /// <summary>
        ///   Elementwise <#=name#>.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] <#=method#>(this <#=a#>[] value, <#=r#>[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (<#=r#>)(<#=code#>);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise <#=name#>.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] <#=method#>(this <#=a#>[,] value, <#=r#>[,] result)
        {
            unsafe
            {
                fixed (<#=a#>* ptrV = value)
                fixed (<#=r#>* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (<#=r#>)(<#=code#>);
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise <#=name#>.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] <#=method#>(this <#=a#>[][] value, <#=r#>[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (<#=r#>)(<#=code#>);
                    }
                }
            }
            return result;
        }
<#
            }
        }
    }

    operations = new string[][]
    {
        new string[] { "SignedPow", "signed power", "Math.Sign(v) * Math.Pow((double)Math.Abs(v), y)" },
        new string[] { "Pow", "power", "Math.Pow((double)Math.Abs(v), y)" },
    };

    foreach (string a in types)
    {
        foreach (string[] opt in operations)
        {
            string method = opt[0];
            string name   = opt[1];
            string code   = opt[2];
            string r = a;
            if (opt.Length >= 4)
                r = opt[3];
#>
        /// <summary>
        ///   Elementwise <#=name#>.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] <#=method#>(this <#=a#>[] value, double y)
        {
            return <#=method#>(value, y, new <#=r#>[value.Length]);
        }

        /// <summary>
        ///   Elementwise <#=name#>.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] <#=method#>(this <#=a#>[,] value, double y)
        {
            return <#=method#>(value, y, MatrixCreateAs<<#=a#>, <#=r#>>(value));
        }

        /// <summary>
        ///   Elementwise <#=name#>.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] <#=method#>(this <#=a#>[][] value, double y)
        {
            return <#=method#>(value, y, JaggedCreateAs<<#=a#>, <#=r#>>(value));
        }
<#
        }
    }

    foreach (string a in types)
    {
        foreach (string r in types)
        {
            foreach (string[] opt in operations)
            {
                string method = opt[0];
                string name   = opt[1];
                string code   = opt[2];
#>
        /// <summary>
        ///   Elementwise <#=name#>.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] <#=method#>(this <#=a#>[] value, double y, <#=r#>[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (<#=r#>)(<#=code#>);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise <#=name#>.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] <#=method#>(this <#=a#>[,] value, double y, <#=r#>[,] result)
        {
            unsafe
            {
                fixed (<#=a#>* ptrV = value)
                fixed (<#=r#>* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (<#=r#>)(<#=code#>);
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise <#=name#>.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] <#=method#>(this <#=a#>[][] value, double y, <#=r#>[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (<#=r#>)(<#=code#>);
                    }
                }
            }
            return result;
        }
<#
            }
        }
    }
#>
    }
}