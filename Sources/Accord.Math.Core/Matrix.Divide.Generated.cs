// Accord Math Library
// The Accord.NET Framework
// http://accord-framework.net
//
// Copyright © César Souza, 2009-2017
// cesarsouza at gmail.com
//
//    This library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    This library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with this library; if not, write to the Free Software
//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
//

// ======================================================================
// This code has been generated by a tool; do not edit manually. Instead,
// edit the T4 template Matrix.Elementwise2.tt so this file can be regenerated. 
// ======================================================================

namespace Accord.Math
{
    using System;
    using Accord.Math;
    using System.Runtime.CompilerServices;

    /// <summary>
    ///   Elementwise matrix and vector operations.
    /// </summary>
    ///
    public static partial class Elementwise
    {
#pragma warning disable 1591

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[,] a, int b)
        {
            return Divide(a, b, new double[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[][] a, int b)
        {
            return Divide(a, b, JaggedCreateAs<int, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static double[] Divide(this int[] a, int b)
        {
            return Divide(a, b, new double[a.Length]);
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this int[] a, int[] b)
        {
            return Divide(a, b, new double[a.Length]);
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[][] a, int[][] b)
        {
            return Divide(a, b, JaggedCreateAs<int, double>(a));
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[,] a, int[,] b)
        {
            return Divide(a, b, MatrixCreateAs<int, double>(a));
        }     
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[][] a, int[,] b)
        {
            return Divide(a, b, JaggedCreateAs<int, double>(a));
        }      
*/
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int a, int[,] b)
        {
            return Divide(a, b, MatrixCreateAs<int, double>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int a, int[][] b)
        {
            return Divide(a, b, JaggedCreateAs<int, double>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this int a, int[] b)
        {
            return Divide(a, b, new double[b.Length]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[,] a,  int[] b, int dimension)
        {
            return Divide(a, b, dimension, MatrixCreateAs<int, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[][] a,  int[] b, int dimension)
        {
            return Divide(a, b, dimension, JaggedCreateAs<int, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int a, int[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int a, int[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int[] a, int[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int[] a, int[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int[,] a, int b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int[][] a, int b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int[,] a, int[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int[][] a, int[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this int[,] a, float b)
        {
            return Divide(a, b, new float[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this int[][] a, float b)
        {
            return Divide(a, b, JaggedCreateAs<int, float>(a));
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static float[] Divide(this int[] a, float b)
        {
            return Divide(a, b, new float[a.Length]);
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this int[] a, float[] b)
        {
            return Divide(a, b, new float[a.Length]);
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this int[][] a, float[][] b)
        {
            return Divide(a, b, JaggedCreateAs<int, float>(a));
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this int[,] a, float[,] b)
        {
            return Divide(a, b, MatrixCreateAs<int, float>(a));
        }     
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this int[][] a, float[,] b)
        {
            return Divide(a, b, JaggedCreateAs<int, float>(a));
        }      
*/
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this int a, float[,] b)
        {
            return Divide(a, b, MatrixCreateAs<float, float>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this int a, float[][] b)
        {
            return Divide(a, b, JaggedCreateAs<float, float>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this int a, float[] b)
        {
            return Divide(a, b, new float[b.Length]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this int[,] a,  float[] b, int dimension)
        {
            return Divide(a, b, dimension, MatrixCreateAs<int, float>(a));
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this int[][] a,  float[] b, int dimension)
        {
            return Divide(a, b, dimension, JaggedCreateAs<int, float>(a));
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this int a, float[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this int a, float[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this int[] a, float[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this int[] a, float[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int[,] a, float b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int[][] a, float b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int[,] a, float[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int[][] a, float[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[,] a, double b)
        {
            return Divide(a, b, new double[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[][] a, double b)
        {
            return Divide(a, b, JaggedCreateAs<int, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static double[] Divide(this int[] a, double b)
        {
            return Divide(a, b, new double[a.Length]);
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this int[] a, double[] b)
        {
            return Divide(a, b, new double[a.Length]);
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[][] a, double[][] b)
        {
            return Divide(a, b, JaggedCreateAs<int, double>(a));
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[,] a, double[,] b)
        {
            return Divide(a, b, MatrixCreateAs<int, double>(a));
        }     
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[][] a, double[,] b)
        {
            return Divide(a, b, JaggedCreateAs<int, double>(a));
        }      
*/
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int a, double[,] b)
        {
            return Divide(a, b, MatrixCreateAs<double, double>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int a, double[][] b)
        {
            return Divide(a, b, JaggedCreateAs<double, double>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this int a, double[] b)
        {
            return Divide(a, b, new double[b.Length]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[,] a,  double[] b, int dimension)
        {
            return Divide(a, b, dimension, MatrixCreateAs<int, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[][] a,  double[] b, int dimension)
        {
            return Divide(a, b, dimension, JaggedCreateAs<int, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this int a, double[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this int a, double[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this int[] a, double[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this int[] a, double[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int[,] a, double b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int[][] a, double b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int[,] a, double[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int[][] a, double[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[,] a, byte b)
        {
            return Divide(a, b, new int[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[][] a, byte b)
        {
            return Divide(a, b, JaggedCreateAs<int, int>(a));
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static int[] Divide(this int[] a, byte b)
        {
            return Divide(a, b, new int[a.Length]);
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this int[] a, byte[] b)
        {
            return Divide(a, b, new int[a.Length]);
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[][] a, byte[][] b)
        {
            return Divide(a, b, JaggedCreateAs<int, int>(a));
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[,] a, byte[,] b)
        {
            return Divide(a, b, MatrixCreateAs<int, int>(a));
        }     
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[][] a, byte[,] b)
        {
            return Divide(a, b, JaggedCreateAs<int, int>(a));
        }      
*/
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int a, byte[,] b)
        {
            return Divide(a, b, MatrixCreateAs<byte, int>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int a, byte[][] b)
        {
            return Divide(a, b, JaggedCreateAs<byte, int>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this int a, byte[] b)
        {
            return Divide(a, b, new int[b.Length]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[,] a,  byte[] b, int dimension)
        {
            return Divide(a, b, dimension, MatrixCreateAs<int, int>(a));
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[][] a,  byte[] b, int dimension)
        {
            return Divide(a, b, dimension, JaggedCreateAs<int, int>(a));
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this int a, byte[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this int a, byte[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this int[] a, byte[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this int[] a, byte[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int[,] a, byte b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int[][] a, byte b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int[,] a, byte[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int[][] a, byte[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[,] a, decimal b)
        {
            return Divide(a, b, new int[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[][] a, decimal b)
        {
            return Divide(a, b, JaggedCreateAs<int, int>(a));
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static int[] Divide(this int[] a, decimal b)
        {
            return Divide(a, b, new int[a.Length]);
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this int[] a, decimal[] b)
        {
            return Divide(a, b, new int[a.Length]);
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[][] a, decimal[][] b)
        {
            return Divide(a, b, JaggedCreateAs<int, int>(a));
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[,] a, decimal[,] b)
        {
            return Divide(a, b, MatrixCreateAs<int, int>(a));
        }     
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[][] a, decimal[,] b)
        {
            return Divide(a, b, JaggedCreateAs<int, int>(a));
        }      
*/
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int a, decimal[,] b)
        {
            return Divide(a, b, MatrixCreateAs<decimal, int>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int a, decimal[][] b)
        {
            return Divide(a, b, JaggedCreateAs<decimal, int>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this int a, decimal[] b)
        {
            return Divide(a, b, new int[b.Length]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[,] a,  decimal[] b, int dimension)
        {
            return Divide(a, b, dimension, MatrixCreateAs<int, int>(a));
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[][] a,  decimal[] b, int dimension)
        {
            return Divide(a, b, dimension, JaggedCreateAs<int, int>(a));
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this int a, decimal[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this int a, decimal[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this int[] a, decimal[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this int[] a, decimal[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int[,] a, decimal b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int[][] a, decimal b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int[,] a, decimal[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int[][] a, decimal[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a, int b)
        {
            return Divide(a, b, new float[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a, int b)
        {
            return Divide(a, b, JaggedCreateAs<float, float>(a));
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static float[] Divide(this float[] a, int b)
        {
            return Divide(a, b, new float[a.Length]);
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this float[] a, int[] b)
        {
            return Divide(a, b, new float[a.Length]);
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a, int[][] b)
        {
            return Divide(a, b, JaggedCreateAs<float, float>(a));
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a, int[,] b)
        {
            return Divide(a, b, MatrixCreateAs<float, float>(a));
        }     
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a, int[,] b)
        {
            return Divide(a, b, JaggedCreateAs<float, float>(a));
        }      
*/
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float a, int[,] b)
        {
            return Divide(a, b, MatrixCreateAs<int, float>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float a, int[][] b)
        {
            return Divide(a, b, JaggedCreateAs<int, float>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this float a, int[] b)
        {
            return Divide(a, b, new float[b.Length]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a,  int[] b, int dimension)
        {
            return Divide(a, b, dimension, MatrixCreateAs<float, float>(a));
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a,  int[] b, int dimension)
        {
            return Divide(a, b, dimension, JaggedCreateAs<float, float>(a));
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this float a, int[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this float a, int[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this float[] a, int[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this float[] a, int[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float[,] a, int b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float[][] a, int b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float[,] a, int[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float[][] a, int[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a, float b)
        {
            return Divide(a, b, new float[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a, float b)
        {
            return Divide(a, b, JaggedCreateAs<float, float>(a));
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static float[] Divide(this float[] a, float b)
        {
            return Divide(a, b, new float[a.Length]);
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this float[] a, float[] b)
        {
            return Divide(a, b, new float[a.Length]);
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a, float[][] b)
        {
            return Divide(a, b, JaggedCreateAs<float, float>(a));
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a, float[,] b)
        {
            return Divide(a, b, MatrixCreateAs<float, float>(a));
        }     
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a, float[,] b)
        {
            return Divide(a, b, JaggedCreateAs<float, float>(a));
        }      
*/
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float a, float[,] b)
        {
            return Divide(a, b, MatrixCreateAs<float, float>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float a, float[][] b)
        {
            return Divide(a, b, JaggedCreateAs<float, float>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this float a, float[] b)
        {
            return Divide(a, b, new float[b.Length]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a,  float[] b, int dimension)
        {
            return Divide(a, b, dimension, MatrixCreateAs<float, float>(a));
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a,  float[] b, int dimension)
        {
            return Divide(a, b, dimension, JaggedCreateAs<float, float>(a));
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float a, float[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float a, float[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float[] a, float[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float[] a, float[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float[,] a, float b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float[][] a, float b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float[,] a, float[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float[][] a, float[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[,] a, double b)
        {
            return Divide(a, b, new double[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[][] a, double b)
        {
            return Divide(a, b, JaggedCreateAs<float, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static double[] Divide(this float[] a, double b)
        {
            return Divide(a, b, new double[a.Length]);
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this float[] a, double[] b)
        {
            return Divide(a, b, new double[a.Length]);
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[][] a, double[][] b)
        {
            return Divide(a, b, JaggedCreateAs<float, double>(a));
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[,] a, double[,] b)
        {
            return Divide(a, b, MatrixCreateAs<float, double>(a));
        }     
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[][] a, double[,] b)
        {
            return Divide(a, b, JaggedCreateAs<float, double>(a));
        }      
*/
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float a, double[,] b)
        {
            return Divide(a, b, MatrixCreateAs<double, double>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float a, double[][] b)
        {
            return Divide(a, b, JaggedCreateAs<double, double>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this float a, double[] b)
        {
            return Divide(a, b, new double[b.Length]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[,] a,  double[] b, int dimension)
        {
            return Divide(a, b, dimension, MatrixCreateAs<float, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[][] a,  double[] b, int dimension)
        {
            return Divide(a, b, dimension, JaggedCreateAs<float, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this float a, double[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this float a, double[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this float[] a, double[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this float[] a, double[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float[,] a, double b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float[][] a, double b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float[,] a, double[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float[][] a, double[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a, byte b)
        {
            return Divide(a, b, new float[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a, byte b)
        {
            return Divide(a, b, JaggedCreateAs<float, float>(a));
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static float[] Divide(this float[] a, byte b)
        {
            return Divide(a, b, new float[a.Length]);
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this float[] a, byte[] b)
        {
            return Divide(a, b, new float[a.Length]);
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a, byte[][] b)
        {
            return Divide(a, b, JaggedCreateAs<float, float>(a));
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a, byte[,] b)
        {
            return Divide(a, b, MatrixCreateAs<float, float>(a));
        }     
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a, byte[,] b)
        {
            return Divide(a, b, JaggedCreateAs<float, float>(a));
        }      
*/
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float a, byte[,] b)
        {
            return Divide(a, b, MatrixCreateAs<byte, float>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float a, byte[][] b)
        {
            return Divide(a, b, JaggedCreateAs<byte, float>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this float a, byte[] b)
        {
            return Divide(a, b, new float[b.Length]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a,  byte[] b, int dimension)
        {
            return Divide(a, b, dimension, MatrixCreateAs<float, float>(a));
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a,  byte[] b, int dimension)
        {
            return Divide(a, b, dimension, JaggedCreateAs<float, float>(a));
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this float a, byte[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this float a, byte[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this float[] a, byte[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this float[] a, byte[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float[,] a, byte b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float[][] a, byte b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float[,] a, byte[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float[][] a, byte[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a, decimal b)
        {
            return Divide(a, b, new float[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a, decimal b)
        {
            return Divide(a, b, JaggedCreateAs<float, float>(a));
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static float[] Divide(this float[] a, decimal b)
        {
            return Divide(a, b, new float[a.Length]);
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this float[] a, decimal[] b)
        {
            return Divide(a, b, new float[a.Length]);
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a, decimal[][] b)
        {
            return Divide(a, b, JaggedCreateAs<float, float>(a));
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a, decimal[,] b)
        {
            return Divide(a, b, MatrixCreateAs<float, float>(a));
        }     
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a, decimal[,] b)
        {
            return Divide(a, b, JaggedCreateAs<float, float>(a));
        }      
*/
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float a, decimal[,] b)
        {
            return Divide(a, b, MatrixCreateAs<decimal, float>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float a, decimal[][] b)
        {
            return Divide(a, b, JaggedCreateAs<decimal, float>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this float a, decimal[] b)
        {
            return Divide(a, b, new float[b.Length]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a,  decimal[] b, int dimension)
        {
            return Divide(a, b, dimension, MatrixCreateAs<float, float>(a));
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a,  decimal[] b, int dimension)
        {
            return Divide(a, b, dimension, JaggedCreateAs<float, float>(a));
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this float a, decimal[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this float a, decimal[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this float[] a, decimal[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this float[] a, decimal[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float[,] a, decimal b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float[][] a, decimal b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float[,] a, decimal[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float[][] a, decimal[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a, int b)
        {
            return Divide(a, b, new double[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, int b)
        {
            return Divide(a, b, JaggedCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static double[] Divide(this double[] a, int b)
        {
            return Divide(a, b, new double[a.Length]);
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this double[] a, int[] b)
        {
            return Divide(a, b, new double[a.Length]);
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, int[][] b)
        {
            return Divide(a, b, JaggedCreateAs<double, double>(a));
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a, int[,] b)
        {
            return Divide(a, b, MatrixCreateAs<double, double>(a));
        }     
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, int[,] b)
        {
            return Divide(a, b, JaggedCreateAs<double, double>(a));
        }      
*/
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double a, int[,] b)
        {
            return Divide(a, b, MatrixCreateAs<int, double>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double a, int[][] b)
        {
            return Divide(a, b, JaggedCreateAs<int, double>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this double a, int[] b)
        {
            return Divide(a, b, new double[b.Length]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a,  int[] b, int dimension)
        {
            return Divide(a, b, dimension, MatrixCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a,  int[] b, int dimension)
        {
            return Divide(a, b, dimension, JaggedCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this double a, int[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this double a, int[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this double[] a, int[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this double[] a, int[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double[,] a, int b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double[][] a, int b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double[,] a, int[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double[][] a, int[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a, float b)
        {
            return Divide(a, b, new double[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, float b)
        {
            return Divide(a, b, JaggedCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static double[] Divide(this double[] a, float b)
        {
            return Divide(a, b, new double[a.Length]);
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this double[] a, float[] b)
        {
            return Divide(a, b, new double[a.Length]);
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, float[][] b)
        {
            return Divide(a, b, JaggedCreateAs<double, double>(a));
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a, float[,] b)
        {
            return Divide(a, b, MatrixCreateAs<double, double>(a));
        }     
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, float[,] b)
        {
            return Divide(a, b, JaggedCreateAs<double, double>(a));
        }      
*/
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double a, float[,] b)
        {
            return Divide(a, b, MatrixCreateAs<float, double>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double a, float[][] b)
        {
            return Divide(a, b, JaggedCreateAs<float, double>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this double a, float[] b)
        {
            return Divide(a, b, new double[b.Length]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a,  float[] b, int dimension)
        {
            return Divide(a, b, dimension, MatrixCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a,  float[] b, int dimension)
        {
            return Divide(a, b, dimension, JaggedCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this double a, float[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this double a, float[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this double[] a, float[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this double[] a, float[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double[,] a, float b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double[][] a, float b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double[,] a, float[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double[][] a, float[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a, double b)
        {
            return Divide(a, b, new double[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, double b)
        {
            return Divide(a, b, JaggedCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static double[] Divide(this double[] a, double b)
        {
            return Divide(a, b, new double[a.Length]);
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this double[] a, double[] b)
        {
            return Divide(a, b, new double[a.Length]);
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, double[][] b)
        {
            return Divide(a, b, JaggedCreateAs<double, double>(a));
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a, double[,] b)
        {
            return Divide(a, b, MatrixCreateAs<double, double>(a));
        }     
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, double[,] b)
        {
            return Divide(a, b, JaggedCreateAs<double, double>(a));
        }      
*/
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double a, double[,] b)
        {
            return Divide(a, b, MatrixCreateAs<double, double>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double a, double[][] b)
        {
            return Divide(a, b, JaggedCreateAs<double, double>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this double a, double[] b)
        {
            return Divide(a, b, new double[b.Length]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a,  double[] b, int dimension)
        {
            return Divide(a, b, dimension, MatrixCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a,  double[] b, int dimension)
        {
            return Divide(a, b, dimension, JaggedCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double a, double[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double a, double[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double[] a, double[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double[] a, double[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double[,] a, double b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double[][] a, double b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double[,] a, double[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double[][] a, double[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a, byte b)
        {
            return Divide(a, b, new double[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, byte b)
        {
            return Divide(a, b, JaggedCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static double[] Divide(this double[] a, byte b)
        {
            return Divide(a, b, new double[a.Length]);
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this double[] a, byte[] b)
        {
            return Divide(a, b, new double[a.Length]);
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, byte[][] b)
        {
            return Divide(a, b, JaggedCreateAs<double, double>(a));
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a, byte[,] b)
        {
            return Divide(a, b, MatrixCreateAs<double, double>(a));
        }     
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, byte[,] b)
        {
            return Divide(a, b, JaggedCreateAs<double, double>(a));
        }      
*/
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double a, byte[,] b)
        {
            return Divide(a, b, MatrixCreateAs<byte, double>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double a, byte[][] b)
        {
            return Divide(a, b, JaggedCreateAs<byte, double>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this double a, byte[] b)
        {
            return Divide(a, b, new double[b.Length]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a,  byte[] b, int dimension)
        {
            return Divide(a, b, dimension, MatrixCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a,  byte[] b, int dimension)
        {
            return Divide(a, b, dimension, JaggedCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this double a, byte[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this double a, byte[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this double[] a, byte[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this double[] a, byte[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double[,] a, byte b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double[][] a, byte b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double[,] a, byte[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double[][] a, byte[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a, decimal b)
        {
            return Divide(a, b, new double[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, decimal b)
        {
            return Divide(a, b, JaggedCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static double[] Divide(this double[] a, decimal b)
        {
            return Divide(a, b, new double[a.Length]);
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this double[] a, decimal[] b)
        {
            return Divide(a, b, new double[a.Length]);
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, decimal[][] b)
        {
            return Divide(a, b, JaggedCreateAs<double, double>(a));
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a, decimal[,] b)
        {
            return Divide(a, b, MatrixCreateAs<double, double>(a));
        }     
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, decimal[,] b)
        {
            return Divide(a, b, JaggedCreateAs<double, double>(a));
        }      
*/
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double a, decimal[,] b)
        {
            return Divide(a, b, MatrixCreateAs<decimal, double>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double a, decimal[][] b)
        {
            return Divide(a, b, JaggedCreateAs<decimal, double>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this double a, decimal[] b)
        {
            return Divide(a, b, new double[b.Length]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a,  decimal[] b, int dimension)
        {
            return Divide(a, b, dimension, MatrixCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a,  decimal[] b, int dimension)
        {
            return Divide(a, b, dimension, JaggedCreateAs<double, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this double a, decimal[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this double a, decimal[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this double[] a, decimal[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this double[] a, decimal[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double[,] a, decimal b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double[][] a, decimal b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double[,] a, decimal[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double[][] a, decimal[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this byte[,] a, int b)
        {
            return Divide(a, b, new int[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this byte[][] a, int b)
        {
            return Divide(a, b, JaggedCreateAs<byte, int>(a));
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static int[] Divide(this byte[] a, int b)
        {
            return Divide(a, b, new int[a.Length]);
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this byte[] a, int[] b)
        {
            return Divide(a, b, new int[a.Length]);
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this byte[][] a, int[][] b)
        {
            return Divide(a, b, JaggedCreateAs<byte, int>(a));
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this byte[,] a, int[,] b)
        {
            return Divide(a, b, MatrixCreateAs<byte, int>(a));
        }     
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this byte[][] a, int[,] b)
        {
            return Divide(a, b, JaggedCreateAs<byte, int>(a));
        }      
*/
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this byte a, int[,] b)
        {
            return Divide(a, b, MatrixCreateAs<int, int>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this byte a, int[][] b)
        {
            return Divide(a, b, JaggedCreateAs<int, int>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this byte a, int[] b)
        {
            return Divide(a, b, new int[b.Length]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this byte[,] a,  int[] b, int dimension)
        {
            return Divide(a, b, dimension, MatrixCreateAs<byte, int>(a));
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this byte[][] a,  int[] b, int dimension)
        {
            return Divide(a, b, dimension, JaggedCreateAs<byte, int>(a));
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this byte a, int[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this byte a, int[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this byte[] a, int[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this byte[] a, int[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte[,] a, int b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte[][] a, int b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte[,] a, int[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte[][] a, int[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this byte[,] a, float b)
        {
            return Divide(a, b, new float[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this byte[][] a, float b)
        {
            return Divide(a, b, JaggedCreateAs<byte, float>(a));
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static float[] Divide(this byte[] a, float b)
        {
            return Divide(a, b, new float[a.Length]);
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this byte[] a, float[] b)
        {
            return Divide(a, b, new float[a.Length]);
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this byte[][] a, float[][] b)
        {
            return Divide(a, b, JaggedCreateAs<byte, float>(a));
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this byte[,] a, float[,] b)
        {
            return Divide(a, b, MatrixCreateAs<byte, float>(a));
        }     
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this byte[][] a, float[,] b)
        {
            return Divide(a, b, JaggedCreateAs<byte, float>(a));
        }      
*/
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this byte a, float[,] b)
        {
            return Divide(a, b, MatrixCreateAs<float, float>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this byte a, float[][] b)
        {
            return Divide(a, b, JaggedCreateAs<float, float>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this byte a, float[] b)
        {
            return Divide(a, b, new float[b.Length]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this byte[,] a,  float[] b, int dimension)
        {
            return Divide(a, b, dimension, MatrixCreateAs<byte, float>(a));
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this byte[][] a,  float[] b, int dimension)
        {
            return Divide(a, b, dimension, JaggedCreateAs<byte, float>(a));
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this byte a, float[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this byte a, float[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this byte[] a, float[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this byte[] a, float[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte[,] a, float b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte[][] a, float b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte[,] a, float[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte[][] a, float[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[,] a, double b)
        {
            return Divide(a, b, new double[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[][] a, double b)
        {
            return Divide(a, b, JaggedCreateAs<byte, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static double[] Divide(this byte[] a, double b)
        {
            return Divide(a, b, new double[a.Length]);
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this byte[] a, double[] b)
        {
            return Divide(a, b, new double[a.Length]);
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[][] a, double[][] b)
        {
            return Divide(a, b, JaggedCreateAs<byte, double>(a));
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[,] a, double[,] b)
        {
            return Divide(a, b, MatrixCreateAs<byte, double>(a));
        }     
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[][] a, double[,] b)
        {
            return Divide(a, b, JaggedCreateAs<byte, double>(a));
        }      
*/
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte a, double[,] b)
        {
            return Divide(a, b, MatrixCreateAs<double, double>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte a, double[][] b)
        {
            return Divide(a, b, JaggedCreateAs<double, double>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this byte a, double[] b)
        {
            return Divide(a, b, new double[b.Length]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[,] a,  double[] b, int dimension)
        {
            return Divide(a, b, dimension, MatrixCreateAs<byte, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[][] a,  double[] b, int dimension)
        {
            return Divide(a, b, dimension, JaggedCreateAs<byte, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this byte a, double[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this byte a, double[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this byte[] a, double[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this byte[] a, double[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte[,] a, double b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte[][] a, double b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte[,] a, double[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte[][] a, double[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[,] a, byte b)
        {
            return Divide(a, b, new byte[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[][] a, byte b)
        {
            return Divide(a, b, JaggedCreateAs<byte, byte>(a));
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static byte[] Divide(this byte[] a, byte b)
        {
            return Divide(a, b, new byte[a.Length]);
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Divide(this byte[] a, byte[] b)
        {
            return Divide(a, b, new byte[a.Length]);
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[][] a, byte[][] b)
        {
            return Divide(a, b, JaggedCreateAs<byte, byte>(a));
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[,] a, byte[,] b)
        {
            return Divide(a, b, MatrixCreateAs<byte, byte>(a));
        }     
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[][] a, byte[,] b)
        {
            return Divide(a, b, JaggedCreateAs<byte, byte>(a));
        }      
*/
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte a, byte[,] b)
        {
            return Divide(a, b, MatrixCreateAs<byte, byte>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte a, byte[][] b)
        {
            return Divide(a, b, JaggedCreateAs<byte, byte>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Divide(this byte a, byte[] b)
        {
            return Divide(a, b, new byte[b.Length]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[,] a,  byte[] b, int dimension)
        {
            return Divide(a, b, dimension, MatrixCreateAs<byte, byte>(a));
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[][] a,  byte[] b, int dimension)
        {
            return Divide(a, b, dimension, JaggedCreateAs<byte, byte>(a));
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte a, byte[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte a, byte[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte[] a, byte[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte[] a, byte[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte[,] a, byte b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte[][] a, byte b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte[,] a, byte[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte[][] a, byte[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this decimal[,] a, int b)
        {
            return Divide(a, b, new int[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this decimal[][] a, int b)
        {
            return Divide(a, b, JaggedCreateAs<decimal, int>(a));
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static int[] Divide(this decimal[] a, int b)
        {
            return Divide(a, b, new int[a.Length]);
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this decimal[] a, int[] b)
        {
            return Divide(a, b, new int[a.Length]);
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this decimal[][] a, int[][] b)
        {
            return Divide(a, b, JaggedCreateAs<decimal, int>(a));
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this decimal[,] a, int[,] b)
        {
            return Divide(a, b, MatrixCreateAs<decimal, int>(a));
        }     
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this decimal[][] a, int[,] b)
        {
            return Divide(a, b, JaggedCreateAs<decimal, int>(a));
        }      
*/
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this decimal a, int[,] b)
        {
            return Divide(a, b, MatrixCreateAs<int, int>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this decimal a, int[][] b)
        {
            return Divide(a, b, JaggedCreateAs<int, int>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this decimal a, int[] b)
        {
            return Divide(a, b, new int[b.Length]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this decimal[,] a,  int[] b, int dimension)
        {
            return Divide(a, b, dimension, MatrixCreateAs<decimal, int>(a));
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this decimal[][] a,  int[] b, int dimension)
        {
            return Divide(a, b, dimension, JaggedCreateAs<decimal, int>(a));
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this decimal a, int[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this decimal a, int[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this decimal[] a, int[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this decimal[] a, int[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal[,] a, int b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal[][] a, int b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal[,] a, int[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal[][] a, int[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this decimal[,] a, float b)
        {
            return Divide(a, b, new float[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this decimal[][] a, float b)
        {
            return Divide(a, b, JaggedCreateAs<decimal, float>(a));
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static float[] Divide(this decimal[] a, float b)
        {
            return Divide(a, b, new float[a.Length]);
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this decimal[] a, float[] b)
        {
            return Divide(a, b, new float[a.Length]);
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this decimal[][] a, float[][] b)
        {
            return Divide(a, b, JaggedCreateAs<decimal, float>(a));
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this decimal[,] a, float[,] b)
        {
            return Divide(a, b, MatrixCreateAs<decimal, float>(a));
        }     
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this decimal[][] a, float[,] b)
        {
            return Divide(a, b, JaggedCreateAs<decimal, float>(a));
        }      
*/
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this decimal a, float[,] b)
        {
            return Divide(a, b, MatrixCreateAs<float, float>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this decimal a, float[][] b)
        {
            return Divide(a, b, JaggedCreateAs<float, float>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this decimal a, float[] b)
        {
            return Divide(a, b, new float[b.Length]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this decimal[,] a,  float[] b, int dimension)
        {
            return Divide(a, b, dimension, MatrixCreateAs<decimal, float>(a));
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this decimal[][] a,  float[] b, int dimension)
        {
            return Divide(a, b, dimension, JaggedCreateAs<decimal, float>(a));
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this decimal a, float[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this decimal a, float[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this decimal[] a, float[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this decimal[] a, float[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal[,] a, float b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal[][] a, float b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal[,] a, float[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal[][] a, float[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[,] a, double b)
        {
            return Divide(a, b, new double[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[][] a, double b)
        {
            return Divide(a, b, JaggedCreateAs<decimal, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static double[] Divide(this decimal[] a, double b)
        {
            return Divide(a, b, new double[a.Length]);
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this decimal[] a, double[] b)
        {
            return Divide(a, b, new double[a.Length]);
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[][] a, double[][] b)
        {
            return Divide(a, b, JaggedCreateAs<decimal, double>(a));
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[,] a, double[,] b)
        {
            return Divide(a, b, MatrixCreateAs<decimal, double>(a));
        }     
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[][] a, double[,] b)
        {
            return Divide(a, b, JaggedCreateAs<decimal, double>(a));
        }      
*/
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal a, double[,] b)
        {
            return Divide(a, b, MatrixCreateAs<double, double>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal a, double[][] b)
        {
            return Divide(a, b, JaggedCreateAs<double, double>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this decimal a, double[] b)
        {
            return Divide(a, b, new double[b.Length]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[,] a,  double[] b, int dimension)
        {
            return Divide(a, b, dimension, MatrixCreateAs<decimal, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[][] a,  double[] b, int dimension)
        {
            return Divide(a, b, dimension, JaggedCreateAs<decimal, double>(a));
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this decimal a, double[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this decimal a, double[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this decimal[] a, double[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this decimal[] a, double[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal[,] a, double b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal[][] a, double b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal[,] a, double[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal[][] a, double[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }
 

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[,] a, decimal b)
        {
            return Divide(a, b, new decimal[a.GetLength(0), a.GetLength(1)]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[][] a, decimal b)
        {
            return Divide(a, b, JaggedCreateAs<decimal, decimal>(a));
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// 
        public static decimal[] Divide(this decimal[] a, decimal b)
        {
            return Divide(a, b, new decimal[a.Length]);
        }

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Divide(this decimal[] a, decimal[] b)
        {
            return Divide(a, b, new decimal[a.Length]);
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[][] a, decimal[][] b)
        {
            return Divide(a, b, JaggedCreateAs<decimal, decimal>(a));
        }     

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[,] a, decimal[,] b)
        {
            return Divide(a, b, MatrixCreateAs<decimal, decimal>(a));
        }     
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[][] a, decimal[,] b)
        {
            return Divide(a, b, JaggedCreateAs<decimal, decimal>(a));
        }      
*/
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal a, decimal[,] b)
        {
            return Divide(a, b, MatrixCreateAs<decimal, decimal>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal a, decimal[][] b)
        {
            return Divide(a, b, JaggedCreateAs<decimal, decimal>(b));
        }     

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Divide(this decimal a, decimal[] b)
        {
            return Divide(a, b, new decimal[b.Length]);
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[,] a,  decimal[] b, int dimension)
        {
            return Divide(a, b, dimension, MatrixCreateAs<decimal, decimal>(a));
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[][] a,  decimal[] b, int dimension)
        {
            return Divide(a, b, dimension, JaggedCreateAs<decimal, decimal>(a));
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal a, decimal[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal a, decimal[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal[] a, decimal[,] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal[] a, decimal[][] b)
        {
            return DivideByDiagonal(a, b, b.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal[,] a, decimal b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal[][] a, decimal b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal[,] a, decimal[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and to the main diagonal of matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal[][] a, decimal[] b)
        {
            return DivideByDiagonal(a, b, a.MemberwiseClone());
        }
 

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[][] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (int)((int)a[i][j] / (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[,] a, int[][] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (int)((int)(*pa) / (int)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[,] a, int[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (int* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (int)((int)(*pa) / (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[][] a, int[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)(a[i][j]) / (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[,] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (int)((int)(*pa) / (int)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[][] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (int)((int)(a[i][j]) / (int)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[,] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (int* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (int)((int)(*pa) / (int)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[,] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) /  (int)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[][] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (int)((int)a[i][j] / (int)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[][] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] / (int)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int a, int[,] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)a /  (int)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (int)((int)a / (int)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int a, int[][] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (int)((int)a / (int)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (int)((int)a / (int)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[,] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (int)((int)(*pa) / (int)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[,] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) /  (int)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[][] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] / (int)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this int[] a, int[] b, int[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] / (int)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this int[] a, int b, int[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] / (int)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this int a, int[] b, int[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (int)((int)a / (int)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[,] a,  int[] b, int dimension, int[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] / (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] / (int)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[][] a,  int[] b, int dimension, int[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] / (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] / (int)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a / (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a / (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int[] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a[j] / (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int[] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i] / (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int[,] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) / (int)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int[][] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (int)((int)a[i][i] / (int)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int[,] a, int[] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) / (int)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int[][] a, int[] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i][i] / (int)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[][] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[,] a, int[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[,] a, int[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (int* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[][] a, int[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[,] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[][] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) / (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[,] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (int* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[,] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[][] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[][] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int a, int[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a /  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a / (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int a, int[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a / (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[,] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[,] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[][] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this int[] a, int[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this int[] a, int b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this int a, int[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a / (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[,] a,  int[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[][] a,  int[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this int a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this int a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this int[] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this int[] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this int[,] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this int[][] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this int[,] a, int[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this int[][] a, int[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[][] a, float[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (int)((int)a[i][j] / (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[,] a, float[][] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (int)((int)(*pa) / (int)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[,] a, float[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (float* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (int)((int)(*pa) / (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[][] a, float[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)(a[i][j]) / (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[,] a, float[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (int)((int)(*pa) / (int)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[][] a, float[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (int)((int)(a[i][j]) / (int)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[,] a, float[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (float* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (int)((int)(*pa) / (int)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[,] a, float b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) /  (int)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[][] a, float b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (int)((int)a[i][j] / (int)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[][] a, float b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] / (int)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int a, float[,] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)a /  (int)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int a, float[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (int)((int)a / (int)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int a, float[][] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (int)((int)a / (int)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int a, float[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (int)((int)a / (int)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[,] a, float b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (int)((int)(*pa) / (int)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[,] a, float b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) /  (int)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[][] a, float b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] / (int)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this int[] a, float[] b, int[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] / (int)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this int[] a, float b, int[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] / (int)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this int a, float[] b, int[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (int)((int)a / (int)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[,] a,  float[] b, int dimension, int[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] / (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] / (int)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[][] a,  float[] b, int dimension, int[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] / (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] / (int)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int a, float[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a / (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int a, float[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a / (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int[] a, float[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a[j] / (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int[] a, float[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i] / (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int[,] a, float b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) / (int)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int[][] a, float b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (int)((int)a[i][i] / (int)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int[,] a, float[] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) / (int)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int[][] a, float[] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i][i] / (int)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this int[][] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (float)((float)a[i][j] / (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this int[,] a, float[][] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (float)((float)(*pa) / (float)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this int[,] a, float[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (float* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (float)((float)(*pa) / (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this int[][] a, float[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)(a[i][j]) / (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this int[,] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (float)((float)(*pa) / (float)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this int[][] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (float)((float)(a[i][j]) / (float)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this int[,] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (float* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (float)((float)(*pa) / (float)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this int[,] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) /  (float)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this int[][] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (float)((float)a[i][j] / (float)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this int[][] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] / (float)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this int a, float[,] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)a /  (float)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this int a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (float)((float)a / (float)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this int a, float[][] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (float)((float)a / (float)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this int a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (float)((float)a / (float)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this int[,] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (float)((float)(*pa) / (float)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this int[,] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) /  (float)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this int[][] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] / (float)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this int[] a, float[] b, float[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] / (float)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this int[] a, float b, float[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] / (float)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this int a, float[] b, float[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (float)((float)a / (float)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this int[,] a,  float[] b, int dimension, float[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] / (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] / (float)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this int[][] a,  float[] b, int dimension, float[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] / (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] / (float)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this int a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a / (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this int a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a / (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this int[] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a[j] / (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this int[] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i] / (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this int[,] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) / (float)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this int[][] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (float)((float)a[i][i] / (float)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this int[,] a, float[] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) / (float)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this int[][] a, float[] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i][i] / (float)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[][] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[,] a, float[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[,] a, float[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (float* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[][] a, float[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[,] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[][] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) / (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[,] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (float* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[,] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[][] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[][] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int a, float[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a /  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a / (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int a, float[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a / (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[,] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[,] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[][] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this int[] a, float[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this int[] a, float b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this int a, float[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a / (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[,] a,  float[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[][] a,  float[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this int a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this int a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this int[] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this int[] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this int[,] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this int[][] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this int[,] a, float[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this int[][] a, float[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[][] a, double[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (int)((int)a[i][j] / (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[,] a, double[][] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (int)((int)(*pa) / (int)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[,] a, double[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (double* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (int)((int)(*pa) / (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[][] a, double[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)(a[i][j]) / (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[,] a, double[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (int)((int)(*pa) / (int)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[][] a, double[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (int)((int)(a[i][j]) / (int)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[,] a, double[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (double* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (int)((int)(*pa) / (int)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[,] a, double b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) /  (int)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[][] a, double b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (int)((int)a[i][j] / (int)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[][] a, double b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] / (int)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int a, double[,] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)a /  (int)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int a, double[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (int)((int)a / (int)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int a, double[][] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (int)((int)a / (int)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int a, double[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (int)((int)a / (int)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[,] a, double b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (int)((int)(*pa) / (int)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[,] a, double b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) /  (int)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[][] a, double b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] / (int)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this int[] a, double[] b, int[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] / (int)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this int[] a, double b, int[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] / (int)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this int a, double[] b, int[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (int)((int)a / (int)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[,] a,  double[] b, int dimension, int[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] / (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] / (int)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[][] a,  double[] b, int dimension, int[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] / (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] / (int)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int a, double[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a / (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int a, double[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a / (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int[] a, double[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a[j] / (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int[] a, double[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i] / (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int[,] a, double b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) / (int)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int[][] a, double b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (int)((int)a[i][i] / (int)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int[,] a, double[] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) / (int)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int[][] a, double[] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i][i] / (int)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[][] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[,] a, double[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[,] a, double[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (double* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[][] a, double[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[,] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[][] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) / (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[,] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (double* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[,] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[][] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[][] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int a, double[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a /  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a / (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int a, double[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a / (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[,] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[,] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[][] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this int[] a, double[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this int[] a, double b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this int a, double[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a / (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[,] a,  double[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[][] a,  double[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this int a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this int a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this int[] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this int[] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this int[,] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this int[][] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this int[,] a, double[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this int[][] a, double[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[][] a, byte[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (int)((int)a[i][j] / (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[,] a, byte[][] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (int)((int)(*pa) / (int)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[,] a, byte[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (byte* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (int)((int)(*pa) / (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[][] a, byte[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)(a[i][j]) / (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[,] a, byte[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (int)((int)(*pa) / (int)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[][] a, byte[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (int)((int)(a[i][j]) / (int)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[,] a, byte[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (byte* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (int)((int)(*pa) / (int)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[,] a, byte b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) /  (int)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[][] a, byte b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (int)((int)a[i][j] / (int)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[][] a, byte b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] / (int)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int a, byte[,] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)a /  (int)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int a, byte[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (int)((int)a / (int)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int a, byte[][] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (int)((int)a / (int)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int a, byte[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (int)((int)a / (int)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[,] a, byte b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (int)((int)(*pa) / (int)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[,] a, byte b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) /  (int)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[][] a, byte b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] / (int)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this int[] a, byte[] b, int[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] / (int)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this int[] a, byte b, int[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] / (int)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this int a, byte[] b, int[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (int)((int)a / (int)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[,] a,  byte[] b, int dimension, int[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] / (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] / (int)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[][] a,  byte[] b, int dimension, int[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] / (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] / (int)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int a, byte[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a / (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int a, byte[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a / (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int[] a, byte[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a[j] / (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int[] a, byte[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i] / (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int[,] a, byte b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) / (int)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int[][] a, byte b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (int)((int)a[i][i] / (int)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int[,] a, byte[] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) / (int)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int[][] a, byte[] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i][i] / (int)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this int[][] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (byte)((byte)a[i][j] / (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this int[,] a, byte[][] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (byte)((byte)(*pa) / (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this int[,] a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (byte* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (byte)((byte)(*pa) / (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this int[][] a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)(a[i][j]) / (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this int[,] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (byte)((byte)(*pa) / (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this int[][] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (byte)((byte)(a[i][j]) / (byte)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this int[,] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (byte* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (byte)((byte)(*pa) / (byte)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this int[,] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) /  (byte)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this int[][] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (byte)((byte)a[i][j] / (byte)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this int[][] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] / (byte)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this int a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)a /  (byte)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this int a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (byte)((byte)a / (byte)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this int a, byte[][] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (byte)((byte)a / (byte)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this int a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (byte)((byte)a / (byte)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this int[,] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (byte)((byte)(*pa) / (byte)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this int[,] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) /  (byte)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this int[][] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] / (byte)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Divide(this int[] a, byte[] b, byte[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] / (byte)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Divide(this int[] a, byte b, byte[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] / (byte)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Divide(this int a, byte[] b, byte[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (byte)((byte)a / (byte)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this int[,] a,  byte[] b, int dimension, byte[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] / (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] / (byte)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this int[][] a,  byte[] b, int dimension, byte[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] / (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] / (byte)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this int a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a / (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this int a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a / (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this int[] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a[j] / (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this int[] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i] / (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this int[,] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) / (byte)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this int[][] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] / (byte)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this int[,] a, byte[] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) / (byte)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this int[][] a, byte[] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] / (byte)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[][] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[,] a, byte[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[,] a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (byte* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[][] a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[,] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[][] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) / (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[,] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (byte* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[,] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[][] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[][] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a /  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a / (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int a, byte[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a / (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[,] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[,] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[][] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this int[] a, byte[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this int[] a, byte b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this int a, byte[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a / (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[,] a,  byte[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[][] a,  byte[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this int a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this int a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this int[] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this int[] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this int[,] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this int[][] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this int[,] a, byte[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this int[][] a, byte[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[][] a, decimal[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (int)((int)a[i][j] / (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[,] a, decimal[][] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (int)((int)(*pa) / (int)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[,] a, decimal[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (decimal* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (int)((int)(*pa) / (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[][] a, decimal[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)(a[i][j]) / (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[,] a, decimal[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (int)((int)(*pa) / (int)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[][] a, decimal[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (int)((int)(a[i][j]) / (int)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[,] a, decimal[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (decimal* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (int)((int)(*pa) / (int)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[,] a, decimal b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) /  (int)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[][] a, decimal b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (int)((int)a[i][j] / (int)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[][] a, decimal b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] / (int)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int a, decimal[,] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)a /  (int)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int a, decimal[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (int)((int)a / (int)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int a, decimal[][] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (int)((int)a / (int)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int a, decimal[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (int)((int)a / (int)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[,] a, decimal b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (int)((int)(*pa) / (int)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[,] a, decimal b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) /  (int)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[][] a, decimal b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] / (int)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this int[] a, decimal[] b, int[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] / (int)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this int[] a, decimal b, int[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] / (int)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this int a, decimal[] b, int[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (int)((int)a / (int)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this int[,] a,  decimal[] b, int dimension, int[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] / (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] / (int)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this int[][] a,  decimal[] b, int dimension, int[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] / (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] / (int)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int a, decimal[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a / (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int a, decimal[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a / (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int[] a, decimal[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a[j] / (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int[] a, decimal[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i] / (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int[,] a, decimal b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) / (int)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int[][] a, decimal b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (int)((int)a[i][i] / (int)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this int[,] a, decimal[] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) / (int)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this int[][] a, decimal[] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i][i] / (int)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this int[][] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (decimal)((decimal)a[i][j] / (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this int[,] a, decimal[][] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (decimal)((decimal)(*pa) / (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this int[,] a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (decimal* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (decimal)((decimal)(*pa) / (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this int[][] a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)(a[i][j]) / (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this int[,] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (decimal)((decimal)(*pa) / (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this int[][] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (decimal)((decimal)(a[i][j]) / (decimal)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this int[,] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (decimal* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (decimal)((decimal)(*pa) / (decimal)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this int[,] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) /  (decimal)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this int[][] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a[i][j] / (decimal)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this int[][] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] / (decimal)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this int a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)a /  (decimal)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this int a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a / (decimal)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this int a, decimal[][] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (decimal)((decimal)a / (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this int a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (decimal)((decimal)a / (decimal)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this int[,] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (decimal)((decimal)(*pa) / (decimal)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this int[,] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) /  (decimal)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this int[][] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] / (decimal)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Divide(this int[] a, decimal[] b, decimal[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] / (decimal)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Divide(this int[] a, decimal b, decimal[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] / (decimal)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Divide(this int a, decimal[] b, decimal[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (decimal)((decimal)a / (decimal)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this int[,] a,  decimal[] b, int dimension, decimal[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] / (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] / (decimal)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this int[][] a,  decimal[] b, int dimension, decimal[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] / (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] / (decimal)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this int a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a / (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this int a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a / (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this int[] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a[j] / (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this int[] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i] / (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this int[,] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) / (decimal)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this int[][] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] / (decimal)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this int[,] a, decimal[] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) / (decimal)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this int[][] a, decimal[] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] / (decimal)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[][] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[,] a, decimal[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[,] a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (decimal* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[][] a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[,] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[][] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) / (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[,] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (decimal* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[,] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[][] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[][] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a /  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a / (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int a, decimal[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a / (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[,] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[,] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[][] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this int[] a, decimal[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this int[] a, decimal b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this int a, decimal[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a / (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this int[,] a,  decimal[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this int[][] a,  decimal[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this int a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this int a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this int[] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this int[] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this int[,] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this int[][] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this int[,] a, decimal[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this int[][] a, decimal[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[][] a, int[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (float)((float)a[i][j] / (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a, int[][] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (float)((float)(*pa) / (float)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[,] a, int[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (int* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (float)((float)(*pa) / (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a, int[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)(a[i][j]) / (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[,] a, int[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (float)((float)(*pa) / (float)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a, int[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (float)((float)(a[i][j]) / (float)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a, int[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (int* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (float)((float)(*pa) / (float)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[,] a, int b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) /  (float)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a, int b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (float)((float)a[i][j] / (float)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[][] a, int b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] / (float)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float a, int[,] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)a /  (float)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float a, int[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (float)((float)a / (float)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float a, int[][] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (float)((float)a / (float)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float a, int[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (float)((float)a / (float)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a, int b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (float)((float)(*pa) / (float)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[,] a, int b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) /  (float)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[][] a, int b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] / (float)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this float[] a, int[] b, float[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] / (float)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this float[] a, int b, float[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] / (float)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this float a, int[] b, float[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (float)((float)a / (float)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a,  int[] b, int dimension, float[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] / (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] / (float)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a,  int[] b, int dimension, float[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] / (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] / (float)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float a, int[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a / (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float a, int[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a / (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float[] a, int[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a[j] / (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float[] a, int[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i] / (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float[,] a, int b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) / (float)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float[][] a, int b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (float)((float)a[i][i] / (float)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float[,] a, int[] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) / (float)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float[][] a, int[] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i][i] / (float)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this float[][] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (int)((int)a[i][j] / (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this float[,] a, int[][] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (int)((int)(*pa) / (int)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this float[,] a, int[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (int* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (int)((int)(*pa) / (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this float[][] a, int[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)(a[i][j]) / (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this float[,] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (int)((int)(*pa) / (int)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this float[][] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (int)((int)(a[i][j]) / (int)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this float[,] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (int* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (int)((int)(*pa) / (int)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this float[,] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) /  (int)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this float[][] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (int)((int)a[i][j] / (int)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this float[][] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] / (int)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this float a, int[,] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)a /  (int)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this float a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (int)((int)a / (int)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this float a, int[][] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (int)((int)a / (int)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this float a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (int)((int)a / (int)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this float[,] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (int)((int)(*pa) / (int)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this float[,] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) /  (int)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this float[][] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] / (int)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this float[] a, int[] b, int[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] / (int)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this float[] a, int b, int[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] / (int)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this float a, int[] b, int[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (int)((int)a / (int)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this float[,] a,  int[] b, int dimension, int[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] / (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] / (int)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this float[][] a,  int[] b, int dimension, int[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] / (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] / (int)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this float a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a / (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this float a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a / (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this float[] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a[j] / (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this float[] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i] / (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this float[,] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) / (int)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this float[][] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (int)((int)a[i][i] / (int)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this float[,] a, int[] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) / (int)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this float[][] a, int[] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i][i] / (int)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[][] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[,] a, int[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[,] a, int[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (int* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[][] a, int[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[,] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[][] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) / (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[,] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (int* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[,] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[][] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[][] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float a, int[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a /  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a / (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float a, int[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a / (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[,] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[,] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[][] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this float[] a, int[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this float[] a, int b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this float a, int[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a / (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[,] a,  int[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[][] a,  int[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this float a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this float a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this float[] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this float[] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this float[,] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this float[][] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this float[,] a, int[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this float[][] a, int[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[][] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (float)((float)a[i][j] / (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a, float[][] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (float)((float)(*pa) / (float)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[,] a, float[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (float* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (float)((float)(*pa) / (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a, float[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)(a[i][j]) / (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[,] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (float)((float)(*pa) / (float)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (float)((float)(a[i][j]) / (float)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (float* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (float)((float)(*pa) / (float)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[,] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) /  (float)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (float)((float)a[i][j] / (float)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[][] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] / (float)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float a, float[,] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)a /  (float)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (float)((float)a / (float)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float a, float[][] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (float)((float)a / (float)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (float)((float)a / (float)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (float)((float)(*pa) / (float)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[,] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) /  (float)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[][] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] / (float)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this float[] a, float[] b, float[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] / (float)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this float[] a, float b, float[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] / (float)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this float a, float[] b, float[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (float)((float)a / (float)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a,  float[] b, int dimension, float[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] / (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] / (float)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a,  float[] b, int dimension, float[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] / (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] / (float)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a / (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a / (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float[] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a[j] / (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float[] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i] / (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float[,] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) / (float)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float[][] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (float)((float)a[i][i] / (float)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float[,] a, float[] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) / (float)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float[][] a, float[] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i][i] / (float)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[][] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[,] a, float[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[,] a, float[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (float* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[][] a, float[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[,] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[][] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) / (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[,] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (float* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[,] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[][] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[][] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float a, float[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a /  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a / (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float a, float[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a / (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[,] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[,] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[][] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this float[] a, float[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this float[] a, float b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this float a, float[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a / (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[,] a,  float[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[][] a,  float[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this float a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this float a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this float[] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this float[] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this float[,] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this float[][] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this float[,] a, float[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this float[][] a, float[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[][] a, double[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (float)((float)a[i][j] / (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a, double[][] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (float)((float)(*pa) / (float)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[,] a, double[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (double* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (float)((float)(*pa) / (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a, double[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)(a[i][j]) / (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[,] a, double[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (float)((float)(*pa) / (float)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a, double[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (float)((float)(a[i][j]) / (float)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a, double[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (double* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (float)((float)(*pa) / (float)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[,] a, double b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) /  (float)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a, double b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (float)((float)a[i][j] / (float)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[][] a, double b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] / (float)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float a, double[,] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)a /  (float)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float a, double[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (float)((float)a / (float)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float a, double[][] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (float)((float)a / (float)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float a, double[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (float)((float)a / (float)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a, double b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (float)((float)(*pa) / (float)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[,] a, double b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) /  (float)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[][] a, double b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] / (float)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this float[] a, double[] b, float[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] / (float)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this float[] a, double b, float[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] / (float)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this float a, double[] b, float[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (float)((float)a / (float)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a,  double[] b, int dimension, float[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] / (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] / (float)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a,  double[] b, int dimension, float[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] / (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] / (float)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float a, double[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a / (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float a, double[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a / (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float[] a, double[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a[j] / (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float[] a, double[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i] / (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float[,] a, double b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) / (float)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float[][] a, double b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (float)((float)a[i][i] / (float)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float[,] a, double[] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) / (float)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float[][] a, double[] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i][i] / (float)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[][] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[,] a, double[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[,] a, double[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (double* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[][] a, double[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[,] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[][] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) / (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[,] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (double* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[,] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[][] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[][] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float a, double[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a /  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a / (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float a, double[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a / (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[,] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[,] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[][] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this float[] a, double[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this float[] a, double b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this float a, double[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a / (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[,] a,  double[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[][] a,  double[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this float a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this float a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this float[] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this float[] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this float[,] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this float[][] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this float[,] a, double[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this float[][] a, double[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[][] a, byte[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (float)((float)a[i][j] / (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a, byte[][] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (float)((float)(*pa) / (float)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[,] a, byte[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (byte* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (float)((float)(*pa) / (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a, byte[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)(a[i][j]) / (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[,] a, byte[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (float)((float)(*pa) / (float)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a, byte[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (float)((float)(a[i][j]) / (float)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a, byte[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (byte* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (float)((float)(*pa) / (float)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[,] a, byte b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) /  (float)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a, byte b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (float)((float)a[i][j] / (float)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[][] a, byte b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] / (float)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float a, byte[,] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)a /  (float)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float a, byte[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (float)((float)a / (float)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float a, byte[][] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (float)((float)a / (float)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float a, byte[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (float)((float)a / (float)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a, byte b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (float)((float)(*pa) / (float)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[,] a, byte b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) /  (float)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[][] a, byte b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] / (float)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this float[] a, byte[] b, float[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] / (float)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this float[] a, byte b, float[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] / (float)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this float a, byte[] b, float[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (float)((float)a / (float)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a,  byte[] b, int dimension, float[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] / (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] / (float)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a,  byte[] b, int dimension, float[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] / (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] / (float)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float a, byte[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a / (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float a, byte[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a / (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float[] a, byte[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a[j] / (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float[] a, byte[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i] / (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float[,] a, byte b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) / (float)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float[][] a, byte b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (float)((float)a[i][i] / (float)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float[,] a, byte[] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) / (float)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float[][] a, byte[] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i][i] / (float)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this float[][] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (byte)((byte)a[i][j] / (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this float[,] a, byte[][] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (byte)((byte)(*pa) / (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this float[,] a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (byte* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (byte)((byte)(*pa) / (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this float[][] a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)(a[i][j]) / (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this float[,] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (byte)((byte)(*pa) / (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this float[][] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (byte)((byte)(a[i][j]) / (byte)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this float[,] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (byte* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (byte)((byte)(*pa) / (byte)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this float[,] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) /  (byte)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this float[][] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (byte)((byte)a[i][j] / (byte)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this float[][] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] / (byte)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this float a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)a /  (byte)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this float a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (byte)((byte)a / (byte)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this float a, byte[][] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (byte)((byte)a / (byte)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this float a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (byte)((byte)a / (byte)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this float[,] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (byte)((byte)(*pa) / (byte)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this float[,] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) /  (byte)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this float[][] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] / (byte)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Divide(this float[] a, byte[] b, byte[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] / (byte)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Divide(this float[] a, byte b, byte[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] / (byte)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Divide(this float a, byte[] b, byte[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (byte)((byte)a / (byte)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this float[,] a,  byte[] b, int dimension, byte[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] / (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] / (byte)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this float[][] a,  byte[] b, int dimension, byte[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] / (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] / (byte)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this float a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a / (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this float a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a / (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this float[] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a[j] / (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this float[] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i] / (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this float[,] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) / (byte)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this float[][] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] / (byte)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this float[,] a, byte[] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) / (byte)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this float[][] a, byte[] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] / (byte)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[][] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[,] a, byte[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[,] a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (byte* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[][] a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[,] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[][] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) / (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[,] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (byte* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[,] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[][] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[][] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a /  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a / (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float a, byte[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a / (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[,] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[,] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[][] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this float[] a, byte[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this float[] a, byte b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this float a, byte[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a / (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[,] a,  byte[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[][] a,  byte[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this float a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this float a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this float[] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this float[] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this float[,] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this float[][] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this float[,] a, byte[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this float[][] a, byte[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[][] a, decimal[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (float)((float)a[i][j] / (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a, decimal[][] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (float)((float)(*pa) / (float)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[,] a, decimal[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (decimal* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (float)((float)(*pa) / (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a, decimal[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)(a[i][j]) / (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[,] a, decimal[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (float)((float)(*pa) / (float)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a, decimal[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (float)((float)(a[i][j]) / (float)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a, decimal[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (decimal* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (float)((float)(*pa) / (float)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[,] a, decimal b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) /  (float)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a, decimal b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (float)((float)a[i][j] / (float)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[][] a, decimal b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] / (float)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float a, decimal[,] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)a /  (float)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float a, decimal[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (float)((float)a / (float)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float a, decimal[][] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (float)((float)a / (float)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float a, decimal[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (float)((float)a / (float)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a, decimal b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (float)((float)(*pa) / (float)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[,] a, decimal b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) /  (float)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[][] a, decimal b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] / (float)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this float[] a, decimal[] b, float[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] / (float)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this float[] a, decimal b, float[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] / (float)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this float a, decimal[] b, float[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (float)((float)a / (float)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this float[,] a,  decimal[] b, int dimension, float[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] / (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] / (float)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this float[][] a,  decimal[] b, int dimension, float[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] / (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] / (float)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float a, decimal[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a / (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float a, decimal[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a / (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float[] a, decimal[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a[j] / (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float[] a, decimal[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i] / (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float[,] a, decimal b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) / (float)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float[][] a, decimal b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (float)((float)a[i][i] / (float)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this float[,] a, decimal[] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) / (float)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this float[][] a, decimal[] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i][i] / (float)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this float[][] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (decimal)((decimal)a[i][j] / (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this float[,] a, decimal[][] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (decimal)((decimal)(*pa) / (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this float[,] a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (decimal* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (decimal)((decimal)(*pa) / (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this float[][] a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)(a[i][j]) / (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this float[,] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (decimal)((decimal)(*pa) / (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this float[][] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (decimal)((decimal)(a[i][j]) / (decimal)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this float[,] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (decimal* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (decimal)((decimal)(*pa) / (decimal)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this float[,] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) /  (decimal)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this float[][] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a[i][j] / (decimal)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this float[][] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] / (decimal)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this float a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)a /  (decimal)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this float a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a / (decimal)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this float a, decimal[][] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (decimal)((decimal)a / (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this float a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (decimal)((decimal)a / (decimal)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this float[,] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (decimal)((decimal)(*pa) / (decimal)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this float[,] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) /  (decimal)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this float[][] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] / (decimal)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Divide(this float[] a, decimal[] b, decimal[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] / (decimal)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Divide(this float[] a, decimal b, decimal[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] / (decimal)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Divide(this float a, decimal[] b, decimal[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (decimal)((decimal)a / (decimal)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this float[,] a,  decimal[] b, int dimension, decimal[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] / (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] / (decimal)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this float[][] a,  decimal[] b, int dimension, decimal[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] / (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] / (decimal)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this float a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a / (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this float a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a / (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this float[] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a[j] / (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this float[] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i] / (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this float[,] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) / (decimal)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this float[][] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] / (decimal)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this float[,] a, decimal[] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) / (decimal)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this float[][] a, decimal[] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] / (decimal)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[][] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[,] a, decimal[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[,] a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (decimal* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[][] a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[,] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[][] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) / (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[,] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (decimal* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[,] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[][] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[][] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a /  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a / (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float a, decimal[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a / (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[,] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[,] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[][] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this float[] a, decimal[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this float[] a, decimal b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this float a, decimal[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a / (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this float[,] a,  decimal[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this float[][] a,  decimal[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this float a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this float a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this float[] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this float[] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this float[,] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this float[][] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this float[,] a, decimal[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this float[][] a, decimal[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[][] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a, int[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[,] a, int[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (int* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, int[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[,] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) / (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (int* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[,] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[][] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double a, int[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a /  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a / (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double a, int[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a / (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[,] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[][] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this double[] a, int[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this double[] a, int b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this double a, int[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a / (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a,  int[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a,  int[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double[] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double[] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double[,] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double[][] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double[,] a, int[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double[][] a, int[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this double[][] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (int)((int)a[i][j] / (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this double[,] a, int[][] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (int)((int)(*pa) / (int)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this double[,] a, int[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (int* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (int)((int)(*pa) / (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this double[][] a, int[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)(a[i][j]) / (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this double[,] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (int)((int)(*pa) / (int)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this double[][] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (int)((int)(a[i][j]) / (int)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this double[,] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (int* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (int)((int)(*pa) / (int)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this double[,] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) /  (int)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this double[][] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (int)((int)a[i][j] / (int)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this double[][] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] / (int)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this double a, int[,] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)a /  (int)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this double a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (int)((int)a / (int)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this double a, int[][] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (int)((int)a / (int)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this double a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (int)((int)a / (int)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this double[,] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (int)((int)(*pa) / (int)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this double[,] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) /  (int)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this double[][] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] / (int)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this double[] a, int[] b, int[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] / (int)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this double[] a, int b, int[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] / (int)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this double a, int[] b, int[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (int)((int)a / (int)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this double[,] a,  int[] b, int dimension, int[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] / (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] / (int)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this double[][] a,  int[] b, int dimension, int[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] / (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] / (int)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this double a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a / (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this double a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a / (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this double[] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a[j] / (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this double[] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i] / (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this double[,] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) / (int)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this double[][] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (int)((int)a[i][i] / (int)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this double[,] a, int[] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) / (int)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this double[][] a, int[] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i][i] / (int)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[][] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a, float[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[,] a, float[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (float* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, float[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[,] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) / (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (float* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[,] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[][] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double a, float[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a /  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a / (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double a, float[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a / (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[,] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[][] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this double[] a, float[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this double[] a, float b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this double a, float[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a / (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a,  float[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a,  float[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double[] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double[] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double[,] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double[][] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double[,] a, float[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double[][] a, float[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this double[][] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (float)((float)a[i][j] / (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this double[,] a, float[][] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (float)((float)(*pa) / (float)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this double[,] a, float[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (float* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (float)((float)(*pa) / (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this double[][] a, float[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)(a[i][j]) / (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this double[,] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (float)((float)(*pa) / (float)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this double[][] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (float)((float)(a[i][j]) / (float)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this double[,] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (float* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (float)((float)(*pa) / (float)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this double[,] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) /  (float)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this double[][] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (float)((float)a[i][j] / (float)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this double[][] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] / (float)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this double a, float[,] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)a /  (float)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this double a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (float)((float)a / (float)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this double a, float[][] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (float)((float)a / (float)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this double a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (float)((float)a / (float)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this double[,] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (float)((float)(*pa) / (float)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this double[,] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) /  (float)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this double[][] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] / (float)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this double[] a, float[] b, float[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] / (float)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this double[] a, float b, float[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] / (float)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this double a, float[] b, float[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (float)((float)a / (float)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this double[,] a,  float[] b, int dimension, float[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] / (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] / (float)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this double[][] a,  float[] b, int dimension, float[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] / (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] / (float)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this double a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a / (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this double a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a / (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this double[] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a[j] / (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this double[] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i] / (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this double[,] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) / (float)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this double[][] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (float)((float)a[i][i] / (float)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this double[,] a, float[] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) / (float)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this double[][] a, float[] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i][i] / (float)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[][] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a, double[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[,] a, double[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (double* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, double[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[,] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) / (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (double* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[,] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[][] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double a, double[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a /  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a / (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double a, double[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a / (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[,] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[][] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this double[] a, double[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this double[] a, double b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this double a, double[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a / (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a,  double[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a,  double[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double[] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double[] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double[,] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double[][] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double[,] a, double[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double[][] a, double[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[][] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a, byte[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[,] a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (byte* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[,] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) / (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (byte* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[,] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[][] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a /  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a / (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double a, byte[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a / (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[,] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[][] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this double[] a, byte[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this double[] a, byte b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this double a, byte[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a / (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a,  byte[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a,  byte[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double[] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double[] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double[,] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double[][] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double[,] a, byte[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double[][] a, byte[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this double[][] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (byte)((byte)a[i][j] / (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this double[,] a, byte[][] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (byte)((byte)(*pa) / (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this double[,] a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (byte* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (byte)((byte)(*pa) / (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this double[][] a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)(a[i][j]) / (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this double[,] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (byte)((byte)(*pa) / (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this double[][] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (byte)((byte)(a[i][j]) / (byte)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this double[,] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (byte* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (byte)((byte)(*pa) / (byte)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this double[,] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) /  (byte)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this double[][] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (byte)((byte)a[i][j] / (byte)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this double[][] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] / (byte)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this double a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)a /  (byte)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this double a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (byte)((byte)a / (byte)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this double a, byte[][] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (byte)((byte)a / (byte)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this double a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (byte)((byte)a / (byte)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this double[,] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (byte)((byte)(*pa) / (byte)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this double[,] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) /  (byte)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this double[][] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] / (byte)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Divide(this double[] a, byte[] b, byte[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] / (byte)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Divide(this double[] a, byte b, byte[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] / (byte)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Divide(this double a, byte[] b, byte[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (byte)((byte)a / (byte)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this double[,] a,  byte[] b, int dimension, byte[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] / (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] / (byte)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this double[][] a,  byte[] b, int dimension, byte[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] / (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] / (byte)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this double a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a / (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this double a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a / (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this double[] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a[j] / (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this double[] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i] / (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this double[,] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) / (byte)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this double[][] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] / (byte)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this double[,] a, byte[] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) / (byte)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this double[][] a, byte[] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] / (byte)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[][] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a, decimal[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[,] a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (decimal* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[,] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) / (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (decimal* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[,] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[][] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a /  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a / (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double a, decimal[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a / (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[,] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[][] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this double[] a, decimal[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this double[] a, decimal b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this double a, decimal[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a / (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this double[,] a,  decimal[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this double[][] a,  decimal[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double[] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double[] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double[,] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double[][] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this double[,] a, decimal[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this double[][] a, decimal[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this double[][] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (decimal)((decimal)a[i][j] / (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this double[,] a, decimal[][] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (decimal)((decimal)(*pa) / (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this double[,] a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (decimal* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (decimal)((decimal)(*pa) / (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this double[][] a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)(a[i][j]) / (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this double[,] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (decimal)((decimal)(*pa) / (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this double[][] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (decimal)((decimal)(a[i][j]) / (decimal)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this double[,] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (decimal* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (decimal)((decimal)(*pa) / (decimal)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this double[,] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) /  (decimal)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this double[][] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a[i][j] / (decimal)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this double[][] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] / (decimal)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this double a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)a /  (decimal)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this double a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a / (decimal)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this double a, decimal[][] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (decimal)((decimal)a / (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this double a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (decimal)((decimal)a / (decimal)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this double[,] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (decimal)((decimal)(*pa) / (decimal)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this double[,] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) /  (decimal)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this double[][] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] / (decimal)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Divide(this double[] a, decimal[] b, decimal[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] / (decimal)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Divide(this double[] a, decimal b, decimal[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] / (decimal)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Divide(this double a, decimal[] b, decimal[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (decimal)((decimal)a / (decimal)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this double[,] a,  decimal[] b, int dimension, decimal[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] / (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] / (decimal)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this double[][] a,  decimal[] b, int dimension, decimal[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] / (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] / (decimal)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this double a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a / (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this double a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a / (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this double[] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a[j] / (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this double[] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i] / (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this double[,] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) / (decimal)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this double[][] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] / (decimal)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this double[,] a, decimal[] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) / (decimal)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this double[][] a, decimal[] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] / (decimal)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[][] a, int[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (byte)((byte)a[i][j] / (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[,] a, int[][] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (byte)((byte)(*pa) / (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[,] a, int[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (int* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (byte)((byte)(*pa) / (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[][] a, int[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)(a[i][j]) / (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[,] a, int[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (byte)((byte)(*pa) / (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[][] a, int[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (byte)((byte)(a[i][j]) / (byte)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[,] a, int[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (int* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (byte)((byte)(*pa) / (byte)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[,] a, int b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) /  (byte)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[][] a, int b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (byte)((byte)a[i][j] / (byte)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[][] a, int b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] / (byte)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte a, int[,] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)a /  (byte)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte a, int[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (byte)((byte)a / (byte)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte a, int[][] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (byte)((byte)a / (byte)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte a, int[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (byte)((byte)a / (byte)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[,] a, int b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (byte)((byte)(*pa) / (byte)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[,] a, int b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) /  (byte)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[][] a, int b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] / (byte)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Divide(this byte[] a, int[] b, byte[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] / (byte)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Divide(this byte[] a, int b, byte[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] / (byte)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Divide(this byte a, int[] b, byte[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (byte)((byte)a / (byte)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[,] a,  int[] b, int dimension, byte[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] / (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] / (byte)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[][] a,  int[] b, int dimension, byte[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] / (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] / (byte)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte a, int[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a / (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte a, int[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a / (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte[] a, int[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a[j] / (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte[] a, int[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i] / (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte[,] a, int b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) / (byte)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte[][] a, int b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] / (byte)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte[,] a, int[] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) / (byte)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte[][] a, int[] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] / (byte)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this byte[][] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (int)((int)a[i][j] / (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this byte[,] a, int[][] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (int)((int)(*pa) / (int)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this byte[,] a, int[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (int* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (int)((int)(*pa) / (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this byte[][] a, int[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)(a[i][j]) / (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this byte[,] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (int)((int)(*pa) / (int)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this byte[][] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (int)((int)(a[i][j]) / (int)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this byte[,] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (int* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (int)((int)(*pa) / (int)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this byte[,] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) /  (int)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this byte[][] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (int)((int)a[i][j] / (int)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this byte[][] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] / (int)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this byte a, int[,] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)a /  (int)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this byte a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (int)((int)a / (int)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this byte a, int[][] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (int)((int)a / (int)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this byte a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (int)((int)a / (int)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this byte[,] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (int)((int)(*pa) / (int)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this byte[,] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) /  (int)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this byte[][] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] / (int)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this byte[] a, int[] b, int[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] / (int)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this byte[] a, int b, int[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] / (int)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this byte a, int[] b, int[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (int)((int)a / (int)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this byte[,] a,  int[] b, int dimension, int[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] / (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] / (int)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this byte[][] a,  int[] b, int dimension, int[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] / (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] / (int)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this byte a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a / (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this byte a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a / (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this byte[] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a[j] / (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this byte[] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i] / (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this byte[,] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) / (int)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this byte[][] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (int)((int)a[i][i] / (int)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this byte[,] a, int[] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) / (int)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this byte[][] a, int[] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i][i] / (int)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[][] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[,] a, int[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[,] a, int[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (int* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[][] a, int[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[,] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[][] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) / (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[,] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (int* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[,] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[][] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[][] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte a, int[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a /  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a / (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte a, int[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a / (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[,] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[,] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[][] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this byte[] a, int[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this byte[] a, int b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this byte a, int[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a / (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[,] a,  int[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[][] a,  int[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this byte a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this byte a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this byte[] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this byte[] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this byte[,] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this byte[][] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this byte[,] a, int[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this byte[][] a, int[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[][] a, float[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (byte)((byte)a[i][j] / (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[,] a, float[][] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (byte)((byte)(*pa) / (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[,] a, float[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (float* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (byte)((byte)(*pa) / (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[][] a, float[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)(a[i][j]) / (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[,] a, float[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (byte)((byte)(*pa) / (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[][] a, float[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (byte)((byte)(a[i][j]) / (byte)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[,] a, float[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (float* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (byte)((byte)(*pa) / (byte)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[,] a, float b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) /  (byte)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[][] a, float b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (byte)((byte)a[i][j] / (byte)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[][] a, float b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] / (byte)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte a, float[,] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)a /  (byte)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte a, float[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (byte)((byte)a / (byte)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte a, float[][] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (byte)((byte)a / (byte)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte a, float[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (byte)((byte)a / (byte)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[,] a, float b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (byte)((byte)(*pa) / (byte)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[,] a, float b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) /  (byte)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[][] a, float b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] / (byte)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Divide(this byte[] a, float[] b, byte[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] / (byte)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Divide(this byte[] a, float b, byte[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] / (byte)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Divide(this byte a, float[] b, byte[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (byte)((byte)a / (byte)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[,] a,  float[] b, int dimension, byte[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] / (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] / (byte)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[][] a,  float[] b, int dimension, byte[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] / (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] / (byte)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte a, float[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a / (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte a, float[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a / (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte[] a, float[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a[j] / (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte[] a, float[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i] / (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte[,] a, float b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) / (byte)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte[][] a, float b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] / (byte)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte[,] a, float[] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) / (byte)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte[][] a, float[] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] / (byte)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this byte[][] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (float)((float)a[i][j] / (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this byte[,] a, float[][] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (float)((float)(*pa) / (float)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this byte[,] a, float[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (float* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (float)((float)(*pa) / (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this byte[][] a, float[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)(a[i][j]) / (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this byte[,] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (float)((float)(*pa) / (float)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this byte[][] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (float)((float)(a[i][j]) / (float)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this byte[,] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (float* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (float)((float)(*pa) / (float)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this byte[,] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) /  (float)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this byte[][] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (float)((float)a[i][j] / (float)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this byte[][] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] / (float)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this byte a, float[,] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)a /  (float)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this byte a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (float)((float)a / (float)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this byte a, float[][] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (float)((float)a / (float)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this byte a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (float)((float)a / (float)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this byte[,] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (float)((float)(*pa) / (float)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this byte[,] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) /  (float)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this byte[][] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] / (float)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this byte[] a, float[] b, float[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] / (float)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this byte[] a, float b, float[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] / (float)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this byte a, float[] b, float[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (float)((float)a / (float)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this byte[,] a,  float[] b, int dimension, float[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] / (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] / (float)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this byte[][] a,  float[] b, int dimension, float[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] / (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] / (float)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this byte a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a / (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this byte a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a / (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this byte[] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a[j] / (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this byte[] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i] / (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this byte[,] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) / (float)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this byte[][] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (float)((float)a[i][i] / (float)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this byte[,] a, float[] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) / (float)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this byte[][] a, float[] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i][i] / (float)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[][] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[,] a, float[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[,] a, float[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (float* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[][] a, float[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[,] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[][] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) / (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[,] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (float* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[,] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[][] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[][] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte a, float[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a /  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a / (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte a, float[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a / (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[,] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[,] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[][] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this byte[] a, float[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this byte[] a, float b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this byte a, float[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a / (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[,] a,  float[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[][] a,  float[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this byte a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this byte a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this byte[] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this byte[] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this byte[,] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this byte[][] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this byte[,] a, float[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this byte[][] a, float[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[][] a, double[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (byte)((byte)a[i][j] / (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[,] a, double[][] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (byte)((byte)(*pa) / (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[,] a, double[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (double* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (byte)((byte)(*pa) / (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[][] a, double[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)(a[i][j]) / (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[,] a, double[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (byte)((byte)(*pa) / (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[][] a, double[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (byte)((byte)(a[i][j]) / (byte)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[,] a, double[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (double* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (byte)((byte)(*pa) / (byte)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[,] a, double b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) /  (byte)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[][] a, double b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (byte)((byte)a[i][j] / (byte)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[][] a, double b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] / (byte)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte a, double[,] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)a /  (byte)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte a, double[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (byte)((byte)a / (byte)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte a, double[][] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (byte)((byte)a / (byte)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte a, double[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (byte)((byte)a / (byte)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[,] a, double b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (byte)((byte)(*pa) / (byte)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[,] a, double b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) /  (byte)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[][] a, double b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] / (byte)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Divide(this byte[] a, double[] b, byte[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] / (byte)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Divide(this byte[] a, double b, byte[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] / (byte)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Divide(this byte a, double[] b, byte[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (byte)((byte)a / (byte)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[,] a,  double[] b, int dimension, byte[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] / (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] / (byte)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[][] a,  double[] b, int dimension, byte[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] / (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] / (byte)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte a, double[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a / (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte a, double[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a / (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte[] a, double[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a[j] / (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte[] a, double[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i] / (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte[,] a, double b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) / (byte)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte[][] a, double b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] / (byte)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte[,] a, double[] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) / (byte)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte[][] a, double[] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] / (byte)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[][] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[,] a, double[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[,] a, double[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (double* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[][] a, double[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[,] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[][] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) / (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[,] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (double* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[,] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[][] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[][] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte a, double[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a /  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a / (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte a, double[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a / (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[,] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[,] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[][] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this byte[] a, double[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this byte[] a, double b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this byte a, double[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a / (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[,] a,  double[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[][] a,  double[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this byte a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this byte a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this byte[] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this byte[] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this byte[,] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this byte[][] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this byte[,] a, double[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this byte[][] a, double[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[][] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (byte)((byte)a[i][j] / (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[,] a, byte[][] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (byte)((byte)(*pa) / (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[,] a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (byte* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (byte)((byte)(*pa) / (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[][] a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)(a[i][j]) / (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[,] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (byte)((byte)(*pa) / (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[][] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (byte)((byte)(a[i][j]) / (byte)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[,] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (byte* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (byte)((byte)(*pa) / (byte)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[,] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) /  (byte)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[][] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (byte)((byte)a[i][j] / (byte)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[][] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] / (byte)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)a /  (byte)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (byte)((byte)a / (byte)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte a, byte[][] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (byte)((byte)a / (byte)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (byte)((byte)a / (byte)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[,] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (byte)((byte)(*pa) / (byte)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[,] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) /  (byte)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[][] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] / (byte)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Divide(this byte[] a, byte[] b, byte[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] / (byte)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Divide(this byte[] a, byte b, byte[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] / (byte)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Divide(this byte a, byte[] b, byte[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (byte)((byte)a / (byte)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[,] a,  byte[] b, int dimension, byte[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] / (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] / (byte)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[][] a,  byte[] b, int dimension, byte[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] / (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] / (byte)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a / (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a / (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte[] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a[j] / (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte[] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i] / (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte[,] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) / (byte)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte[][] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] / (byte)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte[,] a, byte[] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) / (byte)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte[][] a, byte[] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] / (byte)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[][] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[,] a, byte[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[,] a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (byte* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[][] a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[,] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[][] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) / (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[,] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (byte* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[,] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[][] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[][] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a /  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a / (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte a, byte[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a / (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[,] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[,] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[][] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this byte[] a, byte[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this byte[] a, byte b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this byte a, byte[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a / (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[,] a,  byte[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[][] a,  byte[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this byte a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this byte a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this byte[] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this byte[] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this byte[,] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this byte[][] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this byte[,] a, byte[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this byte[][] a, byte[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[][] a, decimal[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (byte)((byte)a[i][j] / (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[,] a, decimal[][] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (byte)((byte)(*pa) / (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[,] a, decimal[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (decimal* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (byte)((byte)(*pa) / (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[][] a, decimal[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)(a[i][j]) / (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[,] a, decimal[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (byte)((byte)(*pa) / (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[][] a, decimal[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (byte)((byte)(a[i][j]) / (byte)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[,] a, decimal[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (decimal* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (byte)((byte)(*pa) / (byte)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[,] a, decimal b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) /  (byte)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[][] a, decimal b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (byte)((byte)a[i][j] / (byte)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[][] a, decimal b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] / (byte)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte a, decimal[,] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)a /  (byte)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte a, decimal[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (byte)((byte)a / (byte)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte a, decimal[][] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (byte)((byte)a / (byte)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte a, decimal[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (byte)((byte)a / (byte)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[,] a, decimal b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (byte)((byte)(*pa) / (byte)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[,] a, decimal b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) /  (byte)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[][] a, decimal b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] / (byte)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Divide(this byte[] a, decimal[] b, byte[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] / (byte)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Divide(this byte[] a, decimal b, byte[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] / (byte)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Divide(this byte a, decimal[] b, byte[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (byte)((byte)a / (byte)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this byte[,] a,  decimal[] b, int dimension, byte[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] / (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] / (byte)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this byte[][] a,  decimal[] b, int dimension, byte[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] / (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] / (byte)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte a, decimal[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a / (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte a, decimal[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a / (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte[] a, decimal[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a[j] / (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte[] a, decimal[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i] / (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte[,] a, decimal b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) / (byte)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte[][] a, decimal b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] / (byte)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this byte[,] a, decimal[] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) / (byte)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this byte[][] a, decimal[] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] / (byte)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this byte[][] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (decimal)((decimal)a[i][j] / (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this byte[,] a, decimal[][] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (decimal)((decimal)(*pa) / (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this byte[,] a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (decimal* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (decimal)((decimal)(*pa) / (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this byte[][] a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)(a[i][j]) / (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this byte[,] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (decimal)((decimal)(*pa) / (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this byte[][] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (decimal)((decimal)(a[i][j]) / (decimal)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this byte[,] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (decimal* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (decimal)((decimal)(*pa) / (decimal)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this byte[,] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) /  (decimal)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this byte[][] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a[i][j] / (decimal)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this byte[][] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] / (decimal)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this byte a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)a /  (decimal)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this byte a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a / (decimal)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this byte a, decimal[][] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (decimal)((decimal)a / (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this byte a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (decimal)((decimal)a / (decimal)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this byte[,] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (decimal)((decimal)(*pa) / (decimal)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this byte[,] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) /  (decimal)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this byte[][] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] / (decimal)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Divide(this byte[] a, decimal[] b, decimal[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] / (decimal)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Divide(this byte[] a, decimal b, decimal[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] / (decimal)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Divide(this byte a, decimal[] b, decimal[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (decimal)((decimal)a / (decimal)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this byte[,] a,  decimal[] b, int dimension, decimal[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] / (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] / (decimal)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this byte[][] a,  decimal[] b, int dimension, decimal[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] / (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] / (decimal)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this byte a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a / (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this byte a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a / (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this byte[] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a[j] / (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this byte[] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i] / (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this byte[,] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) / (decimal)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this byte[][] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] / (decimal)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this byte[,] a, decimal[] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) / (decimal)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this byte[][] a, decimal[] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] / (decimal)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[][] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[,] a, decimal[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[,] a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (decimal* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[][] a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[,] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[][] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) / (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[,] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (decimal* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[,] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[][] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[][] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a /  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a / (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte a, decimal[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a / (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[,] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[,] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[][] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this byte[] a, decimal[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this byte[] a, decimal b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this byte a, decimal[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a / (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this byte[,] a,  decimal[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this byte[][] a,  decimal[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this byte a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this byte a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this byte[] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this byte[] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this byte[,] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this byte[][] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this byte[,] a, decimal[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this byte[][] a, decimal[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[][] a, int[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (decimal)((decimal)a[i][j] / (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[,] a, int[][] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (decimal)((decimal)(*pa) / (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[,] a, int[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (int* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (decimal)((decimal)(*pa) / (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[][] a, int[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)(a[i][j]) / (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[,] a, int[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (decimal)((decimal)(*pa) / (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[][] a, int[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (decimal)((decimal)(a[i][j]) / (decimal)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[,] a, int[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (int* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (decimal)((decimal)(*pa) / (decimal)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[,] a, int b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) /  (decimal)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[][] a, int b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a[i][j] / (decimal)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[][] a, int b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] / (decimal)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal a, int[,] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)a /  (decimal)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal a, int[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a / (decimal)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal a, int[][] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (decimal)((decimal)a / (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal a, int[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (decimal)((decimal)a / (decimal)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[,] a, int b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (decimal)((decimal)(*pa) / (decimal)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[,] a, int b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) /  (decimal)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[][] a, int b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] / (decimal)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Divide(this decimal[] a, int[] b, decimal[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] / (decimal)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Divide(this decimal[] a, int b, decimal[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] / (decimal)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Divide(this decimal a, int[] b, decimal[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (decimal)((decimal)a / (decimal)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[,] a,  int[] b, int dimension, decimal[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] / (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] / (decimal)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[][] a,  int[] b, int dimension, decimal[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] / (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] / (decimal)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal a, int[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a / (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal a, int[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a / (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal[] a, int[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a[j] / (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal[] a, int[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i] / (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal[,] a, int b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) / (decimal)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal[][] a, int b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] / (decimal)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal[,] a, int[] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) / (decimal)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal[][] a, int[] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] / (decimal)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this decimal[][] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (int)((int)a[i][j] / (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this decimal[,] a, int[][] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (int)((int)(*pa) / (int)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this decimal[,] a, int[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (int* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (int)((int)(*pa) / (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this decimal[][] a, int[,] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)(a[i][j]) / (int)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this decimal[,] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (int)((int)(*pa) / (int)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this decimal[][] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (int)((int)(a[i][j]) / (int)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this decimal[,] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (int* ptrB = b)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (int)((int)(*pa) / (int)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this decimal[,] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) /  (int)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this decimal[][] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (int)((int)a[i][j] / (int)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this decimal[][] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] / (int)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this decimal a, int[,] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (int)((int)a /  (int)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this decimal a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (int)((int)a / (int)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this decimal a, int[][] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (int)((int)a / (int)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this decimal a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (int)((int)a / (int)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this decimal[,] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (int* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (int)((int)(*pa) / (int)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this decimal[,] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (int)((int)(*pa) /  (int)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this decimal[][] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (int)((int)a[i][j] / (int)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this decimal[] a, int[] b, int[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] / (int)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this decimal[] a, int b, int[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (int)((int)a[i] / (int)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Divide(this decimal a, int[] b, int[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (int)((int)a / (int)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Divide(this decimal[,] a,  int[] b, int dimension, int[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] / (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (int)((int)a[i, j] / (int)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Divide(this decimal[][] a,  int[] b, int dimension, int[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] / (int)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (int)((int)a[i][j] / (int)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this decimal a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a / (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this decimal a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a / (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this decimal[] a, int[,] b, int[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (int)((int)a[j] / (int)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this decimal[] a, int[][] b, int[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i] / (int)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this decimal[,] a, int b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) / (int)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this decimal[][] a, int b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (int)((int)a[i][i] / (int)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] DivideByDiagonal(this decimal[,] a, int[] b, int[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (int* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (int)((int)(*pa) / (int)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] DivideByDiagonal(this decimal[][] a, int[] b, int[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (int)((int)a[i][i] / (int)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[][] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[,] a, int[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[,] a, int[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (int* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[][] a, int[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[,] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[][] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) / (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[,] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (int* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[,] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[][] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[][] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal a, int[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a /  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a / (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal a, int[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a / (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[,] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[,] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[][] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this decimal[] a, int[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this decimal[] a, int b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this decimal a, int[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a / (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[,] a,  int[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[][] a,  int[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this decimal a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this decimal a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this decimal[] a, int[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (int* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this decimal[] a, int[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this decimal[,] a, int b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this decimal[][] a, int b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this decimal[,] a, int[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this decimal[][] a, int[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[][] a, float[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (decimal)((decimal)a[i][j] / (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[,] a, float[][] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (decimal)((decimal)(*pa) / (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[,] a, float[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (float* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (decimal)((decimal)(*pa) / (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[][] a, float[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)(a[i][j]) / (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[,] a, float[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (decimal)((decimal)(*pa) / (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[][] a, float[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (decimal)((decimal)(a[i][j]) / (decimal)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[,] a, float[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (float* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (decimal)((decimal)(*pa) / (decimal)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[,] a, float b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) /  (decimal)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[][] a, float b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a[i][j] / (decimal)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[][] a, float b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] / (decimal)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal a, float[,] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)a /  (decimal)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal a, float[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a / (decimal)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal a, float[][] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (decimal)((decimal)a / (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal a, float[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (decimal)((decimal)a / (decimal)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[,] a, float b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (decimal)((decimal)(*pa) / (decimal)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[,] a, float b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) /  (decimal)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[][] a, float b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] / (decimal)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Divide(this decimal[] a, float[] b, decimal[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] / (decimal)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Divide(this decimal[] a, float b, decimal[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] / (decimal)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Divide(this decimal a, float[] b, decimal[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (decimal)((decimal)a / (decimal)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[,] a,  float[] b, int dimension, decimal[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] / (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] / (decimal)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[][] a,  float[] b, int dimension, decimal[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] / (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] / (decimal)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal a, float[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a / (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal a, float[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a / (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal[] a, float[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a[j] / (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal[] a, float[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i] / (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal[,] a, float b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) / (decimal)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal[][] a, float b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] / (decimal)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal[,] a, float[] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) / (decimal)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal[][] a, float[] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] / (decimal)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this decimal[][] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (float)((float)a[i][j] / (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this decimal[,] a, float[][] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (float)((float)(*pa) / (float)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this decimal[,] a, float[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (float* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (float)((float)(*pa) / (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this decimal[][] a, float[,] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)(a[i][j]) / (float)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this decimal[,] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (float)((float)(*pa) / (float)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this decimal[][] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (float)((float)(a[i][j]) / (float)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this decimal[,] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (float* ptrB = b)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (float)((float)(*pa) / (float)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this decimal[,] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) /  (float)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this decimal[][] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (float)((float)a[i][j] / (float)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this decimal[][] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] / (float)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this decimal a, float[,] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (float)((float)a /  (float)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this decimal a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (float)((float)a / (float)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this decimal a, float[][] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (float)((float)a / (float)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this decimal a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (float)((float)a / (float)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this decimal[,] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (float* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (float)((float)(*pa) / (float)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this decimal[,] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (float)((float)(*pa) /  (float)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this decimal[][] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (float)((float)a[i][j] / (float)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this decimal[] a, float[] b, float[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] / (float)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this decimal[] a, float b, float[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (float)((float)a[i] / (float)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Divide(this decimal a, float[] b, float[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (float)((float)a / (float)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Divide(this decimal[,] a,  float[] b, int dimension, float[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] / (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (float)((float)a[i, j] / (float)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Divide(this decimal[][] a,  float[] b, int dimension, float[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] / (float)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (float)((float)a[i][j] / (float)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this decimal a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a / (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this decimal a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a / (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this decimal[] a, float[,] b, float[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (float)((float)a[j] / (float)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this decimal[] a, float[][] b, float[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i] / (float)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this decimal[,] a, float b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) / (float)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this decimal[][] a, float b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (float)((float)a[i][i] / (float)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] DivideByDiagonal(this decimal[,] a, float[] b, float[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (float* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (float)((float)(*pa) / (float)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] DivideByDiagonal(this decimal[][] a, float[] b, float[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (float)((float)a[i][i] / (float)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[][] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[,] a, float[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[,] a, float[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (float* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[][] a, float[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[,] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[][] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) / (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[,] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (float* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[,] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[][] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[][] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal a, float[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a /  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a / (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal a, float[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a / (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[,] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[,] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[][] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this decimal[] a, float[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this decimal[] a, float b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this decimal a, float[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a / (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[,] a,  float[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[][] a,  float[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this decimal a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this decimal a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this decimal[] a, float[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (float* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this decimal[] a, float[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this decimal[,] a, float b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this decimal[][] a, float b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this decimal[,] a, float[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this decimal[][] a, float[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[][] a, double[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (decimal)((decimal)a[i][j] / (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[,] a, double[][] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (decimal)((decimal)(*pa) / (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[,] a, double[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (double* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (decimal)((decimal)(*pa) / (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[][] a, double[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)(a[i][j]) / (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[,] a, double[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (decimal)((decimal)(*pa) / (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[][] a, double[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (decimal)((decimal)(a[i][j]) / (decimal)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[,] a, double[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (double* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (decimal)((decimal)(*pa) / (decimal)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[,] a, double b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) /  (decimal)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[][] a, double b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a[i][j] / (decimal)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[][] a, double b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] / (decimal)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal a, double[,] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)a /  (decimal)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal a, double[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a / (decimal)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal a, double[][] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (decimal)((decimal)a / (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal a, double[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (decimal)((decimal)a / (decimal)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[,] a, double b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (decimal)((decimal)(*pa) / (decimal)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[,] a, double b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) /  (decimal)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[][] a, double b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] / (decimal)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Divide(this decimal[] a, double[] b, decimal[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] / (decimal)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Divide(this decimal[] a, double b, decimal[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] / (decimal)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Divide(this decimal a, double[] b, decimal[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (decimal)((decimal)a / (decimal)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[,] a,  double[] b, int dimension, decimal[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] / (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] / (decimal)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[][] a,  double[] b, int dimension, decimal[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] / (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] / (decimal)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal a, double[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a / (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal a, double[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a / (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal[] a, double[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a[j] / (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal[] a, double[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i] / (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal[,] a, double b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) / (decimal)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal[][] a, double b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] / (decimal)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal[,] a, double[] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) / (decimal)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal[][] a, double[] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] / (decimal)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[][] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[,] a, double[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[,] a, double[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (double* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[][] a, double[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[,] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[][] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) / (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[,] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (double* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[,] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[][] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[][] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal a, double[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a /  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a / (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal a, double[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a / (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[,] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[,] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[][] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this decimal[] a, double[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this decimal[] a, double b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this decimal a, double[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a / (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[,] a,  double[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[][] a,  double[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this decimal a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this decimal a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this decimal[] a, double[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (double* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this decimal[] a, double[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this decimal[,] a, double b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this decimal[][] a, double b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this decimal[,] a, double[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this decimal[][] a, double[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[][] a, byte[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (decimal)((decimal)a[i][j] / (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[,] a, byte[][] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (decimal)((decimal)(*pa) / (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[,] a, byte[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (byte* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (decimal)((decimal)(*pa) / (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[][] a, byte[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)(a[i][j]) / (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[,] a, byte[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (decimal)((decimal)(*pa) / (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[][] a, byte[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (decimal)((decimal)(a[i][j]) / (decimal)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[,] a, byte[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (byte* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (decimal)((decimal)(*pa) / (decimal)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[,] a, byte b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) /  (decimal)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[][] a, byte b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a[i][j] / (decimal)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[][] a, byte b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] / (decimal)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal a, byte[,] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)a /  (decimal)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal a, byte[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a / (decimal)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal a, byte[][] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (decimal)((decimal)a / (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal a, byte[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (decimal)((decimal)a / (decimal)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[,] a, byte b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (decimal)((decimal)(*pa) / (decimal)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[,] a, byte b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) /  (decimal)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[][] a, byte b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] / (decimal)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Divide(this decimal[] a, byte[] b, decimal[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] / (decimal)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Divide(this decimal[] a, byte b, decimal[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] / (decimal)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Divide(this decimal a, byte[] b, decimal[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (decimal)((decimal)a / (decimal)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[,] a,  byte[] b, int dimension, decimal[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] / (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] / (decimal)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[][] a,  byte[] b, int dimension, decimal[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] / (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] / (decimal)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal a, byte[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a / (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal a, byte[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a / (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal[] a, byte[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a[j] / (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal[] a, byte[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i] / (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal[,] a, byte b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) / (decimal)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal[][] a, byte b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] / (decimal)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal[,] a, byte[] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) / (decimal)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal[][] a, byte[] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] / (decimal)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this decimal[][] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (byte)((byte)a[i][j] / (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this decimal[,] a, byte[][] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (byte)((byte)(*pa) / (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this decimal[,] a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (byte* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (byte)((byte)(*pa) / (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this decimal[][] a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)(a[i][j]) / (byte)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this decimal[,] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (byte)((byte)(*pa) / (byte)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this decimal[][] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (byte)((byte)(a[i][j]) / (byte)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this decimal[,] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (byte* ptrB = b)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (byte)((byte)(*pa) / (byte)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this decimal[,] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) /  (byte)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this decimal[][] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (byte)((byte)a[i][j] / (byte)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this decimal[][] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] / (byte)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this decimal a, byte[,] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (byte)((byte)a /  (byte)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this decimal a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (byte)((byte)a / (byte)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this decimal a, byte[][] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (byte)((byte)a / (byte)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this decimal a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (byte)((byte)a / (byte)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this decimal[,] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (byte* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (byte)((byte)(*pa) / (byte)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this decimal[,] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (byte)((byte)(*pa) /  (byte)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this decimal[][] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (byte)((byte)a[i][j] / (byte)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Divide(this decimal[] a, byte[] b, byte[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] / (byte)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Divide(this decimal[] a, byte b, byte[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (byte)((byte)a[i] / (byte)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] Divide(this decimal a, byte[] b, byte[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (byte)((byte)a / (byte)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] Divide(this decimal[,] a,  byte[] b, int dimension, byte[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] / (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (byte)((byte)a[i, j] / (byte)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] Divide(this decimal[][] a,  byte[] b, int dimension, byte[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] / (byte)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (byte)((byte)a[i][j] / (byte)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this decimal a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a / (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this decimal a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a / (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this decimal[] a, byte[,] b, byte[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (byte)((byte)a[j] / (byte)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this decimal[] a, byte[][] b, byte[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i] / (byte)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this decimal[,] a, byte b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) / (byte)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this decimal[][] a, byte b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] / (byte)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] DivideByDiagonal(this decimal[,] a, byte[] b, byte[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (byte* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (byte)((byte)(*pa) / (byte)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] DivideByDiagonal(this decimal[][] a, byte[] b, byte[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (byte)((byte)a[i][i] / (byte)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[][] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[,] a, byte[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[,] a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (byte* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[][] a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[,] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[][] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) / (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[,] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (byte* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[,] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[][] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[][] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal a, byte[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a /  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a / (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal a, byte[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a / (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[,] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[,] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[][] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this decimal[] a, byte[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this decimal[] a, byte b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this decimal a, byte[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a / (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[,] a,  byte[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[][] a,  byte[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this decimal a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this decimal a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this decimal[] a, byte[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (byte* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this decimal[] a, byte[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this decimal[,] a, byte b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this decimal[][] a, byte b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this decimal[,] a, byte[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this decimal[][] a, byte[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[][] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (decimal)((decimal)a[i][j] / (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[,] a, decimal[][] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (decimal)((decimal)(*pa) / (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[,] a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (decimal* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (decimal)((decimal)(*pa) / (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[][] a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)(a[i][j]) / (decimal)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[,] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (decimal)((decimal)(*pa) / (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[][] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (decimal)((decimal)(a[i][j]) / (decimal)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[,] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (decimal* ptrB = b)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (decimal)((decimal)(*pa) / (decimal)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[,] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) /  (decimal)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[][] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a[i][j] / (decimal)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[][] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] / (decimal)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal a, decimal[,] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (decimal)((decimal)a /  (decimal)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (decimal)((decimal)a / (decimal)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal a, decimal[][] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (decimal)((decimal)a / (decimal)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (decimal)((decimal)a / (decimal)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[,] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (decimal* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (decimal)((decimal)(*pa) / (decimal)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[,] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (decimal)((decimal)(*pa) /  (decimal)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[][] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (decimal)((decimal)a[i][j] / (decimal)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Divide(this decimal[] a, decimal[] b, decimal[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] / (decimal)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Divide(this decimal[] a, decimal b, decimal[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (decimal)((decimal)a[i] / (decimal)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Divide(this decimal a, decimal[] b, decimal[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (decimal)((decimal)a / (decimal)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Divide(this decimal[,] a,  decimal[] b, int dimension, decimal[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] / (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (decimal)((decimal)a[i, j] / (decimal)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Divide(this decimal[][] a,  decimal[] b, int dimension, decimal[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] / (decimal)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (decimal)((decimal)a[i][j] / (decimal)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a / (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a / (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal[] a, decimal[,] b, decimal[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (decimal)((decimal)a[j] / (decimal)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal[] a, decimal[][] b, decimal[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i] / (decimal)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal[,] a, decimal b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) / (decimal)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal[][] a, decimal b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] / (decimal)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] DivideByDiagonal(this decimal[,] a, decimal[] b, decimal[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (decimal* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (decimal)((decimal)(*pa) / (decimal)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] DivideByDiagonal(this decimal[][] a, decimal[] b, decimal[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (decimal)((decimal)a[i][i] / (decimal)b[i]);
            return result;
        }
 
#endregion
     

#region Matrix matrix
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[][] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++)
                        for (int j = 0; j < a[i].Length; j++, pb++, pr++)
                            *pr = (double)((double)a[i][j] / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[,] a, decimal[][] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pa++, pr++)
                            *pr = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[,] a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (decimal* ptrB = b)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++, pb++)
                            result[i][j] = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[][] a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)(a[i][j]) / (double)(*pb));
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[,] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                            result[i][j] = (double)((double)(*pa) / (double)(b[i][j]));
                }
            }

            return result;
        }
*/
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[][] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (double)((double)(a[i][j]) / (double)(b[i][j]));

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[,] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(b.GetLength()) || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (decimal* ptrB = b)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pb = ptrB;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pb++, pr++)
                        *pr = (double)((double)(*pa) / (double)(*pb));
                }
            }

            return result;
        }
#endregion


























#region Matrix with scalar
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[,] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[][] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i][j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[][] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal a, decimal[,] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)
                {
                    var pb = ptrB;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pb++)
                            result[i][j] = (double)((double)a /  (double)(*pb));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                for (int j = 0; j < b[i].Length; j++)
                    result[i][j] = (double)((double)a / (double)b[i][j]);
            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal a, decimal[][] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (double* ptrR = result)
                {
                    var pr = ptrR;
                    for (int i = 0; i < b.Length; i++)
                        for (int j = 0; j < b[i].Length; j++, pr++)
                            *pr = (double)((double)a / (double)(b[i][j]));
                }
            }

            return result;
        }
*/

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a matrix <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The matrix <c>B</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < b.Length; j++, pr++, pb++)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[,] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                fixed (double* ptrR = result)
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int i = 0; i < a.Length; i++, pa++, pr++)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }

            return result;
        }
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[,] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            unsafe
            {
                fixed (decimal* ptrA = a)
                {
                    var pa = ptrA;
                    for (int i = 0; i < result.Length; i++)
                        for (int j = 0; j < result[i].Length; j++, pa++)
                        result[i][j] = (double)((double)(*pa) /  (double)b);
                }
            }

            return result;
        }
*/
/*
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a scalar <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[][] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < a[i].Length; j++)
                    result[i, j] = (double)((double)a[i][j] / (double)b);
            return result;
        }
*/
#endregion
























#region vector vector

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this decimal[] a, decimal[] b, double[] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || !b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b[i]);
            return result;
        }
#endregion






#region Vector with scalar

        /// <summary>
        ///   Elementwise division between a vector <c>a</c> and a scalar <c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The vector <c>a</c>.</param>
        /// <param name="b">The scalar <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this decimal[] a, decimal b, double[] result)
        {
#if CHECK
            if (a.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i] = (double)((double)a[i] / (double)b);
            return result;
        }

        /// <summary>
        ///   Elementwise division between a scalar <c>a</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The scalar <c>a</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Divide(this decimal a, decimal[] b, double[] result)
        {
#if CHECK
            if (b.Length != result.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i] = (double)((double)a / (double)b[i]);
            return result;
        }
#endregion







#region Matrix vector
        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the operation will be carried. If set to
        ///   0, then the vector <c>b</c> must have the same dimensions as rows
        ///   of <c>A</c>, and the operation will be carried at each column vector. If 
        ///   1, then it must have the same dimensions as columns in <c>A</c>, and the
        ///   operation will be carried at each row vector.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Divide(this decimal[,] a,  decimal[] b, int dimension, double[,] result)
        {
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            if (dimension == 0)
            {
#if CHECK
            if (a.GetLength(1) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.GetLength(0) != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        result[i, j] = (double)((double)a[i, j] / (double)b[i]);
            }

            return result;
        }

        /// <summary>
        ///   Elementwise division between a matrix <c>A</c> and a vector<c>b</c>.
        /// </summary>
        ///
        /// <param name="a">The matrix <c>A</c>.</param>
        /// <param name="b">The vector <c>b</c>.</param>
        /// <param name="dimension">
        ///   The dimension along which the means will be calculated. Pass
        ///   0 to compute a row vector containing the mean of each column,
        ///   or 1 to compute a column vector containing the mean of each row.
        ///   Default value is 0.
        /// </param>
        /// <param name="result">The matrix where the result should be stored. Pass the same
        ///   matrix as one of the arguments to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Divide(this decimal[][] a,  decimal[] b, int dimension, double[][] result)
        {
            if (dimension == 0)
            {
#if CHECK
            if (a[0].Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[j]);
            }
            else
            {
#if CHECK
            if (a.Length != b.Length || !a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
                        result[i][j] = (double)((double)a[i][j] / (double)b[i]);
            }

            return result;
        }
#endregion























#region Diagonal
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this decimal a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this decimal a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this decimal[] a, decimal[,] b, double[,] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrB = b)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pb = ptrB;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pb += cols + 1)
                        *pr = (double)((double)a[j] / (double)(*pb));
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this decimal[] a, decimal[][] b, double[][] result)
        {
#if CHECK
            if (!b.GetLength().IsEqual(result.GetLength()) || a.Length != b[0].Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i] / (double)b[i][i]);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this decimal[,] a, decimal b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            int rows = a.GetLength(0);
            int cols = a.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pa = ptrA;
                    var pr = ptrR;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this decimal[][] a, decimal b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()))
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < a.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b);
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] DivideByDiagonal(this decimal[,] a, decimal[] b, double[,] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.GetLength(0) != b.Length)
                throw new DimensionMismatchException();
#endif
            int rows = b.GetLength(0);
            int cols = b.GetLength(1);

            unsafe 
            {
                fixed (decimal* ptrA = a)        
                fixed (double* ptrR = result)        
                {
                    var pr = ptrR;
                    var pa = ptrA;
                    for (int j = 0; j < rows; j++, pr += cols + 1, pa += cols + 1)
                        *pr = (double)((double)(*pa) / (double)b[j]);
                }
            }
            return result;
        }

#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] DivideByDiagonal(this decimal[][] a, decimal[] b, double[][] result)
        {
#if CHECK
            if (!a.GetLength().IsEqual(result.GetLength()) || a.Length != b.Length)
                throw new DimensionMismatchException();
#endif
            for (int i = 0; i < b.Length; i++)
                result[i][i] = (double)((double)a[i][i] / (double)b[i]);
            return result;
        }
 
#endregion
     
#pragma warning restore 1591
    }
}
