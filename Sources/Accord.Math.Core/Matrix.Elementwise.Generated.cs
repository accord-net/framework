// Accord Math Library
// The Accord.NET Framework
// http://accord-framework.net
//
// Copyright © César Souza, 2009-2017
// cesarsouza at gmail.com
//
//    This library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    This library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with this library; if not, write to the Free Software
//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
//

// ======================================================================
// This code has been generated by a tool; do not edit manually. Instead,
// edit the T4 template Matrix.Elementwise.tt so this file can be regenerated. 
// ======================================================================

namespace Accord.Math
{
    using System;
    using System.CodeDom.Compiler;
    using Accord.Math;
    using System.Runtime.CompilerServices;

    public static partial class Elementwise
    {
        private static TOutput[] VectorCreateAs<TInput, TOutput>(TInput[] vector)
        {
            return new TOutput[vector.Length];
        }

        private static TOutput[,] MatrixCreateAs<TInput, TOutput>(TInput[,] matrix)
        {
            return new TOutput[matrix.GetLength(0), matrix.GetLength(1)];
        }

        private static TOutput[][] JaggedCreateAs<TInput, TOutput>(TInput[][] matrix)
        {
            var r = new TOutput[matrix.Length][];
            for (int i = 0; i < r.Length; i++)
                r[i] = new TOutput[matrix[i].Length];
            return r;
        }

        private static TOutput[,] MatrixCreateAs<TInput, TOutput>(TInput[][] matrix)
        {
            return new TOutput[matrix.Length, matrix[0].Length];
        }

        private static TOutput[][] JaggedCreateAs<TInput, TOutput>(TInput[,] matrix)
        {
            var r = new TOutput[matrix.GetLength(0)][];
            for (int i = 0; i < r.Length; i++)
                r[i] = new TOutput[matrix.GetLength(1)];
            return r;
        }

        private static T[,] MemberwiseClone<T>(this T[,] matrix)
        {
            return (T[,])matrix.Clone();
        }

        private static T[][] MemberwiseClone<T>(this T[][] matrix)
        {
            T[][] r = new T[matrix.Length][];
            for (int i = 0; i < matrix.Length; i++)
                r[i] = (T[])matrix[i].Clone();
            return r;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Exp(this int[] value)
        {
            return Exp(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Exp(this int[,] value)
        {
            return Exp(value, MatrixCreateAs<int, double>(value));
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Exp(this int[][] value)
        {
            return Exp(value, JaggedCreateAs<int, double>(value));
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Log(this int[] value)
        {
            return Log(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Log(this int[,] value)
        {
            return Log(value, MatrixCreateAs<int, double>(value));
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Log(this int[][] value)
        {
            return Log(value, JaggedCreateAs<int, double>(value));
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Sign(this int[] value)
        {
            return Sign(value, new int[value.Length]);
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Sign(this int[,] value)
        {
            return Sign(value, MatrixCreateAs<int, int>(value));
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Sign(this int[][] value)
        {
            return Sign(value, JaggedCreateAs<int, int>(value));
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Abs(this int[] value)
        {
            return Abs(value, new int[value.Length]);
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Abs(this int[,] value)
        {
            return Abs(value, MatrixCreateAs<int, int>(value));
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Abs(this int[][] value)
        {
            return Abs(value, JaggedCreateAs<int, int>(value));
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Sqrt(this int[] value)
        {
            return Sqrt(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Sqrt(this int[,] value)
        {
            return Sqrt(value, MatrixCreateAs<int, double>(value));
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Sqrt(this int[][] value)
        {
            return Sqrt(value, JaggedCreateAs<int, double>(value));
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] SignSqrt(this int[] value)
        {
            return SignSqrt(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] SignSqrt(this int[,] value)
        {
            return SignSqrt(value, MatrixCreateAs<int, double>(value));
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] SignSqrt(this int[][] value)
        {
            return SignSqrt(value, JaggedCreateAs<int, double>(value));
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Floor(this int[] value)
        {
            return Floor(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Floor(this int[,] value)
        {
            return Floor(value, MatrixCreateAs<int, double>(value));
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Floor(this int[][] value)
        {
            return Floor(value, JaggedCreateAs<int, double>(value));
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Ceiling(this int[] value)
        {
            return Ceiling(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Ceiling(this int[,] value)
        {
            return Ceiling(value, MatrixCreateAs<int, double>(value));
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Ceiling(this int[][] value)
        {
            return Ceiling(value, JaggedCreateAs<int, double>(value));
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Round(this int[] value)
        {
            return Round(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Round(this int[,] value)
        {
            return Round(value, MatrixCreateAs<int, double>(value));
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Round(this int[][] value)
        {
            return Round(value, JaggedCreateAs<int, double>(value));
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Exp(this short[] value)
        {
            return Exp(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Exp(this short[,] value)
        {
            return Exp(value, MatrixCreateAs<short, double>(value));
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Exp(this short[][] value)
        {
            return Exp(value, JaggedCreateAs<short, double>(value));
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Log(this short[] value)
        {
            return Log(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Log(this short[,] value)
        {
            return Log(value, MatrixCreateAs<short, double>(value));
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Log(this short[][] value)
        {
            return Log(value, JaggedCreateAs<short, double>(value));
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Sign(this short[] value)
        {
            return Sign(value, new short[value.Length]);
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Sign(this short[,] value)
        {
            return Sign(value, MatrixCreateAs<short, short>(value));
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Sign(this short[][] value)
        {
            return Sign(value, JaggedCreateAs<short, short>(value));
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Abs(this short[] value)
        {
            return Abs(value, new short[value.Length]);
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Abs(this short[,] value)
        {
            return Abs(value, MatrixCreateAs<short, short>(value));
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Abs(this short[][] value)
        {
            return Abs(value, JaggedCreateAs<short, short>(value));
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Sqrt(this short[] value)
        {
            return Sqrt(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Sqrt(this short[,] value)
        {
            return Sqrt(value, MatrixCreateAs<short, double>(value));
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Sqrt(this short[][] value)
        {
            return Sqrt(value, JaggedCreateAs<short, double>(value));
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] SignSqrt(this short[] value)
        {
            return SignSqrt(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] SignSqrt(this short[,] value)
        {
            return SignSqrt(value, MatrixCreateAs<short, double>(value));
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] SignSqrt(this short[][] value)
        {
            return SignSqrt(value, JaggedCreateAs<short, double>(value));
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Floor(this short[] value)
        {
            return Floor(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Floor(this short[,] value)
        {
            return Floor(value, MatrixCreateAs<short, double>(value));
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Floor(this short[][] value)
        {
            return Floor(value, JaggedCreateAs<short, double>(value));
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Ceiling(this short[] value)
        {
            return Ceiling(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Ceiling(this short[,] value)
        {
            return Ceiling(value, MatrixCreateAs<short, double>(value));
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Ceiling(this short[][] value)
        {
            return Ceiling(value, JaggedCreateAs<short, double>(value));
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Round(this short[] value)
        {
            return Round(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Round(this short[,] value)
        {
            return Round(value, MatrixCreateAs<short, double>(value));
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Round(this short[][] value)
        {
            return Round(value, JaggedCreateAs<short, double>(value));
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Exp(this float[] value)
        {
            return Exp(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Exp(this float[,] value)
        {
            return Exp(value, MatrixCreateAs<float, double>(value));
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Exp(this float[][] value)
        {
            return Exp(value, JaggedCreateAs<float, double>(value));
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Log(this float[] value)
        {
            return Log(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Log(this float[,] value)
        {
            return Log(value, MatrixCreateAs<float, double>(value));
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Log(this float[][] value)
        {
            return Log(value, JaggedCreateAs<float, double>(value));
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Sign(this float[] value)
        {
            return Sign(value, new float[value.Length]);
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Sign(this float[,] value)
        {
            return Sign(value, MatrixCreateAs<float, float>(value));
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Sign(this float[][] value)
        {
            return Sign(value, JaggedCreateAs<float, float>(value));
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Abs(this float[] value)
        {
            return Abs(value, new float[value.Length]);
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Abs(this float[,] value)
        {
            return Abs(value, MatrixCreateAs<float, float>(value));
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Abs(this float[][] value)
        {
            return Abs(value, JaggedCreateAs<float, float>(value));
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Sqrt(this float[] value)
        {
            return Sqrt(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Sqrt(this float[,] value)
        {
            return Sqrt(value, MatrixCreateAs<float, double>(value));
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Sqrt(this float[][] value)
        {
            return Sqrt(value, JaggedCreateAs<float, double>(value));
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] SignSqrt(this float[] value)
        {
            return SignSqrt(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] SignSqrt(this float[,] value)
        {
            return SignSqrt(value, MatrixCreateAs<float, double>(value));
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] SignSqrt(this float[][] value)
        {
            return SignSqrt(value, JaggedCreateAs<float, double>(value));
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Floor(this float[] value)
        {
            return Floor(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Floor(this float[,] value)
        {
            return Floor(value, MatrixCreateAs<float, double>(value));
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Floor(this float[][] value)
        {
            return Floor(value, JaggedCreateAs<float, double>(value));
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Ceiling(this float[] value)
        {
            return Ceiling(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Ceiling(this float[,] value)
        {
            return Ceiling(value, MatrixCreateAs<float, double>(value));
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Ceiling(this float[][] value)
        {
            return Ceiling(value, JaggedCreateAs<float, double>(value));
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Round(this float[] value)
        {
            return Round(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Round(this float[,] value)
        {
            return Round(value, MatrixCreateAs<float, double>(value));
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Round(this float[][] value)
        {
            return Round(value, JaggedCreateAs<float, double>(value));
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Exp(this double[] value)
        {
            return Exp(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Exp(this double[,] value)
        {
            return Exp(value, MatrixCreateAs<double, double>(value));
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Exp(this double[][] value)
        {
            return Exp(value, JaggedCreateAs<double, double>(value));
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Log(this double[] value)
        {
            return Log(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Log(this double[,] value)
        {
            return Log(value, MatrixCreateAs<double, double>(value));
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Log(this double[][] value)
        {
            return Log(value, JaggedCreateAs<double, double>(value));
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Sign(this double[] value)
        {
            return Sign(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Sign(this double[,] value)
        {
            return Sign(value, MatrixCreateAs<double, double>(value));
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Sign(this double[][] value)
        {
            return Sign(value, JaggedCreateAs<double, double>(value));
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Abs(this double[] value)
        {
            return Abs(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Abs(this double[,] value)
        {
            return Abs(value, MatrixCreateAs<double, double>(value));
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Abs(this double[][] value)
        {
            return Abs(value, JaggedCreateAs<double, double>(value));
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Sqrt(this double[] value)
        {
            return Sqrt(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Sqrt(this double[,] value)
        {
            return Sqrt(value, MatrixCreateAs<double, double>(value));
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Sqrt(this double[][] value)
        {
            return Sqrt(value, JaggedCreateAs<double, double>(value));
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] SignSqrt(this double[] value)
        {
            return SignSqrt(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] SignSqrt(this double[,] value)
        {
            return SignSqrt(value, MatrixCreateAs<double, double>(value));
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] SignSqrt(this double[][] value)
        {
            return SignSqrt(value, JaggedCreateAs<double, double>(value));
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Floor(this double[] value)
        {
            return Floor(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Floor(this double[,] value)
        {
            return Floor(value, MatrixCreateAs<double, double>(value));
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Floor(this double[][] value)
        {
            return Floor(value, JaggedCreateAs<double, double>(value));
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Ceiling(this double[] value)
        {
            return Ceiling(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Ceiling(this double[,] value)
        {
            return Ceiling(value, MatrixCreateAs<double, double>(value));
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Ceiling(this double[][] value)
        {
            return Ceiling(value, JaggedCreateAs<double, double>(value));
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Round(this double[] value)
        {
            return Round(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Round(this double[,] value)
        {
            return Round(value, MatrixCreateAs<double, double>(value));
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Round(this double[][] value)
        {
            return Round(value, JaggedCreateAs<double, double>(value));
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Exp(this long[] value)
        {
            return Exp(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Exp(this long[,] value)
        {
            return Exp(value, MatrixCreateAs<long, double>(value));
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Exp(this long[][] value)
        {
            return Exp(value, JaggedCreateAs<long, double>(value));
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Log(this long[] value)
        {
            return Log(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Log(this long[,] value)
        {
            return Log(value, MatrixCreateAs<long, double>(value));
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Log(this long[][] value)
        {
            return Log(value, JaggedCreateAs<long, double>(value));
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Sign(this long[] value)
        {
            return Sign(value, new long[value.Length]);
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Sign(this long[,] value)
        {
            return Sign(value, MatrixCreateAs<long, long>(value));
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Sign(this long[][] value)
        {
            return Sign(value, JaggedCreateAs<long, long>(value));
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Abs(this long[] value)
        {
            return Abs(value, new long[value.Length]);
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Abs(this long[,] value)
        {
            return Abs(value, MatrixCreateAs<long, long>(value));
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Abs(this long[][] value)
        {
            return Abs(value, JaggedCreateAs<long, long>(value));
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Sqrt(this long[] value)
        {
            return Sqrt(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Sqrt(this long[,] value)
        {
            return Sqrt(value, MatrixCreateAs<long, double>(value));
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Sqrt(this long[][] value)
        {
            return Sqrt(value, JaggedCreateAs<long, double>(value));
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] SignSqrt(this long[] value)
        {
            return SignSqrt(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] SignSqrt(this long[,] value)
        {
            return SignSqrt(value, MatrixCreateAs<long, double>(value));
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] SignSqrt(this long[][] value)
        {
            return SignSqrt(value, JaggedCreateAs<long, double>(value));
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Floor(this long[] value)
        {
            return Floor(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Floor(this long[,] value)
        {
            return Floor(value, MatrixCreateAs<long, double>(value));
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Floor(this long[][] value)
        {
            return Floor(value, JaggedCreateAs<long, double>(value));
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Ceiling(this long[] value)
        {
            return Ceiling(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Ceiling(this long[,] value)
        {
            return Ceiling(value, MatrixCreateAs<long, double>(value));
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Ceiling(this long[][] value)
        {
            return Ceiling(value, JaggedCreateAs<long, double>(value));
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Round(this long[] value)
        {
            return Round(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Round(this long[,] value)
        {
            return Round(value, MatrixCreateAs<long, double>(value));
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Round(this long[][] value)
        {
            return Round(value, JaggedCreateAs<long, double>(value));
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Exp(this decimal[] value)
        {
            return Exp(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Exp(this decimal[,] value)
        {
            return Exp(value, MatrixCreateAs<decimal, double>(value));
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Exp(this decimal[][] value)
        {
            return Exp(value, JaggedCreateAs<decimal, double>(value));
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Log(this decimal[] value)
        {
            return Log(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Log(this decimal[,] value)
        {
            return Log(value, MatrixCreateAs<decimal, double>(value));
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Log(this decimal[][] value)
        {
            return Log(value, JaggedCreateAs<decimal, double>(value));
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Sign(this decimal[] value)
        {
            return Sign(value, new decimal[value.Length]);
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Sign(this decimal[,] value)
        {
            return Sign(value, MatrixCreateAs<decimal, decimal>(value));
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Sign(this decimal[][] value)
        {
            return Sign(value, JaggedCreateAs<decimal, decimal>(value));
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Abs(this decimal[] value)
        {
            return Abs(value, new decimal[value.Length]);
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Abs(this decimal[,] value)
        {
            return Abs(value, MatrixCreateAs<decimal, decimal>(value));
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Abs(this decimal[][] value)
        {
            return Abs(value, JaggedCreateAs<decimal, decimal>(value));
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Sqrt(this decimal[] value)
        {
            return Sqrt(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Sqrt(this decimal[,] value)
        {
            return Sqrt(value, MatrixCreateAs<decimal, double>(value));
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Sqrt(this decimal[][] value)
        {
            return Sqrt(value, JaggedCreateAs<decimal, double>(value));
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] SignSqrt(this decimal[] value)
        {
            return SignSqrt(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] SignSqrt(this decimal[,] value)
        {
            return SignSqrt(value, MatrixCreateAs<decimal, double>(value));
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] SignSqrt(this decimal[][] value)
        {
            return SignSqrt(value, JaggedCreateAs<decimal, double>(value));
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Floor(this decimal[] value)
        {
            return Floor(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Floor(this decimal[,] value)
        {
            return Floor(value, MatrixCreateAs<decimal, double>(value));
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Floor(this decimal[][] value)
        {
            return Floor(value, JaggedCreateAs<decimal, double>(value));
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Ceiling(this decimal[] value)
        {
            return Ceiling(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Ceiling(this decimal[,] value)
        {
            return Ceiling(value, MatrixCreateAs<decimal, double>(value));
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Ceiling(this decimal[][] value)
        {
            return Ceiling(value, JaggedCreateAs<decimal, double>(value));
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Round(this decimal[] value)
        {
            return Round(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Round(this decimal[,] value)
        {
            return Round(value, MatrixCreateAs<decimal, double>(value));
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Round(this decimal[][] value)
        {
            return Round(value, JaggedCreateAs<decimal, double>(value));
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Exp(this int[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Exp(this int[,] value, int[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Exp(this int[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Log(this int[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Log(this int[,] value, int[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Log(this int[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Sign(this int[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Sign(this int[,] value, int[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Sign(this int[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Abs(this int[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Abs(this int[,] value, int[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Abs(this int[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Sqrt(this int[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Sqrt(this int[,] value, int[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Sqrt(this int[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] SignSqrt(this int[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] SignSqrt(this int[,] value, int[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] SignSqrt(this int[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Floor(this int[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Floor(this int[,] value, int[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Floor(this int[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Ceiling(this int[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Ceiling(this int[,] value, int[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Ceiling(this int[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Round(this int[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Round(this int[,] value, int[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Round(this int[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Exp(this int[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Exp(this int[,] value, short[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Exp(this int[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Log(this int[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Log(this int[,] value, short[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Log(this int[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Sign(this int[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Sign(this int[,] value, short[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Sign(this int[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Abs(this int[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Abs(this int[,] value, short[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Abs(this int[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Sqrt(this int[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Sqrt(this int[,] value, short[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Sqrt(this int[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] SignSqrt(this int[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] SignSqrt(this int[,] value, short[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] SignSqrt(this int[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Floor(this int[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Floor(this int[,] value, short[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Floor(this int[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Ceiling(this int[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Ceiling(this int[,] value, short[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Ceiling(this int[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Round(this int[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Round(this int[,] value, short[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Round(this int[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Exp(this int[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Exp(this int[,] value, float[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Exp(this int[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Log(this int[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Log(this int[,] value, float[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Log(this int[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Sign(this int[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Sign(this int[,] value, float[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Sign(this int[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Abs(this int[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Abs(this int[,] value, float[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Abs(this int[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Sqrt(this int[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Sqrt(this int[,] value, float[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Sqrt(this int[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] SignSqrt(this int[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] SignSqrt(this int[,] value, float[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] SignSqrt(this int[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Floor(this int[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Floor(this int[,] value, float[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Floor(this int[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Ceiling(this int[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Ceiling(this int[,] value, float[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Ceiling(this int[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Round(this int[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Round(this int[,] value, float[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Round(this int[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Exp(this int[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Exp(this int[,] value, double[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Exp(this int[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Log(this int[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Log(this int[,] value, double[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Log(this int[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Sign(this int[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Sign(this int[,] value, double[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Sign(this int[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Abs(this int[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Abs(this int[,] value, double[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Abs(this int[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Sqrt(this int[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Sqrt(this int[,] value, double[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Sqrt(this int[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] SignSqrt(this int[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] SignSqrt(this int[,] value, double[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] SignSqrt(this int[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Floor(this int[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Floor(this int[,] value, double[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Floor(this int[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Ceiling(this int[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Ceiling(this int[,] value, double[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Ceiling(this int[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Round(this int[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Round(this int[,] value, double[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Round(this int[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Exp(this int[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Exp(this int[,] value, long[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Exp(this int[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Log(this int[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Log(this int[,] value, long[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Log(this int[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Sign(this int[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Sign(this int[,] value, long[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Sign(this int[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Abs(this int[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Abs(this int[,] value, long[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Abs(this int[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Sqrt(this int[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Sqrt(this int[,] value, long[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Sqrt(this int[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] SignSqrt(this int[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] SignSqrt(this int[,] value, long[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] SignSqrt(this int[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Floor(this int[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Floor(this int[,] value, long[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Floor(this int[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Ceiling(this int[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Ceiling(this int[,] value, long[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Ceiling(this int[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Round(this int[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Round(this int[,] value, long[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Round(this int[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Exp(this int[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Exp(this int[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Exp(this int[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Log(this int[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Log(this int[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Log(this int[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Sign(this int[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Sign(this int[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Sign(this int[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Abs(this int[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Abs(this int[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Abs(this int[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Sqrt(this int[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Sqrt(this int[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Sqrt(this int[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] SignSqrt(this int[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] SignSqrt(this int[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] SignSqrt(this int[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Floor(this int[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Floor(this int[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Floor(this int[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Ceiling(this int[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Ceiling(this int[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Ceiling(this int[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Round(this int[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Round(this int[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Round(this int[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Exp(this short[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Exp(this short[,] value, int[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Exp(this short[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Log(this short[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Log(this short[,] value, int[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Log(this short[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Sign(this short[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Sign(this short[,] value, int[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Sign(this short[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Abs(this short[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Abs(this short[,] value, int[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Abs(this short[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Sqrt(this short[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Sqrt(this short[,] value, int[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Sqrt(this short[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] SignSqrt(this short[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] SignSqrt(this short[,] value, int[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] SignSqrt(this short[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Floor(this short[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Floor(this short[,] value, int[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Floor(this short[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Ceiling(this short[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Ceiling(this short[,] value, int[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Ceiling(this short[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Round(this short[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Round(this short[,] value, int[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Round(this short[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Exp(this short[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Exp(this short[,] value, short[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Exp(this short[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Log(this short[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Log(this short[,] value, short[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Log(this short[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Sign(this short[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Sign(this short[,] value, short[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Sign(this short[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Abs(this short[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Abs(this short[,] value, short[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Abs(this short[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Sqrt(this short[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Sqrt(this short[,] value, short[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Sqrt(this short[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] SignSqrt(this short[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] SignSqrt(this short[,] value, short[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] SignSqrt(this short[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Floor(this short[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Floor(this short[,] value, short[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Floor(this short[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Ceiling(this short[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Ceiling(this short[,] value, short[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Ceiling(this short[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Round(this short[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Round(this short[,] value, short[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Round(this short[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Exp(this short[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Exp(this short[,] value, float[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Exp(this short[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Log(this short[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Log(this short[,] value, float[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Log(this short[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Sign(this short[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Sign(this short[,] value, float[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Sign(this short[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Abs(this short[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Abs(this short[,] value, float[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Abs(this short[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Sqrt(this short[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Sqrt(this short[,] value, float[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Sqrt(this short[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] SignSqrt(this short[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] SignSqrt(this short[,] value, float[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] SignSqrt(this short[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Floor(this short[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Floor(this short[,] value, float[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Floor(this short[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Ceiling(this short[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Ceiling(this short[,] value, float[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Ceiling(this short[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Round(this short[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Round(this short[,] value, float[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Round(this short[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Exp(this short[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Exp(this short[,] value, double[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Exp(this short[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Log(this short[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Log(this short[,] value, double[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Log(this short[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Sign(this short[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Sign(this short[,] value, double[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Sign(this short[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Abs(this short[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Abs(this short[,] value, double[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Abs(this short[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Sqrt(this short[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Sqrt(this short[,] value, double[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Sqrt(this short[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] SignSqrt(this short[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] SignSqrt(this short[,] value, double[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] SignSqrt(this short[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Floor(this short[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Floor(this short[,] value, double[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Floor(this short[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Ceiling(this short[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Ceiling(this short[,] value, double[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Ceiling(this short[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Round(this short[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Round(this short[,] value, double[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Round(this short[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Exp(this short[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Exp(this short[,] value, long[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Exp(this short[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Log(this short[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Log(this short[,] value, long[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Log(this short[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Sign(this short[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Sign(this short[,] value, long[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Sign(this short[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Abs(this short[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Abs(this short[,] value, long[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Abs(this short[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Sqrt(this short[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Sqrt(this short[,] value, long[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Sqrt(this short[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] SignSqrt(this short[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] SignSqrt(this short[,] value, long[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] SignSqrt(this short[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Floor(this short[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Floor(this short[,] value, long[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Floor(this short[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Ceiling(this short[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Ceiling(this short[,] value, long[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Ceiling(this short[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Round(this short[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Round(this short[,] value, long[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Round(this short[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Exp(this short[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Exp(this short[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Exp(this short[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Log(this short[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Log(this short[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Log(this short[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Sign(this short[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Sign(this short[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Sign(this short[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Abs(this short[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Abs(this short[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Abs(this short[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Sqrt(this short[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Sqrt(this short[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Sqrt(this short[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] SignSqrt(this short[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] SignSqrt(this short[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] SignSqrt(this short[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Floor(this short[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Floor(this short[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Floor(this short[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Ceiling(this short[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Ceiling(this short[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Ceiling(this short[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Round(this short[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Round(this short[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Round(this short[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Exp(this float[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Exp(this float[,] value, int[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Exp(this float[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Log(this float[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Log(this float[,] value, int[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Log(this float[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Sign(this float[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Sign(this float[,] value, int[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Sign(this float[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Abs(this float[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Abs(this float[,] value, int[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Abs(this float[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Sqrt(this float[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Sqrt(this float[,] value, int[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Sqrt(this float[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] SignSqrt(this float[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] SignSqrt(this float[,] value, int[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] SignSqrt(this float[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Floor(this float[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Floor(this float[,] value, int[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Floor(this float[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Ceiling(this float[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Ceiling(this float[,] value, int[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Ceiling(this float[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Round(this float[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Round(this float[,] value, int[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Round(this float[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Exp(this float[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Exp(this float[,] value, short[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Exp(this float[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Log(this float[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Log(this float[,] value, short[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Log(this float[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Sign(this float[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Sign(this float[,] value, short[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Sign(this float[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Abs(this float[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Abs(this float[,] value, short[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Abs(this float[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Sqrt(this float[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Sqrt(this float[,] value, short[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Sqrt(this float[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] SignSqrt(this float[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] SignSqrt(this float[,] value, short[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] SignSqrt(this float[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Floor(this float[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Floor(this float[,] value, short[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Floor(this float[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Ceiling(this float[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Ceiling(this float[,] value, short[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Ceiling(this float[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Round(this float[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Round(this float[,] value, short[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Round(this float[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Exp(this float[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Exp(this float[,] value, float[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Exp(this float[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Log(this float[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Log(this float[,] value, float[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Log(this float[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Sign(this float[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Sign(this float[,] value, float[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Sign(this float[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Abs(this float[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Abs(this float[,] value, float[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Abs(this float[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Sqrt(this float[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Sqrt(this float[,] value, float[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Sqrt(this float[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] SignSqrt(this float[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] SignSqrt(this float[,] value, float[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] SignSqrt(this float[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Floor(this float[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Floor(this float[,] value, float[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Floor(this float[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Ceiling(this float[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Ceiling(this float[,] value, float[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Ceiling(this float[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Round(this float[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Round(this float[,] value, float[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Round(this float[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Exp(this float[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Exp(this float[,] value, double[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Exp(this float[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Log(this float[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Log(this float[,] value, double[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Log(this float[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Sign(this float[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Sign(this float[,] value, double[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Sign(this float[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Abs(this float[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Abs(this float[,] value, double[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Abs(this float[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Sqrt(this float[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Sqrt(this float[,] value, double[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Sqrt(this float[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] SignSqrt(this float[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] SignSqrt(this float[,] value, double[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] SignSqrt(this float[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Floor(this float[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Floor(this float[,] value, double[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Floor(this float[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Ceiling(this float[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Ceiling(this float[,] value, double[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Ceiling(this float[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Round(this float[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Round(this float[,] value, double[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Round(this float[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Exp(this float[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Exp(this float[,] value, long[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Exp(this float[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Log(this float[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Log(this float[,] value, long[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Log(this float[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Sign(this float[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Sign(this float[,] value, long[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Sign(this float[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Abs(this float[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Abs(this float[,] value, long[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Abs(this float[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Sqrt(this float[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Sqrt(this float[,] value, long[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Sqrt(this float[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] SignSqrt(this float[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] SignSqrt(this float[,] value, long[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] SignSqrt(this float[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Floor(this float[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Floor(this float[,] value, long[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Floor(this float[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Ceiling(this float[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Ceiling(this float[,] value, long[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Ceiling(this float[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Round(this float[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Round(this float[,] value, long[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Round(this float[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Exp(this float[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Exp(this float[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Exp(this float[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Log(this float[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Log(this float[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Log(this float[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Sign(this float[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Sign(this float[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Sign(this float[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Abs(this float[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Abs(this float[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Abs(this float[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Sqrt(this float[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Sqrt(this float[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Sqrt(this float[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] SignSqrt(this float[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] SignSqrt(this float[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] SignSqrt(this float[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Floor(this float[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Floor(this float[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Floor(this float[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Ceiling(this float[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Ceiling(this float[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Ceiling(this float[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Round(this float[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Round(this float[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Round(this float[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Exp(this double[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Exp(this double[,] value, int[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Exp(this double[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Log(this double[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Log(this double[,] value, int[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Log(this double[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Sign(this double[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Sign(this double[,] value, int[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Sign(this double[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Abs(this double[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Abs(this double[,] value, int[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Abs(this double[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Sqrt(this double[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Sqrt(this double[,] value, int[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Sqrt(this double[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] SignSqrt(this double[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] SignSqrt(this double[,] value, int[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] SignSqrt(this double[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Floor(this double[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Floor(this double[,] value, int[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Floor(this double[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Ceiling(this double[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Ceiling(this double[,] value, int[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Ceiling(this double[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Round(this double[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Round(this double[,] value, int[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Round(this double[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Exp(this double[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Exp(this double[,] value, short[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Exp(this double[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Log(this double[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Log(this double[,] value, short[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Log(this double[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Sign(this double[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Sign(this double[,] value, short[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Sign(this double[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Abs(this double[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Abs(this double[,] value, short[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Abs(this double[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Sqrt(this double[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Sqrt(this double[,] value, short[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Sqrt(this double[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] SignSqrt(this double[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] SignSqrt(this double[,] value, short[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] SignSqrt(this double[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Floor(this double[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Floor(this double[,] value, short[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Floor(this double[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Ceiling(this double[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Ceiling(this double[,] value, short[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Ceiling(this double[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Round(this double[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Round(this double[,] value, short[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Round(this double[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Exp(this double[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Exp(this double[,] value, float[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Exp(this double[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Log(this double[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Log(this double[,] value, float[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Log(this double[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Sign(this double[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Sign(this double[,] value, float[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Sign(this double[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Abs(this double[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Abs(this double[,] value, float[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Abs(this double[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Sqrt(this double[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Sqrt(this double[,] value, float[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Sqrt(this double[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] SignSqrt(this double[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] SignSqrt(this double[,] value, float[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] SignSqrt(this double[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Floor(this double[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Floor(this double[,] value, float[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Floor(this double[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Ceiling(this double[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Ceiling(this double[,] value, float[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Ceiling(this double[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Round(this double[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Round(this double[,] value, float[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Round(this double[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Exp(this double[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Exp(this double[,] value, double[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Exp(this double[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Log(this double[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Log(this double[,] value, double[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Log(this double[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Sign(this double[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Sign(this double[,] value, double[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Sign(this double[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Abs(this double[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Abs(this double[,] value, double[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Abs(this double[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Sqrt(this double[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Sqrt(this double[,] value, double[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Sqrt(this double[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] SignSqrt(this double[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] SignSqrt(this double[,] value, double[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] SignSqrt(this double[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Floor(this double[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Floor(this double[,] value, double[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Floor(this double[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Ceiling(this double[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Ceiling(this double[,] value, double[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Ceiling(this double[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Round(this double[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Round(this double[,] value, double[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Round(this double[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Exp(this double[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Exp(this double[,] value, long[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Exp(this double[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Log(this double[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Log(this double[,] value, long[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Log(this double[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Sign(this double[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Sign(this double[,] value, long[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Sign(this double[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Abs(this double[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Abs(this double[,] value, long[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Abs(this double[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Sqrt(this double[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Sqrt(this double[,] value, long[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Sqrt(this double[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] SignSqrt(this double[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] SignSqrt(this double[,] value, long[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] SignSqrt(this double[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Floor(this double[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Floor(this double[,] value, long[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Floor(this double[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Ceiling(this double[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Ceiling(this double[,] value, long[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Ceiling(this double[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Round(this double[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Round(this double[,] value, long[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Round(this double[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Exp(this double[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Exp(this double[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Exp(this double[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Log(this double[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Log(this double[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Log(this double[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Sign(this double[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Sign(this double[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Sign(this double[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Abs(this double[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Abs(this double[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Abs(this double[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Sqrt(this double[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Sqrt(this double[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Sqrt(this double[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] SignSqrt(this double[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] SignSqrt(this double[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] SignSqrt(this double[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Floor(this double[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Floor(this double[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Floor(this double[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Ceiling(this double[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Ceiling(this double[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Ceiling(this double[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Round(this double[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Round(this double[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Round(this double[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Exp(this long[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Exp(this long[,] value, int[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Exp(this long[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Log(this long[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Log(this long[,] value, int[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Log(this long[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Sign(this long[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Sign(this long[,] value, int[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Sign(this long[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Abs(this long[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Abs(this long[,] value, int[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Abs(this long[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Sqrt(this long[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Sqrt(this long[,] value, int[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Sqrt(this long[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] SignSqrt(this long[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] SignSqrt(this long[,] value, int[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] SignSqrt(this long[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Floor(this long[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Floor(this long[,] value, int[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Floor(this long[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Ceiling(this long[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Ceiling(this long[,] value, int[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Ceiling(this long[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Round(this long[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Round(this long[,] value, int[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Round(this long[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Exp(this long[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Exp(this long[,] value, short[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Exp(this long[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Log(this long[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Log(this long[,] value, short[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Log(this long[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Sign(this long[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Sign(this long[,] value, short[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Sign(this long[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Abs(this long[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Abs(this long[,] value, short[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Abs(this long[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Sqrt(this long[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Sqrt(this long[,] value, short[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Sqrt(this long[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] SignSqrt(this long[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] SignSqrt(this long[,] value, short[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] SignSqrt(this long[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Floor(this long[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Floor(this long[,] value, short[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Floor(this long[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Ceiling(this long[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Ceiling(this long[,] value, short[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Ceiling(this long[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Round(this long[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Round(this long[,] value, short[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Round(this long[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Exp(this long[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Exp(this long[,] value, float[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Exp(this long[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Log(this long[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Log(this long[,] value, float[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Log(this long[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Sign(this long[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Sign(this long[,] value, float[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Sign(this long[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Abs(this long[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Abs(this long[,] value, float[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Abs(this long[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Sqrt(this long[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Sqrt(this long[,] value, float[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Sqrt(this long[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] SignSqrt(this long[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] SignSqrt(this long[,] value, float[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] SignSqrt(this long[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Floor(this long[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Floor(this long[,] value, float[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Floor(this long[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Ceiling(this long[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Ceiling(this long[,] value, float[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Ceiling(this long[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Round(this long[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Round(this long[,] value, float[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Round(this long[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Exp(this long[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Exp(this long[,] value, double[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Exp(this long[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Log(this long[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Log(this long[,] value, double[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Log(this long[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Sign(this long[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Sign(this long[,] value, double[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Sign(this long[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Abs(this long[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Abs(this long[,] value, double[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Abs(this long[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Sqrt(this long[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Sqrt(this long[,] value, double[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Sqrt(this long[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] SignSqrt(this long[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] SignSqrt(this long[,] value, double[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] SignSqrt(this long[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Floor(this long[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Floor(this long[,] value, double[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Floor(this long[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Ceiling(this long[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Ceiling(this long[,] value, double[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Ceiling(this long[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Round(this long[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Round(this long[,] value, double[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Round(this long[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Exp(this long[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Exp(this long[,] value, long[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Exp(this long[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Log(this long[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Log(this long[,] value, long[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Log(this long[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Sign(this long[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Sign(this long[,] value, long[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Sign(this long[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Abs(this long[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Abs(this long[,] value, long[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Abs(this long[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Sqrt(this long[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Sqrt(this long[,] value, long[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Sqrt(this long[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] SignSqrt(this long[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] SignSqrt(this long[,] value, long[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] SignSqrt(this long[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Floor(this long[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Floor(this long[,] value, long[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Floor(this long[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Ceiling(this long[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Ceiling(this long[,] value, long[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Ceiling(this long[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Round(this long[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Round(this long[,] value, long[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Round(this long[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Exp(this long[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Exp(this long[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Exp(this long[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Log(this long[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Log(this long[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Log(this long[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Sign(this long[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Sign(this long[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Sign(this long[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Abs(this long[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Abs(this long[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Abs(this long[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Sqrt(this long[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Sqrt(this long[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Sqrt(this long[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] SignSqrt(this long[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] SignSqrt(this long[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] SignSqrt(this long[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Floor(this long[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Floor(this long[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Floor(this long[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Ceiling(this long[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Ceiling(this long[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Ceiling(this long[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Round(this long[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Round(this long[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Round(this long[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Exp(this decimal[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Exp(this decimal[,] value, int[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Exp(this decimal[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Log(this decimal[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Log(this decimal[,] value, int[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Log(this decimal[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Sign(this decimal[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Sign(this decimal[,] value, int[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Sign(this decimal[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Abs(this decimal[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Abs(this decimal[,] value, int[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Abs(this decimal[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Sqrt(this decimal[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Sqrt(this decimal[,] value, int[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Sqrt(this decimal[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] SignSqrt(this decimal[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] SignSqrt(this decimal[,] value, int[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] SignSqrt(this decimal[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Floor(this decimal[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Floor(this decimal[,] value, int[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Floor(this decimal[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Ceiling(this decimal[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Ceiling(this decimal[,] value, int[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Ceiling(this decimal[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Round(this decimal[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Round(this decimal[,] value, int[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Round(this decimal[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Exp(this decimal[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Exp(this decimal[,] value, short[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Exp(this decimal[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Log(this decimal[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Log(this decimal[,] value, short[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Log(this decimal[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Sign(this decimal[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Sign(this decimal[,] value, short[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Sign(this decimal[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Abs(this decimal[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Abs(this decimal[,] value, short[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Abs(this decimal[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Sqrt(this decimal[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Sqrt(this decimal[,] value, short[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Sqrt(this decimal[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] SignSqrt(this decimal[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] SignSqrt(this decimal[,] value, short[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] SignSqrt(this decimal[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Floor(this decimal[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Floor(this decimal[,] value, short[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Floor(this decimal[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Ceiling(this decimal[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Ceiling(this decimal[,] value, short[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Ceiling(this decimal[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Round(this decimal[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Round(this decimal[,] value, short[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Round(this decimal[][] value, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Exp(this decimal[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Exp(this decimal[,] value, float[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Exp(this decimal[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Log(this decimal[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Log(this decimal[,] value, float[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Log(this decimal[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Sign(this decimal[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Sign(this decimal[,] value, float[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Sign(this decimal[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Abs(this decimal[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Abs(this decimal[,] value, float[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Abs(this decimal[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Sqrt(this decimal[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Sqrt(this decimal[,] value, float[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Sqrt(this decimal[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] SignSqrt(this decimal[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] SignSqrt(this decimal[,] value, float[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] SignSqrt(this decimal[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Floor(this decimal[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Floor(this decimal[,] value, float[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Floor(this decimal[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Ceiling(this decimal[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Ceiling(this decimal[,] value, float[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Ceiling(this decimal[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Round(this decimal[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Round(this decimal[,] value, float[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Round(this decimal[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Exp(this decimal[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Exp(this decimal[,] value, double[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Exp(this decimal[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Log(this decimal[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Log(this decimal[,] value, double[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Log(this decimal[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Sign(this decimal[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Sign(this decimal[,] value, double[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Sign(this decimal[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Abs(this decimal[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Abs(this decimal[,] value, double[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Abs(this decimal[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Sqrt(this decimal[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Sqrt(this decimal[,] value, double[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Sqrt(this decimal[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] SignSqrt(this decimal[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] SignSqrt(this decimal[,] value, double[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] SignSqrt(this decimal[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Floor(this decimal[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Floor(this decimal[,] value, double[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Floor(this decimal[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Ceiling(this decimal[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Ceiling(this decimal[,] value, double[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Ceiling(this decimal[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Round(this decimal[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Round(this decimal[,] value, double[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Round(this decimal[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Exp(this decimal[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Exp(this decimal[,] value, long[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Exp(this decimal[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Log(this decimal[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Log(this decimal[,] value, long[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Log(this decimal[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Sign(this decimal[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Sign(this decimal[,] value, long[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Sign(this decimal[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Abs(this decimal[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Abs(this decimal[,] value, long[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Abs(this decimal[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Sqrt(this decimal[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Sqrt(this decimal[,] value, long[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Sqrt(this decimal[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] SignSqrt(this decimal[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] SignSqrt(this decimal[,] value, long[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] SignSqrt(this decimal[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Floor(this decimal[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Floor(this decimal[,] value, long[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Floor(this decimal[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Ceiling(this decimal[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Ceiling(this decimal[,] value, long[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Ceiling(this decimal[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Round(this decimal[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Round(this decimal[,] value, long[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Round(this decimal[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Exp(this decimal[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Exp(this decimal[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Exp(this decimal[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Log(this decimal[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Log(this decimal[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Log(this decimal[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Sign(this decimal[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Sign(this decimal[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Sign(this decimal[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Abs(this decimal[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Abs(this decimal[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Abs(this decimal[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Sqrt(this decimal[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Sqrt(this decimal[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Sqrt(this decimal[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] SignSqrt(this decimal[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] SignSqrt(this decimal[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] SignSqrt(this decimal[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Floor(this decimal[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Floor((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Floor(this decimal[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Floor((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise floor.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Floor(this decimal[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Floor((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Ceiling(this decimal[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Ceiling((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Ceiling(this decimal[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Ceiling((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise ceiling.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Ceiling(this decimal[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Ceiling((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Round(this decimal[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Round((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Round(this decimal[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Round((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise round.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Round(this decimal[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Round((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] SignedPow(this int[] value, double y)
        {
            return SignedPow(value, y, new int[value.Length]);
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] SignedPow(this int[,] value, double y)
        {
            return SignedPow(value, y, MatrixCreateAs<int, int>(value));
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] SignedPow(this int[][] value, double y)
        {
            return SignedPow(value, y, JaggedCreateAs<int, int>(value));
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Pow(this int[] value, double y)
        {
            return Pow(value, y, new int[value.Length]);
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Pow(this int[,] value, double y)
        {
            return Pow(value, y, MatrixCreateAs<int, int>(value));
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Pow(this int[][] value, double y)
        {
            return Pow(value, y, JaggedCreateAs<int, int>(value));
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] SignedPow(this short[] value, double y)
        {
            return SignedPow(value, y, new short[value.Length]);
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] SignedPow(this short[,] value, double y)
        {
            return SignedPow(value, y, MatrixCreateAs<short, short>(value));
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] SignedPow(this short[][] value, double y)
        {
            return SignedPow(value, y, JaggedCreateAs<short, short>(value));
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Pow(this short[] value, double y)
        {
            return Pow(value, y, new short[value.Length]);
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Pow(this short[,] value, double y)
        {
            return Pow(value, y, MatrixCreateAs<short, short>(value));
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Pow(this short[][] value, double y)
        {
            return Pow(value, y, JaggedCreateAs<short, short>(value));
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] SignedPow(this float[] value, double y)
        {
            return SignedPow(value, y, new float[value.Length]);
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] SignedPow(this float[,] value, double y)
        {
            return SignedPow(value, y, MatrixCreateAs<float, float>(value));
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] SignedPow(this float[][] value, double y)
        {
            return SignedPow(value, y, JaggedCreateAs<float, float>(value));
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Pow(this float[] value, double y)
        {
            return Pow(value, y, new float[value.Length]);
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Pow(this float[,] value, double y)
        {
            return Pow(value, y, MatrixCreateAs<float, float>(value));
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Pow(this float[][] value, double y)
        {
            return Pow(value, y, JaggedCreateAs<float, float>(value));
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] SignedPow(this double[] value, double y)
        {
            return SignedPow(value, y, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] SignedPow(this double[,] value, double y)
        {
            return SignedPow(value, y, MatrixCreateAs<double, double>(value));
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] SignedPow(this double[][] value, double y)
        {
            return SignedPow(value, y, JaggedCreateAs<double, double>(value));
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Pow(this double[] value, double y)
        {
            return Pow(value, y, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Pow(this double[,] value, double y)
        {
            return Pow(value, y, MatrixCreateAs<double, double>(value));
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Pow(this double[][] value, double y)
        {
            return Pow(value, y, JaggedCreateAs<double, double>(value));
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] SignedPow(this long[] value, double y)
        {
            return SignedPow(value, y, new long[value.Length]);
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] SignedPow(this long[,] value, double y)
        {
            return SignedPow(value, y, MatrixCreateAs<long, long>(value));
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] SignedPow(this long[][] value, double y)
        {
            return SignedPow(value, y, JaggedCreateAs<long, long>(value));
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Pow(this long[] value, double y)
        {
            return Pow(value, y, new long[value.Length]);
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Pow(this long[,] value, double y)
        {
            return Pow(value, y, MatrixCreateAs<long, long>(value));
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Pow(this long[][] value, double y)
        {
            return Pow(value, y, JaggedCreateAs<long, long>(value));
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] SignedPow(this decimal[] value, double y)
        {
            return SignedPow(value, y, new decimal[value.Length]);
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] SignedPow(this decimal[,] value, double y)
        {
            return SignedPow(value, y, MatrixCreateAs<decimal, decimal>(value));
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] SignedPow(this decimal[][] value, double y)
        {
            return SignedPow(value, y, JaggedCreateAs<decimal, decimal>(value));
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Pow(this decimal[] value, double y)
        {
            return Pow(value, y, new decimal[value.Length]);
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Pow(this decimal[,] value, double y)
        {
            return Pow(value, y, MatrixCreateAs<decimal, decimal>(value));
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Pow(this decimal[][] value, double y)
        {
            return Pow(value, y, JaggedCreateAs<decimal, decimal>(value));
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] SignedPow(this int[] value, double y, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] SignedPow(this int[,] value, double y, int[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] SignedPow(this int[][] value, double y, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Pow(this int[] value, double y, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Pow(this int[,] value, double y, int[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Pow(this int[][] value, double y, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] SignedPow(this int[] value, double y, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] SignedPow(this int[,] value, double y, short[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] SignedPow(this int[][] value, double y, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Pow(this int[] value, double y, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Pow(this int[,] value, double y, short[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Pow(this int[][] value, double y, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] SignedPow(this int[] value, double y, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] SignedPow(this int[,] value, double y, float[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] SignedPow(this int[][] value, double y, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Pow(this int[] value, double y, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Pow(this int[,] value, double y, float[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Pow(this int[][] value, double y, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] SignedPow(this int[] value, double y, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] SignedPow(this int[,] value, double y, double[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] SignedPow(this int[][] value, double y, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Pow(this int[] value, double y, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Pow(this int[,] value, double y, double[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Pow(this int[][] value, double y, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] SignedPow(this int[] value, double y, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] SignedPow(this int[,] value, double y, long[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] SignedPow(this int[][] value, double y, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Pow(this int[] value, double y, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Pow(this int[,] value, double y, long[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Pow(this int[][] value, double y, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] SignedPow(this int[] value, double y, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] SignedPow(this int[,] value, double y, decimal[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] SignedPow(this int[][] value, double y, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Pow(this int[] value, double y, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Pow(this int[,] value, double y, decimal[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Pow(this int[][] value, double y, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] SignedPow(this short[] value, double y, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] SignedPow(this short[,] value, double y, int[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] SignedPow(this short[][] value, double y, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Pow(this short[] value, double y, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Pow(this short[,] value, double y, int[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Pow(this short[][] value, double y, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] SignedPow(this short[] value, double y, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] SignedPow(this short[,] value, double y, short[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] SignedPow(this short[][] value, double y, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Pow(this short[] value, double y, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Pow(this short[,] value, double y, short[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Pow(this short[][] value, double y, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] SignedPow(this short[] value, double y, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] SignedPow(this short[,] value, double y, float[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] SignedPow(this short[][] value, double y, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Pow(this short[] value, double y, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Pow(this short[,] value, double y, float[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Pow(this short[][] value, double y, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] SignedPow(this short[] value, double y, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] SignedPow(this short[,] value, double y, double[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] SignedPow(this short[][] value, double y, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Pow(this short[] value, double y, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Pow(this short[,] value, double y, double[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Pow(this short[][] value, double y, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] SignedPow(this short[] value, double y, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] SignedPow(this short[,] value, double y, long[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] SignedPow(this short[][] value, double y, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Pow(this short[] value, double y, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Pow(this short[,] value, double y, long[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Pow(this short[][] value, double y, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] SignedPow(this short[] value, double y, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] SignedPow(this short[,] value, double y, decimal[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] SignedPow(this short[][] value, double y, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Pow(this short[] value, double y, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Pow(this short[,] value, double y, decimal[,] result)
        {
            unsafe
            {
                fixed (short* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Pow(this short[][] value, double y, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] SignedPow(this float[] value, double y, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] SignedPow(this float[,] value, double y, int[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] SignedPow(this float[][] value, double y, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Pow(this float[] value, double y, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Pow(this float[,] value, double y, int[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Pow(this float[][] value, double y, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] SignedPow(this float[] value, double y, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] SignedPow(this float[,] value, double y, short[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] SignedPow(this float[][] value, double y, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Pow(this float[] value, double y, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Pow(this float[,] value, double y, short[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Pow(this float[][] value, double y, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] SignedPow(this float[] value, double y, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] SignedPow(this float[,] value, double y, float[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] SignedPow(this float[][] value, double y, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Pow(this float[] value, double y, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Pow(this float[,] value, double y, float[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Pow(this float[][] value, double y, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] SignedPow(this float[] value, double y, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] SignedPow(this float[,] value, double y, double[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] SignedPow(this float[][] value, double y, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Pow(this float[] value, double y, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Pow(this float[,] value, double y, double[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Pow(this float[][] value, double y, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] SignedPow(this float[] value, double y, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] SignedPow(this float[,] value, double y, long[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] SignedPow(this float[][] value, double y, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Pow(this float[] value, double y, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Pow(this float[,] value, double y, long[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Pow(this float[][] value, double y, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] SignedPow(this float[] value, double y, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] SignedPow(this float[,] value, double y, decimal[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] SignedPow(this float[][] value, double y, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Pow(this float[] value, double y, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Pow(this float[,] value, double y, decimal[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Pow(this float[][] value, double y, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] SignedPow(this double[] value, double y, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] SignedPow(this double[,] value, double y, int[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] SignedPow(this double[][] value, double y, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Pow(this double[] value, double y, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Pow(this double[,] value, double y, int[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Pow(this double[][] value, double y, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] SignedPow(this double[] value, double y, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] SignedPow(this double[,] value, double y, short[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] SignedPow(this double[][] value, double y, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Pow(this double[] value, double y, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Pow(this double[,] value, double y, short[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Pow(this double[][] value, double y, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] SignedPow(this double[] value, double y, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] SignedPow(this double[,] value, double y, float[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] SignedPow(this double[][] value, double y, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Pow(this double[] value, double y, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Pow(this double[,] value, double y, float[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Pow(this double[][] value, double y, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] SignedPow(this double[] value, double y, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] SignedPow(this double[,] value, double y, double[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] SignedPow(this double[][] value, double y, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Pow(this double[] value, double y, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Pow(this double[,] value, double y, double[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Pow(this double[][] value, double y, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] SignedPow(this double[] value, double y, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] SignedPow(this double[,] value, double y, long[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] SignedPow(this double[][] value, double y, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Pow(this double[] value, double y, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Pow(this double[,] value, double y, long[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Pow(this double[][] value, double y, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] SignedPow(this double[] value, double y, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] SignedPow(this double[,] value, double y, decimal[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] SignedPow(this double[][] value, double y, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Pow(this double[] value, double y, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Pow(this double[,] value, double y, decimal[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Pow(this double[][] value, double y, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] SignedPow(this long[] value, double y, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] SignedPow(this long[,] value, double y, int[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] SignedPow(this long[][] value, double y, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Pow(this long[] value, double y, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Pow(this long[,] value, double y, int[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Pow(this long[][] value, double y, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] SignedPow(this long[] value, double y, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] SignedPow(this long[,] value, double y, short[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] SignedPow(this long[][] value, double y, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Pow(this long[] value, double y, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Pow(this long[,] value, double y, short[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Pow(this long[][] value, double y, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] SignedPow(this long[] value, double y, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] SignedPow(this long[,] value, double y, float[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] SignedPow(this long[][] value, double y, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Pow(this long[] value, double y, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Pow(this long[,] value, double y, float[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Pow(this long[][] value, double y, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] SignedPow(this long[] value, double y, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] SignedPow(this long[,] value, double y, double[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] SignedPow(this long[][] value, double y, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Pow(this long[] value, double y, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Pow(this long[,] value, double y, double[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Pow(this long[][] value, double y, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] SignedPow(this long[] value, double y, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] SignedPow(this long[,] value, double y, long[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] SignedPow(this long[][] value, double y, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Pow(this long[] value, double y, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Pow(this long[,] value, double y, long[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Pow(this long[][] value, double y, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] SignedPow(this long[] value, double y, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] SignedPow(this long[,] value, double y, decimal[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] SignedPow(this long[][] value, double y, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Pow(this long[] value, double y, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Pow(this long[,] value, double y, decimal[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Pow(this long[][] value, double y, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] SignedPow(this decimal[] value, double y, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] SignedPow(this decimal[,] value, double y, int[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] SignedPow(this decimal[][] value, double y, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] Pow(this decimal[] value, double y, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] Pow(this decimal[,] value, double y, int[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] Pow(this decimal[][] value, double y, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] SignedPow(this decimal[] value, double y, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] SignedPow(this decimal[,] value, double y, short[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] SignedPow(this decimal[][] value, double y, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] Pow(this decimal[] value, double y, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (short)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] Pow(this decimal[,] value, double y, short[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (short* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (short)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] Pow(this decimal[][] value, double y, short[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (short)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] SignedPow(this decimal[] value, double y, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] SignedPow(this decimal[,] value, double y, float[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] SignedPow(this decimal[][] value, double y, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] Pow(this decimal[] value, double y, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] Pow(this decimal[,] value, double y, float[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] Pow(this decimal[][] value, double y, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] SignedPow(this decimal[] value, double y, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] SignedPow(this decimal[,] value, double y, double[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] SignedPow(this decimal[][] value, double y, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] Pow(this decimal[] value, double y, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] Pow(this decimal[,] value, double y, double[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] Pow(this decimal[][] value, double y, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] SignedPow(this decimal[] value, double y, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] SignedPow(this decimal[,] value, double y, long[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] SignedPow(this decimal[][] value, double y, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] Pow(this decimal[] value, double y, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] Pow(this decimal[,] value, double y, long[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] Pow(this decimal[][] value, double y, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] SignedPow(this decimal[] value, double y, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] SignedPow(this decimal[,] value, double y, decimal[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] SignedPow(this decimal[][] value, double y, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] Pow(this decimal[] value, double y, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] Pow(this decimal[,] value, double y, decimal[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] Pow(this decimal[][] value, double y, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
    }
}