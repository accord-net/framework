<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension="Generated.cs" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="System.Text" #>
<#@ include file="T4Toolbox.tt" #>
// Accord Math Library
// The Accord.NET Framework
// http://accord-framework.net
//
// Copyright © César Souza, 2009-2017
// cesarsouza at gmail.com
//
//    This library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    This library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with this library; if not, write to the Free Software
//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
//

// ======================================================================
// This code has been generated by a tool; do not edit manually. Instead,
// edit the T4 template Matrix.Comparisons.tt so this file can be regenerated. 
// ======================================================================

namespace Accord.Math
{
    using System;
    using System.CodeDom.Compiler;
    using Accord.Math;
    using System.Runtime.CompilerServices;

    public static partial class Elementwise
    {
<# 
    string[] types =
    { 
        "Int32", "Int16",
        "Single", "Double", 
        "Int64", "Decimal",
        "Byte", "sbyte", 
    };

    Action<StringBuilder, string, string, string, string, string, string> doubleTests = (sb, a, b, r, A, B, R) =>
    {
        if ((a == "Double" || a == "Single") && (b == "Double" || b == "Single"))
        {
            sb.AppendLine(String.Format("    if ({0}.IsNaN(A) && {1}.IsNaN(B))", a, b));
            sb.AppendLine(String.Format("{{ {0} = true; continue; }}", R));
            sb.AppendLine(String.Format("    if ({0}.IsNaN(A) ^ {1}.IsNaN(B))", a, b));
            sb.AppendLine(String.Format("{{ {0} = false; continue; }}", R));
            sb.AppendLine(String.Format("    if ({0}.IsPositiveInfinity(A) ^ {1}.IsPositiveInfinity(B))", a, b));
            sb.AppendLine(String.Format("{{ {0} = false; continue; }}", R));
            sb.AppendLine(String.Format("    if ({0}.IsNegativeInfinity(A) ^ {1}.IsNegativeInfinity(B))", a, b));
            sb.AppendLine(String.Format("{{ {0} = false; continue; }}", R));
        }
        else if (a == "Double" || a == "Single")
        {                   
            sb.AppendLine(String.Format("    if ({0}.IsNaN(A))", a));
            sb.AppendLine(String.Format("{{ {0} = false; continue; }}", R));
            sb.AppendLine(String.Format("    if ({0}.IsInfinity(A))", a));
            sb.AppendLine(String.Format("{{ {0} = false; continue; }}", R));
        }
        else if (b == "Double" || b == "Single")
        {                   
            sb.AppendLine(String.Format("    if ({0}.IsNaN(B))", b));
            sb.AppendLine(String.Format("{{ {0} = false; continue; }}", R));
            sb.AppendLine(String.Format("    if ({0}.IsInfinity(B))", b));
            sb.AppendLine(String.Format("{{ {0} = false; continue; }}", R));
        }
    };

    Func<string, string, string, string, string, string, string> atol = (a, b, r, A, B, R) =>
    {
        StringBuilder sb = new StringBuilder();
        sb.AppendLine("{");
        if (a == "Decimal" || b == "Decimal")
        {
            sb.AppendLine(String.Format("    var A = {0};", A));
            sb.AppendLine(String.Format("    var B = {0};", B));
            doubleTests(sb, a, b, r, A, B, R);
            sb.AppendLine(String.Format("    decimal C = (decimal)A;", A));
            sb.AppendLine(String.Format("    decimal D = (decimal)B;", B));
            sb.AppendLine("    if (C == D)");
            sb.AppendLine(String.Format("{{ {0} = true; continue; }}", R));
        }
        else
        {
            sb.AppendLine(String.Format("    var A = {0};", A));
            sb.AppendLine(String.Format("    var B = {0};", B));
            sb.AppendLine("    if (A == B)");
            sb.AppendLine(String.Format("{{ {0} = true; continue; }}", R));
            doubleTests(sb, a, b, r, A, B, R);
            sb.AppendLine(String.Format("    var C = A;", A));
            sb.AppendLine(String.Format("    var D = B;", B));
        }
        sb.AppendLine(String.Format("{{ {0} = (Math.Abs(C - D) <= atol); continue; }}", R));
        sb.AppendLine("}");
        string indent = new String(' ', 4 * 0);
        return indent + sb.ToString().Replace("\n", "\n" + indent);
    };

    Func<string, string, string, string, string, string, string> rtol = (a, b, r, A, B, R) =>
    {
        StringBuilder sb = new StringBuilder();
        sb.AppendLine("{");
        if (a == "Decimal" || b == "Decimal")
        {
            sb.AppendLine(String.Format("    var A = {0};", A));
            sb.AppendLine(String.Format("    var B = {0};", B));
            doubleTests(sb, a, b, r, A, B, R);
            sb.AppendLine(String.Format("    decimal C = (decimal)A;", A));
            sb.AppendLine(String.Format("    decimal D = (decimal)B;", B));
            sb.AppendLine("    if (C == D)");
            sb.AppendLine(String.Format("{{ {0} = true; continue; }}", R));
        }
        else
        {
            sb.AppendLine(String.Format("    var A = {0};", A));
            sb.AppendLine(String.Format("    var B = {0};", B));
            sb.AppendLine("    if (A == B)");
            sb.AppendLine(String.Format("{{ {0} = true; continue; }}", R));
            doubleTests(sb, a, b, r, A, B, R);
            sb.AppendLine(String.Format("    var C = A;", A));
            sb.AppendLine(String.Format("    var D = B;", B));
        }
        sb.AppendLine("    var delta = Math.Abs(C - D);");
        sb.AppendLine("    if (C == 0)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (delta <= rtol)");
        sb.AppendLine(String.Format("{{ {0} = true; continue; }}", R));
        sb.AppendLine("    }");
        sb.AppendLine("    else if (D == 0)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (delta <= rtol)");
        sb.AppendLine(String.Format("{{ {0} = true; continue; }}", R));
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine(String.Format("{{ {0} = (delta <= Math.Abs(C) * rtol); continue; }}", R));
        sb.AppendLine("}");
        string indent = new String(' ', 4 * 0);
        return indent + sb.ToString().Replace("\n", "\n" + indent);
    };

    Func<string, string, string, string, string, string, string> notol = (a, b, r, A, B, R) =>
    {
        StringBuilder sb = new StringBuilder();
        sb.AppendLine("{");
        if (a == "Decimal" || b == "Decimal")
        {
            sb.AppendLine(String.Format("    var A = (decimal){0};", A));
            sb.AppendLine(String.Format("    var B = (decimal){0};", B));
            sb.AppendLine(String.Format("{{ {0} = (A == B); continue; }}", R));
        }
        else
        {
            sb.AppendLine(String.Format("    var A = {0};", A));
            sb.AppendLine(String.Format("    var B = {0};", B));
            doubleTests(sb, a, b, r, A, B, R);
            sb.AppendLine(String.Format("{{ {0} = (A == B); continue; }}", R));
        }
        sb.AppendLine("}");
        string indent = new String(' ', 4 * 0);
        return indent + sb.ToString().Replace("\n", "\n" + indent);
    };

    Func<string, string, string, string, string, string, string> reference = (a, b, r, A, B, R) =>
    {
         StringBuilder sb = new StringBuilder();
         if (R == "[]")
            sb.AppendLine(String.Format("{0}{1} r = VectorCreateAs<{2},{3}>(a);", r, R, a, r));
        else if (R == "[][]")
            sb.AppendLine(String.Format("{0}{1} r = JaggedCreateAs<{2},{3}>(a);", r, R, a, r));
        else if (R == "[,]")
            sb.AppendLine(String.Format("{0}{1} r = MatrixCreateAs<{2},{3}>(a);", r, R, a, r));
        return sb.ToString();
    };


    foreach (string a in types)
    {
        foreach (string b in types)
        {
            string r = "bool";
            string tr = "Double";
            string ta = null;
            if (a == "Decimal" || b == "Decimal")
            {
                ta = "Decimal";
                tr = "Decimal";
            }
            else if (a == "Double" || b == "Double")
                ta = "Double";
            else if (a == "Single" || b == "Single")
                ta = "Single";
            else if (a == "Int64" || b == "Int64")
                ta = "Int64";
            else if (a == "Int32" || b == "Int32")
                ta = "Int32";
            else if (a == "Int16" || b == "Int16")
                ta = "Int16";
            else if (a == "Byte" || b == "Byte")
                ta = "Byte";
            else if (a == "sbyte" || b == "sbyte")
                ta = "byte";

#>
        /// <summary>
        ///   Determines whether two vectors contain the same values.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static bool[] Equals(<#=a#>[] a, <#=b#>[] b, <#=ta#> atol = 0, <#=tr#> rtol = 0)
        {
<#=reference(a, b, r, "[]", "[]", "[]")#>
            if (rtol > 0)
            {
                for (int i = 0; i < a.Length; i++)
<#=rtol(a, b, r, "a[i]", "b[i]", "r[i]")#>
            }
            else if (atol > 0)
            {
                for (int i = 0; i < a.Length; i++)
<#=atol(a, b, r, "a[i]", "b[i]", "r[i]")#>
            }
            else
            {
                for (int i = 0; i < a.Length; i++)
<#=notol(a, b, r, "a[i]", "b[i]", "r[i]")#>
            }

            return r;
        }

        /// <summary>
        ///   Determines whether two matrices contain the same values.
        /// </summary>
        ///
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static bool[,] Equals(<#=a#>[,] a, <#=b#>[,] b, <#=ta#> atol = 0, <#=tr#> rtol = 0)
        {
<#=reference(a, b, r, "[,]", "[,]", "[,]")#>
            unsafe
            {
                fixed (<#=a#>* ptrA = a)
                fixed (<#=b#>* ptrB = b)
                fixed (<#=r#>* ptrR = r)
                {
                    if (rtol > 0)
                    {
                        for (int i = 0; i < a.Length; i++)
<#=rtol(a, b, r, "ptrA[i]", "ptrB[i]", "ptrR[i]")#>
                    }
                    else if (atol > 0)
                    {
                        for (int i = 0; i < a.Length; i++)
<#=atol(a, b, r, "ptrA[i]", "ptrB[i]", "ptrR[i]")#>
                    }
                    else
                    {
                        for (int i = 0; i < a.Length; i++)
<#=notol(a, b, r, "ptrA[i]", "ptrB[i]", "ptrR[i]")#>
                    }
                }
            }

            return r;
        }

        /// <summary>
        ///   Determines whether two matrices contain the same values.
        /// </summary>
        ///
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static bool[][] Equals(<#=a#>[,] a, <#=b#>[][] b, <#=ta#> atol = 0, <#=tr#> rtol = 0)
        {
<#=reference(a, b, r, "[,]", "[][]", "[][]")#>
            if (rtol > 0)
            {
                for (int i = 0; i < b.Length; i++)
                    for (int j = 0; j < b[i].Length; j++)
<#=rtol(a, b, r, "a[i, j]", "b[i][j]", "r[i][j]")#>
            }
            else if (atol > 0)
            {
                for (int i = 0; i < b.Length; i++)
                    for (int j = 0; j < b[i].Length; j++)
<#=atol(a, b, r, "a[i, j]", "b[i][j]", "r[i][j]")#>
            }
            else
            {
                for (int i = 0; i < b.Length; i++)
                    for (int j = 0; j < b[i].Length; j++)
<#=notol(a, b, r, "a[i, j]", "b[i][j]", "r[i][j]")#>
            }

            return r;
        }

        /// <summary>
        ///   Determines whether two matrices contain the same values.
        /// </summary>
        ///
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static bool[][] Equals(<#=a#>[][] a, <#=b#>[,] b, <#=ta#> atol = 0, <#=tr#> rtol = 0)
        {
<#=reference(a, b, r, "[][]", "[,]", "[][]")#>
            if (rtol > 0)
            {
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
<#=rtol(a, b, r, "a[i][j]", "b[i, j]", "r[i][j]")#>
            }
            else if (atol > 0)
            {
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
<#=atol(a, b, r, "a[i][j]", "b[i, j]", "r[i][j]")#>
            }
            else
            {
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
<#=notol(a, b, r, "a[i][j]", "b[i, j]", "r[i][j]")#>
            }

            return r;
        }

        /// <summary>
        ///   Determines whether two matrices contain the same values.
        /// </summary>
        ///
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static bool[][] Equals(<#=a#>[][] a, <#=b#>[][] b, <#=ta#> atol = 0, <#=tr#> rtol = 0)
        {
<#=reference(a, b, r, "[][]", "[][]", "[][]")#>
            if (rtol > 0)
            {
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
<#=rtol(a, b, r, "a[i][j]", "b[i][j]", "r[i][j]")#>
            }
            else if (atol > 0)
            {
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
<#=atol(a, b, r, "a[i][j]", "b[i][j]", "r[i][j]")#>
            }
            else
            {
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
<#=notol(a, b, r, "a[i][j]", "b[i][j]", "r[i][j]")#>
            }

            return r;
        }










        /// <summary>
        ///   Determines whether two vectors contain the same values.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static bool[] Equals(<#=a#>[] a, <#=b#> b, <#=ta#> atol = 0, <#=tr#> rtol = 0)
        {
<#=reference(a, b, r, "[]", "", "[]")#>
            if (rtol > 0)
            {
                for (int i = 0; i < a.Length; i++)
<#=rtol(a, b, r, "a[i]", "b", "r[i]")#>
            }
            else if (atol > 0)
            {
                for (int i = 0; i < a.Length; i++)
<#=atol(a, b, r, "a[i]", "b", "r[i]")#>
            }
            else
            {
                for (int i = 0; i < a.Length; i++)
<#=notol(a, b, r, "a[i]", "b", "r[i]")#>
            }

            return r;
        }

        /// <summary>
        ///   Determines whether two matrices contain the same values.
        /// </summary>
        ///
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static bool[,] Equals(<#=a#>[,] a, <#=b#> b, <#=ta#> atol = 0, <#=tr#> rtol = 0)
        {
<#=reference(a, b, r, "[,]", "", "[,]")#>
            unsafe
            {
                fixed (<#=a#>* ptrA = a)
                fixed (<#=r#>* ptrR = r)
                {
                    if (rtol > 0)
                    {
                        for (int i = 0; i < a.Length; i++)
<#=rtol(a, b, r, "ptrA[i]", "b", "ptrR[i]")#>
                    }
                    else if (atol > 0)
                    {
                        for (int i = 0; i < a.Length; i++)
<#=atol(a, b, r, "ptrA[i]", "b", "ptrR[i]")#>
                    }
                    else
                    {
                        for (int i = 0; i < a.Length; i++)
<#=notol(a, b, r, "ptrA[i]", "b", "ptrR[i]")#>
                    }
                }
            }

            return r;
        }

        /// <summary>
        ///   Determines whether two matrices contain the same values.
        /// </summary>
        ///
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static bool[][] Equals(<#=a#>[][] a, <#=b#> b, <#=ta#> atol = 0, <#=tr#> rtol = 0)
        {
<#=reference(a, b, r, "[][]", "", "[][]")#>
            if (rtol > 0)
            {
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
<#=rtol(a, b, r, "a[i][j]", "b", "r[i][j]")#>

            }
            else if (atol > 0)
            {
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
<#=atol(a, b, r, "a[i][j]", "b", "r[i][j]")#>
            }
            else
            {
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
<#=notol(a, b, r, "a[i][j]", "b", "r[i][j]")#>
            }

            return r;
        }



















        /// <summary>
        ///   Determines whether two vectors contain the same values.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static bool[] Equals(<#=a#> a, <#=b#>[] b, <#=ta#> atol = 0, <#=tr#> rtol = 0)
        {
            return Equals(b, a, rtol, atol);
        }

        /// <summary>
        ///   Determines whether two matrices contain the same values.
        /// </summary>
        ///
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static bool[,] Equals(<#=a#> a, <#=b#>[,] b, <#=ta#> atol = 0, <#=tr#> rtol = 0)
        {
            return Equals(b, a, rtol, atol);
        }

        /// <summary>
        ///   Determines whether two matrices contain the same values.
        /// </summary>
        ///
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static bool[][] Equals(<#=a#> a, <#=b#>[][] b, <#=ta#> atol = 0, <#=tr#> rtol = 0)
        {
            return Equals(b, a, rtol, atol);
        }

<#
        }
    }
#>
    }
}