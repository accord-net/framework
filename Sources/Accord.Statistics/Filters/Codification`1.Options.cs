// Accord Statistics Library
// The Accord.NET Framework
// http://accord-framework.net
//
// Copyright © César Souza, 2009-2017
// cesarsouza at gmail.com
//
//    This library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    This library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with this library; if not, write to the Free Software
//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
//

namespace Accord.Statistics.Filters
{
    using System;
    using System.Collections.Generic;
    using System.Data;
    using Accord.Math;
    using Accord.Collections;
    using MachineLearning;
    using System.Threading;

    public partial class Codification<T>
    {
        /// <summary>
        ///   Options for processing a column.
        /// </summary>
        /// 
        [Serializable]
        public class Options : ColumnOptionsBase,
            ITransform<T, int>, IClassifier<T, int>,
            ITransform<T, double[]>,
            IUnsupervisedLearning<Options, T, int>,
            IUnsupervisedLearning<Options, T, double[]>
        {

            bool hasMissingValue;
            T missingValue;
            object missingValueReplacement = DBNull.Value;

            /// <summary>
            ///   Gets or sets the label mapping for translating
            ///   integer labels to the original string labels.
            /// </summary>
            /// 
            public TwoWayDictionary<T, int> Mapping { get; private set; }

            /// <summary>
            ///   Gets or sets whether the column can contain missing values.
            /// </summary>
            /// 
            public bool HasMissingValue
            {
                get { return hasMissingValue; }
                set { hasMissingValue = value; }
            }

            /// <summary>
            ///   Gets or sets how missing values are represented in this column.
            /// </summary>
            /// 
            public T MissingValue
            {
                get { return missingValue; }
                set { missingValue = value; }
            }

            /// <summary>
            ///   Gets or sets a value to be used to replace missing values. Default
            ///   is to replace missing values using <c>System.DBNull.Value</c>.
            /// </summary>
            /// 
            public object MissingValueReplacement
            {
                get { return missingValueReplacement; }
                set { missingValueReplacement = value; }
            }

            /// <summary>
            ///   Gets the number of symbols used to code this variable.
            /// </summary>
            /// 
            [Obsolete("Please use NumberOfSymbols instead.")]
            public int Symbols { get { return Mapping.Count; } }

            /// <summary>
            ///   Gets the number of symbols used to code this variable.
            /// </summary>
            /// 
            public int NumberOfSymbols
            {
                get
                {
                    if (VariableType == CodificationVariable.Continuous || VariableType == CodificationVariable.Discrete)
                        return 1;
                    return Mapping.Count;
                }
            }

            /// <summary>
            ///   Gets the codification type that should be used for this variable.
            /// </summary>
            /// 
            public CodificationVariable VariableType { get; set; }

            /// <summary>
            ///   Gets the number of inputs accepted by the model (value will be 1).
            /// </summary>
            /// 
            /// <value>The number of inputs.</value>
            /// 
            public int NumberOfInputs { get; set; }

            /// <summary>
            /// Gets the number of outputs generated by the model (value will be 1).
            /// </summary>
            /// 
            /// <value>The number of outputs.</value>
            /// 
            public int NumberOfOutputs { get; set; }

            /// <summary>
            ///   Gets the values associated with each symbol, in the order of the symbols.
            /// </summary>
            /// 
            public T[] Values
            {
                get
                {
                    var values = new T[Mapping.Count];
                    for (int i = 0; i < values.Length; i++)
                        values[i] = Mapping.Reverse[i];
                    return values;
                }
            }

            /// <summary>
            /// Gets or sets the number of classes expected and recognized by the classifier.
            /// </summary>
            /// <value>The number of classes.</value>
            /// <exception cref="System.NotImplementedException"></exception>
            public int NumberOfClasses
            {
                get { return NumberOfSymbols; }
                set { throw new NotImplementedException(); }
            }


            /// <summary>
            ///   Determines whether the given object denotes a missing value.
            /// </summary>
            /// 
            public bool IsMissingValue(object value)
            {
                return this.HasMissingValue && (value is DBNull || Object.Equals(this.MissingValue, value));
            }

            /// <summary>
            ///   Forces the given key to have a specific symbol value.
            /// </summary>
            /// 
            /// <param name="key">The key.</param>
            /// <param name="value">The value that should be associated with this key.</param>
            /// 
            public void Remap(T key, int value)
            {
                int oldValue = Mapping[key];
                T oldKey = Mapping.Reverse[value];

                Mapping[key] = value;
                Mapping[oldKey] = oldValue;
            }

            /// <summary>
            /// Applies the transformation to an input, producing an associated output.
            /// </summary>
            /// <param name="input">The input data to which the transformation should be applied.</param>
            /// <returns>The output generated by applying this transformation to the given input.</returns>
            public int Transform(T input)
            {
                if (hasMissingValue && input.IsEqual(missingValue))
                    return -1;

                Check();
                return Mapping[input];
            }

            /// <summary>
            /// Applies the transformation to a set of input vectors,
            /// producing an associated set of output vectors.
            /// </summary>
            /// <param name="input">The input data to which
            /// the transformation should be applied.</param>
            /// <returns>The output generated by applying this
            /// transformation to the given input.</returns>
            public int[] Transform(T[] input)
            {
                return Transform(input, new int[input.Length]);
            }


            /// <summary>
            /// Applies the transformation to a set of input vectors,
            /// producing an associated set of output vectors.
            /// </summary>
            /// <param name="input">The input data to which
            /// the transformation should be applied.</param>
            /// <param name="result">The location to where to store the
            /// result of this transformation.</param>
            /// <returns>The output generated by applying this
            /// transformation to the given input.</returns>
            public int[] Transform(T[] input, int[] result)
            {
                for (int i = 0; i < input.Length; i++)
                    result[i] = Transform(input[i]);
                return result;
            }

            /// <summary>
            /// Applies the transformation to an input, producing an associated output.
            /// </summary>
            /// <param name="input">The input data to which the transformation should be applied.</param>
            /// <returns>The output generated by applying this transformation to the given input.</returns>
            public int Transform(DataRow input)
            {
                Check();
                return Transform((T)input[ColumnName]);
            }

            private void Check()
            {
                if (VariableType == CodificationVariable.Continuous)
                    throw new InvalidOperationException("The variable is continuous and cannot be codified as an integer.");
                if (VariableType == CodificationVariable.Discrete)
                    throw new InvalidOperationException("The variable is discrete and cannot be codified as an integer.");
            }

            /// <summary>
            /// Applies the transformation to an input, producing an associated output.
            /// </summary>
            /// <param name="input">The input data to which the transformation should be applied.</param>
            /// <returns>The output generated by applying this transformation to the given input.</returns>
            public int[] Transform(DataRow[] input)
            {
                return Transform(input, new int[input.Length]);
            }

            /// <summary>
            /// Applies the transformation to a set of input vectors,
            /// producing an associated set of output vectors.
            /// </summary>
            /// <param name="input">The input data to which
            /// the transformation should be applied.</param>
            /// <param name="result">The location to where to store the
            /// result of this transformation.</param>
            /// <returns>The output generated by applying this
            /// transformation to the given input.</returns>
            public int[] Transform(DataRow[] input, int[] result)
            {
                for (int i = 0; i < input.Length; i++)
                    result[i] = Transform(input[i]);
                return result;
            }

            /// <summary>
            /// Reverts the transformation to a set of output vectors,
            /// producing an associated set of input vectors.
            /// </summary>
            /// <param name="output">The input data to which
            /// the transformation should be reverted.</param>
            public T Revert(int output)
            {
                if (hasMissingValue && output == -1)
                    return missingValue;
                return Mapping.Reverse[output];
            }

            /// <summary>
            /// Reverts the transformation to a set of output vectors,
            /// producing an associated set of input vectors.
            /// </summary>
            /// <param name="output">The input data to which
            /// the transformation should be reverted.</param>
            public T[] Revert(int[] output)
            {
                return Revert(output, new T[output.Length]);
            }

            /// <summary>
            /// Reverts the transformation to a set of output vectors,
            /// producing an associated set of input vectors.
            /// </summary>
            /// <param name="output">The input data to which
            /// the transformation should be reverted.</param>
            /// <param name="result">The location to where to store the
            /// result of this transformation.</param>
            /// <returns>The input generated by reverting this
            /// transformation to the given output.</returns>
            public T[] Revert(int[] output, T[] result)
            {
                for (int i = 0; i < output.Length; i++)
                    result[i] = Revert(output[i]);
                return result;
            }

            /// <summary>
            /// Learns a model that can map the given inputs to the desired outputs.
            /// </summary>
            /// <param name="x">The model inputs.</param>
            /// <param name="weights">The weight of importance for each input sample.</param>
            /// <returns>A model that has learned how to produce suitable outputs
            /// given the input data <paramref name="x" />.</returns>
            /// <exception cref="System.ArgumentException">Weights are not supported and should be null.</exception>
            public Options Learn(T[] x, double[] weights = null)
            {
                if (weights != null)
                    throw new ArgumentException("Weights are not supported and should be null.");

                this.NumberOfInputs = 1;
                this.NumberOfOutputs = 1;

                if (CanBeCodified)
                {
                    T[] unique = x.Distinct();

                    // For each distinct value, create a corresponding integer
                    for (int i = 0; i < unique.Length; i++)
                    {
                        TryAddValue(unique[i]);

                        if (this.Token.IsCancellationRequested)
                            return this;
                    }
                }

                return this;
            }

            private bool CanBeCodified
            {
                get
                {
                    return VariableType == CodificationVariable.Categorical ||
                           VariableType == CodificationVariable.CategoricalWithBaseline ||
                           VariableType == CodificationVariable.Ordinal;
                }
            }

            /// <summary>
            /// Learns a model that can map the given inputs to the desired outputs.
            /// </summary>
            /// <param name="x">The model inputs.</param>
            /// <param name="weights">The weight of importance for each input sample.</param>
            /// <returns>A model that has learned how to produce suitable outputs
            /// given the input data <paramref name="x" />.</returns>
            /// <exception cref="System.ArgumentException">Weights are not supported and should be null.</exception>
            public Options Learn(DataTable x, double[] weights = null)
            {
                if (weights != null)
                    throw new ArgumentException("Weights are not supported and should be null.");

                this.NumberOfInputs = 1;
                this.NumberOfOutputs = 1;

                if (CanBeCodified)
                {
                    // Do a select distinct to get distinct values
                    DataTable d = x.DefaultView.ToTable(true, ColumnName);

                    // For each distinct value, create a corresponding integer
                    for (int i = 0; i < d.Rows.Count; i++)
                    {
                        TryAddValue(d.Rows[i][ColumnName]);

                        if (this.Token.IsCancellationRequested)
                            return this;
                    }
                }

                return this;
            }

            /// <summary>
            /// Learns a model that can map the given inputs to the desired outputs.
            /// </summary>
            /// <param name="x">The model inputs.</param>
            /// <param name="weights">The weight of importance for each input sample.</param>
            /// <returns>A model that has learned how to produce suitable outputs
            /// given the input data <paramref name="x" />.</returns>
            /// <exception cref="System.ArgumentException">Weights are not supported and should be null.</exception>
            public Options Learn(DataRow[] x, double[] weights = null)
            {
                if (weights != null)
                    throw new ArgumentException("Weights are not supported and should be null.");

                this.NumberOfInputs = 1;
                this.NumberOfOutputs = 1;

                if (CanBeCodified)
                {
                    // Do a select distinct to get distinct values
                    object[] column = x.Apply(xi => xi[ColumnName]);
                    object[] unique = x.Distinct();

                    // For each distinct value, create a corresponding integer
                    for (int i = 0; i < unique.Length; i++)
                    {
                        TryAddValue(unique[i]);

                        if (this.Token.IsCancellationRequested)
                            return this;
                    }
                }

                return this;
            }

            private void TryAddValue(object value)
            {
                if (value == null || value is DBNull)
                {
                    if (!hasMissingValue)
                    {
                        hasMissingValue = true;
                        missingValue = (T)System.Convert.ChangeType(null, typeof(T));
                    }
                }
                else
                {
                    T key = (T)value;
                    if (!Mapping.ContainsKey(key))
                        Mapping.Add(key, Mapping.Count); // And register the String->Integer mapping
                }
            }

            /// <summary>
            /// Computes a class-label decision for a given <paramref name="input" />.
            /// </summary>
            /// <param name="input">The input vector that should be classified into
            /// one of the <see cref="P:Accord.MachineLearning.ITransform.NumberOfOutputs" /> possible classes.</param>
            /// <returns>A class-label that best described <paramref name="input" /> according
            /// to this classifier.</returns>
            public int Decide(T input)
            {
                return Transform(input);
            }

            /// <summary>
            /// Computes class-label decisions for each vector in the given <paramref name="input" />.
            /// </summary>
            /// <param name="input">The input vectors that should be classified into
            /// one of the <see cref="P:Accord.MachineLearning.ITransform.NumberOfOutputs" /> possible classes.</param>
            /// <returns>The class-labels that best describe each <paramref name="input" />
            /// vectors according to this classifier.</returns>
            public int[] Decide(T[] input)
            {
                return Transform(input);
            }

            /// <summary>
            /// Computes class-label decisions for each vector in the given <paramref name="input" />.
            /// </summary>
            /// <param name="input">The input vectors that should be classified into
            /// one of the <see cref="P:Accord.MachineLearning.ITransform.NumberOfOutputs" /> possible classes.</param>
            /// <param name="result">The location where to store the class-labels.</param>
            /// <returns>The class-labels that best describe each <paramref name="input" />
            /// vectors according to this classifier.</returns>
            public int[] Decide(T[] input, int[] result)
            {
                return Transform(input, result);
            }

            /// <summary>
            /// Applies the transformation to an input, producing an associated output.
            /// </summary>
            /// <param name="input">The input data to which the transformation should be applied.</param>
            /// <returns>The output generated by applying this transformation to the given input.</returns>
            double[] ITransform<T, double[]>.Transform(T input)
            {
                return Vector.OneHot(Transform(input), columns: NumberOfClasses);
            }

            /// <summary>
            /// Applies the transformation to a set of input vectors,
            /// producing an associated set of output vectors.
            /// </summary>
            /// <param name="input">The input data to which
            /// the transformation should be applied.</param>
            /// <returns>The output generated by applying this
            /// transformation to the given input.</returns>
            double[][] ITransform<T, double[]>.Transform(T[] input)
            {
                return Transform(input, Jagged.Zeros(input.Length, NumberOfClasses));
            }

            /// <summary>
            /// Applies the transformation to a set of input vectors,
            /// producing an associated set of output vectors.
            /// </summary>
            /// <param name="input">The input data to which
            /// the transformation should be applied.</param>
            /// <param name="result">The location to where to store the
            /// result of this transformation.</param>
            /// <returns>The output generated by applying this
            /// transformation to the given input.</returns>
            public double[][] Transform(T[] input, double[][] result)
            {
                return Jagged.OneHot(Transform(input), result: result);
            }

            /// <summary>
            ///   Constructs a new Options object.
            /// </summary>
            /// 
            public Options()
                : this("New column")
            {
            }

            /// <summary>
            ///   Constructs a new Options object for the given column.
            /// </summary>
            /// 
            /// <param name="name">
            ///   The name of the column to create this options for.
            /// </param>
            /// 
            public Options(String name)
                : this(name, new Dictionary<T, int>())
            {
            }

            /// <summary>
            ///   Constructs a new Options object for the given column.
            /// </summary>
            /// 
            /// <param name="name">The name of the column to create this options for.</param>
            /// <param name="variableType">The type of the variable in the column.</param>
            /// 
            public Options(String name, CodificationVariable variableType)
                : this(name)
            {
                this.VariableType = variableType;
            }

            /// <summary>
            ///   Constructs a new Options object for the given column.
            /// </summary>
            /// 
            /// <param name="name">
            ///   The name of the column to create this options for.
            /// </param>
            /// 
            /// <param name="map">The initial mapping for this column.</param>
            /// 
            public Options(String name, Dictionary<T, int> map)
                : base(name)
            {
                this.Mapping = new TwoWayDictionary<T, int>(map);
                this.NumberOfInputs = 1;
                this.NumberOfOutputs = 1;
            }

        }
    }
}
