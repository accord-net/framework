<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension="Generated.cs" #>
<#@ assembly name="EnvDTE" #> 
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.15.0" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Microsoft.VisualStudio.Shell" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ include file="T4Toolbox.tt" #>
// Accord Math Library
// The Accord.NET Framework
// http://accord-framework.net
//
// Copyright © César Souza, 2009-2017
// cesarsouza at gmail.com
//
//    This library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    This library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with this library; if not, write to the Free Software
//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
//

// ======================================================================
// This code has been generated by a tool; do not edit manually. Instead,
// edit the T4 template Distance.tt so this file can be regenerated. 
// ======================================================================

namespace Accord.Math
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Runtime.CompilerServices;
    using Accord;
    using Accord.Math.Distances;
    using Accord.Math.Decompositions;
    using Accord.Compat;

    /// <summary>
    ///   Static class Distance. Defines a set of methods defining distance measures.
    /// </summary>
    /// 
    public static partial class Distance
    {
<#
    foreach (KeyValuePair<string, CodeElement> pair in FindClasses("Accord.Math.Distances", "", ""))
    {
        string name = pair.Key;
        CodeElement cls = pair.Value;
        if (cls.FullName.Contains("<T>"))
            continue;

        bool included = false;

        foreach (CodeElement ctor in GetConstructors(cls))
        {
            var ctorDocumentation = GetParameterDocumentation(ctor);
            String ctorParameters = GetParameterString(ctor, true);
            String ctorArguments = GetParameterString(ctor, false);

            foreach (CodeElement dist in GetMethods(cls, "Distance"))
            {
                var documentation = GetParameterDocumentation(dist);
                documentation.AddRange(ctorDocumentation);
                String parameters = GetParameterString(dist, true);
                String arguments = GetParameterString(dist, false);

                if (!String.IsNullOrEmpty(ctorParameters))
                    parameters += ", " + ctorParameters;
#>

        /// <summary>
        ///   Gets the <#=cls.Name#> distance between two points.
        /// </summary>
        ///  
<#
                foreach (var doc in documentation)
                {
#>
        /// <param name="<#=doc.Item1#>"><#=doc.Item2#></param>
<#
                }
#>        /// 
        /// <returns>The <#=cls.Name#> distance between x and y.</returns>
        /// 
        /// <example>
        ///   For examples, please see <see cref="Accord.Math.Distances.<#=cls.Name#>"/> documentation page.
        /// </example>
        ///
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double <#=cls.Name#>(<#=parameters#>)
        {
            // Note: this is an auto-generated method stub that forwards the call
            // to the actual implementation, indicated in the next line below:
<#
                if (String.IsNullOrEmpty(ctorParameters))
                {
                    included = true;
#>
            return cache<#=cls.Name#>.Distance(<#=arguments#>);
<#
                } 
                else
                {
#>
            return new <#=cls.Name#>(<#=ctorArguments#>).Distance(<#=arguments#>);
<#
                }
#>
        }
<#
            }
        }

        if (included)
        {
#>

        private static readonly <#=cls.Name#> cache<#=cls.Name#> = new <#=cls.Name#>();

<#
        }
    } 
#>
    }
}

<#+
    private List<CodeElement> GetConstructors(CodeElement cls)
    {
        var methods = GetMethods(cls, cls.Name);

        if (cls is CodeStruct)
            methods.Add(null);

        return methods;
    }

    private List<CodeElement> GetMethods(CodeElement cls, string name)
    {
        var methods = new List<CodeElement>();
        foreach (CodeElement e in cls.Children)
        {
            string eName = e.Name;
            vsCMElement eKind = e.Kind;

            if (eKind == vsCMElement.vsCMElementFunction && eName == name)
                methods.Add(e);
        }

        return methods;
    }

    private List<Tuple<string, string>> GetParameterDocumentation(CodeElement e)
    {
        var list = new List<Tuple<string, string>>();

        if (e != null)
        {
            foreach (CodeElement a in e.Children)
            {
                EnvDTE.CodeParameter p = a as EnvDTE.CodeParameter;
                if (p == null)
                    continue;
				string comment = p.DocComment;
				if (String.IsNullOrEmpty(comment))
				{	
					if (p.Name == "x")
						comment = "The first point <c>x</c>.";
					else if  (p.Name == "y")
						comment = "The second point <c>y</c>.";
				}
                list.Add(Tuple.Create(p.Name, comment));
            }
        }

        return list;
    }

    private string GetParameterString(CodeElement e, bool includeTypes)
    {
        var list = new List<string>();
        
        if (e != null)
        {
            foreach (CodeElement a in e.Children)
            {
                EnvDTE.CodeParameter p = a as EnvDTE.CodeParameter;
                if (p == null)
                    continue;

                if (includeTypes)
                {
                    var str = p.Type.AsString.Split('.');
                    list.Add(str[str.Length - 1] + " " + p.FullName);
                }
                else 
                    list.Add(p.FullName);
            }
        }

        return String.Join(", ", list);
    }

/*    private bool HasParameterlessConstructor(CodeClass cls)
    {
        foreach (CodeElement e in cls.Children)
        {
            if (e.Kind == vsCMElement.vsCMElementFunction && e.Name == cls.Name)
            {
                foreach (CodeElement a in e.Children)
                {
                    if (a.Kind == vsCMElement.vsCMElementParameter)
                        return false;
                }
            }
        }
        return true;
    }
*/
    private Dictionary<string, CodeElement> FindClasses(string nameSpace, string className, string baseClassName)
    {
        var result = new Dictionary<string, CodeElement>();
        FindClasses(GetProject().CodeModel.CodeElements, className, baseClassName, nameSpace, result, false);
        return result;
    }

    private void FindClasses(CodeElements elements, string className, string baseClassName, string searchNamespace, Dictionary<string, CodeElement> result, bool isNamespaceOk)
    {
        if (elements == null)
            return;

        foreach (CodeElement element in elements)
        {       

            if (element is CodeNamespace)
            {
                CodeNamespace ns = element as CodeNamespace;
                if (ns != null)
                {
                    string fullName = ns.FullName;

                    if (fullName == searchNamespace)
                        FindClasses(ns.Members, className, baseClassName, searchNamespace, result, true);
                    else                   
                        FindClasses(ns.Members, className, baseClassName, searchNamespace, result, false);
                }
            }

            else if (element is CodeClass && isNamespaceOk)
            {
                CodeClass c = element as CodeClass;
                if (c != null)
                {
                    string name = c.Name;
                    string fullName = c.FullName;

                    if (fullName.Contains(className) && (String.IsNullOrEmpty(baseClassName) || (HasIt(c.Bases, baseClassName) && name != baseClassName)))
                        result.Add(fullName, element);

                    FindClasses(c.Members, className, baseClassName, searchNamespace, result, true);
                }
            }

            else if (element is CodeStruct && isNamespaceOk) 
            {
                CodeStruct c = element as CodeStruct; 
                if (c != null)
                {
                    string name = c.Name;
                    string fullName = c.FullName;

                    if (fullName.Contains(className) && (String.IsNullOrEmpty(baseClassName) || (HasIt(c.Bases, baseClassName) && name != baseClassName)))
                        result.Add(fullName, element);

                    FindClasses(c.Members, className, baseClassName, searchNamespace, result, true);
                }
            }
        }
    }

    private bool HasIt(CodeElements elements, string name)
    {
        foreach (CodeElement element in elements)
        {
            if (element.Name == name)
                return true;
        }

        return false;
    }

    private Project GetProject()
    {
        // Get DTE
        var dte = (DTE)TransformationContext.Current.GetService(typeof(DTE));

        // Get ProjectItem representing the template file
        ProjectItem projectItem = dte.Solution.FindProjectItem(TransformationContext.Current.Host.TemplateFile);

        // Get the Project of the template file
        Project project = projectItem.ContainingProject;

        return project;
    }

    private string GetDefaultNamespace()
    {
        // Get DTE
        var dte = (DTE)TransformationContext.Current.GetService(typeof(DTE));

        // Get ProjectItem representing the template file
        ProjectItem projectItem = dte.Solution.FindProjectItem(TransformationContext.Current.Host.TemplateFile);

        // Get the Project of the template file
        Project project = projectItem.ContainingProject;

        // Get the root namespace of the project
        var rootNamespace = (string)project.Properties.Item("RootNamespace").Value;
        //this.WriteLine(rootNamespace);

        // Get the default namespace of the project item
        var vsSolution = (IVsSolution)TransformationContext.Current.GetService(typeof(SVsSolution));
        
        IVsHierarchy vsHierarchy;
        ErrorHandler.ThrowOnFailure(vsSolution.GetProjectOfUniqueName(project.FullName, out vsHierarchy));
        
        uint projectItemId;
        ErrorHandler.ThrowOnFailure(vsHierarchy.ParseCanonicalName(projectItem.FileNames[1], out projectItemId));
        
        object defaultNamespace;
        ErrorHandler.ThrowOnFailure(vsHierarchy.GetProperty(projectItemId, (int)VsHierarchyPropID.DefaultNamespace, out defaultNamespace));
        
        return (string)defaultNamespace;
    }
#>
