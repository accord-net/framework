// Accord Math Library
// The Accord.NET Framework
// http://accord-framework.net
//
// Copyright © César Souza, 2009-2015
// cesarsouza at gmail.com
//
//    This library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    This library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with this library; if not, write to the Free Software
//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
//

// ======================================================================
// This code has been generated by a tool; do not edit manually. Instead,
// edit the T4 template Matrix.Multiply.tt so this file can be regenerated. 
// ======================================================================

namespace Accord.Math
{
    using System;
    using System.CodeDom.Compiler;
    using Accord.Math;

    [GeneratedCode("Accord.NET T4 Templates", "3.1")]
    public static partial class Elementwise
    {
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
        public static double[] Exp(this int[] value)
        {
            return Exp(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
        public static double[,] Exp(this int[,] value)
        {
            return Exp(value, Matrix.CreateAs<int, double>(value));
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
        public static double[][] Exp(this int[][] value)
        {
            return Exp(value, Matrix.JaggedAs<int, double>(value));
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
        public static double[] Log(this int[] value)
        {
            return Log(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
        public static double[,] Log(this int[,] value)
        {
            return Log(value, Matrix.CreateAs<int, double>(value));
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
        public static double[][] Log(this int[][] value)
        {
            return Log(value, Matrix.JaggedAs<int, double>(value));
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
        public static int[] Sign(this int[] value)
        {
            return Sign(value, new int[value.Length]);
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
        public static int[,] Sign(this int[,] value)
        {
            return Sign(value, Matrix.CreateAs<int, int>(value));
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
        public static int[][] Sign(this int[][] value)
        {
            return Sign(value, Matrix.JaggedAs<int, int>(value));
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
        public static int[] Abs(this int[] value)
        {
            return Abs(value, new int[value.Length]);
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
        public static int[,] Abs(this int[,] value)
        {
            return Abs(value, Matrix.CreateAs<int, int>(value));
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
        public static int[][] Abs(this int[][] value)
        {
            return Abs(value, Matrix.JaggedAs<int, int>(value));
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
        public static double[] Sqrt(this int[] value)
        {
            return Sqrt(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
        public static double[,] Sqrt(this int[,] value)
        {
            return Sqrt(value, Matrix.CreateAs<int, double>(value));
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
        public static double[][] Sqrt(this int[][] value)
        {
            return Sqrt(value, Matrix.JaggedAs<int, double>(value));
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
        public static double[] SignSqrt(this int[] value)
        {
            return SignSqrt(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
        public static double[,] SignSqrt(this int[,] value)
        {
            return SignSqrt(value, Matrix.CreateAs<int, double>(value));
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
        public static double[][] SignSqrt(this int[][] value)
        {
            return SignSqrt(value, Matrix.JaggedAs<int, double>(value));
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
        public static double[] Exp(this float[] value)
        {
            return Exp(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
        public static double[,] Exp(this float[,] value)
        {
            return Exp(value, Matrix.CreateAs<float, double>(value));
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
        public static double[][] Exp(this float[][] value)
        {
            return Exp(value, Matrix.JaggedAs<float, double>(value));
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
        public static double[] Log(this float[] value)
        {
            return Log(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
        public static double[,] Log(this float[,] value)
        {
            return Log(value, Matrix.CreateAs<float, double>(value));
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
        public static double[][] Log(this float[][] value)
        {
            return Log(value, Matrix.JaggedAs<float, double>(value));
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
        public static float[] Sign(this float[] value)
        {
            return Sign(value, new float[value.Length]);
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
        public static float[,] Sign(this float[,] value)
        {
            return Sign(value, Matrix.CreateAs<float, float>(value));
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
        public static float[][] Sign(this float[][] value)
        {
            return Sign(value, Matrix.JaggedAs<float, float>(value));
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
        public static float[] Abs(this float[] value)
        {
            return Abs(value, new float[value.Length]);
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
        public static float[,] Abs(this float[,] value)
        {
            return Abs(value, Matrix.CreateAs<float, float>(value));
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
        public static float[][] Abs(this float[][] value)
        {
            return Abs(value, Matrix.JaggedAs<float, float>(value));
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
        public static double[] Sqrt(this float[] value)
        {
            return Sqrt(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
        public static double[,] Sqrt(this float[,] value)
        {
            return Sqrt(value, Matrix.CreateAs<float, double>(value));
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
        public static double[][] Sqrt(this float[][] value)
        {
            return Sqrt(value, Matrix.JaggedAs<float, double>(value));
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
        public static double[] SignSqrt(this float[] value)
        {
            return SignSqrt(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
        public static double[,] SignSqrt(this float[,] value)
        {
            return SignSqrt(value, Matrix.CreateAs<float, double>(value));
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
        public static double[][] SignSqrt(this float[][] value)
        {
            return SignSqrt(value, Matrix.JaggedAs<float, double>(value));
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
        public static double[] Exp(this double[] value)
        {
            return Exp(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
        public static double[,] Exp(this double[,] value)
        {
            return Exp(value, Matrix.CreateAs<double, double>(value));
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
        public static double[][] Exp(this double[][] value)
        {
            return Exp(value, Matrix.JaggedAs<double, double>(value));
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
        public static double[] Log(this double[] value)
        {
            return Log(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
        public static double[,] Log(this double[,] value)
        {
            return Log(value, Matrix.CreateAs<double, double>(value));
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
        public static double[][] Log(this double[][] value)
        {
            return Log(value, Matrix.JaggedAs<double, double>(value));
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
        public static double[] Sign(this double[] value)
        {
            return Sign(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
        public static double[,] Sign(this double[,] value)
        {
            return Sign(value, Matrix.CreateAs<double, double>(value));
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
        public static double[][] Sign(this double[][] value)
        {
            return Sign(value, Matrix.JaggedAs<double, double>(value));
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
        public static double[] Abs(this double[] value)
        {
            return Abs(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
        public static double[,] Abs(this double[,] value)
        {
            return Abs(value, Matrix.CreateAs<double, double>(value));
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
        public static double[][] Abs(this double[][] value)
        {
            return Abs(value, Matrix.JaggedAs<double, double>(value));
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
        public static double[] Sqrt(this double[] value)
        {
            return Sqrt(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
        public static double[,] Sqrt(this double[,] value)
        {
            return Sqrt(value, Matrix.CreateAs<double, double>(value));
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
        public static double[][] Sqrt(this double[][] value)
        {
            return Sqrt(value, Matrix.JaggedAs<double, double>(value));
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
        public static double[] SignSqrt(this double[] value)
        {
            return SignSqrt(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
        public static double[,] SignSqrt(this double[,] value)
        {
            return SignSqrt(value, Matrix.CreateAs<double, double>(value));
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
        public static double[][] SignSqrt(this double[][] value)
        {
            return SignSqrt(value, Matrix.JaggedAs<double, double>(value));
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
        public static double[] Exp(this long[] value)
        {
            return Exp(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
        public static double[,] Exp(this long[,] value)
        {
            return Exp(value, Matrix.CreateAs<long, double>(value));
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
        public static double[][] Exp(this long[][] value)
        {
            return Exp(value, Matrix.JaggedAs<long, double>(value));
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
        public static double[] Log(this long[] value)
        {
            return Log(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
        public static double[,] Log(this long[,] value)
        {
            return Log(value, Matrix.CreateAs<long, double>(value));
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
        public static double[][] Log(this long[][] value)
        {
            return Log(value, Matrix.JaggedAs<long, double>(value));
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
        public static long[] Sign(this long[] value)
        {
            return Sign(value, new long[value.Length]);
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
        public static long[,] Sign(this long[,] value)
        {
            return Sign(value, Matrix.CreateAs<long, long>(value));
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
        public static long[][] Sign(this long[][] value)
        {
            return Sign(value, Matrix.JaggedAs<long, long>(value));
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
        public static long[] Abs(this long[] value)
        {
            return Abs(value, new long[value.Length]);
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
        public static long[,] Abs(this long[,] value)
        {
            return Abs(value, Matrix.CreateAs<long, long>(value));
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
        public static long[][] Abs(this long[][] value)
        {
            return Abs(value, Matrix.JaggedAs<long, long>(value));
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
        public static double[] Sqrt(this long[] value)
        {
            return Sqrt(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
        public static double[,] Sqrt(this long[,] value)
        {
            return Sqrt(value, Matrix.CreateAs<long, double>(value));
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
        public static double[][] Sqrt(this long[][] value)
        {
            return Sqrt(value, Matrix.JaggedAs<long, double>(value));
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
        public static double[] SignSqrt(this long[] value)
        {
            return SignSqrt(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
        public static double[,] SignSqrt(this long[,] value)
        {
            return SignSqrt(value, Matrix.CreateAs<long, double>(value));
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
        public static double[][] SignSqrt(this long[][] value)
        {
            return SignSqrt(value, Matrix.JaggedAs<long, double>(value));
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
        public static double[] Exp(this decimal[] value)
        {
            return Exp(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
        public static double[,] Exp(this decimal[,] value)
        {
            return Exp(value, Matrix.CreateAs<decimal, double>(value));
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        /// 
        public static double[][] Exp(this decimal[][] value)
        {
            return Exp(value, Matrix.JaggedAs<decimal, double>(value));
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
        public static double[] Log(this decimal[] value)
        {
            return Log(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
        public static double[,] Log(this decimal[,] value)
        {
            return Log(value, Matrix.CreateAs<decimal, double>(value));
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        /// 
        public static double[][] Log(this decimal[][] value)
        {
            return Log(value, Matrix.JaggedAs<decimal, double>(value));
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
        public static decimal[] Sign(this decimal[] value)
        {
            return Sign(value, new decimal[value.Length]);
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
        public static decimal[,] Sign(this decimal[,] value)
        {
            return Sign(value, Matrix.CreateAs<decimal, decimal>(value));
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        /// 
        public static decimal[][] Sign(this decimal[][] value)
        {
            return Sign(value, Matrix.JaggedAs<decimal, decimal>(value));
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
        public static decimal[] Abs(this decimal[] value)
        {
            return Abs(value, new decimal[value.Length]);
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
        public static decimal[,] Abs(this decimal[,] value)
        {
            return Abs(value, Matrix.CreateAs<decimal, decimal>(value));
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        /// 
        public static decimal[][] Abs(this decimal[][] value)
        {
            return Abs(value, Matrix.JaggedAs<decimal, decimal>(value));
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
        public static double[] Sqrt(this decimal[] value)
        {
            return Sqrt(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
        public static double[,] Sqrt(this decimal[,] value)
        {
            return Sqrt(value, Matrix.CreateAs<decimal, double>(value));
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        /// 
        public static double[][] Sqrt(this decimal[][] value)
        {
            return Sqrt(value, Matrix.JaggedAs<decimal, double>(value));
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
        public static double[] SignSqrt(this decimal[] value)
        {
            return SignSqrt(value, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
        public static double[,] SignSqrt(this decimal[,] value)
        {
            return SignSqrt(value, Matrix.CreateAs<decimal, double>(value));
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        /// 
        public static double[][] SignSqrt(this decimal[][] value)
        {
            return SignSqrt(value, Matrix.JaggedAs<decimal, double>(value));
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Exp(this int[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Exp(this int[,] value, int[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Exp(this int[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Log(this int[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Log(this int[,] value, int[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Log(this int[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Sign(this int[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Sign(this int[,] value, int[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Sign(this int[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Abs(this int[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Abs(this int[,] value, int[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Abs(this int[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Sqrt(this int[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Sqrt(this int[,] value, int[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Sqrt(this int[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] SignSqrt(this int[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] SignSqrt(this int[,] value, int[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] SignSqrt(this int[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Exp(this int[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Exp(this int[,] value, float[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Exp(this int[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Log(this int[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Log(this int[,] value, float[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Log(this int[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Sign(this int[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Sign(this int[,] value, float[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Sign(this int[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Abs(this int[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Abs(this int[,] value, float[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Abs(this int[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Sqrt(this int[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Sqrt(this int[,] value, float[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Sqrt(this int[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] SignSqrt(this int[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] SignSqrt(this int[,] value, float[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] SignSqrt(this int[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Exp(this int[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Exp(this int[,] value, double[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Exp(this int[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Log(this int[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Log(this int[,] value, double[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Log(this int[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Sign(this int[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Sign(this int[,] value, double[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Sign(this int[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Abs(this int[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Abs(this int[,] value, double[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Abs(this int[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Sqrt(this int[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Sqrt(this int[,] value, double[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Sqrt(this int[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] SignSqrt(this int[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] SignSqrt(this int[,] value, double[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] SignSqrt(this int[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Exp(this int[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Exp(this int[,] value, long[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Exp(this int[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Log(this int[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Log(this int[,] value, long[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Log(this int[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Sign(this int[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Sign(this int[,] value, long[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Sign(this int[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Abs(this int[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Abs(this int[,] value, long[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Abs(this int[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Sqrt(this int[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Sqrt(this int[,] value, long[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Sqrt(this int[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] SignSqrt(this int[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] SignSqrt(this int[,] value, long[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] SignSqrt(this int[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Exp(this int[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Exp(this int[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Exp(this int[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Log(this int[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Log(this int[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Log(this int[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Sign(this int[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Sign(this int[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Sign(this int[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Abs(this int[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Abs(this int[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Abs(this int[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Sqrt(this int[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Sqrt(this int[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Sqrt(this int[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] SignSqrt(this int[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] SignSqrt(this int[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] SignSqrt(this int[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Exp(this float[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Exp(this float[,] value, int[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Exp(this float[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Log(this float[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Log(this float[,] value, int[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Log(this float[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Sign(this float[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Sign(this float[,] value, int[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Sign(this float[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Abs(this float[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Abs(this float[,] value, int[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Abs(this float[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Sqrt(this float[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Sqrt(this float[,] value, int[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Sqrt(this float[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] SignSqrt(this float[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] SignSqrt(this float[,] value, int[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] SignSqrt(this float[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Exp(this float[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Exp(this float[,] value, float[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Exp(this float[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Log(this float[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Log(this float[,] value, float[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Log(this float[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Sign(this float[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Sign(this float[,] value, float[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Sign(this float[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Abs(this float[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Abs(this float[,] value, float[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Abs(this float[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Sqrt(this float[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Sqrt(this float[,] value, float[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Sqrt(this float[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] SignSqrt(this float[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] SignSqrt(this float[,] value, float[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] SignSqrt(this float[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Exp(this float[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Exp(this float[,] value, double[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Exp(this float[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Log(this float[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Log(this float[,] value, double[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Log(this float[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Sign(this float[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Sign(this float[,] value, double[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Sign(this float[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Abs(this float[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Abs(this float[,] value, double[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Abs(this float[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Sqrt(this float[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Sqrt(this float[,] value, double[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Sqrt(this float[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] SignSqrt(this float[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] SignSqrt(this float[,] value, double[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] SignSqrt(this float[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Exp(this float[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Exp(this float[,] value, long[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Exp(this float[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Log(this float[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Log(this float[,] value, long[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Log(this float[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Sign(this float[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Sign(this float[,] value, long[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Sign(this float[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Abs(this float[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Abs(this float[,] value, long[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Abs(this float[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Sqrt(this float[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Sqrt(this float[,] value, long[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Sqrt(this float[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] SignSqrt(this float[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] SignSqrt(this float[,] value, long[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] SignSqrt(this float[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Exp(this float[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Exp(this float[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Exp(this float[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Log(this float[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Log(this float[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Log(this float[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Sign(this float[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Sign(this float[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Sign(this float[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Abs(this float[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Abs(this float[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Abs(this float[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Sqrt(this float[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Sqrt(this float[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Sqrt(this float[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] SignSqrt(this float[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] SignSqrt(this float[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] SignSqrt(this float[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Exp(this double[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Exp(this double[,] value, int[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Exp(this double[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Log(this double[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Log(this double[,] value, int[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Log(this double[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Sign(this double[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Sign(this double[,] value, int[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Sign(this double[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Abs(this double[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Abs(this double[,] value, int[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Abs(this double[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Sqrt(this double[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Sqrt(this double[,] value, int[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Sqrt(this double[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] SignSqrt(this double[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] SignSqrt(this double[,] value, int[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] SignSqrt(this double[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Exp(this double[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Exp(this double[,] value, float[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Exp(this double[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Log(this double[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Log(this double[,] value, float[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Log(this double[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Sign(this double[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Sign(this double[,] value, float[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Sign(this double[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Abs(this double[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Abs(this double[,] value, float[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Abs(this double[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Sqrt(this double[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Sqrt(this double[,] value, float[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Sqrt(this double[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] SignSqrt(this double[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] SignSqrt(this double[,] value, float[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] SignSqrt(this double[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Exp(this double[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Exp(this double[,] value, double[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Exp(this double[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Log(this double[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Log(this double[,] value, double[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Log(this double[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Sign(this double[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Sign(this double[,] value, double[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Sign(this double[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Abs(this double[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Abs(this double[,] value, double[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Abs(this double[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Sqrt(this double[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Sqrt(this double[,] value, double[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Sqrt(this double[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] SignSqrt(this double[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] SignSqrt(this double[,] value, double[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] SignSqrt(this double[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Exp(this double[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Exp(this double[,] value, long[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Exp(this double[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Log(this double[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Log(this double[,] value, long[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Log(this double[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Sign(this double[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Sign(this double[,] value, long[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Sign(this double[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Abs(this double[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Abs(this double[,] value, long[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Abs(this double[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Sqrt(this double[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Sqrt(this double[,] value, long[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Sqrt(this double[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] SignSqrt(this double[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] SignSqrt(this double[,] value, long[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] SignSqrt(this double[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Exp(this double[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Exp(this double[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Exp(this double[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Log(this double[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Log(this double[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Log(this double[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Sign(this double[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Sign(this double[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Sign(this double[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Abs(this double[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Abs(this double[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Abs(this double[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Sqrt(this double[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Sqrt(this double[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Sqrt(this double[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] SignSqrt(this double[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] SignSqrt(this double[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] SignSqrt(this double[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Exp(this long[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Exp(this long[,] value, int[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Exp(this long[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Log(this long[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Log(this long[,] value, int[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Log(this long[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Sign(this long[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Sign(this long[,] value, int[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Sign(this long[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Abs(this long[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Abs(this long[,] value, int[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Abs(this long[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Sqrt(this long[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Sqrt(this long[,] value, int[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Sqrt(this long[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] SignSqrt(this long[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] SignSqrt(this long[,] value, int[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] SignSqrt(this long[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Exp(this long[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Exp(this long[,] value, float[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Exp(this long[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Log(this long[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Log(this long[,] value, float[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Log(this long[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Sign(this long[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Sign(this long[,] value, float[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Sign(this long[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Abs(this long[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Abs(this long[,] value, float[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Abs(this long[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Sqrt(this long[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Sqrt(this long[,] value, float[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Sqrt(this long[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] SignSqrt(this long[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] SignSqrt(this long[,] value, float[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] SignSqrt(this long[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Exp(this long[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Exp(this long[,] value, double[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Exp(this long[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Log(this long[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Log(this long[,] value, double[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Log(this long[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Sign(this long[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Sign(this long[,] value, double[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Sign(this long[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Abs(this long[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Abs(this long[,] value, double[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Abs(this long[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Sqrt(this long[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Sqrt(this long[,] value, double[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Sqrt(this long[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] SignSqrt(this long[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] SignSqrt(this long[,] value, double[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] SignSqrt(this long[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Exp(this long[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Exp(this long[,] value, long[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Exp(this long[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Log(this long[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Log(this long[,] value, long[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Log(this long[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Sign(this long[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Sign(this long[,] value, long[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Sign(this long[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Abs(this long[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Abs(this long[,] value, long[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Abs(this long[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Sqrt(this long[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Sqrt(this long[,] value, long[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Sqrt(this long[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] SignSqrt(this long[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] SignSqrt(this long[,] value, long[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] SignSqrt(this long[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Exp(this long[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Exp(this long[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Exp(this long[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Log(this long[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Log(this long[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Log(this long[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Sign(this long[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Sign(this long[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Sign(this long[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Abs(this long[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Abs(this long[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Abs(this long[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Sqrt(this long[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Sqrt(this long[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Sqrt(this long[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] SignSqrt(this long[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] SignSqrt(this long[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] SignSqrt(this long[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Exp(this decimal[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Exp(this decimal[,] value, int[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Exp(this decimal[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Log(this decimal[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Log(this decimal[,] value, int[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Log(this decimal[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Sign(this decimal[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Sign(this decimal[,] value, int[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Sign(this decimal[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Abs(this decimal[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Abs(this decimal[,] value, int[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Abs(this decimal[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Sqrt(this decimal[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Sqrt(this decimal[,] value, int[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Sqrt(this decimal[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] SignSqrt(this decimal[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] SignSqrt(this decimal[,] value, int[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] SignSqrt(this decimal[][] value, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Exp(this decimal[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Exp(this decimal[,] value, float[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Exp(this decimal[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Log(this decimal[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Log(this decimal[,] value, float[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Log(this decimal[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Sign(this decimal[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Sign(this decimal[,] value, float[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Sign(this decimal[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Abs(this decimal[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Abs(this decimal[,] value, float[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Abs(this decimal[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Sqrt(this decimal[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Sqrt(this decimal[,] value, float[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Sqrt(this decimal[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] SignSqrt(this decimal[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] SignSqrt(this decimal[,] value, float[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] SignSqrt(this decimal[][] value, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Exp(this decimal[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Exp(this decimal[,] value, double[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Exp(this decimal[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Log(this decimal[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Log(this decimal[,] value, double[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Log(this decimal[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Sign(this decimal[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Sign(this decimal[,] value, double[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Sign(this decimal[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Abs(this decimal[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Abs(this decimal[,] value, double[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Abs(this decimal[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Sqrt(this decimal[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Sqrt(this decimal[,] value, double[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Sqrt(this decimal[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] SignSqrt(this decimal[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] SignSqrt(this decimal[,] value, double[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] SignSqrt(this decimal[][] value, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Exp(this decimal[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Exp(this decimal[,] value, long[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Exp(this decimal[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Log(this decimal[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Log(this decimal[,] value, long[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Log(this decimal[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Sign(this decimal[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Sign(this decimal[,] value, long[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Sign(this decimal[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Abs(this decimal[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Abs(this decimal[,] value, long[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Abs(this decimal[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Sqrt(this decimal[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Sqrt(this decimal[,] value, long[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Sqrt(this decimal[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] SignSqrt(this decimal[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] SignSqrt(this decimal[,] value, long[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] SignSqrt(this decimal[][] value, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Exp(this decimal[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Exp((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Exp(this decimal[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Exp((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise exponential.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Exp(this decimal[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Exp((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Log(this decimal[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Log((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Log(this decimal[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Log((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise logarithm.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Log(this decimal[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Log((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Sign(this decimal[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Sign(this decimal[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise sign.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Sign(this decimal[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Abs(this decimal[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Abs(v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Abs(this decimal[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Abs(v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise absolute value.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Abs(this decimal[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Abs(v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Sqrt(this decimal[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Sqrt(this decimal[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Sqrt(this decimal[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] SignSqrt(this decimal[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] SignSqrt(this decimal[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed square-root.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] SignSqrt(this decimal[][] value, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v) * Math.Sqrt((double)v));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static int[] SignedPow(this int[] value, double y)
        {
            return SignedPow(value, y, new int[value.Length]);
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static int[,] SignedPow(this int[,] value, double y)
        {
            return SignedPow(value, y, Matrix.CreateAs<int, int>(value));
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static int[][] SignedPow(this int[][] value, double y)
        {
            return SignedPow(value, y, Matrix.JaggedAs<int, int>(value));
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static int[] Pow(this int[] value, double y)
        {
            return Pow(value, y, new int[value.Length]);
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static int[,] Pow(this int[,] value, double y)
        {
            return Pow(value, y, Matrix.CreateAs<int, int>(value));
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static int[][] Pow(this int[][] value, double y)
        {
            return Pow(value, y, Matrix.JaggedAs<int, int>(value));
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static float[] SignedPow(this float[] value, double y)
        {
            return SignedPow(value, y, new float[value.Length]);
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static float[,] SignedPow(this float[,] value, double y)
        {
            return SignedPow(value, y, Matrix.CreateAs<float, float>(value));
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static float[][] SignedPow(this float[][] value, double y)
        {
            return SignedPow(value, y, Matrix.JaggedAs<float, float>(value));
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static float[] Pow(this float[] value, double y)
        {
            return Pow(value, y, new float[value.Length]);
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static float[,] Pow(this float[,] value, double y)
        {
            return Pow(value, y, Matrix.CreateAs<float, float>(value));
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static float[][] Pow(this float[][] value, double y)
        {
            return Pow(value, y, Matrix.JaggedAs<float, float>(value));
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static double[] SignedPow(this double[] value, double y)
        {
            return SignedPow(value, y, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static double[,] SignedPow(this double[,] value, double y)
        {
            return SignedPow(value, y, Matrix.CreateAs<double, double>(value));
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static double[][] SignedPow(this double[][] value, double y)
        {
            return SignedPow(value, y, Matrix.JaggedAs<double, double>(value));
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static double[] Pow(this double[] value, double y)
        {
            return Pow(value, y, new double[value.Length]);
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static double[,] Pow(this double[,] value, double y)
        {
            return Pow(value, y, Matrix.CreateAs<double, double>(value));
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static double[][] Pow(this double[][] value, double y)
        {
            return Pow(value, y, Matrix.JaggedAs<double, double>(value));
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static long[] SignedPow(this long[] value, double y)
        {
            return SignedPow(value, y, new long[value.Length]);
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static long[,] SignedPow(this long[,] value, double y)
        {
            return SignedPow(value, y, Matrix.CreateAs<long, long>(value));
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static long[][] SignedPow(this long[][] value, double y)
        {
            return SignedPow(value, y, Matrix.JaggedAs<long, long>(value));
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static long[] Pow(this long[] value, double y)
        {
            return Pow(value, y, new long[value.Length]);
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static long[,] Pow(this long[,] value, double y)
        {
            return Pow(value, y, Matrix.CreateAs<long, long>(value));
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static long[][] Pow(this long[][] value, double y)
        {
            return Pow(value, y, Matrix.JaggedAs<long, long>(value));
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static decimal[] SignedPow(this decimal[] value, double y)
        {
            return SignedPow(value, y, new decimal[value.Length]);
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static decimal[,] SignedPow(this decimal[,] value, double y)
        {
            return SignedPow(value, y, Matrix.CreateAs<decimal, decimal>(value));
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static decimal[][] SignedPow(this decimal[][] value, double y)
        {
            return SignedPow(value, y, Matrix.JaggedAs<decimal, decimal>(value));
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static decimal[] Pow(this decimal[] value, double y)
        {
            return Pow(value, y, new decimal[value.Length]);
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static decimal[,] Pow(this decimal[,] value, double y)
        {
            return Pow(value, y, Matrix.CreateAs<decimal, decimal>(value));
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// 
        public static decimal[][] Pow(this decimal[][] value, double y)
        {
            return Pow(value, y, Matrix.JaggedAs<decimal, decimal>(value));
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] SignedPow(this int[] value, double y, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] SignedPow(this int[,] value, double y, int[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] SignedPow(this int[][] value, double y, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Pow(this int[] value, double y, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Pow(this int[,] value, double y, int[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Pow(this int[][] value, double y, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] SignedPow(this int[] value, double y, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] SignedPow(this int[,] value, double y, float[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] SignedPow(this int[][] value, double y, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Pow(this int[] value, double y, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Pow(this int[,] value, double y, float[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Pow(this int[][] value, double y, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] SignedPow(this int[] value, double y, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] SignedPow(this int[,] value, double y, double[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] SignedPow(this int[][] value, double y, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Pow(this int[] value, double y, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Pow(this int[,] value, double y, double[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Pow(this int[][] value, double y, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] SignedPow(this int[] value, double y, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] SignedPow(this int[,] value, double y, long[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] SignedPow(this int[][] value, double y, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Pow(this int[] value, double y, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Pow(this int[,] value, double y, long[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Pow(this int[][] value, double y, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] SignedPow(this int[] value, double y, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] SignedPow(this int[,] value, double y, decimal[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] SignedPow(this int[][] value, double y, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Pow(this int[] value, double y, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Pow(this int[,] value, double y, decimal[,] result)
        {
            unsafe
            {
                fixed (int* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Pow(this int[][] value, double y, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] SignedPow(this float[] value, double y, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] SignedPow(this float[,] value, double y, int[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] SignedPow(this float[][] value, double y, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Pow(this float[] value, double y, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Pow(this float[,] value, double y, int[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Pow(this float[][] value, double y, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] SignedPow(this float[] value, double y, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] SignedPow(this float[,] value, double y, float[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] SignedPow(this float[][] value, double y, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Pow(this float[] value, double y, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Pow(this float[,] value, double y, float[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Pow(this float[][] value, double y, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] SignedPow(this float[] value, double y, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] SignedPow(this float[,] value, double y, double[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] SignedPow(this float[][] value, double y, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Pow(this float[] value, double y, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Pow(this float[,] value, double y, double[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Pow(this float[][] value, double y, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] SignedPow(this float[] value, double y, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] SignedPow(this float[,] value, double y, long[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] SignedPow(this float[][] value, double y, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Pow(this float[] value, double y, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Pow(this float[,] value, double y, long[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Pow(this float[][] value, double y, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] SignedPow(this float[] value, double y, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] SignedPow(this float[,] value, double y, decimal[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] SignedPow(this float[][] value, double y, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Pow(this float[] value, double y, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Pow(this float[,] value, double y, decimal[,] result)
        {
            unsafe
            {
                fixed (float* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Pow(this float[][] value, double y, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] SignedPow(this double[] value, double y, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] SignedPow(this double[,] value, double y, int[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] SignedPow(this double[][] value, double y, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Pow(this double[] value, double y, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Pow(this double[,] value, double y, int[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Pow(this double[][] value, double y, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] SignedPow(this double[] value, double y, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] SignedPow(this double[,] value, double y, float[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] SignedPow(this double[][] value, double y, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Pow(this double[] value, double y, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Pow(this double[,] value, double y, float[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Pow(this double[][] value, double y, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] SignedPow(this double[] value, double y, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] SignedPow(this double[,] value, double y, double[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] SignedPow(this double[][] value, double y, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Pow(this double[] value, double y, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Pow(this double[,] value, double y, double[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Pow(this double[][] value, double y, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] SignedPow(this double[] value, double y, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] SignedPow(this double[,] value, double y, long[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] SignedPow(this double[][] value, double y, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Pow(this double[] value, double y, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Pow(this double[,] value, double y, long[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Pow(this double[][] value, double y, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] SignedPow(this double[] value, double y, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] SignedPow(this double[,] value, double y, decimal[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] SignedPow(this double[][] value, double y, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Pow(this double[] value, double y, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Pow(this double[,] value, double y, decimal[,] result)
        {
            unsafe
            {
                fixed (double* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Pow(this double[][] value, double y, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] SignedPow(this long[] value, double y, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] SignedPow(this long[,] value, double y, int[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] SignedPow(this long[][] value, double y, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Pow(this long[] value, double y, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Pow(this long[,] value, double y, int[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Pow(this long[][] value, double y, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] SignedPow(this long[] value, double y, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] SignedPow(this long[,] value, double y, float[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] SignedPow(this long[][] value, double y, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Pow(this long[] value, double y, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Pow(this long[,] value, double y, float[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Pow(this long[][] value, double y, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] SignedPow(this long[] value, double y, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] SignedPow(this long[,] value, double y, double[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] SignedPow(this long[][] value, double y, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Pow(this long[] value, double y, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Pow(this long[,] value, double y, double[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Pow(this long[][] value, double y, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] SignedPow(this long[] value, double y, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] SignedPow(this long[,] value, double y, long[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] SignedPow(this long[][] value, double y, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Pow(this long[] value, double y, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Pow(this long[,] value, double y, long[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Pow(this long[][] value, double y, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] SignedPow(this long[] value, double y, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] SignedPow(this long[,] value, double y, decimal[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] SignedPow(this long[][] value, double y, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Pow(this long[] value, double y, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Pow(this long[,] value, double y, decimal[,] result)
        {
            unsafe
            {
                fixed (long* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Pow(this long[][] value, double y, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] SignedPow(this decimal[] value, double y, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] SignedPow(this decimal[,] value, double y, int[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] SignedPow(this decimal[][] value, double y, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[] Pow(this decimal[] value, double y, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (int)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[,] Pow(this decimal[,] value, double y, int[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (int* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (int)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static int[][] Pow(this decimal[][] value, double y, int[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (int)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] SignedPow(this decimal[] value, double y, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] SignedPow(this decimal[,] value, double y, float[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] SignedPow(this decimal[][] value, double y, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[] Pow(this decimal[] value, double y, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (float)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[,] Pow(this decimal[,] value, double y, float[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (float* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (float)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static float[][] Pow(this decimal[][] value, double y, float[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (float)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] SignedPow(this decimal[] value, double y, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] SignedPow(this decimal[,] value, double y, double[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] SignedPow(this decimal[][] value, double y, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[] Pow(this decimal[] value, double y, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (double)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[,] Pow(this decimal[,] value, double y, double[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (double* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (double)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static double[][] Pow(this decimal[][] value, double y, double[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (double)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] SignedPow(this decimal[] value, double y, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] SignedPow(this decimal[,] value, double y, long[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] SignedPow(this decimal[][] value, double y, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[] Pow(this decimal[] value, double y, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (long)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[,] Pow(this decimal[,] value, double y, long[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (long* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (long)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static long[][] Pow(this decimal[][] value, double y, long[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (long)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] SignedPow(this decimal[] value, double y, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] SignedPow(this decimal[,] value, double y, decimal[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise signed power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] SignedPow(this decimal[][] value, double y, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Sign(v) * Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[] Pow(this decimal[] value, double y, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
            {
                var v = value[i];
                result[i] = (decimal)(Math.Pow((double)Math.Abs(v), y));
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[,] Pow(this decimal[,] value, double y, decimal[,] result)
        {
            unsafe
            {
                fixed (decimal* ptrV = value)
                fixed (decimal* ptrR = result)
                {
                    var pv = ptrV;
                    var pr = ptrR;
                    for (int j = 0; j < result.Length; j++, pv++, pr++)
                    {
                        var v = *pv;
                        *pr = (decimal)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Elementwise power.
        /// </summary>
        ///
        /// <param name="value">A matrix.</param>
        /// <param name="y">A power.</param>
        /// <param name="result">The vector where the result should be stored. Pass the same
        ///   vector as <paramref name="value"/> to perform the operation in place.</param>
        /// 
        public static decimal[][] Pow(this decimal[][] value, double y, decimal[][] result)
        {
            unsafe 
            {
                for (int i = 0; i < value.Length; i++)
                {
                    for (int j = 0; j < value[i].Length; j++)
                    {
                        var v = value[i][j];
                        result[i][j] = (decimal)(Math.Pow((double)Math.Abs(v), y));
                    }
                }
            }
            return result;
        }
    }
}