// Accord Math Library
// The Accord.NET Framework
// http://accord-framework.net
//
// Copyright © César Souza, 2009-2015
// cesarsouza at gmail.com
//
//    This library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    This library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with this library; if not, write to the Free Software
//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
//

// ======================================================================
// This code has been generated by a tool; do not edit manually. Instead,
// edit the T4 template Matrix.Elementwise.tt so this file can be regenerated. 
// ======================================================================

namespace Accord.Math
{
    using System;
    using System.CodeDom.Compiler;
    using Accord.Math;
    using System.Runtime.CompilerServices;

    // [GeneratedCode("Accord.NET T4 Templates", "3.1")]
    public static partial class Matrix
    {
        /// <summary>
        ///   Converts a integer to a short integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] ToInt16(this int[] value)
        {
            return ToInt16(value, new short[value.Length]);
        }

        /// <summary>
        ///   Converts a integer to a short integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] ToInt16(this int[,] value)
        {
            return ToInt16(value, Matrix.CreateAs<int, short>(value));
        }

        /// <summary>
        ///   Converts a integer to a short integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] ToInt16(this int[][] value)
        {
            return ToInt16(value, Jagged.CreateAs<int, short>(value));
        }





        /// <summary>
        ///   Converts a integer array to a short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] ToInt16(this int[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Int16)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional integer array to a multidimensional short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] ToInt16(this int[,] value, short[,] result)
        {
            unsafe
            {
                fixed (int* src = value)
                fixed (short* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (short)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional integer array to a jagged short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] ToInt16(this int[,] value, short[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Int16)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged integer array to a jagged short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] ToInt16(this int[][] value, short[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Int16)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged integer array to a multidimensional short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] ToInt16(this int[][] value, short[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Int16)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a integer to a single-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] ToSingle(this int[] value)
        {
            return ToSingle(value, new float[value.Length]);
        }

        /// <summary>
        ///   Converts a integer to a single-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] ToSingle(this int[,] value)
        {
            return ToSingle(value, Matrix.CreateAs<int, float>(value));
        }

        /// <summary>
        ///   Converts a integer to a single-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] ToSingle(this int[][] value)
        {
            return ToSingle(value, Jagged.CreateAs<int, float>(value));
        }





        /// <summary>
        ///   Converts a integer array to a single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] ToSingle(this int[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Single)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional integer array to a multidimensional single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] ToSingle(this int[,] value, float[,] result)
        {
            unsafe
            {
                fixed (int* src = value)
                fixed (float* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (float)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional integer array to a jagged single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] ToSingle(this int[,] value, float[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Single)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged integer array to a jagged single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] ToSingle(this int[][] value, float[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Single)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged integer array to a multidimensional single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] ToSingle(this int[][] value, float[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Single)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a integer to a double-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] ToDouble(this int[] value)
        {
            return ToDouble(value, new double[value.Length]);
        }

        /// <summary>
        ///   Converts a integer to a double-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] ToDouble(this int[,] value)
        {
            return ToDouble(value, Matrix.CreateAs<int, double>(value));
        }

        /// <summary>
        ///   Converts a integer to a double-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] ToDouble(this int[][] value)
        {
            return ToDouble(value, Jagged.CreateAs<int, double>(value));
        }





        /// <summary>
        ///   Converts a integer array to a double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] ToDouble(this int[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Double)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional integer array to a multidimensional double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] ToDouble(this int[,] value, double[,] result)
        {
            unsafe
            {
                fixed (int* src = value)
                fixed (double* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (double)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional integer array to a jagged double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] ToDouble(this int[,] value, double[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Double)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged integer array to a jagged double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] ToDouble(this int[][] value, double[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Double)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged integer array to a multidimensional double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] ToDouble(this int[][] value, double[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Double)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a integer to a long integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] ToInt64(this int[] value)
        {
            return ToInt64(value, new long[value.Length]);
        }

        /// <summary>
        ///   Converts a integer to a long integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] ToInt64(this int[,] value)
        {
            return ToInt64(value, Matrix.CreateAs<int, long>(value));
        }

        /// <summary>
        ///   Converts a integer to a long integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] ToInt64(this int[][] value)
        {
            return ToInt64(value, Jagged.CreateAs<int, long>(value));
        }





        /// <summary>
        ///   Converts a integer array to a long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] ToInt64(this int[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Int64)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional integer array to a multidimensional long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] ToInt64(this int[,] value, long[,] result)
        {
            unsafe
            {
                fixed (int* src = value)
                fixed (long* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (long)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional integer array to a jagged long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] ToInt64(this int[,] value, long[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Int64)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged integer array to a jagged long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] ToInt64(this int[][] value, long[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Int64)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged integer array to a multidimensional long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] ToInt64(this int[][] value, long[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Int64)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a integer to a 8-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] ToByte(this int[] value)
        {
            return ToByte(value, new byte[value.Length]);
        }

        /// <summary>
        ///   Converts a integer to a 8-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] ToByte(this int[,] value)
        {
            return ToByte(value, Matrix.CreateAs<int, byte>(value));
        }

        /// <summary>
        ///   Converts a integer to a 8-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] ToByte(this int[][] value)
        {
            return ToByte(value, Jagged.CreateAs<int, byte>(value));
        }





        /// <summary>
        ///   Converts a integer array to a 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] ToByte(this int[] value, byte[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Byte)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional integer array to a multidimensional 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] ToByte(this int[,] value, byte[,] result)
        {
            unsafe
            {
                fixed (int* src = value)
                fixed (byte* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (byte)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional integer array to a jagged 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] ToByte(this int[,] value, byte[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Byte)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged integer array to a jagged 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] ToByte(this int[][] value, byte[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Byte)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged integer array to a multidimensional 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] ToByte(this int[][] value, byte[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Byte)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a integer to a signed 7-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[] ToSByte(this int[] value)
        {
            return ToSByte(value, new sbyte[value.Length]);
        }

        /// <summary>
        ///   Converts a integer to a signed 7-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[,] ToSByte(this int[,] value)
        {
            return ToSByte(value, Matrix.CreateAs<int, sbyte>(value));
        }

        /// <summary>
        ///   Converts a integer to a signed 7-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[][] ToSByte(this int[][] value)
        {
            return ToSByte(value, Jagged.CreateAs<int, sbyte>(value));
        }





        /// <summary>
        ///   Converts a integer array to a signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[] ToSByte(this int[] value, sbyte[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (SByte)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional integer array to a multidimensional signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[,] ToSByte(this int[,] value, sbyte[,] result)
        {
            unsafe
            {
                fixed (int* src = value)
                fixed (sbyte* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (sbyte)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional integer array to a jagged signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[][] ToSByte(this int[,] value, sbyte[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (SByte)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged integer array to a jagged signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[][] ToSByte(this int[][] value, sbyte[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (SByte)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged integer array to a multidimensional signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[,] ToSByte(this int[][] value, sbyte[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (SByte)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a integer to a decimal fixed-point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] ToDecimal(this int[] value)
        {
            return ToDecimal(value, new decimal[value.Length]);
        }

        /// <summary>
        ///   Converts a integer to a decimal fixed-point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] ToDecimal(this int[,] value)
        {
            return ToDecimal(value, Matrix.CreateAs<int, decimal>(value));
        }

        /// <summary>
        ///   Converts a integer to a decimal fixed-point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] ToDecimal(this int[][] value)
        {
            return ToDecimal(value, Jagged.CreateAs<int, decimal>(value));
        }





        /// <summary>
        ///   Converts a integer array to a decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] ToDecimal(this int[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Decimal)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional integer array to a multidimensional decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] ToDecimal(this int[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (int* src = value)
                fixed (decimal* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (decimal)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional integer array to a jagged decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] ToDecimal(this int[,] value, decimal[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Decimal)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged integer array to a jagged decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] ToDecimal(this int[][] value, decimal[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Decimal)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged integer array to a multidimensional decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] ToDecimal(this int[][] value, decimal[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Decimal)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a short integer to a integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] ToInt32(this short[] value)
        {
            return ToInt32(value, new int[value.Length]);
        }

        /// <summary>
        ///   Converts a short integer to a integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] ToInt32(this short[,] value)
        {
            return ToInt32(value, Matrix.CreateAs<short, int>(value));
        }

        /// <summary>
        ///   Converts a short integer to a integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] ToInt32(this short[][] value)
        {
            return ToInt32(value, Jagged.CreateAs<short, int>(value));
        }





        /// <summary>
        ///   Converts a short integer array to a integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] ToInt32(this short[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Int32)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional short integer array to a multidimensional integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] ToInt32(this short[,] value, int[,] result)
        {
            unsafe
            {
                fixed (short* src = value)
                fixed (int* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (int)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional short integer array to a jagged integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] ToInt32(this short[,] value, int[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Int32)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged short integer array to a jagged integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] ToInt32(this short[][] value, int[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Int32)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged short integer array to a multidimensional integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] ToInt32(this short[][] value, int[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Int32)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a short integer to a single-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] ToSingle(this short[] value)
        {
            return ToSingle(value, new float[value.Length]);
        }

        /// <summary>
        ///   Converts a short integer to a single-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] ToSingle(this short[,] value)
        {
            return ToSingle(value, Matrix.CreateAs<short, float>(value));
        }

        /// <summary>
        ///   Converts a short integer to a single-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] ToSingle(this short[][] value)
        {
            return ToSingle(value, Jagged.CreateAs<short, float>(value));
        }





        /// <summary>
        ///   Converts a short integer array to a single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] ToSingle(this short[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Single)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional short integer array to a multidimensional single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] ToSingle(this short[,] value, float[,] result)
        {
            unsafe
            {
                fixed (short* src = value)
                fixed (float* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (float)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional short integer array to a jagged single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] ToSingle(this short[,] value, float[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Single)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged short integer array to a jagged single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] ToSingle(this short[][] value, float[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Single)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged short integer array to a multidimensional single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] ToSingle(this short[][] value, float[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Single)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a short integer to a double-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] ToDouble(this short[] value)
        {
            return ToDouble(value, new double[value.Length]);
        }

        /// <summary>
        ///   Converts a short integer to a double-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] ToDouble(this short[,] value)
        {
            return ToDouble(value, Matrix.CreateAs<short, double>(value));
        }

        /// <summary>
        ///   Converts a short integer to a double-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] ToDouble(this short[][] value)
        {
            return ToDouble(value, Jagged.CreateAs<short, double>(value));
        }





        /// <summary>
        ///   Converts a short integer array to a double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] ToDouble(this short[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Double)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional short integer array to a multidimensional double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] ToDouble(this short[,] value, double[,] result)
        {
            unsafe
            {
                fixed (short* src = value)
                fixed (double* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (double)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional short integer array to a jagged double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] ToDouble(this short[,] value, double[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Double)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged short integer array to a jagged double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] ToDouble(this short[][] value, double[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Double)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged short integer array to a multidimensional double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] ToDouble(this short[][] value, double[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Double)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a short integer to a long integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] ToInt64(this short[] value)
        {
            return ToInt64(value, new long[value.Length]);
        }

        /// <summary>
        ///   Converts a short integer to a long integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] ToInt64(this short[,] value)
        {
            return ToInt64(value, Matrix.CreateAs<short, long>(value));
        }

        /// <summary>
        ///   Converts a short integer to a long integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] ToInt64(this short[][] value)
        {
            return ToInt64(value, Jagged.CreateAs<short, long>(value));
        }





        /// <summary>
        ///   Converts a short integer array to a long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] ToInt64(this short[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Int64)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional short integer array to a multidimensional long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] ToInt64(this short[,] value, long[,] result)
        {
            unsafe
            {
                fixed (short* src = value)
                fixed (long* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (long)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional short integer array to a jagged long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] ToInt64(this short[,] value, long[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Int64)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged short integer array to a jagged long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] ToInt64(this short[][] value, long[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Int64)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged short integer array to a multidimensional long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] ToInt64(this short[][] value, long[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Int64)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a short integer to a 8-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] ToByte(this short[] value)
        {
            return ToByte(value, new byte[value.Length]);
        }

        /// <summary>
        ///   Converts a short integer to a 8-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] ToByte(this short[,] value)
        {
            return ToByte(value, Matrix.CreateAs<short, byte>(value));
        }

        /// <summary>
        ///   Converts a short integer to a 8-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] ToByte(this short[][] value)
        {
            return ToByte(value, Jagged.CreateAs<short, byte>(value));
        }





        /// <summary>
        ///   Converts a short integer array to a 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] ToByte(this short[] value, byte[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Byte)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional short integer array to a multidimensional 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] ToByte(this short[,] value, byte[,] result)
        {
            unsafe
            {
                fixed (short* src = value)
                fixed (byte* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (byte)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional short integer array to a jagged 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] ToByte(this short[,] value, byte[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Byte)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged short integer array to a jagged 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] ToByte(this short[][] value, byte[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Byte)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged short integer array to a multidimensional 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] ToByte(this short[][] value, byte[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Byte)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a short integer to a signed 7-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[] ToSByte(this short[] value)
        {
            return ToSByte(value, new sbyte[value.Length]);
        }

        /// <summary>
        ///   Converts a short integer to a signed 7-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[,] ToSByte(this short[,] value)
        {
            return ToSByte(value, Matrix.CreateAs<short, sbyte>(value));
        }

        /// <summary>
        ///   Converts a short integer to a signed 7-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[][] ToSByte(this short[][] value)
        {
            return ToSByte(value, Jagged.CreateAs<short, sbyte>(value));
        }





        /// <summary>
        ///   Converts a short integer array to a signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[] ToSByte(this short[] value, sbyte[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (SByte)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional short integer array to a multidimensional signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[,] ToSByte(this short[,] value, sbyte[,] result)
        {
            unsafe
            {
                fixed (short* src = value)
                fixed (sbyte* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (sbyte)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional short integer array to a jagged signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[][] ToSByte(this short[,] value, sbyte[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (SByte)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged short integer array to a jagged signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[][] ToSByte(this short[][] value, sbyte[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (SByte)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged short integer array to a multidimensional signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[,] ToSByte(this short[][] value, sbyte[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (SByte)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a short integer to a decimal fixed-point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] ToDecimal(this short[] value)
        {
            return ToDecimal(value, new decimal[value.Length]);
        }

        /// <summary>
        ///   Converts a short integer to a decimal fixed-point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] ToDecimal(this short[,] value)
        {
            return ToDecimal(value, Matrix.CreateAs<short, decimal>(value));
        }

        /// <summary>
        ///   Converts a short integer to a decimal fixed-point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] ToDecimal(this short[][] value)
        {
            return ToDecimal(value, Jagged.CreateAs<short, decimal>(value));
        }





        /// <summary>
        ///   Converts a short integer array to a decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] ToDecimal(this short[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Decimal)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional short integer array to a multidimensional decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] ToDecimal(this short[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (short* src = value)
                fixed (decimal* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (decimal)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional short integer array to a jagged decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] ToDecimal(this short[,] value, decimal[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Decimal)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged short integer array to a jagged decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] ToDecimal(this short[][] value, decimal[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Decimal)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged short integer array to a multidimensional decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] ToDecimal(this short[][] value, decimal[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Decimal)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a single-precision floating point to a integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] ToInt32(this float[] value)
        {
            return ToInt32(value, new int[value.Length]);
        }

        /// <summary>
        ///   Converts a single-precision floating point to a integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] ToInt32(this float[,] value)
        {
            return ToInt32(value, Matrix.CreateAs<float, int>(value));
        }

        /// <summary>
        ///   Converts a single-precision floating point to a integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] ToInt32(this float[][] value)
        {
            return ToInt32(value, Jagged.CreateAs<float, int>(value));
        }





        /// <summary>
        ///   Converts a single-precision floating point array to a integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] ToInt32(this float[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Int32)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional single-precision floating point array to a multidimensional integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] ToInt32(this float[,] value, int[,] result)
        {
            unsafe
            {
                fixed (float* src = value)
                fixed (int* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (int)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional single-precision floating point array to a jagged integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] ToInt32(this float[,] value, int[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Int32)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged single-precision floating point array to a jagged integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] ToInt32(this float[][] value, int[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Int32)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged single-precision floating point array to a multidimensional integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] ToInt32(this float[][] value, int[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Int32)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a single-precision floating point to a short integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] ToInt16(this float[] value)
        {
            return ToInt16(value, new short[value.Length]);
        }

        /// <summary>
        ///   Converts a single-precision floating point to a short integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] ToInt16(this float[,] value)
        {
            return ToInt16(value, Matrix.CreateAs<float, short>(value));
        }

        /// <summary>
        ///   Converts a single-precision floating point to a short integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] ToInt16(this float[][] value)
        {
            return ToInt16(value, Jagged.CreateAs<float, short>(value));
        }





        /// <summary>
        ///   Converts a single-precision floating point array to a short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] ToInt16(this float[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Int16)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional single-precision floating point array to a multidimensional short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] ToInt16(this float[,] value, short[,] result)
        {
            unsafe
            {
                fixed (float* src = value)
                fixed (short* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (short)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional single-precision floating point array to a jagged short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] ToInt16(this float[,] value, short[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Int16)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged single-precision floating point array to a jagged short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] ToInt16(this float[][] value, short[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Int16)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged single-precision floating point array to a multidimensional short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] ToInt16(this float[][] value, short[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Int16)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a single-precision floating point to a double-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] ToDouble(this float[] value)
        {
            return ToDouble(value, new double[value.Length]);
        }

        /// <summary>
        ///   Converts a single-precision floating point to a double-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] ToDouble(this float[,] value)
        {
            return ToDouble(value, Matrix.CreateAs<float, double>(value));
        }

        /// <summary>
        ///   Converts a single-precision floating point to a double-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] ToDouble(this float[][] value)
        {
            return ToDouble(value, Jagged.CreateAs<float, double>(value));
        }





        /// <summary>
        ///   Converts a single-precision floating point array to a double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] ToDouble(this float[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Double)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional single-precision floating point array to a multidimensional double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] ToDouble(this float[,] value, double[,] result)
        {
            unsafe
            {
                fixed (float* src = value)
                fixed (double* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (double)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional single-precision floating point array to a jagged double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] ToDouble(this float[,] value, double[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Double)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged single-precision floating point array to a jagged double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] ToDouble(this float[][] value, double[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Double)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged single-precision floating point array to a multidimensional double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] ToDouble(this float[][] value, double[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Double)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a single-precision floating point to a long integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] ToInt64(this float[] value)
        {
            return ToInt64(value, new long[value.Length]);
        }

        /// <summary>
        ///   Converts a single-precision floating point to a long integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] ToInt64(this float[,] value)
        {
            return ToInt64(value, Matrix.CreateAs<float, long>(value));
        }

        /// <summary>
        ///   Converts a single-precision floating point to a long integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] ToInt64(this float[][] value)
        {
            return ToInt64(value, Jagged.CreateAs<float, long>(value));
        }





        /// <summary>
        ///   Converts a single-precision floating point array to a long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] ToInt64(this float[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Int64)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional single-precision floating point array to a multidimensional long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] ToInt64(this float[,] value, long[,] result)
        {
            unsafe
            {
                fixed (float* src = value)
                fixed (long* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (long)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional single-precision floating point array to a jagged long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] ToInt64(this float[,] value, long[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Int64)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged single-precision floating point array to a jagged long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] ToInt64(this float[][] value, long[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Int64)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged single-precision floating point array to a multidimensional long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] ToInt64(this float[][] value, long[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Int64)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a single-precision floating point to a 8-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] ToByte(this float[] value)
        {
            return ToByte(value, new byte[value.Length]);
        }

        /// <summary>
        ///   Converts a single-precision floating point to a 8-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] ToByte(this float[,] value)
        {
            return ToByte(value, Matrix.CreateAs<float, byte>(value));
        }

        /// <summary>
        ///   Converts a single-precision floating point to a 8-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] ToByte(this float[][] value)
        {
            return ToByte(value, Jagged.CreateAs<float, byte>(value));
        }





        /// <summary>
        ///   Converts a single-precision floating point array to a 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] ToByte(this float[] value, byte[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Byte)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional single-precision floating point array to a multidimensional 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] ToByte(this float[,] value, byte[,] result)
        {
            unsafe
            {
                fixed (float* src = value)
                fixed (byte* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (byte)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional single-precision floating point array to a jagged 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] ToByte(this float[,] value, byte[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Byte)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged single-precision floating point array to a jagged 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] ToByte(this float[][] value, byte[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Byte)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged single-precision floating point array to a multidimensional 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] ToByte(this float[][] value, byte[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Byte)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a single-precision floating point to a signed 7-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[] ToSByte(this float[] value)
        {
            return ToSByte(value, new sbyte[value.Length]);
        }

        /// <summary>
        ///   Converts a single-precision floating point to a signed 7-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[,] ToSByte(this float[,] value)
        {
            return ToSByte(value, Matrix.CreateAs<float, sbyte>(value));
        }

        /// <summary>
        ///   Converts a single-precision floating point to a signed 7-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[][] ToSByte(this float[][] value)
        {
            return ToSByte(value, Jagged.CreateAs<float, sbyte>(value));
        }





        /// <summary>
        ///   Converts a single-precision floating point array to a signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[] ToSByte(this float[] value, sbyte[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (SByte)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional single-precision floating point array to a multidimensional signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[,] ToSByte(this float[,] value, sbyte[,] result)
        {
            unsafe
            {
                fixed (float* src = value)
                fixed (sbyte* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (sbyte)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional single-precision floating point array to a jagged signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[][] ToSByte(this float[,] value, sbyte[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (SByte)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged single-precision floating point array to a jagged signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[][] ToSByte(this float[][] value, sbyte[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (SByte)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged single-precision floating point array to a multidimensional signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[,] ToSByte(this float[][] value, sbyte[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (SByte)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a single-precision floating point to a decimal fixed-point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] ToDecimal(this float[] value)
        {
            return ToDecimal(value, new decimal[value.Length]);
        }

        /// <summary>
        ///   Converts a single-precision floating point to a decimal fixed-point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] ToDecimal(this float[,] value)
        {
            return ToDecimal(value, Matrix.CreateAs<float, decimal>(value));
        }

        /// <summary>
        ///   Converts a single-precision floating point to a decimal fixed-point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] ToDecimal(this float[][] value)
        {
            return ToDecimal(value, Jagged.CreateAs<float, decimal>(value));
        }





        /// <summary>
        ///   Converts a single-precision floating point array to a decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] ToDecimal(this float[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Decimal)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional single-precision floating point array to a multidimensional decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] ToDecimal(this float[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (float* src = value)
                fixed (decimal* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (decimal)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional single-precision floating point array to a jagged decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] ToDecimal(this float[,] value, decimal[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Decimal)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged single-precision floating point array to a jagged decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] ToDecimal(this float[][] value, decimal[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Decimal)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged single-precision floating point array to a multidimensional decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] ToDecimal(this float[][] value, decimal[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Decimal)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a double-precision floating point to a integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] ToInt32(this double[] value)
        {
            return ToInt32(value, new int[value.Length]);
        }

        /// <summary>
        ///   Converts a double-precision floating point to a integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] ToInt32(this double[,] value)
        {
            return ToInt32(value, Matrix.CreateAs<double, int>(value));
        }

        /// <summary>
        ///   Converts a double-precision floating point to a integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] ToInt32(this double[][] value)
        {
            return ToInt32(value, Jagged.CreateAs<double, int>(value));
        }





        /// <summary>
        ///   Converts a double-precision floating point array to a integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] ToInt32(this double[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Int32)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional double-precision floating point array to a multidimensional integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] ToInt32(this double[,] value, int[,] result)
        {
            unsafe
            {
                fixed (double* src = value)
                fixed (int* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (int)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional double-precision floating point array to a jagged integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] ToInt32(this double[,] value, int[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Int32)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged double-precision floating point array to a jagged integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] ToInt32(this double[][] value, int[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Int32)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged double-precision floating point array to a multidimensional integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] ToInt32(this double[][] value, int[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Int32)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a double-precision floating point to a short integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] ToInt16(this double[] value)
        {
            return ToInt16(value, new short[value.Length]);
        }

        /// <summary>
        ///   Converts a double-precision floating point to a short integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] ToInt16(this double[,] value)
        {
            return ToInt16(value, Matrix.CreateAs<double, short>(value));
        }

        /// <summary>
        ///   Converts a double-precision floating point to a short integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] ToInt16(this double[][] value)
        {
            return ToInt16(value, Jagged.CreateAs<double, short>(value));
        }





        /// <summary>
        ///   Converts a double-precision floating point array to a short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] ToInt16(this double[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Int16)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional double-precision floating point array to a multidimensional short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] ToInt16(this double[,] value, short[,] result)
        {
            unsafe
            {
                fixed (double* src = value)
                fixed (short* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (short)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional double-precision floating point array to a jagged short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] ToInt16(this double[,] value, short[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Int16)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged double-precision floating point array to a jagged short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] ToInt16(this double[][] value, short[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Int16)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged double-precision floating point array to a multidimensional short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] ToInt16(this double[][] value, short[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Int16)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a double-precision floating point to a single-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] ToSingle(this double[] value)
        {
            return ToSingle(value, new float[value.Length]);
        }

        /// <summary>
        ///   Converts a double-precision floating point to a single-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] ToSingle(this double[,] value)
        {
            return ToSingle(value, Matrix.CreateAs<double, float>(value));
        }

        /// <summary>
        ///   Converts a double-precision floating point to a single-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] ToSingle(this double[][] value)
        {
            return ToSingle(value, Jagged.CreateAs<double, float>(value));
        }





        /// <summary>
        ///   Converts a double-precision floating point array to a single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] ToSingle(this double[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Single)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional double-precision floating point array to a multidimensional single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] ToSingle(this double[,] value, float[,] result)
        {
            unsafe
            {
                fixed (double* src = value)
                fixed (float* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (float)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional double-precision floating point array to a jagged single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] ToSingle(this double[,] value, float[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Single)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged double-precision floating point array to a jagged single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] ToSingle(this double[][] value, float[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Single)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged double-precision floating point array to a multidimensional single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] ToSingle(this double[][] value, float[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Single)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a double-precision floating point to a long integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] ToInt64(this double[] value)
        {
            return ToInt64(value, new long[value.Length]);
        }

        /// <summary>
        ///   Converts a double-precision floating point to a long integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] ToInt64(this double[,] value)
        {
            return ToInt64(value, Matrix.CreateAs<double, long>(value));
        }

        /// <summary>
        ///   Converts a double-precision floating point to a long integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] ToInt64(this double[][] value)
        {
            return ToInt64(value, Jagged.CreateAs<double, long>(value));
        }





        /// <summary>
        ///   Converts a double-precision floating point array to a long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] ToInt64(this double[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Int64)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional double-precision floating point array to a multidimensional long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] ToInt64(this double[,] value, long[,] result)
        {
            unsafe
            {
                fixed (double* src = value)
                fixed (long* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (long)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional double-precision floating point array to a jagged long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] ToInt64(this double[,] value, long[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Int64)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged double-precision floating point array to a jagged long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] ToInt64(this double[][] value, long[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Int64)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged double-precision floating point array to a multidimensional long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] ToInt64(this double[][] value, long[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Int64)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a double-precision floating point to a 8-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] ToByte(this double[] value)
        {
            return ToByte(value, new byte[value.Length]);
        }

        /// <summary>
        ///   Converts a double-precision floating point to a 8-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] ToByte(this double[,] value)
        {
            return ToByte(value, Matrix.CreateAs<double, byte>(value));
        }

        /// <summary>
        ///   Converts a double-precision floating point to a 8-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] ToByte(this double[][] value)
        {
            return ToByte(value, Jagged.CreateAs<double, byte>(value));
        }





        /// <summary>
        ///   Converts a double-precision floating point array to a 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] ToByte(this double[] value, byte[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Byte)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional double-precision floating point array to a multidimensional 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] ToByte(this double[,] value, byte[,] result)
        {
            unsafe
            {
                fixed (double* src = value)
                fixed (byte* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (byte)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional double-precision floating point array to a jagged 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] ToByte(this double[,] value, byte[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Byte)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged double-precision floating point array to a jagged 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] ToByte(this double[][] value, byte[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Byte)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged double-precision floating point array to a multidimensional 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] ToByte(this double[][] value, byte[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Byte)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a double-precision floating point to a signed 7-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[] ToSByte(this double[] value)
        {
            return ToSByte(value, new sbyte[value.Length]);
        }

        /// <summary>
        ///   Converts a double-precision floating point to a signed 7-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[,] ToSByte(this double[,] value)
        {
            return ToSByte(value, Matrix.CreateAs<double, sbyte>(value));
        }

        /// <summary>
        ///   Converts a double-precision floating point to a signed 7-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[][] ToSByte(this double[][] value)
        {
            return ToSByte(value, Jagged.CreateAs<double, sbyte>(value));
        }





        /// <summary>
        ///   Converts a double-precision floating point array to a signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[] ToSByte(this double[] value, sbyte[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (SByte)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional double-precision floating point array to a multidimensional signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[,] ToSByte(this double[,] value, sbyte[,] result)
        {
            unsafe
            {
                fixed (double* src = value)
                fixed (sbyte* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (sbyte)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional double-precision floating point array to a jagged signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[][] ToSByte(this double[,] value, sbyte[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (SByte)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged double-precision floating point array to a jagged signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[][] ToSByte(this double[][] value, sbyte[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (SByte)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged double-precision floating point array to a multidimensional signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[,] ToSByte(this double[][] value, sbyte[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (SByte)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a double-precision floating point to a decimal fixed-point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] ToDecimal(this double[] value)
        {
            return ToDecimal(value, new decimal[value.Length]);
        }

        /// <summary>
        ///   Converts a double-precision floating point to a decimal fixed-point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] ToDecimal(this double[,] value)
        {
            return ToDecimal(value, Matrix.CreateAs<double, decimal>(value));
        }

        /// <summary>
        ///   Converts a double-precision floating point to a decimal fixed-point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] ToDecimal(this double[][] value)
        {
            return ToDecimal(value, Jagged.CreateAs<double, decimal>(value));
        }





        /// <summary>
        ///   Converts a double-precision floating point array to a decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] ToDecimal(this double[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Decimal)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional double-precision floating point array to a multidimensional decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] ToDecimal(this double[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (double* src = value)
                fixed (decimal* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (decimal)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional double-precision floating point array to a jagged decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] ToDecimal(this double[,] value, decimal[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Decimal)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged double-precision floating point array to a jagged decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] ToDecimal(this double[][] value, decimal[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Decimal)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged double-precision floating point array to a multidimensional decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] ToDecimal(this double[][] value, decimal[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Decimal)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a long integer to a integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] ToInt32(this long[] value)
        {
            return ToInt32(value, new int[value.Length]);
        }

        /// <summary>
        ///   Converts a long integer to a integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] ToInt32(this long[,] value)
        {
            return ToInt32(value, Matrix.CreateAs<long, int>(value));
        }

        /// <summary>
        ///   Converts a long integer to a integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] ToInt32(this long[][] value)
        {
            return ToInt32(value, Jagged.CreateAs<long, int>(value));
        }





        /// <summary>
        ///   Converts a long integer array to a integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] ToInt32(this long[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Int32)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional long integer array to a multidimensional integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] ToInt32(this long[,] value, int[,] result)
        {
            unsafe
            {
                fixed (long* src = value)
                fixed (int* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (int)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional long integer array to a jagged integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] ToInt32(this long[,] value, int[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Int32)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged long integer array to a jagged integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] ToInt32(this long[][] value, int[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Int32)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged long integer array to a multidimensional integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] ToInt32(this long[][] value, int[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Int32)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a long integer to a short integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] ToInt16(this long[] value)
        {
            return ToInt16(value, new short[value.Length]);
        }

        /// <summary>
        ///   Converts a long integer to a short integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] ToInt16(this long[,] value)
        {
            return ToInt16(value, Matrix.CreateAs<long, short>(value));
        }

        /// <summary>
        ///   Converts a long integer to a short integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] ToInt16(this long[][] value)
        {
            return ToInt16(value, Jagged.CreateAs<long, short>(value));
        }





        /// <summary>
        ///   Converts a long integer array to a short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] ToInt16(this long[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Int16)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional long integer array to a multidimensional short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] ToInt16(this long[,] value, short[,] result)
        {
            unsafe
            {
                fixed (long* src = value)
                fixed (short* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (short)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional long integer array to a jagged short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] ToInt16(this long[,] value, short[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Int16)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged long integer array to a jagged short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] ToInt16(this long[][] value, short[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Int16)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged long integer array to a multidimensional short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] ToInt16(this long[][] value, short[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Int16)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a long integer to a single-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] ToSingle(this long[] value)
        {
            return ToSingle(value, new float[value.Length]);
        }

        /// <summary>
        ///   Converts a long integer to a single-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] ToSingle(this long[,] value)
        {
            return ToSingle(value, Matrix.CreateAs<long, float>(value));
        }

        /// <summary>
        ///   Converts a long integer to a single-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] ToSingle(this long[][] value)
        {
            return ToSingle(value, Jagged.CreateAs<long, float>(value));
        }





        /// <summary>
        ///   Converts a long integer array to a single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] ToSingle(this long[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Single)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional long integer array to a multidimensional single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] ToSingle(this long[,] value, float[,] result)
        {
            unsafe
            {
                fixed (long* src = value)
                fixed (float* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (float)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional long integer array to a jagged single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] ToSingle(this long[,] value, float[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Single)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged long integer array to a jagged single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] ToSingle(this long[][] value, float[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Single)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged long integer array to a multidimensional single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] ToSingle(this long[][] value, float[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Single)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a long integer to a double-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] ToDouble(this long[] value)
        {
            return ToDouble(value, new double[value.Length]);
        }

        /// <summary>
        ///   Converts a long integer to a double-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] ToDouble(this long[,] value)
        {
            return ToDouble(value, Matrix.CreateAs<long, double>(value));
        }

        /// <summary>
        ///   Converts a long integer to a double-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] ToDouble(this long[][] value)
        {
            return ToDouble(value, Jagged.CreateAs<long, double>(value));
        }





        /// <summary>
        ///   Converts a long integer array to a double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] ToDouble(this long[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Double)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional long integer array to a multidimensional double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] ToDouble(this long[,] value, double[,] result)
        {
            unsafe
            {
                fixed (long* src = value)
                fixed (double* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (double)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional long integer array to a jagged double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] ToDouble(this long[,] value, double[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Double)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged long integer array to a jagged double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] ToDouble(this long[][] value, double[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Double)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged long integer array to a multidimensional double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] ToDouble(this long[][] value, double[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Double)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a long integer to a 8-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] ToByte(this long[] value)
        {
            return ToByte(value, new byte[value.Length]);
        }

        /// <summary>
        ///   Converts a long integer to a 8-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] ToByte(this long[,] value)
        {
            return ToByte(value, Matrix.CreateAs<long, byte>(value));
        }

        /// <summary>
        ///   Converts a long integer to a 8-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] ToByte(this long[][] value)
        {
            return ToByte(value, Jagged.CreateAs<long, byte>(value));
        }





        /// <summary>
        ///   Converts a long integer array to a 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] ToByte(this long[] value, byte[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Byte)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional long integer array to a multidimensional 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] ToByte(this long[,] value, byte[,] result)
        {
            unsafe
            {
                fixed (long* src = value)
                fixed (byte* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (byte)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional long integer array to a jagged 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] ToByte(this long[,] value, byte[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Byte)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged long integer array to a jagged 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] ToByte(this long[][] value, byte[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Byte)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged long integer array to a multidimensional 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] ToByte(this long[][] value, byte[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Byte)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a long integer to a signed 7-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[] ToSByte(this long[] value)
        {
            return ToSByte(value, new sbyte[value.Length]);
        }

        /// <summary>
        ///   Converts a long integer to a signed 7-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[,] ToSByte(this long[,] value)
        {
            return ToSByte(value, Matrix.CreateAs<long, sbyte>(value));
        }

        /// <summary>
        ///   Converts a long integer to a signed 7-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[][] ToSByte(this long[][] value)
        {
            return ToSByte(value, Jagged.CreateAs<long, sbyte>(value));
        }





        /// <summary>
        ///   Converts a long integer array to a signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[] ToSByte(this long[] value, sbyte[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (SByte)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional long integer array to a multidimensional signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[,] ToSByte(this long[,] value, sbyte[,] result)
        {
            unsafe
            {
                fixed (long* src = value)
                fixed (sbyte* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (sbyte)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional long integer array to a jagged signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[][] ToSByte(this long[,] value, sbyte[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (SByte)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged long integer array to a jagged signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[][] ToSByte(this long[][] value, sbyte[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (SByte)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged long integer array to a multidimensional signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[,] ToSByte(this long[][] value, sbyte[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (SByte)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a long integer to a decimal fixed-point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] ToDecimal(this long[] value)
        {
            return ToDecimal(value, new decimal[value.Length]);
        }

        /// <summary>
        ///   Converts a long integer to a decimal fixed-point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] ToDecimal(this long[,] value)
        {
            return ToDecimal(value, Matrix.CreateAs<long, decimal>(value));
        }

        /// <summary>
        ///   Converts a long integer to a decimal fixed-point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] ToDecimal(this long[][] value)
        {
            return ToDecimal(value, Jagged.CreateAs<long, decimal>(value));
        }





        /// <summary>
        ///   Converts a long integer array to a decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] ToDecimal(this long[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Decimal)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional long integer array to a multidimensional decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] ToDecimal(this long[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (long* src = value)
                fixed (decimal* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (decimal)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional long integer array to a jagged decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] ToDecimal(this long[,] value, decimal[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Decimal)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged long integer array to a jagged decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] ToDecimal(this long[][] value, decimal[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Decimal)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged long integer array to a multidimensional decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] ToDecimal(this long[][] value, decimal[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Decimal)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a 8-bit byte to a integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] ToInt32(this byte[] value)
        {
            return ToInt32(value, new int[value.Length]);
        }

        /// <summary>
        ///   Converts a 8-bit byte to a integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] ToInt32(this byte[,] value)
        {
            return ToInt32(value, Matrix.CreateAs<byte, int>(value));
        }

        /// <summary>
        ///   Converts a 8-bit byte to a integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] ToInt32(this byte[][] value)
        {
            return ToInt32(value, Jagged.CreateAs<byte, int>(value));
        }





        /// <summary>
        ///   Converts a 8-bit byte array to a integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] ToInt32(this byte[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Int32)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional 8-bit byte array to a multidimensional integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] ToInt32(this byte[,] value, int[,] result)
        {
            unsafe
            {
                fixed (byte* src = value)
                fixed (int* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (int)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional 8-bit byte array to a jagged integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] ToInt32(this byte[,] value, int[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Int32)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged 8-bit byte array to a jagged integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] ToInt32(this byte[][] value, int[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Int32)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged 8-bit byte array to a multidimensional integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] ToInt32(this byte[][] value, int[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Int32)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a 8-bit byte to a short integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] ToInt16(this byte[] value)
        {
            return ToInt16(value, new short[value.Length]);
        }

        /// <summary>
        ///   Converts a 8-bit byte to a short integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] ToInt16(this byte[,] value)
        {
            return ToInt16(value, Matrix.CreateAs<byte, short>(value));
        }

        /// <summary>
        ///   Converts a 8-bit byte to a short integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] ToInt16(this byte[][] value)
        {
            return ToInt16(value, Jagged.CreateAs<byte, short>(value));
        }





        /// <summary>
        ///   Converts a 8-bit byte array to a short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] ToInt16(this byte[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Int16)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional 8-bit byte array to a multidimensional short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] ToInt16(this byte[,] value, short[,] result)
        {
            unsafe
            {
                fixed (byte* src = value)
                fixed (short* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (short)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional 8-bit byte array to a jagged short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] ToInt16(this byte[,] value, short[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Int16)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged 8-bit byte array to a jagged short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] ToInt16(this byte[][] value, short[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Int16)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged 8-bit byte array to a multidimensional short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] ToInt16(this byte[][] value, short[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Int16)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a 8-bit byte to a single-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] ToSingle(this byte[] value)
        {
            return ToSingle(value, new float[value.Length]);
        }

        /// <summary>
        ///   Converts a 8-bit byte to a single-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] ToSingle(this byte[,] value)
        {
            return ToSingle(value, Matrix.CreateAs<byte, float>(value));
        }

        /// <summary>
        ///   Converts a 8-bit byte to a single-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] ToSingle(this byte[][] value)
        {
            return ToSingle(value, Jagged.CreateAs<byte, float>(value));
        }





        /// <summary>
        ///   Converts a 8-bit byte array to a single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] ToSingle(this byte[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Single)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional 8-bit byte array to a multidimensional single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] ToSingle(this byte[,] value, float[,] result)
        {
            unsafe
            {
                fixed (byte* src = value)
                fixed (float* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (float)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional 8-bit byte array to a jagged single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] ToSingle(this byte[,] value, float[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Single)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged 8-bit byte array to a jagged single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] ToSingle(this byte[][] value, float[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Single)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged 8-bit byte array to a multidimensional single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] ToSingle(this byte[][] value, float[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Single)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a 8-bit byte to a double-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] ToDouble(this byte[] value)
        {
            return ToDouble(value, new double[value.Length]);
        }

        /// <summary>
        ///   Converts a 8-bit byte to a double-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] ToDouble(this byte[,] value)
        {
            return ToDouble(value, Matrix.CreateAs<byte, double>(value));
        }

        /// <summary>
        ///   Converts a 8-bit byte to a double-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] ToDouble(this byte[][] value)
        {
            return ToDouble(value, Jagged.CreateAs<byte, double>(value));
        }





        /// <summary>
        ///   Converts a 8-bit byte array to a double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] ToDouble(this byte[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Double)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional 8-bit byte array to a multidimensional double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] ToDouble(this byte[,] value, double[,] result)
        {
            unsafe
            {
                fixed (byte* src = value)
                fixed (double* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (double)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional 8-bit byte array to a jagged double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] ToDouble(this byte[,] value, double[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Double)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged 8-bit byte array to a jagged double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] ToDouble(this byte[][] value, double[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Double)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged 8-bit byte array to a multidimensional double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] ToDouble(this byte[][] value, double[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Double)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a 8-bit byte to a long integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] ToInt64(this byte[] value)
        {
            return ToInt64(value, new long[value.Length]);
        }

        /// <summary>
        ///   Converts a 8-bit byte to a long integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] ToInt64(this byte[,] value)
        {
            return ToInt64(value, Matrix.CreateAs<byte, long>(value));
        }

        /// <summary>
        ///   Converts a 8-bit byte to a long integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] ToInt64(this byte[][] value)
        {
            return ToInt64(value, Jagged.CreateAs<byte, long>(value));
        }





        /// <summary>
        ///   Converts a 8-bit byte array to a long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] ToInt64(this byte[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Int64)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional 8-bit byte array to a multidimensional long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] ToInt64(this byte[,] value, long[,] result)
        {
            unsafe
            {
                fixed (byte* src = value)
                fixed (long* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (long)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional 8-bit byte array to a jagged long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] ToInt64(this byte[,] value, long[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Int64)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged 8-bit byte array to a jagged long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] ToInt64(this byte[][] value, long[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Int64)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged 8-bit byte array to a multidimensional long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] ToInt64(this byte[][] value, long[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Int64)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a 8-bit byte to a signed 7-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[] ToSByte(this byte[] value)
        {
            return ToSByte(value, new sbyte[value.Length]);
        }

        /// <summary>
        ///   Converts a 8-bit byte to a signed 7-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[,] ToSByte(this byte[,] value)
        {
            return ToSByte(value, Matrix.CreateAs<byte, sbyte>(value));
        }

        /// <summary>
        ///   Converts a 8-bit byte to a signed 7-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[][] ToSByte(this byte[][] value)
        {
            return ToSByte(value, Jagged.CreateAs<byte, sbyte>(value));
        }





        /// <summary>
        ///   Converts a 8-bit byte array to a signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[] ToSByte(this byte[] value, sbyte[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (SByte)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional 8-bit byte array to a multidimensional signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[,] ToSByte(this byte[,] value, sbyte[,] result)
        {
            unsafe
            {
                fixed (byte* src = value)
                fixed (sbyte* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (sbyte)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional 8-bit byte array to a jagged signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[][] ToSByte(this byte[,] value, sbyte[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (SByte)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged 8-bit byte array to a jagged signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[][] ToSByte(this byte[][] value, sbyte[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (SByte)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged 8-bit byte array to a multidimensional signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[,] ToSByte(this byte[][] value, sbyte[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (SByte)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a 8-bit byte to a decimal fixed-point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] ToDecimal(this byte[] value)
        {
            return ToDecimal(value, new decimal[value.Length]);
        }

        /// <summary>
        ///   Converts a 8-bit byte to a decimal fixed-point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] ToDecimal(this byte[,] value)
        {
            return ToDecimal(value, Matrix.CreateAs<byte, decimal>(value));
        }

        /// <summary>
        ///   Converts a 8-bit byte to a decimal fixed-point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] ToDecimal(this byte[][] value)
        {
            return ToDecimal(value, Jagged.CreateAs<byte, decimal>(value));
        }





        /// <summary>
        ///   Converts a 8-bit byte array to a decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] ToDecimal(this byte[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Decimal)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional 8-bit byte array to a multidimensional decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] ToDecimal(this byte[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (byte* src = value)
                fixed (decimal* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (decimal)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional 8-bit byte array to a jagged decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] ToDecimal(this byte[,] value, decimal[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Decimal)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged 8-bit byte array to a jagged decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] ToDecimal(this byte[][] value, decimal[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Decimal)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged 8-bit byte array to a multidimensional decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] ToDecimal(this byte[][] value, decimal[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Decimal)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a signed 7-bit byte to a integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] ToInt32(this sbyte[] value)
        {
            return ToInt32(value, new int[value.Length]);
        }

        /// <summary>
        ///   Converts a signed 7-bit byte to a integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] ToInt32(this sbyte[,] value)
        {
            return ToInt32(value, Matrix.CreateAs<sbyte, int>(value));
        }

        /// <summary>
        ///   Converts a signed 7-bit byte to a integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] ToInt32(this sbyte[][] value)
        {
            return ToInt32(value, Jagged.CreateAs<sbyte, int>(value));
        }





        /// <summary>
        ///   Converts a signed 7-bit byte array to a integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] ToInt32(this sbyte[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Int32)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional signed 7-bit byte array to a multidimensional integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] ToInt32(this sbyte[,] value, int[,] result)
        {
            unsafe
            {
                fixed (sbyte* src = value)
                fixed (int* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (int)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional signed 7-bit byte array to a jagged integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] ToInt32(this sbyte[,] value, int[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Int32)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged signed 7-bit byte array to a jagged integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] ToInt32(this sbyte[][] value, int[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Int32)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged signed 7-bit byte array to a multidimensional integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] ToInt32(this sbyte[][] value, int[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Int32)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a signed 7-bit byte to a short integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] ToInt16(this sbyte[] value)
        {
            return ToInt16(value, new short[value.Length]);
        }

        /// <summary>
        ///   Converts a signed 7-bit byte to a short integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] ToInt16(this sbyte[,] value)
        {
            return ToInt16(value, Matrix.CreateAs<sbyte, short>(value));
        }

        /// <summary>
        ///   Converts a signed 7-bit byte to a short integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] ToInt16(this sbyte[][] value)
        {
            return ToInt16(value, Jagged.CreateAs<sbyte, short>(value));
        }





        /// <summary>
        ///   Converts a signed 7-bit byte array to a short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] ToInt16(this sbyte[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Int16)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional signed 7-bit byte array to a multidimensional short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] ToInt16(this sbyte[,] value, short[,] result)
        {
            unsafe
            {
                fixed (sbyte* src = value)
                fixed (short* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (short)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional signed 7-bit byte array to a jagged short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] ToInt16(this sbyte[,] value, short[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Int16)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged signed 7-bit byte array to a jagged short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] ToInt16(this sbyte[][] value, short[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Int16)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged signed 7-bit byte array to a multidimensional short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] ToInt16(this sbyte[][] value, short[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Int16)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a signed 7-bit byte to a single-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] ToSingle(this sbyte[] value)
        {
            return ToSingle(value, new float[value.Length]);
        }

        /// <summary>
        ///   Converts a signed 7-bit byte to a single-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] ToSingle(this sbyte[,] value)
        {
            return ToSingle(value, Matrix.CreateAs<sbyte, float>(value));
        }

        /// <summary>
        ///   Converts a signed 7-bit byte to a single-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] ToSingle(this sbyte[][] value)
        {
            return ToSingle(value, Jagged.CreateAs<sbyte, float>(value));
        }





        /// <summary>
        ///   Converts a signed 7-bit byte array to a single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] ToSingle(this sbyte[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Single)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional signed 7-bit byte array to a multidimensional single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] ToSingle(this sbyte[,] value, float[,] result)
        {
            unsafe
            {
                fixed (sbyte* src = value)
                fixed (float* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (float)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional signed 7-bit byte array to a jagged single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] ToSingle(this sbyte[,] value, float[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Single)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged signed 7-bit byte array to a jagged single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] ToSingle(this sbyte[][] value, float[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Single)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged signed 7-bit byte array to a multidimensional single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] ToSingle(this sbyte[][] value, float[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Single)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a signed 7-bit byte to a double-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] ToDouble(this sbyte[] value)
        {
            return ToDouble(value, new double[value.Length]);
        }

        /// <summary>
        ///   Converts a signed 7-bit byte to a double-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] ToDouble(this sbyte[,] value)
        {
            return ToDouble(value, Matrix.CreateAs<sbyte, double>(value));
        }

        /// <summary>
        ///   Converts a signed 7-bit byte to a double-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] ToDouble(this sbyte[][] value)
        {
            return ToDouble(value, Jagged.CreateAs<sbyte, double>(value));
        }





        /// <summary>
        ///   Converts a signed 7-bit byte array to a double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] ToDouble(this sbyte[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Double)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional signed 7-bit byte array to a multidimensional double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] ToDouble(this sbyte[,] value, double[,] result)
        {
            unsafe
            {
                fixed (sbyte* src = value)
                fixed (double* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (double)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional signed 7-bit byte array to a jagged double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] ToDouble(this sbyte[,] value, double[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Double)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged signed 7-bit byte array to a jagged double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] ToDouble(this sbyte[][] value, double[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Double)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged signed 7-bit byte array to a multidimensional double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] ToDouble(this sbyte[][] value, double[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Double)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a signed 7-bit byte to a long integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] ToInt64(this sbyte[] value)
        {
            return ToInt64(value, new long[value.Length]);
        }

        /// <summary>
        ///   Converts a signed 7-bit byte to a long integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] ToInt64(this sbyte[,] value)
        {
            return ToInt64(value, Matrix.CreateAs<sbyte, long>(value));
        }

        /// <summary>
        ///   Converts a signed 7-bit byte to a long integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] ToInt64(this sbyte[][] value)
        {
            return ToInt64(value, Jagged.CreateAs<sbyte, long>(value));
        }





        /// <summary>
        ///   Converts a signed 7-bit byte array to a long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] ToInt64(this sbyte[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Int64)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional signed 7-bit byte array to a multidimensional long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] ToInt64(this sbyte[,] value, long[,] result)
        {
            unsafe
            {
                fixed (sbyte* src = value)
                fixed (long* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (long)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional signed 7-bit byte array to a jagged long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] ToInt64(this sbyte[,] value, long[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Int64)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged signed 7-bit byte array to a jagged long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] ToInt64(this sbyte[][] value, long[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Int64)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged signed 7-bit byte array to a multidimensional long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] ToInt64(this sbyte[][] value, long[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Int64)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a signed 7-bit byte to a 8-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] ToByte(this sbyte[] value)
        {
            return ToByte(value, new byte[value.Length]);
        }

        /// <summary>
        ///   Converts a signed 7-bit byte to a 8-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] ToByte(this sbyte[,] value)
        {
            return ToByte(value, Matrix.CreateAs<sbyte, byte>(value));
        }

        /// <summary>
        ///   Converts a signed 7-bit byte to a 8-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] ToByte(this sbyte[][] value)
        {
            return ToByte(value, Jagged.CreateAs<sbyte, byte>(value));
        }





        /// <summary>
        ///   Converts a signed 7-bit byte array to a 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] ToByte(this sbyte[] value, byte[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Byte)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional signed 7-bit byte array to a multidimensional 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] ToByte(this sbyte[,] value, byte[,] result)
        {
            unsafe
            {
                fixed (sbyte* src = value)
                fixed (byte* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (byte)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional signed 7-bit byte array to a jagged 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] ToByte(this sbyte[,] value, byte[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Byte)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged signed 7-bit byte array to a jagged 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] ToByte(this sbyte[][] value, byte[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Byte)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged signed 7-bit byte array to a multidimensional 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] ToByte(this sbyte[][] value, byte[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Byte)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a signed 7-bit byte to a decimal fixed-point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] ToDecimal(this sbyte[] value)
        {
            return ToDecimal(value, new decimal[value.Length]);
        }

        /// <summary>
        ///   Converts a signed 7-bit byte to a decimal fixed-point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] ToDecimal(this sbyte[,] value)
        {
            return ToDecimal(value, Matrix.CreateAs<sbyte, decimal>(value));
        }

        /// <summary>
        ///   Converts a signed 7-bit byte to a decimal fixed-point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] ToDecimal(this sbyte[][] value)
        {
            return ToDecimal(value, Jagged.CreateAs<sbyte, decimal>(value));
        }





        /// <summary>
        ///   Converts a signed 7-bit byte array to a decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[] ToDecimal(this sbyte[] value, decimal[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Decimal)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional signed 7-bit byte array to a multidimensional decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] ToDecimal(this sbyte[,] value, decimal[,] result)
        {
            unsafe
            {
                fixed (sbyte* src = value)
                fixed (decimal* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (decimal)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional signed 7-bit byte array to a jagged decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] ToDecimal(this sbyte[,] value, decimal[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Decimal)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged signed 7-bit byte array to a jagged decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[][] ToDecimal(this sbyte[][] value, decimal[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Decimal)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged signed 7-bit byte array to a multidimensional decimal fixed-point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static decimal[,] ToDecimal(this sbyte[][] value, decimal[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Decimal)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a decimal fixed-point to a integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] ToInt32(this decimal[] value)
        {
            return ToInt32(value, new int[value.Length]);
        }

        /// <summary>
        ///   Converts a decimal fixed-point to a integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] ToInt32(this decimal[,] value)
        {
            return ToInt32(value, Matrix.CreateAs<decimal, int>(value));
        }

        /// <summary>
        ///   Converts a decimal fixed-point to a integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] ToInt32(this decimal[][] value)
        {
            return ToInt32(value, Jagged.CreateAs<decimal, int>(value));
        }





        /// <summary>
        ///   Converts a decimal fixed-point array to a integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[] ToInt32(this decimal[] value, int[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Int32)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional decimal fixed-point array to a multidimensional integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] ToInt32(this decimal[,] value, int[,] result)
        {
            unsafe
            {
                fixed (decimal* src = value)
                fixed (int* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (int)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional decimal fixed-point array to a jagged integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] ToInt32(this decimal[,] value, int[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Int32)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged decimal fixed-point array to a jagged integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[][] ToInt32(this decimal[][] value, int[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Int32)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged decimal fixed-point array to a multidimensional integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static int[,] ToInt32(this decimal[][] value, int[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Int32)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a decimal fixed-point to a short integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] ToInt16(this decimal[] value)
        {
            return ToInt16(value, new short[value.Length]);
        }

        /// <summary>
        ///   Converts a decimal fixed-point to a short integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] ToInt16(this decimal[,] value)
        {
            return ToInt16(value, Matrix.CreateAs<decimal, short>(value));
        }

        /// <summary>
        ///   Converts a decimal fixed-point to a short integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] ToInt16(this decimal[][] value)
        {
            return ToInt16(value, Jagged.CreateAs<decimal, short>(value));
        }





        /// <summary>
        ///   Converts a decimal fixed-point array to a short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[] ToInt16(this decimal[] value, short[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Int16)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional decimal fixed-point array to a multidimensional short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] ToInt16(this decimal[,] value, short[,] result)
        {
            unsafe
            {
                fixed (decimal* src = value)
                fixed (short* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (short)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional decimal fixed-point array to a jagged short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] ToInt16(this decimal[,] value, short[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Int16)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged decimal fixed-point array to a jagged short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[][] ToInt16(this decimal[][] value, short[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Int16)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged decimal fixed-point array to a multidimensional short integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static short[,] ToInt16(this decimal[][] value, short[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Int16)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a decimal fixed-point to a single-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] ToSingle(this decimal[] value)
        {
            return ToSingle(value, new float[value.Length]);
        }

        /// <summary>
        ///   Converts a decimal fixed-point to a single-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] ToSingle(this decimal[,] value)
        {
            return ToSingle(value, Matrix.CreateAs<decimal, float>(value));
        }

        /// <summary>
        ///   Converts a decimal fixed-point to a single-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] ToSingle(this decimal[][] value)
        {
            return ToSingle(value, Jagged.CreateAs<decimal, float>(value));
        }





        /// <summary>
        ///   Converts a decimal fixed-point array to a single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[] ToSingle(this decimal[] value, float[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Single)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional decimal fixed-point array to a multidimensional single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] ToSingle(this decimal[,] value, float[,] result)
        {
            unsafe
            {
                fixed (decimal* src = value)
                fixed (float* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (float)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional decimal fixed-point array to a jagged single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] ToSingle(this decimal[,] value, float[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Single)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged decimal fixed-point array to a jagged single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[][] ToSingle(this decimal[][] value, float[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Single)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged decimal fixed-point array to a multidimensional single-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static float[,] ToSingle(this decimal[][] value, float[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Single)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a decimal fixed-point to a double-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] ToDouble(this decimal[] value)
        {
            return ToDouble(value, new double[value.Length]);
        }

        /// <summary>
        ///   Converts a decimal fixed-point to a double-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] ToDouble(this decimal[,] value)
        {
            return ToDouble(value, Matrix.CreateAs<decimal, double>(value));
        }

        /// <summary>
        ///   Converts a decimal fixed-point to a double-precision floating point.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] ToDouble(this decimal[][] value)
        {
            return ToDouble(value, Jagged.CreateAs<decimal, double>(value));
        }





        /// <summary>
        ///   Converts a decimal fixed-point array to a double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[] ToDouble(this decimal[] value, double[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Double)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional decimal fixed-point array to a multidimensional double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] ToDouble(this decimal[,] value, double[,] result)
        {
            unsafe
            {
                fixed (decimal* src = value)
                fixed (double* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (double)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional decimal fixed-point array to a jagged double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] ToDouble(this decimal[,] value, double[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Double)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged decimal fixed-point array to a jagged double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[][] ToDouble(this decimal[][] value, double[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Double)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged decimal fixed-point array to a multidimensional double-precision floating point array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static double[,] ToDouble(this decimal[][] value, double[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Double)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a decimal fixed-point to a long integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] ToInt64(this decimal[] value)
        {
            return ToInt64(value, new long[value.Length]);
        }

        /// <summary>
        ///   Converts a decimal fixed-point to a long integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] ToInt64(this decimal[,] value)
        {
            return ToInt64(value, Matrix.CreateAs<decimal, long>(value));
        }

        /// <summary>
        ///   Converts a decimal fixed-point to a long integer.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] ToInt64(this decimal[][] value)
        {
            return ToInt64(value, Jagged.CreateAs<decimal, long>(value));
        }





        /// <summary>
        ///   Converts a decimal fixed-point array to a long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[] ToInt64(this decimal[] value, long[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Int64)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional decimal fixed-point array to a multidimensional long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] ToInt64(this decimal[,] value, long[,] result)
        {
            unsafe
            {
                fixed (decimal* src = value)
                fixed (long* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (long)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional decimal fixed-point array to a jagged long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] ToInt64(this decimal[,] value, long[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Int64)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged decimal fixed-point array to a jagged long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[][] ToInt64(this decimal[][] value, long[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Int64)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged decimal fixed-point array to a multidimensional long integer array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static long[,] ToInt64(this decimal[][] value, long[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Int64)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a decimal fixed-point to a 8-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] ToByte(this decimal[] value)
        {
            return ToByte(value, new byte[value.Length]);
        }

        /// <summary>
        ///   Converts a decimal fixed-point to a 8-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] ToByte(this decimal[,] value)
        {
            return ToByte(value, Matrix.CreateAs<decimal, byte>(value));
        }

        /// <summary>
        ///   Converts a decimal fixed-point to a 8-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] ToByte(this decimal[][] value)
        {
            return ToByte(value, Jagged.CreateAs<decimal, byte>(value));
        }





        /// <summary>
        ///   Converts a decimal fixed-point array to a 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[] ToByte(this decimal[] value, byte[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (Byte)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional decimal fixed-point array to a multidimensional 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] ToByte(this decimal[,] value, byte[,] result)
        {
            unsafe
            {
                fixed (decimal* src = value)
                fixed (byte* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (byte)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional decimal fixed-point array to a jagged 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] ToByte(this decimal[,] value, byte[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (Byte)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged decimal fixed-point array to a jagged 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[][] ToByte(this decimal[][] value, byte[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (Byte)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged decimal fixed-point array to a multidimensional 8-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static byte[,] ToByte(this decimal[][] value, byte[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (Byte)value[i][j];
            return result;            
        }
        /// <summary>
        ///   Converts a decimal fixed-point to a signed 7-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[] ToSByte(this decimal[] value)
        {
            return ToSByte(value, new sbyte[value.Length]);
        }

        /// <summary>
        ///   Converts a decimal fixed-point to a signed 7-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[,] ToSByte(this decimal[,] value)
        {
            return ToSByte(value, Matrix.CreateAs<decimal, sbyte>(value));
        }

        /// <summary>
        ///   Converts a decimal fixed-point to a signed 7-bit byte.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[][] ToSByte(this decimal[][] value)
        {
            return ToSByte(value, Jagged.CreateAs<decimal, sbyte>(value));
        }





        /// <summary>
        ///   Converts a decimal fixed-point array to a signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[] ToSByte(this decimal[] value, sbyte[] result)
        {
            for (int i = 0; i < value.Length; i++)
                result[i] = (SByte)value[i];
            return result;
        }

        /// <summary>
        ///   Converts a multidimensional decimal fixed-point array to a multidimensional signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[,] ToSByte(this decimal[,] value, sbyte[,] result)
        {
            unsafe
            {
                fixed (decimal* src = value)
                fixed (sbyte* dst = result)
                {
                    for (int i = 0; i < value.Length; i++)
                        dst[i] = (sbyte)src[i];
                }
            }

            return result;
        }

        /// <summary>
        ///   Converts a multidimensional decimal fixed-point array to a jagged signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[][] ToSByte(this decimal[,] value, sbyte[][] result)
        {
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < result[i].Length; j++)
                    result[i][j] = (SByte)value[i, j];
            return result;
        }

        /// <summary>
        ///   Converts a jagged decimal fixed-point array to a jagged signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[][] ToSByte(this decimal[][] value, sbyte[][] result)
        {
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i][j] = (SByte)value[i][j];
            return result;            
        }

        /// <summary>
        ///   Converts a jagged decimal fixed-point array to a multidimensional signed 7-bit byte array.
        /// </summary>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static sbyte[,] ToSByte(this decimal[][] value, sbyte[,] result)
        {
            // TODO: Optimize
            for (int i = 0; i < value.Length; i++)
                for (int j = 0; j < value[i].Length; j++)
                    result[i, j] = (SByte)value[i][j];
            return result;            
        }
    }
}