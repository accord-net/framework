<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ output extension="Generated.cs" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="T4Toolbox.tt" #>
// Accord Math Library
// The Accord.NET Framework
// http://accord-framework.net
//
// Copyright © César Souza, 2009-2017
// cesarsouza at gmail.com
//
//    This library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    This library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with this library; if not, write to the Free Software
//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
//

// ======================================================================
// This code has been generated by a tool; do not edit manually. Instead,
// edit the T4 template Matrix.Product.tt so this file can be regenerated. 
// ======================================================================

namespace Accord.Math
{
    using Accord.Math;    
    using System;
    using System.CodeDom.Compiler;
    using System.Collections.Generic;
    using System.Runtime.CompilerServices;

    [GeneratedCode("Accord.NET T4 Templates", "3.3")]
    public static partial class Matrix
    {

<# 
    string[] types =
    { 
        "int", "double", "float",
        "long", "decimal", "byte",
        "short", "sbyte", 
    };

    foreach (string a in types)
    {
        foreach (string b in new HashSet<string>() { a, "double", "int", "float" })
        {
            string r = null;
            if (a == b)
                r = a;
            else if (a == "double" || b == "double")
                r = "double";
            else if (a == "float" || b == "float")
                r = "float";
            else if (a == "int" || b == "int")
                r = "int";
            else if (a == "uint" || b == "uint")
                r = "uint";
            else continue;

            string t = r;
            if (a == "float" || b == "float")
                t = "double";

#>

        /// <summary>
        ///   Gets the inner product (scalar product) between two vectors (a'*b).
        /// </summary>
        /// 
        /// <param name="a">A vector.</param>
        /// <param name="b">A vector.</param>
        /// 
        /// <returns>The inner product of the multiplication of the vectors.</returns>
        /// 
        /// <remarks>
        ///  <para>
        ///    In mathematics, the dot product is an algebraic operation that takes two
        ///    equal-length sequences of numbers (usually coordinate vectors) and returns
        ///    a single number obtained by multiplying corresponding entries and adding up
        ///    those products. The name is derived from the dot that is often used to designate
        ///    this operation; the alternative name scalar product emphasizes the scalar
        ///    (rather than vector) nature of the result.</para>
        ///  <para>
        ///    The principal use of this product is the inner product in a Euclidean vector space:
        ///    when two vectors are expressed on an orthonormal basis, the dot product of their 
        ///    coordinate vectors gives their inner product.</para>  
        /// </remarks>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#> Dot(this <#=a#>[] a, <#=b#>[] b)
        {
            <#=t#> r = (<#=t#>)0;
            for (int i = 0; i < a.Length; i++)
                r += (<#=t#>)((<#=t#>)a[i] * (<#=t#>)b[i]);
            return (<#=r#>)r;
        }




        /// <summary>
        ///   Computes the product <c>A*b</c> of a matrix <c>A</c> and a column vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="columnVector">The right vector <c>b</c>.</param>
        ///
        /// <returns>The product <c>A*b</c> of the given matrix <c>A</c> and vector <c>b</c>.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] Dot(this <#=a#>[][] a, <#=b#>[] columnVector)
        {
            return Dot(a, columnVector, new <#=r#>[a.Length]);
        }

        /// <summary>
        ///   Computes the product <c>A*b</c> of a matrix <c>A</c> and a column vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="columnVector">The right vector <c>b</c>.</param>
        ///
        /// <returns>The product <c>A*b</c> of the given matrix <c>A</c> and vector <c>b</c>.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] Dot(this <#=a#>[,] a, <#=b#>[] columnVector)
        {
            return Dot(a, columnVector, new <#=r#>[a.Rows()]);
        }

        /// <summary>
        ///   Computes the product <c>a*B</c> of a row vector <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="rowVector">The left vector <c>a</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>a*B</c> of the given vector <c>a</c> and <c>B</c>.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] Dot(this <#=a#>[] rowVector, <#=b#>[][] b)
        {
            return Dot(rowVector, b, new <#=r#>[b.Columns()]);
        }

        /// <summary>
        ///   Computes the product <c>a*B</c> of a row vector <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="rowVector">The left vector <c>a</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>a*B</c> of the given vector <c>a</c> and <c>B</c>.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] Dot(this <#=a#>[] rowVector, <#=b#>[,] b)
        {
            return Dot(rowVector, b, new <#=r#>[b.Columns()]);
        }

        /// <summary>
        ///   Computes the product <c>A*B</c> of two matrices <c>A</c> and <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] Dot(this <#=a#>[][] a, <#=b#>[][] b)
        {
            return Dot(a, b, Accord.Math.Jagged.Create<<#=r#>>(a.Length, b.Columns()));
        }

        /// <summary>
        ///   Computes the product <c>A*B</c> of two matrices <c>A</c> and <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] Dot(this <#=a#>[,] a, <#=b#>[,] b)
        {
            return Dot(a, b, new <#=r#>[a.Rows(), b.Columns()]);
        }

        /// <summary>
        ///   Computes the product <c>A*B</c> of two matrices <c>A</c> and <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] Dot(this <#=a#>[][] a, <#=b#>[,] b)
        {
            return Dot(a, b, Accord.Math.Jagged.Create<<#=r#>>(a.Length, b.Columns()));
        }

        /// <summary>
        ///   Computes the product <c>A*B</c> of two matrices <c>A</c> and <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] Dot(this <#=a#>[,] a, <#=b#>[][] b)
        {
            return Dot(a, b, Accord.Math.Jagged.Create<<#=r#>>(a.Rows(), b.Columns()));
        }







        /// <summary>
        ///   Computes the product <c>A*b'</c> of matrix <c>A</c> and transpose of <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="columnVector">The right vector <c>b</c>.</param>
        ///
        /// <returns>The product <c>A*B'</c> of the given matrix <c>A</c> and vector <c>b</c>.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] DotWithTransposed(this <#=a#>[][] a, <#=b#>[] columnVector)
        {
            return DotWithTransposed(a, columnVector, Accord.Math.Jagged.Create<<#=r#>>(a.Length, columnVector.Length));
        }

        /// <summary>
        ///   Computes the product <c>A*b'</c> of matrix <c>A</c> and transpose of <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="columnVector">The right vector <c>b</c>.</param>
        ///
        /// <returns>The product <c>A*B'</c> of the given matrix <c>A</c> and vector <c>b</c>.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] DotWithTransposed(this <#=a#>[,] a, <#=b#>[] columnVector)
        {
            return DotWithTransposed(a, columnVector, new <#=r#>[a.Rows(), columnVector.Length]);
        }

        /// <summary>
        ///   Computes the product <c>a*B'</c> of row vector <c>a</c> and transpose of <c>B</c>.
        /// </summary>
        /// 
        /// <param name="rowVector">The left vector <c>a</c>.</param>
        /// <param name="b">The transposed right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>a*B'</c> of the given vector <c>a</c> and matrix <c>B</c>.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] DotWithTransposed(this <#=a#>[] rowVector, <#=b#>[][] b)
        {
            return DotWithTransposed(rowVector, b, new <#=r#>[b.Length]);
        } 

        /// <summary>
        ///   Computes the product <c>a*B'</c> of row vector <c>a</c> and transpose of <c>B</c>.
        /// </summary>
        /// 
        /// <param name="rowVector">The left vector <c>a</c>.</param>
        /// <param name="b">The transposed right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>a*B'</c> of the given vector <c>a</c> and matrix <c>B</c>.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] DotWithTransposed(this <#=a#>[] rowVector, <#=b#>[,] b)
        {
            return DotWithTransposed(rowVector, b, new <#=r#>[b.Rows()]);
        }

        /// <summary>
        ///   Computes the product <c>A*B'</c> of matrix <c>A</c> and transpose of <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The transposed right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>A*B'</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] DotWithTransposed(this <#=a#>[][] a, <#=b#>[][] b)
        {
            return DotWithTransposed(a, b, Accord.Math.Jagged.Create<<#=r#>>(a.Length, b.Length));
        }

        /// <summary>
        ///   Computes the product <c>A*B'</c> of matrix <c>A</c> and transpose of <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The transposed right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>A*B'</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] DotWithTransposed(this <#=a#>[,] a, <#=b#>[,] b)
        {
            return DotWithTransposed(a, b, new <#=r#>[a.Rows(), b.Rows()]);
        }

        /// <summary>
        ///   Computes the product <c>A*B'</c> of matrix <c>A</c> and transpose of <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The transposed right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>A*B'</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] DotWithTransposed(this <#=a#>[][] a, <#=b#>[,] b)
        {
            return DotWithTransposed(a, b, Accord.Math.Jagged.Create<<#=r#>>(a.Length, b.Rows()));
        }

        /// <summary>
        ///   Computes the product <c>A*B'</c> of matrix <c>A</c> and transpose of <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The transposed right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>A*B'</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] DotWithTransposed(this <#=a#>[,] a, <#=b#>[][] b)
        {
            return DotWithTransposed(a, b, Accord.Math.Jagged.Create<<#=r#>>(a.Rows(), b.Length));
        }




# region Transpose and dot

        /// <summary>
        ///   Computes the product <c>A'*B</c> of matrix <c>A</c> transposed and matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The transposed left matrix <c>A</c>.</param>
        /// <param name="columnVector">The right matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] TransposeAndDot(this <#=a#>[][] a, <#=b#>[] columnVector)
        {
            return TransposeAndDot(a, columnVector, new <#=r#>[a.Columns()]);
        }

        /// <summary>
        ///   Computes the product <c>A'*B</c> of matrix <c>A</c> transposed and matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The transposed left matrix <c>A</c>.</param>
        /// <param name="columnVector">The right matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] TransposeAndDot(this <#=a#>[,] a, <#=b#>[] columnVector)
        {
            return TransposeAndDot(a, columnVector, new <#=r#>[a.Columns()]);
        }

        /// <summary>
        ///   Computes the product <c>a'*B</c> of column vector <c>a</c> and <c>B</c>.
        /// </summary>
        /// 
        /// <param name="columnVector">The column vector <c>a</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>a'*B</c> of the given vector <c>a</c> and matrix <c>B</c>.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] TransposeAndDot(this <#=a#>[] columnVector, <#=b#>[][] b)
        {
            return TransposeAndDot(columnVector, b, Accord.Math.Jagged.Create<<#=r#>>(columnVector.Length, b.Columns()));
        }

        /// <summary>
        ///   Computes the product <c>a'*B</c> of column vector <c>a</c> and <c>B</c>.
        /// </summary>
        /// 
        /// <param name="columnVector">The column vector <c>a</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>a'*B</c> of the given vector <c>a</c> and matrix <c>B</c>.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] TransposeAndDot(this <#=a#>[] columnVector, <#=b#>[,] b)
        {
            return TransposeAndDot(columnVector, b, new <#=r#>[columnVector.Length, b.Columns()]);
        }

        /// <summary>
        ///   Computes the product <c>A'*B</c> of transposed of matrix <c>A</c> and <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The transposed left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>A'*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] TransposeAndDot(this <#=a#>[][] a, <#=b#>[][] b)
        {
            return TransposeAndDot(a, b, Accord.Math.Jagged.Create<<#=r#>>(a.Columns(), b.Columns()));
        }

        /// <summary>
        ///   Computes the product <c>A'*B</c> of transposed of matrix <c>A</c> and <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The transposed left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>A'*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] TransposeAndDot(this <#=a#>[,] a, <#=b#>[,] b)
        {
            return TransposeAndDot(a, b, Matrix.Create<<#=r#>>(a.Columns(), b.Columns()));
        }

        /// <summary>
        ///   Computes the product <c>A'*B</c> of transposed of matrix <c>A</c> and <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The transposed left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>A'*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] TransposeAndDot(this <#=a#>[][] a, <#=b#>[,] b)
        {
            return TransposeAndDot(a, b, Accord.Math.Jagged.Create<<#=r#>>(a.Columns(), b.Columns()));
        }

        /// <summary>
        ///   Computes the product <c>A'*B</c> of transposed of matrix <c>A</c> and <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The transposed left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>A'*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] TransposeAndDot(this <#=a#>[,] a, <#=b#>[][] b)
        {
            return TransposeAndDot(a, b, Accord.Math.Jagged.Create<<#=r#>>(a.Rows(), b.Columns()));
        }

#endregion






#region dot with diagonal

        /// <summary>
        ///   Computes the product A*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The diagonal vector of right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] DotWithDiagonal(this <#=a#>[][] a, <#=b#>[] b)
        {
            return DotWithDiagonal(a, b, Accord.Math.Jagged.Create<<#=r#>>(a.Length, b.Length));
        }

        /// <summary>
        ///   Computes the product A*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The diagonal vector of right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] DotWithDiagonal(this <#=a#>[,] a, <#=b#>[] b)
        {
            return DotWithDiagonal(a, b, Matrix.Create<<#=r#>>(a.Rows(), b.Length));
        }


        /// <summary>
        ///   Computes the product A'*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The diagonal vector of right matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] TransposeAndDotWithDiagonal(this <#=a#>[,] a, <#=b#>[] b)
        {
            return TransposeAndDotWithDiagonal(a, b, Matrix.Create<<#=r#>>(a.Columns(), b.Length));
        }

        /// <summary>
        ///   Computes the product A'*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The diagonal vector of right matrix <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] TransposeAndDotWithDiagonal(this <#=a#>[][] a, <#=b#>[] b)
        {
            return TransposeAndDotWithDiagonal(a, b, Jagged.Create<<#=r#>>(a.Columns(), b.Length));
        }



        /// <summary>
        ///   Computes the product A*inv(B) of matrix <c>A</c> and diagonal matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The diagonal vector of inverse right matrix <c>B</c>.</param>
        /// <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] DivideByDiagonal(this <#=a#>[,] a, <#=b#>[] b)
        {
            return DivideByDiagonal(a, b, Matrix.CreateAs<<#=a#>, <#=r#>>(a));
        }

                /// <summary>
        ///   Computes the product A*inv(B) of matrix <c>A</c> and diagonal matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The diagonal vector of inverse right matrix <c>B</c>.</param>
        /// <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] DivideByDiagonal(this <#=a#>[][] a, <#=b#>[] b)
        {
            return DivideByDiagonal(a, b, Jagged.CreateAs<<#=a#>, <#=r#>>(a));
        }

#endregion




        /// <summary>
        ///   Vector product.
        /// </summary>
        /// 
        /// <remarks>
        ///   The cross product, vector product or Gibbs vector product is a binary operation
        ///   on two vectors in three-dimensional space. It has a vector result, a vector which
        ///   is always perpendicular to both of the vectors being multiplied and the plane
        ///   containing them. It has many applications in mathematics, engineering and physics.
        /// </remarks>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] Cross(this <#=a#>[] a, <#=b#>[] b)
        {
            return Cross(a, b, new <#=r#>[a.Length]);
        }

        
        /// <summary>
        ///   Gets the outer product (matrix product) between two vectors (a*bT).
        /// </summary>
        /// 
        /// <remarks>
        ///   In linear algebra, the outer product typically refers to the tensor
        ///   product of two vectors. The result of applying the outer product to
        ///   a pair of vectors is a matrix. The name contrasts with the inner product,
        ///   which takes as input a pair of vectors and produces a scalar.
        /// </remarks>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] Outer(this <#=a#>[] a, <#=b#>[] b)
        {
            return Outer(a, b, new <#=r#>[a.Length, b.Length]);
        }

        /// <summary>
        ///   Gets the inner product (dot product) between two vectors (a*bT).
        /// </summary>
        /// 
        [Obsolete("Please use Matrix.Dot instead.")]
        public static <#=r#> Inner(this <#=a#>[] a, <#=b#>[] b)
        {
            return Dot(a, b);
        }


        /// <summary>
        ///   Computes the Kronecker product between two vectors.
        /// </summary>
        /// 
        /// <param name="a">The left vector a.</param>
        /// <param name="b">The right vector b.</param>
        /// 
        /// <returns>The Kronecker product of the two vectors.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] Kronecker(this <#=a#>[] a, <#=b#>[] b)
        {
            return Kronecker(a, b, new <#=r#>[a.Length * b.Length]);
        }

        /// <summary>
        ///   Computes the Kronecker product between two matrices.
        /// </summary>
        /// 
        /// <param name="a">The left matrix a.</param>
        /// <param name="b">The right matrix b.</param>
        /// 
        /// <returns>The Kronecker product of the two matrices.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] Kronecker(this <#=a#>[][] a, <#=b#>[][] b)
        {
            int crows = a.Length * b.Length;
            int ccols = a.Columns() * b.Columns();
            return Kronecker(a, b, Accord.Math.Jagged.Create<<#=r#>>(crows, ccols));
        }

        /// <summary>
        ///   Computes the Kronecker product between two matrices.
        /// </summary>
        /// 
        /// <param name="a">The left matrix a.</param>
        /// <param name="b">The right matrix b.</param>
        /// 
        /// <returns>The Kronecker product of the two matrices.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] Kronecker(this <#=a#>[,] a, <#=b#>[,] b)
        {
            int crows = a.Rows() * b.Rows();
            int ccols = a.Columns() * b.Columns();
            return Kronecker(a, b, new <#=r#>[crows, ccols]);
        }

        /// <summary>
        ///   Computes the Kronecker product between two matrices.
        /// </summary>
        /// 
        /// <param name="a">The left matrix a.</param>
        /// <param name="b">The right matrix b.</param>
        /// 
        /// <returns>The Kronecker product of the two matrices.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] Kronecker(this <#=a#>[][] a, <#=b#>[,] b)
        {
            int crows = a.Rows() * b.Rows();
            int ccols = a.Columns() * b.Columns();
            return Kronecker(a, b, Accord.Math.Jagged.Create<<#=r#>>(crows, ccols));
        }

        /// <summary>
        ///   Computes the Kronecker product between two matrices.
        /// </summary>
        /// 
        /// <param name="a">The left matrix a.</param>
        /// <param name="b">The right matrix b.</param>
        /// 
        /// <returns>The Kronecker product of the two matrices.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] Kronecker(this <#=a#>[,] a, <#=b#>[][] b)
        {
            int crows = a.Rows() * b.Rows();
            int ccols = a.Columns() * b.Columns();
            return Kronecker(a, b, Accord.Math.Jagged.Create<<#=r#>>(crows, ccols));
        }
<#
        }
    }










    foreach (string a in types)
    {
        foreach (string b in new HashSet<string>() { a, "double", "int", "float" })
        {
            foreach (string c in new HashSet<string>() { a, b, "double", "int", "float" })
            {
                string t = c;
                if (a == "float" || b == "float")
                    t = "double";
#>

        /// <summary>
        ///   Computes the product <c>a*B*c</c> of a row vector <c>a</c>, 
        ///   a square matrix <c>B</c> and a column vector <c>c</c>.
        /// </summary>
        /// 
        /// <param name="rowVector">The left vector <c>a</c>.</param>
        /// <param name="matrix">The square matrix <c>B</c>.</param>
        /// <param name="columnVector">The column vector <c>c</c>.</param>
        ///
        /// <returns>The product <c>a*B*c</c> of the given vector <c>a</c>,
        ///   matrix <c>B</c> and vector <c>c</c>.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=t#> DotAndDot(this <#=a#>[] rowVector, <#=b#>[][] matrix, <#=c#>[] columnVector)
        {
#if DEBUG
            if (rowVector.Length != matrix.Rows() || matrix.Columns() != columnVector.Length)
                throw new DimensionMismatchException();
#endif
            <#=t#> sum = 0;
            
            for (int i = 0; i < rowVector.Length; i++)
            {
                <#=t#> s = 0;
                for (int j = 0; j < columnVector.Length; j++)
                    s += (<#=t#>)((<#=t#>)matrix[i][j] * (<#=t#>)columnVector[j]);
                sum += (<#=t#>)((<#=t#>)rowVector[i] * (<#=t#>)s);
            }

            return sum;
        }

        /// <summary>
        ///   Computes the product <c>a*B*c</c> of a row vector <c>a</c>, 
        ///   a square matrix <c>B</c> and a column vector <c>c</c>.
        /// </summary>
        /// 
        /// <param name="rowVector">The left vector <c>a</c>.</param>
        /// <param name="matrix">The square matrix <c>B</c>.</param>
        /// <param name="columnVector">The column vector <c>c</c>.</param>
        ///
        /// <returns>The product <c>a*B*c</c> of the given vector <c>a</c>,
        ///   matrix <c>B</c> and vector <c>c</c>.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=t#> DotAndDot(this <#=a#>[] rowVector, <#=b#>[,] matrix, <#=c#>[] columnVector)
        {
#if DEBUG
            if (rowVector.Length != matrix.Rows() || matrix.Columns() != columnVector.Length)
                throw new DimensionMismatchException();
#endif
            <#=t#> sum = 0;
            
            for (int i = 0; i < rowVector.Length; i++)
            {
                <#=t#> s = (<#=t#>)0;
                for (int j = 0; j < columnVector.Length; j++)
                    s += (<#=t#>)((<#=t#>)matrix[i, j] * (<#=t#>)columnVector[j]);
                sum += (<#=t#>)((<#=t#>)rowVector[i] * (<#=t#>)s);
            }

            return sum;     
        }





        /// <summary>
        ///   Computes the product <c>a*B*c</c> of a row vector <c>a</c>, 
        ///   a square matrix <c>B</c> and a column vector <c>c</c>.
        /// </summary>
        /// 
        /// <param name="rowVector">The left vector <c>a</c>.</param>
        /// <param name="matrix">The square matrix <c>B</c>.</param>
        /// <param name="columnVector">The column vector <c>c</c>.</param>
        ///
        /// <returns>The product <c>a*B*c</c> of the given vector <c>a</c>,
        ///   matrix <c>B</c> and vector <c>c</c>.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public unsafe static <#=t#> DotAndDotNew(this <#=a#>[] rowVector, <#=b#>[,] matrix, <#=c#>[] columnVector)
        {
            int cols = matrix.Columns();
            int rows = matrix.Rows();
#if DEBUG
            if (rowVector.Length != rows || cols != columnVector.Length)
                throw new DimensionMismatchException();
#endif
            <#=t#> result = 0;

            fixed (<#=a#>* r = rowVector)
            fixed (<#=b#>* a = matrix)
            fixed (<#=c#>* c = columnVector)
            {
                <#=b#>* pa1 = a;
                <#=b#>* pa2 = a + cols;
                <#=a#>* pr = r;

                // Process rows two at a time
                for (int i = 0; i < rows / 2; i++)
                {
                    <#=t#> sum1 = 0, sum2 = 0;
                    <#=c#>* pc = c;

                    for (int j = 0; j < cols; j++)
                    {
                        sum1 += (<#=t#>)((<#=t#>)(*pa1++) * (<#=t#>)(*pc));
                        sum2 += (<#=t#>)((<#=t#>)(*pa2++) * (<#=t#>)(*pc));
                        pc++;
                    }

                    result += (<#=t#>)((<#=t#>)(*pr++) * sum1);
                    result += (<#=t#>)((<#=t#>)(*pr++) * sum2);

                    // Now we skip a row
                    pa1 = pa2;
                    pa2 += cols;
                }

                // Process the remainder
                for (int i = 0; i < rows % 2; i++)
                {
                    <#=t#> sum = 0;
                    <#=c#>* pc = c;

                    for (int j = 0; j < cols; j++)
                        sum += (<#=t#>)((<#=t#>)(*pa1++) * (<#=t#>)(*pc++));

                    result += (<#=t#>)((<#=t#>)(*pr++) * sum);
                }
            }

            return result; 
        }



<#
            }
        }
    }

    foreach (string a in types)
    {
        foreach (string b in new HashSet<string>() { a, "double", "int", "float" })
        {
            foreach (string r in new HashSet<string>() { a, b, "double", "int" })
            {
                string t = r;
                if (a == "float" || b == "float")
                    t = "double";
#>

#region dot

        /// <summary>
        ///   Computes the product <c>R = A*B</c> of two matrices <c>A</c>
        ///   and <c>B</c>, storing the result in matrix <c>R</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] Dot(this <#=a#>[,] a, <#=b#>[,] b, <#=r#>[,] result)
        {
            int N = result.Rows();
            int K = a.Columns();
            int M = result.Columns();
            int stride = b.Columns();
#if DEBUG
            if (a.Columns() != b.Rows() || result.Rows() > a.Rows() || result.Columns() > b.Columns())
                throw new DimensionMismatchException();

            var C = Matrix.CreateAs(result).To<double[,]>();
            for (int i = 0; i < N; i++)
                for (int j = 0; j < M; j++)
                    for (int k = 0; k < K; k++)
                        C[i, j] += ((double)a[i, k] * (double)b[k, j]);
#endif
            var t = new <#=b#>[K];

            unsafe
            {
                fixed (<#=a#>* A = a)
                fixed (<#=b#>* B = b)
                fixed (<#=b#>* T = t)
                fixed (<#=r#>* R = result)
                {
                    for (int j = 0; j < M; j++)
                    {
                        <#=b#>* pb = B + j;
                        for (int k = 0; k < K; k++)
                        {
                            T[k] = *pb;
                            pb += stride;
                        }

                        <#=a#>* pa = A;
                        <#=r#>* pr = R + j;
                        for (int i = 0; i < N; i++)
                        {
                            <#=t#> s = (<#=t#>)0;
                            for (int k = 0; k < K; k++)
                                s += (<#=t#>)((<#=t#>)pa[k] * (<#=t#>)T[k]);
                            *pr = (<#=r#>)s;
                            pa += K;
                            pr += M;
                        }
                    }
                }
            }
#if DEBUG
            if (!Matrix.IsEqual(C, result.To<double[,]>(), 1e-4))
                throw new Exception();
#endif
            return result;
        }

        /// <summary>
        ///   Computes the product <c>R = A*B</c> of two matrices <c>A</c>
        ///   and <c>B</c>, storing the result in matrix <c>R</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] Dot(this <#=a#>[][] a, <#=b#>[][] b, <#=r#>[][] result)
        {
#if DEBUG
            if (a.Columns() != b.Length || result.Length > a.Length || result.Columns() > b.Columns())
                throw new DimensionMismatchException();
            var C = Jagged.CreateAs(result).To<double[,]>();
            C = Dot(a.ToMatrix().To<double[,]>(), b.ToMatrix().To<double[,]>(), C);
#endif
            int N = result.Length;
            int K = a.Columns();
            int M = result.Columns();

            var t = new <#=b#>[K];

            for (int j = 0; j < M; j++)
            {
                for (int k = 0; k < b.Length; k++)
                    t[k] = b[k][j];

                for (int i = 0; i < a.Length; i++)
                {
                    <#=t#> s = (<#=t#>)0;
                    for (int k = 0; k < t.Length; k++)
                        s += (<#=t#>)((<#=t#>)a[i][k] * (<#=t#>)t[k]);
                    result[i][j] = (<#=r#>)s;
                }
            }
#if DEBUG
            if (!Matrix.IsEqual(C, result.ToMatrix().To<double[,]>(), 1e-4))
                throw new Exception();
#endif
            return result;
        }

        /// <summary>
        ///   Computes the product <c>R = A*B</c> of two matrices <c>A</c>
        ///   and <c>B</c>, storing the result in matrix <c>R</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] Dot(this <#=a#>[][] a, <#=b#>[,] b, <#=r#>[][] result)
        {
#if DEBUG
            if (a.Columns() != b.Rows() || result.Length > a.Length || result.Columns() > b.Columns())
                throw new DimensionMismatchException();
            var C = Matrix.CreateAs(result).To<double[,]>();
            C = Dot(a.ToMatrix().To<double[,]>(), b.To<double[,]>(), C);
#endif
            int N = result.Length;
            int K = a.Columns();
            int M = result.Columns();
            int stride = b.Columns();
            var t = new <#=b#>[K];

            unsafe
            {
                fixed (<#=b#>* B = b)
                fixed (<#=b#>* T = t)
                {
                    for (int j = 0; j < M; j++)
                    {
                        <#=b#>* pb = B + j;
                        for (int k = 0; k < K; k++)
                        {
                            T[k] = *pb;
                            pb += stride;
                        }

                        for (int i = 0; i < a.Length; i++)
                        {
                            <#=t#> s = (<#=t#>)0;
                            for (int k = 0; k < a[i].Length; k++)
                                s += (<#=t#>)((<#=t#>)a[i][k] * (<#=t#>)T[k]);
                            result[i][j] = (<#=r#>)s;
                        }
                    }
                }
            }
#if DEBUG
            if (!Matrix.IsEqual(C, result.ToMatrix().To<double[,]>(), 1e-4))
                throw new Exception();
#endif
            return result;
        }

        /// <summary>
        ///   Computes the product <c>R = A*B</c> of two matrices <c>A</c>
        ///   and <c>B</c>, storing the result in matrix <c>R</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] Dot(this <#=a#>[,] a, <#=b#>[][] b, <#=r#>[][] result)
        {
#if DEBUG
            if (a.Columns() != b.Length || result.Length > a.Length || result.Columns() > b.Columns())
                throw new DimensionMismatchException();
            var C = Matrix.CreateAs(result).To<double[,]>();
            C = Dot(a.To<double[,]>(), b.ToMatrix().To<double[,]>(), C);
#endif
            <#// TODO: Optimize#>
            int N = result.Length;
            int K = a.Columns();
            int M = result.Columns();

            var t = new <#=b#>[K];

            for (int j = 0; j < M; j++)
            {
                for (int k = 0; k < t.Length; k++)
                    t[k] = b[k][j];

                for (int i = 0; i < N; i++)
                {
                    <#=t#> s = (<#=t#>)0;
                    for (int k = 0; k < t.Length; k++)
                        s += (<#=t#>)((<#=t#>)a[i, k] * (<#=t#>)t[k]);
                    result[i][j] = (<#=r#>)s;
                }
            }
#if DEBUG
            if (!Matrix.IsEqual(C, result.ToMatrix().To<double[,]>(), 1e-4))
                throw new Exception();
#endif
            return result;
        }

        /// <summary>
        ///   Multiplies a row vector <c>v</c> and a matrix <c>A</c>,
        ///   giving the product <c>v'*A</c>.
        /// </summary>
        /// 
        /// <param name="rowVector">The row vector <c>v</c>.</param>
        /// <param name="matrix">The matrix <c>A</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] Dot(this <#=a#>[] rowVector, <#=b#>[,] matrix, <#=r#>[] result)
        {
#if DEBUG
            if (rowVector.Length != matrix.Rows() || result.Length > matrix.Columns())
                throw new DimensionMismatchException();
#endif
            <#// TODO: Optimize#>
            int cols = matrix.Columns();
            for (int j = 0; j < cols; j++)
            {
                <#=t#> s = (<#=t#>)0;
                for (int k = 0; k < rowVector.Length; k++)
                    s += (<#=t#>)((<#=t#>)rowVector[k] * (<#=t#>)matrix[k, j]);
                result[j] = (<#=r#>)s;
            }
            return result;
        }






        /// <summary>
        ///   Multiplies a row vector <c>v</c> and a matrix <c>A</c>,
        ///   giving the product <c>v'*A</c>.
        /// </summary>
        /// 
        /// <param name="rowVector">The row vector <c>v</c>.</param>
        /// <param name="matrix">The matrix <c>A</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public unsafe static <#=r#>[] DotNew(this <#=a#>[] rowVector, <#=b#>[,] matrix, <#=r#>[] result)
        {
            int cols = matrix.Columns();
            int rows = matrix.Rows();

#if DEBUG
            if (rowVector.Length != rows || result.Length > cols)
                throw new DimensionMismatchException();
#endif

            fixed (<#=b#>* a = matrix)
            fixed (<#=a#>* x = rowVector)
            fixed (<#=r#>* r = result)
            {
                <#=b#>* pa1 = a;
                <#=b#>* pa2 = a + cols;

                <#=a#>* px = x;
                <#=r#>* pr = r;

                for (int j = 0; j < cols; j++)
                    *pr++ = 0;

                // Process rows two at a time
                for (int i = 0; i < rows / 2; i++)
                {
                    pr = r;
                    <#=a#> x1 = *px++;
                    <#=a#> x2 = *px++;
                    for (int j = 0; j < cols; j++)
                    {
                        *pr += (<#=r#>)((<#=t#>)x1 * (<#=t#>)(*pa1++)); <#// TODO: NONONONO we are losing precision here #>
                        *pr += (<#=r#>)((<#=t#>)x2 * (<#=t#>)(*pa2++)); <#// TODO: NONONONO we are losing precision here #>
                        pr++;
                    }

                    // Now we skip a row
                    pa1 = pa2;
                    pa2 += cols;
                }

                // Process the remainder
                for (int i = 0; i < rows % 2; i++)
                {
                    pr = r;
                    <#=a#> x1 = *px++;
                    for (int j = 0; j < cols; j++)
                        *pr++ += (<#=r#>)((<#=t#>)x1 * (<#=t#>)(*pa1++)); <#// TODO: NONONONO we are losing precision here #>
                }
            }

            return result;
        }











        /// <summary>
        ///   Multiplies a matrix <c>A</c> and a column vector <c>v</c>,
        ///   giving the product <c>A*v</c>
        /// </summary>
        /// 
        /// <param name="matrix">The matrix <c>A</c>.</param>
        /// <param name="columnVector">The column vector <c>v</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] Dot(this <#=a#>[][] matrix, <#=b#>[] columnVector, <#=r#>[] result)
        {
#if DEBUG
            if (matrix.Columns() != columnVector.Length || result.Length > matrix.Length)
                throw new DimensionMismatchException();
#endif

            for (int i = 0; i < matrix.Length; i++)
            {
                <#=t#> s = (<#=t#>)0;
                for (int j = 0; j < columnVector.Length; j++)
                    s += (<#=t#>)((<#=t#>)matrix[i][j] * (<#=t#>)columnVector[j]);
                result[i] = (<#=r#>)s;
            }
            return result;
        }

        /// <summary>
        ///   Multiplies a matrix <c>A</c> and a column vector <c>v</c>,
        ///   giving the product <c>A*v</c>
        /// </summary>
        /// 
        /// <param name="matrix">The matrix <c>A</c>.</param>
        /// <param name="columnVector">The column vector <c>v</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] Dot(this <#=a#>[,] matrix, <#=b#>[] columnVector, <#=r#>[] result)
        {
#if DEBUG
            if (matrix.Columns() != columnVector.Length || result.Length > matrix.Rows())
                throw new DimensionMismatchException();
#endif
            <#// TODO: Optimize#>
            for (int i = 0; i < result.Length; i++)
            {
                <#=t#> s = (<#=t#>)0;
                for (int j = 0; j < columnVector.Length; j++)
                    s += (<#=t#>)((<#=t#>)matrix[i, j] * (<#=t#>)columnVector[j]);
                result[i] = (<#=r#>)s;
            }
            return result;
        }

        // TODO: AJC begin

        /// <summary>
        ///   Multiplies a matrix <c>A</c> and a column vector <c>v</c>,
        ///   giving the product <c>A*v</c>
        /// </summary>
        /// 
        /// <param name="matrix">The matrix <c>A</c>.</param>
        /// <param name="columnVector">The column vector <c>v</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public unsafe static <#=r#>[] DotNew(this <#=a#>[,] matrix, <#=b#>[] columnVector, <#=r#>[] result)
        {
            int cols = matrix.Columns();
            int rows = matrix.Rows();

#if DEBUG
            if (cols != columnVector.Length || result.Length > rows)
            {
                throw new DimensionMismatchException();
            }
#endif

            fixed (<#=a#>* a = matrix)
            fixed (<#=b#>* x = columnVector)
            fixed (<#=r#>* r = result)
            {
                <#=a#>* pa1 = a;
                <#=a#>* pa2 = a + cols;
                <#=r#>* pr = r;

                // Process rows two at a time
                for (int i = 0; i < rows / 2; i++)
                {
                    <#=t#> sum1 = 0, sum2 = 0;
                    <#=b#>* px = x;

                    for (int j = 0; j < cols; j++)
                    {
                        sum1 += (<#=t#>)((<#=t#>)(*pa1++) * (<#=t#>)(*px));
                        sum2 += (<#=t#>)((<#=t#>)(*pa2++) * (<#=t#>)(*px));
                        px++;
                    }

                    *pr++ = (<#=r#>)sum1;
                    *pr++ = (<#=r#>)sum2;
                    
                    // Now we skip a row
                    pa1 = pa2;
                    pa2 += cols;
                }

                // Process the remainder
                for (int i = 0; i < rows % 2; i++)
                {
                    <#=t#> sum = 0;
                    <#=b#>* px = x;

                    for (int j = 0; j < cols; j++)
                        sum += (<#=t#>)((<#=t#>)(*pa1++) * (<#=t#>)(*px++));

                    *pr = (<#=r#>)sum;
                }
            }

            return result;
        }




        /// <summary>
        ///   Computes the product <c>R = A*B</c> of two matrices <c>A</c>
        ///   and <c>B</c>, storing the result in matrix <c>R</c>.
        /// </summary>
        /// 
        /// <param name="rowVector">The left matrix <c>A</c>.</param>
        /// <param name="matrix">The right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] Dot(this <#=a#>[] rowVector, <#=b#>[][] matrix, <#=r#>[] result)
        {
#if DEBUG
            if (rowVector.Length != matrix.Length || result.Length > matrix.Columns())
                throw new DimensionMismatchException();
#endif
            var t = new <#=b#>[rowVector.Length];

            for (int j = 0; j < result.Length; j++)
            {
                for (int k = 0; k < rowVector.Length; k++)
                    t[k] = matrix[k][j];

                <#=t#> s = (<#=t#>)0;
                for (int k = 0; k < t.Length; k++)
                    s += (<#=t#>)((<#=t#>)rowVector[k] * (<#=t#>)t[k]);
                result[j] = (<#=r#>)s;
            }

            return result;
        }

#endregion






#region dot with transposed

        /// <summary>
        ///   Computes the product <c>A*B'</c> of matrix <c>A</c> and
        ///   transpose of <c>B</c>, storing the result in matrix <c>R</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The transposed right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A*B'</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        ///    
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] DotWithTransposed(this <#=a#>[,] a, <#=b#>[,] b, <#=r#>[,] result)
        {
#if DEBUG
            if (a.Columns() != b.Columns() || result.Rows() > a.Rows() || result.Columns() > b.Rows())
                throw new DimensionMismatchException();
            var C = Matrix.CreateAs(result).To<double[,]>();
            C = Dot(a.To<double[,]>(), b.Transpose().To<double[,]>(), C);
#endif
            int n = a.Columns();
            int m = a.Rows();
            int p = b.Rows();

            unsafe
            {
                fixed (<#=a#>* A = a)
                fixed (<#=b#>* B = b)
                fixed (<#=r#>* R = result)
                {
                    <#=r#>* pr = R;
                    for (int i = 0; i < m; i++)
                    {
                        <#=b#>* pb = B;
                        for (int j = 0; j < p; j++, pr++)
                        {
                            <#=a#>* pa = A + n * i;

                            <#=t#> s = (<#=t#>)0;
                            for (int k = 0; k < n; k++)
                                s += (<#=t#>)((<#=t#>)(*pa++) * (<#=t#>)(*pb++));
                            *pr = (<#=r#>)s;
                        }
                    }
                }
            }
#if DEBUG
            if (!Matrix.IsEqual(C, result.To<double[,]>(), 1e-4))
                throw new Exception();
#endif
            return result;
        }

        /// <summary>
        ///   Computes the product <c>A*B'</c> of matrix <c>A</c> and
        ///   transpose of <c>B</c>, storing the result in matrix <c>R</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The transposed right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A*B'</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        ///    
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] DotWithTransposed(this <#=a#>[][] a, <#=b#>[,] b, <#=r#>[][] result)
        {
            <#// TODO: Optimize this call#>
            return a.Dot(b.Transpose(), result);
        }

        /// <summary>
        ///   Computes the product <c>A*B'</c> of matrix <c>A</c> and
        ///   transpose of <c>B</c>, storing the result in matrix <c>R</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The transposed right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A*B'</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        ///   
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif 
        public static <#=r#>[][] DotWithTransposed(this <#=a#>[,] a, <#=b#>[][] b, <#=r#>[][] result)
        {
            <#// TODO: Optimize this call#>
            return a.Dot(b.Transpose(), result);
        }

        /// <summary>
        ///   Computes the product <c>A*B'</c> of matrix <c>A</c> and
        ///   transpose of <c>B</c>, storing the result in matrix <c>R</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The transposed right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A*B'</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        ///    
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] DotWithTransposed(this <#=a#>[][] a, <#=b#>[][] b, <#=r#>[][] result)
        {
            <#// TODO: Optimize this call#>
            return a.Dot(b.Transpose(), result);
        }

        /// <summary>
        ///   Computes the product <c>A*B'</c> of matrix <c>A</c> and
        ///   transpose of <c>B</c>, storing the result in matrix <c>R</c>.
        /// </summary>
        /// 
        /// <param name="rowVector">The left matrix <c>A</c>.</param>
        /// <param name="b">The transposed right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A*B'</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        ///    
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] DotWithTransposed(this <#=a#>[] rowVector, <#=b#>[,] b, <#=r#>[] result)
        {
            <#// TODO: Optimize this call: return b.Dot(rowVector); #>
            return rowVector.Dot(b.Transpose(), result);
        }

        /// <summary>
        ///   Computes the product <c>A*B'</c> of matrix <c>A</c> and
        ///   transpose of <c>B</c>, storing the result in matrix <c>R</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="columnVector">The transposed right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A*B'</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        ///    
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] DotWithTransposed(this <#=a#>[,] a, <#=b#>[] columnVector, <#=r#>[,] result)
        {
            <#// TODO: Optimize this call#>
            return a.Dot(columnVector.Transpose(), result);
        }

        /// <summary>
        ///   Computes the product <c>A*B'</c> of matrix <c>A</c> and
        ///   transpose of <c>B</c>, storing the result in matrix <c>R</c>.
        /// </summary>
        /// 
        /// <param name="rowVector">The left matrix <c>A</c>.</param>
        /// <param name="b">The transposed right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A*B'</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        ///    
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] DotWithTransposed(this <#=a#>[] rowVector, <#=b#>[][] b, <#=r#>[] result)
        {
            <#// TODO: Optimize this call#>
            return rowVector.Dot(b.Transpose(), result);
        }

        /// <summary>
        ///   Computes the product <c>A*B'</c> of matrix <c>A</c> and
        ///   transpose of <c>B</c>, storing the result in matrix <c>R</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="columnVector">The transposed right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A*B'</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        ///    
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] DotWithTransposed(this <#=a#>[][] a, <#=b#>[] columnVector, <#=r#>[][] result)
        {
            <#// TODO: Optimize this call#>
            <#=b#>[][] t;
            return a.Dot(columnVector.Transpose(out t), result);
        }

#endregion








#region transpose and dot


        /// <summary>
        ///   Computes the product <c>A'*B</c> of matrix <c>A</c> transposed and matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The transposed left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A'*B</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] TransposeAndDot(this <#=a#>[,] a, <#=b#>[,] b, <#=r#>[,] result)
        {
#if DEBUG
            if (a.Rows() != b.Rows() || result.Rows() > a.Columns() || result.Columns() > b.Columns())
                throw new DimensionMismatchException();
            var C = Dot(a.Transpose().To<double[,]>(), b.To<double[,]>());
#endif
            int n = a.Rows();
            int m = a.Columns();
            int p = b.Columns();

            var Bcolj = new <#=b#>[n];
            for (int i = 0; i < p; i++)
            {
                for (int k = 0; k < n; k++)
                    Bcolj[k] = b[k, i];

                for (int j = 0; j < m; j++)
                {
                    <#=t#> s = (<#=t#>)0;
                    for (int k = 0; k < n; k++)
                        s += (<#=t#>)((<#=t#>)a[k, j] * (<#=t#>)Bcolj[k]);
                    result[j, i] = (<#=r#>)s;
                }
            }
#if DEBUG
            if (!Matrix.IsEqual(C, result.To<double[,]>(), 1e-4))
                throw new Exception();
#endif
            return result;
        }

        /// <summary>
        ///   Computes the product <c>A'*B</c> of matrix <c>A</c> transposed and matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The transposed left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A'*B</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] TransposeAndDot(this <#=a#>[][] a, <#=b#>[][] b, <#=r#>[][] result)
        {
#if DEBUG
            if (a.Length != b.Length || result.Length > a.Columns() || result.Columns() > b.Columns())
                throw new DimensionMismatchException();
            var C = Dot(a.Transpose().To<double[,]>(), b.To<double[,]>());
#endif
            int n = a.Length;
            int m = a.Columns();
            int p = b.Columns();

            var Bcolj = new <#=b#>[n];
            for (int i = 0; i < p; i++)
            {
                for (int k = 0; k < b.Length; k++)
                    Bcolj[k] = b[k][i];

                for (int j = 0; j < m; j++)
                {
                    <#=t#> s = (<#=t#>)0;
                    for (int k = 0; k < Bcolj.Length; k++)
                        s += (<#=t#>)((<#=t#>)a[k][j] * (<#=t#>)Bcolj[k]);
                    result[j][i] = (<#=r#>)s;
                }
            }
#if DEBUG
            if (!Matrix.IsEqual(C, result.To<double[,]>(), 1e-4))
                throw new Exception();
#endif
            return result;
        }


       

        /// <summary>
        ///   Computes the product <c>A'*b</c> of matrix <c>A</c> transposed and column vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="matrix">The transposed left matrix <c>A</c>.</param>
        /// <param name="columnVector">The right column vector <c>b</c>.</param>
        /// <param name="result">The vector <c>r</c> to store the product <c>r = A'*b</c>
        ///   of the given matrix <c>A</c> and vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] TransposeAndDot(this <#=a#>[,] matrix, <#=b#>[] columnVector, <#=r#>[] result)
        {
#if DEBUG
            if (matrix.Rows() != columnVector.Length || result.Length > matrix.Columns())
                throw new DimensionMismatchException();
            var C = Dot(matrix.Transpose().To<double[,]>(), columnVector.To<double[]>());
#endif
            <#// TODO: Optimize this call#>
            int cols = matrix.Columns();
            for (int j = 0; j < cols; j++)
            {
                <#=t#> s = (<#=t#>)0;
                for (int k = 0; k < columnVector.Length; k++)
                    s += (<#=t#>)((<#=t#>)matrix[k, j] * (<#=t#>)columnVector[k]);
                result[j] = (<#=r#>)s;
            }
#if DEBUG
            if (!Matrix.IsEqual(C, result.To<double[]>(), 1e-4))
                throw new Exception();
#endif
            return result;
        }

        /// <summary>
        ///   Computes the product <c>A'*b</c> of matrix <c>A</c> transposed and column vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="matrix">The transposed left matrix <c>A</c>.</param>
        /// <param name="columnVector">The right column vector <c>b</c>.</param>
        /// <param name="result">The vector <c>r</c> to store the product <c>r = A'*b</c>
        ///   of the given matrix <c>A</c> and vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] TransposeAndDot(this <#=a#>[][] matrix, <#=b#>[] columnVector, <#=r#>[] result)
        {
#if DEBUG
            if (matrix.Length != columnVector.Length || result.Length > matrix.Columns())
                throw new DimensionMismatchException();
            var C = Dot(matrix.Transpose().To<double[,]>(), columnVector.To<double[]>());
#endif
            int cols = matrix.Columns();
            for (int j = 0; j < cols; j++)
            {
                <#=t#> s = (<#=t#>)0;
                for (int k = 0; k < columnVector.Length; k++)
                    s += (<#=t#>)((<#=t#>)matrix[k][j] * (<#=t#>)columnVector[k]);
                result[j] = (<#=r#>)s;
            }
#if DEBUG
            if (!Matrix.IsEqual(C, result.To<double[]>(), 1e-4))
                throw new Exception();
#endif
            return result;
        }

        /// <summary>
        ///   Computes the product <c>A'*B</c> of matrix <c>A</c> transposed and matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The transposed left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A'*B</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] TransposeAndDot(this <#=a#>[][] a, <#=b#>[,] b, <#=r#>[][] result)
        {
            <#// TODO: Optimize this call#>
            return a.Transpose().Dot(b, result);
        }

        /// <summary>
        ///   Computes the product <c>A'*B</c> of matrix <c>A</c> transposed and matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The transposed left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A'*B</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] TransposeAndDot(this <#=a#>[,] a, <#=b#>[][] b, <#=r#>[][] result)
        {
            <#// TODO: Optimize this call#>
            return a.Transpose().Dot(b, result);
        }


       

        /// <summary>
        ///   Computes the product <c>A'*b</c> of matrix <c>A</c> transposed and column vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="rowVector">The transposed left matrix <c>A</c>.</param>
        /// <param name="b">The right column vector <c>b</c>.</param>
        /// <param name="result">The vector <c>r</c> to store the product <c>r = A'*b</c>
        ///   of the given matrix <c>A</c> and vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] TransposeAndDot(this <#=a#>[] rowVector, <#=b#>[,] b, <#=r#>[,] result)
        {
            <#// TODO: Optimize this call#>
            return rowVector.Transpose().Dot(b, result);
        }

        /// <summary>
        ///   Computes the product <c>A'*b</c> of matrix <c>A</c> transposed and column vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="rowVector">The transposed left matrix <c>A</c>.</param>
        /// <param name="b">The right column vector <c>b</c>.</param>
        /// <param name="result">The vector <c>r</c> to store the product <c>r = A'*b</c>
        ///   of the given matrix <c>A</c> and vector <c>b</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] TransposeAndDot(this <#=a#>[] rowVector, <#=b#>[][] b, <#=r#>[][] result)
        {
            <#// TODO: Optimize this call#>
            <#=a#>[][] t;
            return rowVector.Transpose(out t).Dot(b, result);
        }

#endregion




#region diagonal

        /// <summary>
        ///   Computes the product A'*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="diagonal">The diagonal vector of right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] TransposeAndDotWithDiagonal(this <#=a#>[,] a, <#=b#>[] diagonal, <#=r#>[,] result)
        {
#if DEBUG
            var C = Dot(a.Transpose().To<double[,]>(), Matrix.Diagonal(diagonal.To<double[]>()));
#endif
            int m = a.Columns();
            for (int i = 0; i < diagonal.Length; i++)
                for (int j = 0; j < m; j++)
                    result[j, i] = (<#=r#>)((<#=t#>)a[i, j] * (<#=t#>)diagonal[i]);
#if DEBUG
            if (!Matrix.IsEqual(C, result.To<double[,]>(), 1e-4))
                throw new Exception();
#endif
            return result;            
        }

        /// <summary>
        ///   Computes the product A'*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="diagonal">The diagonal vector of right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] TransposeAndDotWithDiagonal(this <#=a#>[][] a, <#=b#>[] diagonal, <#=r#>[][] result)
        {
#if DEBUG
            var C = Dot(a.Transpose().To<double[,]>(), Matrix.Diagonal(diagonal.To<double[]>()));
#endif
            int m = a.Columns(); 
            for (int i = 0; i < diagonal.Length; i++)
                for (int j = 0; j < m; j++)
                    result[j][i] = (<#=r#>)((<#=t#>)a[i][j] * (<#=t#>)diagonal[i]);
#if DEBUG
            if (!Matrix.IsEqual(C, result.To<double[,]>(), 1e-4))
                throw new Exception();
#endif
            return result;
        }

        /// <summary>
        ///   Computes the product A*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="diagonal">The diagonal vector of right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] DotWithDiagonal(this <#=a#>[,] a, <#=b#>[] diagonal, <#=r#>[,] result)
        {
#if DEBUG
            var C = Dot(a.To<double[,]>(), Matrix.Diagonal(diagonal.To<double[]>()));
#endif
            int rows = a.Rows();

            unsafe
            {
                fixed (<#=a#>* ptrA = a)
                fixed (<#=r#>* ptrR = result)
                {
                    <#=a#>* A = ptrA;
                    <#=r#>* R = ptrR;
                    for (int i = 0; i < rows; i++)
                        for (int j = 0; j < diagonal.Length; j++)
                            *R++ = (<#=r#>)((<#=t#>)(*A++) * (<#=t#>)diagonal[j]);
                }
            }
#if DEBUG
            if (!Matrix.IsEqual(C, result.To<double[,]>(), 1e-4))
                throw new Exception();
#endif
            return result;
        }

        /// <summary>
        ///   Computes the product A*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="diagonal">The diagonal vector of right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] DotWithDiagonal(this <#=a#>[][] a, <#=b#>[] diagonal, <#=r#>[][] result)
        {
#if DEBUG
            var C = Dot(a.To<double[,]>(), Matrix.Diagonal(diagonal.To<double[]>()));
#endif
            int rows = a.Length;
            for (int i = 0; i < rows; i++)
                for (int j = 0; j < diagonal.Length; j++)
                    result[i][j] = (<#=r#>)((<#=t#>)a[i][j] * (<#=t#>)diagonal[j]);
#if DEBUG
            if (!Matrix.IsEqual(C, result.To<double[,]>(), 1e-4))
                throw new Exception();
#endif
            return result;
        }

        /// <summary>
        ///   Computes the product A*inv(B) of matrix <c>A</c> and diagonal matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="diagonal">The diagonal vector of inverse right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] DivideByDiagonal(this <#=a#>[,] a, <#=b#>[] diagonal, <#=r#>[,] result)
        {
            int rows = a.Rows();

            unsafe
            {
                fixed (<#=a#>* ptrA = a)
                fixed (<#=r#>* ptrR = result)
                {
                    <#=a#>* A = ptrA;
                    <#=r#>* R = ptrR;
                    for (int i = 0; i < rows; i++)
                        for (int j = 0; j < diagonal.Length; j++)
                            (*R++) = (<#=r#>)((<#=t#>)(*A++) / (<#=t#>)diagonal[j]);
                }
            }

            return result;
        }

        /// <summary>
        ///   Computes the product A*inv(B) of matrix <c>A</c> and diagonal matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="diagonal">The diagonal vector of inverse right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] DivideByDiagonal(this <#=a#>[][] a, <#=b#>[] diagonal, <#=r#>[][] result)
        {
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < diagonal.Length; j++)
                    result[i][j] = (<#=r#>)((<#=t#>)(a[i][j]) / (<#=t#>)diagonal[j]);

            return result;
        }

#endregion


     








        /// <summary>
        ///   Gets the outer product (matrix product) between two vectors (a*bT).
        /// </summary>
        /// 
        /// <remarks>
        ///   In linear algebra, the outer product typically refers to the tensor
        ///   product of two vectors. The result of applying the outer product to
        ///   a pair of vectors is a matrix. The name contrasts with the inner product,
        ///   which takes as input a pair of vectors and produces a scalar.
        /// </remarks>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] Outer(this <#=a#>[] a, <#=b#>[] b, <#=r#>[,] result)
        {
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < b.Length; j++)
                    result[i, j] = (<#=r#>)((<#=t#>)a[i] * (<#=t#>)b[j]);
            return result;
        }



        /// <summary>
        ///   Gets the outer product (matrix product) between two vectors (a*bT).
        /// </summary>
        /// 
        /// <remarks>
        ///   In linear algebra, the outer product typically refers to the tensor
        ///   product of two vectors. The result of applying the outer product to
        ///   a pair of vectors is a matrix. The name contrasts with the inner product,
        ///   which takes as input a pair of vectors and produces a scalar.
        /// </remarks>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public unsafe static <#=r#>[,] OuterNew(this <#=a#>[] a, <#=b#>[] b, <#=r#>[,] result)
        {
            fixed (<#=a#>* A = a)
            fixed (<#=b#>* B = b)
            fixed (<#=r#>* R = result)
            {
                <#=a#>* pa = A;
                <#=r#>* pr = R;

                for (int i = 0; i < a.Length; i++)
                {
                    <#=t#> x = (<#=t#>)(*pa++);
                    <#=b#>* pb = B;

                    for (int j = 0; j < b.Length; j++)
                        *pr++ = (<#=r#>)(x * (<#=t#>)(*pb++));
                }
            }

            return result;
        }



        /// <summary>
        ///   Gets the outer product (matrix product) between two vectors (a*bT).
        /// </summary>
        /// 
        /// <remarks>
        ///   In linear algebra, the outer product typically refers to the tensor
        ///   product of two vectors. The result of applying the outer product to
        ///   a pair of vectors is a matrix. The name contrasts with the inner product,
        ///   which takes as input a pair of vectors and produces a scalar.
        /// </remarks>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] Outer(this <#=a#>[] a, <#=b#>[] b, <#=r#>[][] result)
        {
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < b.Length; j++)
                    result[i][j] = (<#=r#>)((<#=t#>)a[i] * (<#=t#>)b[j]);
            return result;
        }

        /// <summary>
        ///   Vector product.
        /// </summary>
        /// 
        /// <remarks>
        ///   The cross product, vector product or Gibbs vector product is a binary operation
        ///   on two vectors in three-dimensional space. It has a vector result, a vector which
        ///   is always perpendicular to both of the vectors being multiplied and the plane
        ///   containing them. It has many applications in mathematics, engineering and physics.
        /// </remarks>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] Cross(<#=a#>[] a, <#=b#>[] b, <#=r#>[] result)
        {
            return new <#=r#>[] 
            {
                (<#=r#>)((<#=t#>)a[1]*(<#=t#>)b[2] - (<#=t#>)a[2]*(<#=t#>)b[1]),
                (<#=r#>)((<#=t#>)a[2]*(<#=t#>)b[0] - (<#=t#>)a[0]*(<#=t#>)b[2]),
                (<#=r#>)((<#=t#>)a[0]*(<#=t#>)b[1] - (<#=t#>)a[1]*(<#=t#>)b[0])
            };
        }






#region Kronecker

        /// <summary>
        ///   Computes the Kronecker product between two matrices.
        /// </summary>
        /// 
        /// <param name="a">The left matrix a.</param>
        /// <param name="b">The right matrix b.</param>
        /// <param name="result">The matrix <c>R</c> to store the 
        ///   Kronecker product between matrices <c>A</c> and <c>B</c>.</param>
        /// 
        /// <returns>The Kronecker product of the two matrices.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] Kronecker(this <#=a#>[,] a, <#=b#>[,] b, <#=r#>[,] result)
        {
            int arows = a.Rows();
            int acols = a.Columns();

            int brows = b.Rows();
            int bcols = b.Columns();

            //int crows = arows * brows;
            int ccols = acols * bcols;
            int block = brows * ccols;

            unsafe
            {
                fixed (<#=r#>* ptrR = result)
                fixed (<#=a#>* ptrA = a)
                fixed (<#=b#>* ptrB = b)
                {
                    <#=a#>* A = ptrA;
                    <#=r#>* Ri = ptrR;

                    for (int i = 0; i < arows; Ri += block, i++)
                    {
                        <#=r#>* Rj = Ri;

                        for (int j = 0; j < acols; j++, Rj += bcols, A++)
                        {
                            <#=r#>* R = Rj;
                            <#=b#>* B = ptrB;

                            for (int k = 0; k < brows; k++, R += ccols)
                            {
                                for (int l = 0; l < bcols; l++, B++)
                                    *(R + l) = (<#=r#>)((<#=t#>)(*A) * (<#=t#>)(*B));
                            }
                        }
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Computes the Kronecker product between two matrices.
        /// </summary>
        /// 
        /// <param name="a">The left matrix a.</param>
        /// <param name="b">The right matrix b.</param>
        /// <param name="result">The matrix <c>R</c> to store the 
        ///   Kronecker product between matrices <c>A</c> and <c>B</c>.</param>
        /// 
        /// <returns>The Kronecker product of the two matrices.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] Kronecker(this <#=a#>[][] a, <#=b#>[][] b, <#=r#>[][] result)
        {
            int arows = a.Rows();
            int acols = a.Columns();
            int brows = b.Rows();
            int bcols = b.Columns();

            for (int i = 0; i < arows; i++)
                for (int j = 0; j < acols; j++)
                    for (int k = 0; k < brows; k++)
                        for (int l = 0; l < bcols; l++)
                            result[i * brows + k][j * bcols + l] = (<#=r#>)((<#=t#>)a[i][j] * (<#=t#>)b[k][l]);

            return result;
        }

        /// <summary>
        ///   Computes the Kronecker product between two matrices.
        /// </summary>
        /// 
        /// <param name="a">The left matrix a.</param>
        /// <param name="b">The right matrix b.</param>
        /// <param name="result">The matrix <c>R</c> to store the 
        ///   Kronecker product between matrices <c>A</c> and <c>B</c>.</param>
        /// 
        /// <returns>The Kronecker product of the two matrices.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] Kronecker(this <#=a#>[][] a, <#=b#>[,] b, <#=r#>[][] result)
        {
            int arows = a.Rows();
            int acols = a.Columns();
            int brows = b.Rows();
            int bcols = b.Columns();

            for (int i = 0; i < arows; i++)
                for (int j = 0; j < acols; j++)
                    for (int k = 0; k < brows; k++)
                        for (int l = 0; l < bcols; l++)
                            result[i * brows + k][j * bcols + l] = (<#=r#>)((<#=t#>)a[i][j] * (<#=t#>)b[k, l]);

            return result;
        }

        /// <summary>
        ///   Computes the Kronecker product between two matrices.
        /// </summary>
        /// 
        /// <param name="a">The left matrix a.</param>
        /// <param name="b">The right matrix b.</param>
        /// <param name="result">The matrix <c>R</c> to store the 
        ///   Kronecker product between matrices <c>A</c> and <c>B</c>.</param>
        /// 
        /// <returns>The Kronecker product of the two matrices.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] Kronecker(this <#=a#>[,] a, <#=b#>[][] b, <#=r#>[][] result)
        {
            int arows = a.Rows();
            int acols = a.Columns();
            int brows = b.Rows();
            int bcols = b.Columns();

            for (int i = 0; i < arows; i++)
                for (int j = 0; j < acols; j++)
                    for (int k = 0; k < brows; k++)
                        for (int l = 0; l < bcols; l++)
                            result[i * brows + k][j * bcols + l] = (<#=r#>)((<#=t#>)a[i, j] * (<#=t#>)b[k][l]);

            return result;
        }

        /// <summary>
        ///   Computes the Kronecker product between two vectors.
        /// </summary>
        /// 
        /// <param name="a">The left vector a.</param>
        /// <param name="b">The right vector b.</param>
        /// <param name="result">The matrix <c>R</c> to store the 
        ///   Kronecker product between matrices <c>A</c> and <c>B</c>.</param>
        /// 
        /// <returns>The Kronecker product of the two vectors.</returns>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD2_0
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] Kronecker(this <#=a#>[] a, <#=b#>[] b, <#=r#>[] result)
        {
            int k = 0;
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < b.Length; j++)
                    result[k++] = (<#=r#>)((<#=t#>)a[i] * (<#=t#>)b[j]);
            return result;
        }

#endregion



<#
            }
        }
    }





    foreach (string a in types)
    {
        foreach (string b in types)
        {
            foreach (string c in types)
            {
                var resultTypes = new HashSet<string>() { a, b, "double", "int" };
                foreach (string r in resultTypes)
                {
#>
<#
                }
            }
        }
    }
#>
    }
}