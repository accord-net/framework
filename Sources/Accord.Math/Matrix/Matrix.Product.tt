<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ output extension="Generated.cs" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="T4Toolbox.tt" #>
// Accord Math Library
// The Accord.NET Framework
// http://accord-framework.net
//
// Copyright © César Souza, 2009-2015
// cesarsouza at gmail.com
//
//    This library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    This library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with this library; if not, write to the Free Software
//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
//

// ======================================================================
// This code has been generated by a tool; do not edit manually. Instead,
// edit the T4 template Matrix.Product.tt so this file can be regenerated. 
// ======================================================================

namespace Accord.Math
{
    using Accord.Math;    
    using System;
    using System.CodeDom.Compiler;
    using System.Collections.Generic;
    using System.Runtime.CompilerServices;

    [GeneratedCode("Accord.NET T4 Templates", "3.1")]
    public static partial class Matrix
    {

<# 
    string[] types =
    { 
        "int", "double", "float",
        "long", "decimal", "byte",
        "short", "sbyte", 
    };

    foreach (string a in types)
    {
        foreach (string b in new HashSet<string>() { a, "double", "int", "float" })
        {
            string r = null;
            if (a == b)
                r = a;
            else if (a == "double" || b == "double")
                r = "double";
            else if (a == "float" || b == "float")
                r = "float";
            else if (a == "int" || b == "int")
                r = "int";
            else if (a == "uint" || b == "uint")
                r = "uint";
            else 
                continue;

#>

        /// <summary>
        ///   Gets the inner product (scalar product) between two vectors (a'*b).
        /// </summary>
        /// 
        /// <param name="a">A vector.</param>
        /// <param name="b">A vector.</param>
        /// 
        /// <returns>The inner product of the multiplication of the vectors.</returns>
        /// 
        /// <remarks>
        ///  <para>
        ///    In mathematics, the dot product is an algebraic operation that takes two
        ///    equal-length sequences of numbers (usually coordinate vectors) and returns
        ///    a single number obtained by multiplying corresponding entries and adding up
        ///    those products. The name is derived from the dot that is often used to designate
        ///    this operation; the alternative name scalar product emphasizes the scalar
        ///    (rather than vector) nature of the result.</para>
        ///  <para>
        ///    The principal use of this product is the inner product in a Euclidean vector space:
        ///    when two vectors are expressed on an orthonormal basis, the dot product of their 
        ///    coordinate vectors gives their inner product.</para>  
        /// </remarks>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#> Dot(this <#=a#>[] a, <#=b#>[] b)
        {
            <#=r#> r = (<#=r#>)0;
            for (int i = 0; i < a.Length; i++)
                r += (<#=r#>)((<#=r#>)a[i] * (<#=r#>)b[i]);
            return r;
        }




        /// <summary>
        ///   Computes the product <c>A*b</c> of a matrix <c>A</c> and a column vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="columnVector">The right vector <c>b</c>.</param>
        ///
        /// <returns>The product <c>A*b</c> of the given matrix <c>A</c> and vector <c>b</c>.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] Dot(this <#=a#>[][] a, <#=b#>[] columnVector)
        {
            return Dot(a, columnVector, new <#=r#>[a.Length]);
        }

        /// <summary>
        ///   Computes the product <c>A*b</c> of a matrix <c>A</c> and a column vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="columnVector">The right vector <c>b</c>.</param>
        ///
        /// <returns>The product <c>A*b</c> of the given matrix <c>A</c> and vector <c>b</c>.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] Dot(this <#=a#>[,] a, <#=b#>[] columnVector)
        {
            return Dot(a, columnVector, new <#=r#>[a.GetLength(0)]);
        }

        /// <summary>
        ///   Computes the product <c>a*B</c> of a row vector <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="rowVector">The left vector <c>a</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>a*B</c> of the given vector <c>a</c> and <c>B</c>.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] Dot(this <#=a#>[] rowVector, <#=b#>[][] b)
        {
            return Dot(rowVector, b, new <#=r#>[b[0].Length]);
        }

        /// <summary>
        ///   Computes the product <c>a*B</c> of a row vector <c>a</c> and a matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="rowVector">The left vector <c>a</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>a*B</c> of the given vector <c>a</c> and <c>B</c>.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] Dot(this <#=a#>[] rowVector, <#=b#>[,] b)
        {
            return Dot(rowVector, b, new <#=r#>[b.GetLength(1)]);
        }

        /// <summary>
        ///   Computes the product <c>A*B</c> of two matrices <c>A</c> and <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] Dot(this <#=a#>[][] a, <#=b#>[][] b)
        {
            return Dot(a, b, Accord.Math.Jagged.Create<<#=r#>>(a.Length, b[0].Length));
        }

        /// <summary>
        ///   Computes the product <c>A*B</c> of two matrices <c>A</c> and <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] Dot(this <#=a#>[,] a, <#=b#>[,] b)
        {
            return Dot(a, b, new <#=r#>[a.GetLength(0), b.GetLength(1)]);
        }

        /// <summary>
        ///   Computes the product <c>A*B</c> of two matrices <c>A</c> and <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] Dot(this <#=a#>[][] a, <#=b#>[,] b)
        {
            return Dot(a, b, Accord.Math.Jagged.Create<<#=r#>>(a.Length, b.GetLength(0)));
        }

        /// <summary>
        ///   Computes the product <c>A*B</c> of two matrices <c>A</c> and <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] Dot(this <#=a#>[,] a, <#=b#>[][] b)
        {
            return Dot(a, b, Accord.Math.Jagged.Create<<#=r#>>(a.GetLength(0), b[0].Length));
        }







        /// <summary>
        ///   Computes the product <c>A*b'</c> of matrix <c>A</c> and transpose of <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="columnVector">The right vector <c>b</c>.</param>
        ///
        /// <returns>The product <c>A*B'</c> of the given matrix <c>A</c> and vector <c>b</c>.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] DotWithTransposed(this <#=a#>[][] a, <#=b#>[] columnVector)
        {
            return DotWithTransposed(a, columnVector, Accord.Math.Jagged.Create<<#=r#>>(a.Length, columnVector.Length));
        }

        /// <summary>
        ///   Computes the product <c>A*b'</c> of matrix <c>A</c> and transpose of <c>b</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="columnVector">The right vector <c>b</c>.</param>
        ///
        /// <returns>The product <c>A*B'</c> of the given matrix <c>A</c> and vector <c>b</c>.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] DotWithTransposed(this <#=a#>[,] a, <#=b#>[] columnVector)
        {
            return DotWithTransposed(a, columnVector, new <#=r#>[a.GetLength(0), columnVector.Length]);
        }

        /// <summary>
        ///   Computes the product <c>a*B'</c> of row vector <c>a</c> and transpose of <c>B</c>.
        /// </summary>
        /// 
        /// <param name="rowVector">The left vector <c>a</c>.</param>
        /// <param name="b">The transposed right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>a*B'</c> of the given vector <c>a</c> and matrix <c>B</c>.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] DotWithTransposed(this <#=a#>[] rowVector, <#=b#>[][] b)
        {
            return DotWithTransposed(rowVector, b, new <#=r#>[b.Length]);
        } 

        /// <summary>
        ///   Computes the product <c>a*B'</c> of row vector <c>a</c> and transpose of <c>B</c>.
        /// </summary>
        /// 
        /// <param name="rowVector">The left vector <c>a</c>.</param>
        /// <param name="b">The transposed right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>a*B'</c> of the given vector <c>a</c> and matrix <c>B</c>.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] DotWithTransposed(this <#=a#>[] rowVector, <#=b#>[,] b)
        {
            return DotWithTransposed(rowVector, b, new <#=r#>[b.GetLength(0)]);
        }

        /// <summary>
        ///   Computes the product <c>A*B'</c> of matrix <c>A</c> and transpose of <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The transposed right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>A*B'</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] DotWithTransposed(this <#=a#>[][] a, <#=b#>[][] b)
        {
            return DotWithTransposed(a, b, Accord.Math.Jagged.Create<<#=r#>>(a.Length, b.Length));
        }

        /// <summary>
        ///   Computes the product <c>A*B'</c> of matrix <c>A</c> and transpose of <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The transposed right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>A*B'</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] DotWithTransposed(this <#=a#>[,] a, <#=b#>[,] b)
        {
            return DotWithTransposed(a, b, new <#=r#>[a.GetLength(0), b.GetLength(0)]);
        }

        /// <summary>
        ///   Computes the product <c>A*B'</c> of matrix <c>A</c> and transpose of <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The transposed right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>A*B'</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] DotWithTransposed(this <#=a#>[][] a, <#=b#>[,] b)
        {
            return DotWithTransposed(a, b, Accord.Math.Jagged.Create<<#=r#>>(a.Length, b.GetLength(0)));
        }

        /// <summary>
        ///   Computes the product <c>A*B'</c> of matrix <c>A</c> and transpose of <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The transposed right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>A*B'</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] DotWithTransposed(this <#=a#>[,] a, <#=b#>[][] b)
        {
            return DotWithTransposed(a, b, Accord.Math.Jagged.Create<<#=r#>>(a.GetLength(0), b.Length));
        }




# region Transpose and dot

        /// <summary>
        ///   Computes the product <c>A'*B</c> of matrix <c>A</c> transposed and matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The transposed left matrix <c>A</c>.</param>
        /// <param name="columnVector">The right matrix <c>B</c>.</param>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] TransposeAndDot(this <#=a#>[][] a, <#=b#>[] columnVector)
        {
            return TransposeAndDot(a, columnVector, new <#=r#>[a[0].Length]);
        }

        /// <summary>
        ///   Computes the product <c>A'*B</c> of matrix <c>A</c> transposed and matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The transposed left matrix <c>A</c>.</param>
        /// <param name="columnVector">The right matrix <c>B</c>.</param>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] TransposeAndDot(this <#=a#>[,] a, <#=b#>[] columnVector)
        {
            return TransposeAndDot(a, columnVector, new <#=r#>[a.GetLength(1)]);
        }

        /// <summary>
        ///   Computes the product <c>a'*B</c> of column vector <c>a</c> and <c>B</c>.
        /// </summary>
        /// 
        /// <param name="columnVector">The column vector <c>a</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>a'*B</c> of the given vector <c>a</c> and matrix <c>B</c>.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] TransposeAndDot(this <#=a#>[] columnVector, <#=b#>[][] b)
        {
            return TransposeAndDot(columnVector, b, Accord.Math.Jagged.Create<<#=r#>>(columnVector.Length, b[0].Length));
        }

        /// <summary>
        ///   Computes the product <c>a'*B</c> of column vector <c>a</c> and <c>B</c>.
        /// </summary>
        /// 
        /// <param name="columnVector">The column vector <c>a</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>a'*B</c> of the given vector <c>a</c> and matrix <c>B</c>.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] TransposeAndDot(this <#=a#>[] columnVector, <#=b#>[,] b)
        {
            return TransposeAndDot(columnVector, b, new <#=r#>[columnVector.Length, b.GetLength(1)]);
        }

        /// <summary>
        ///   Computes the product <c>A'*B</c> of transposed of matrix <c>A</c> and <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The transposed left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>A'*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] TransposeAndDot(this <#=a#>[][] a, <#=b#>[][] b)
        {
            return TransposeAndDot(a, b, Accord.Math.Jagged.Create<<#=r#>>(a[0].Length, b[0].Length));
        }

        /// <summary>
        ///   Computes the product <c>A'*B</c> of transposed of matrix <c>A</c> and <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The transposed left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>A'*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] TransposeAndDot(this <#=a#>[,] a, <#=b#>[,] b)
        {
            return TransposeAndDot(a, b, Matrix.Create<<#=r#>>(a.GetLength(1), b.GetLength(1)));
        }

        /// <summary>
        ///   Computes the product <c>A'*B</c> of transposed of matrix <c>A</c> and <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The transposed left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>A'*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] TransposeAndDot(this <#=a#>[][] a, <#=b#>[,] b)
        {
            return TransposeAndDot(a, b, Accord.Math.Jagged.Create<<#=r#>>(a[0].Length, b.GetLength(1)));
        }

        /// <summary>
        ///   Computes the product <c>A'*B</c> of transposed of matrix <c>A</c> and <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The transposed left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>A'*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] TransposeAndDot(this <#=a#>[,] a, <#=b#>[][] b)
        {
            return TransposeAndDot(a, b, Accord.Math.Jagged.Create<<#=r#>>(a.GetLength(0), b[0].Length));
        }

#endregion






#region dot with diagonal

        /// <summary>
        ///   Computes the product A*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The diagonal vector of right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] DotWithDiagonal(this <#=a#>[][] a, <#=b#>[] b)
        {
            return DotWithDiagonal(a, b, Accord.Math.Jagged.Create<<#=r#>>(a.Length, b.Length));
        }

        /// <summary>
        ///   Computes the product A*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The diagonal vector of right matrix <c>B</c>.</param>
        ///
        /// <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] DotWithDiagonal(this <#=a#>[,] a, <#=b#>[] b)
        {
            return DotWithDiagonal(a, b, Matrix.Create<<#=r#>>(a.GetLength(0), b.Length));
        }


        /// <summary>
        ///   Computes the product A'*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The diagonal vector of right matrix <c>B</c>.</param>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] TransposeAndDotWithDiagonal(this <#=a#>[,] a, <#=b#>[] b)
        {
            return TransposeAndDotWithDiagonal(a, b, Matrix.Create<<#=r#>>(a.GetLength(0), b.Length));
        }

        /// <summary>
        ///   Computes the product A'*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The diagonal vector of right matrix <c>B</c>.</param>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] TransposeAndDotWithDiagonal(this <#=a#>[][] a, <#=b#>[] b)
        {
            return TransposeAndDotWithDiagonal(a, b, Jagged.Create<<#=r#>>(a.GetLength(0), b.Length));
        }



        /// <summary>
        ///   Computes the product A*inv(B) of matrix <c>A</c> and diagonal matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The diagonal vector of inverse right matrix <c>B</c>.</param>
        /// <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] DivideByDiagonal(this <#=a#>[,] a, <#=b#>[] b)
        {
            return DivideByDiagonal(a, b, Matrix.CreateAs<<#=a#>, <#=r#>>(a));
        }

#endregion




        /// <summary>
        ///   Vector product.
        /// </summary>
        /// 
        /// <remarks>
        ///   The cross product, vector product or Gibbs vector product is a binary operation
        ///   on two vectors in three-dimensional space. It has a vector result, a vector which
        ///   is always perpendicular to both of the vectors being multiplied and the plane
        ///   containing them. It has many applications in mathematics, engineering and physics.
        /// </remarks>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] Cross(this <#=a#>[] a, <#=b#>[] b)
        {
            return Cross(a, b, new <#=r#>[a.Length]);
        }

        
        /// <summary>
        ///   Gets the outer product (matrix product) between two vectors (a*bT).
        /// </summary>
        /// 
        /// <remarks>
        ///   In linear algebra, the outer product typically refers to the tensor
        ///   product of two vectors. The result of applying the outer product to
        ///   a pair of vectors is a matrix. The name contrasts with the inner product,
        ///   which takes as input a pair of vectors and produces a scalar.
        /// </remarks>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] Outer(this <#=a#>[] a, <#=b#>[] b)
        {
            return Outer(a, b, new <#=r#>[a.Length, b.Length]);
        }

        /// <summary>
        ///   Gets the outer product (matrix product) between two vectors (a*bT).
        /// </summary>
        /// 
        /// <remarks>
        ///   In linear algebra, the outer product typically refers to the tensor
        ///   product of two vectors. The result of applying the outer product to
        ///   a pair of vectors is a matrix. The name contrasts with the inner product,
        ///   which takes as input a pair of vectors and produces a scalar.
        /// </remarks>
        /// 
        [Obsolete("Please use Matrix.Dot instead.")]
        public static <#=r#> Inner(this <#=a#>[] a, <#=b#>[] b)
        {
            return Dot(a, b);
        }


        /// <summary>
        ///   Computes the Kronecker product between two vectors.
        /// </summary>
        /// 
        /// <param name="a">The left vector a.</param>
        /// <param name="b">The right vector b.</param>
        /// 
        /// <returns>The Kronecker product of the two vectors.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] Kronecker(this <#=a#>[] a, <#=b#>[] b)
        {
            return Kronecker(a, b, new <#=r#>[a.Length * b.Length]);
        }

        /// <summary>
        ///   Computes the Kronecker product between two matrices.
        /// </summary>
        /// 
        /// <param name="a">The left matrix a.</param>
        /// <param name="b">The right matrix b.</param>
        /// 
        /// <returns>The Kronecker product of the two matrices.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] Kronecker(this <#=a#>[][] a, <#=b#>[][] b)
        {
            int crows = a.Length * b.Length;
            int ccols = a[0].Length * b[0].Length;
            return Kronecker(a, b, Accord.Math.Jagged.Create<<#=r#>>(crows, ccols));
        }

        /// <summary>
        ///   Computes the Kronecker product between two matrices.
        /// </summary>
        /// 
        /// <param name="a">The left matrix a.</param>
        /// <param name="b">The right matrix b.</param>
        /// 
        /// <returns>The Kronecker product of the two matrices.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] Kronecker(this <#=a#>[,] a, <#=b#>[,] b)
        {
            int crows = a.GetLength(0) * b.GetLength(0);
            int ccols = a.GetLength(1) * b.GetLength(1);
            return Kronecker(a, b, new <#=r#>[crows, ccols]);
        }

        /// <summary>
        ///   Computes the Kronecker product between two matrices.
        /// </summary>
        /// 
        /// <param name="a">The left matrix a.</param>
        /// <param name="b">The right matrix b.</param>
        /// 
        /// <returns>The Kronecker product of the two matrices.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] Kronecker(this <#=a#>[][] a, <#=b#>[,] b)
        {
            int crows = a.GetLength(0) * b.GetLength(0);
            int ccols = a.GetLength(1) * b.GetLength(1);
            return Kronecker(a, b, Accord.Math.Jagged.Create<<#=r#>>(crows, ccols));
        }

        /// <summary>
        ///   Computes the Kronecker product between two matrices.
        /// </summary>
        /// 
        /// <param name="a">The left matrix a.</param>
        /// <param name="b">The right matrix b.</param>
        /// 
        /// <returns>The Kronecker product of the two matrices.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] Kronecker(this <#=a#>[,] a, <#=b#>[][] b)
        {
            int crows = a.GetLength(0) * b.GetLength(0);
            int ccols = a.GetLength(1) * b.GetLength(1);
            return Kronecker(a, b, Accord.Math.Jagged.Create<<#=r#>>(crows, ccols));
        }
<#
        }
    }










    foreach (string a in types)
    {
        foreach (string b in new HashSet<string>() { a, "double", "int", "float" })
        {
            foreach (string c in new HashSet<string>() { a, b, "double", "int", "float" })
            {
#>

        /// <summary>
        ///   Computes the product <c>a*B*c</c> of a row vector <c>a</c>, 
        ///   a square matrix <c>B</c> and a column vector <c>c</c>.
        /// </summary>
        /// 
        /// <param name="rowVector">The left vector <c>a</c>.</param>
        /// <param name="b">The square matrix <c>B</c>.</param>
        /// <param name="columnVector">The column vector <c>c</c>.</param>
        ///
        /// <returns>The product <c>a*B*c</c> of the given vector <c>a</c>,
        ///   matrix <c>B</c> and vector <c>c</c>.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=c#> DotAndDot(this <#=a#>[] rowVector, <#=b#>[][] b, <#=c#>[] columnVector)
        {
#if DEBUG
            if (rowVector.Length != b.GetLength(0) || b[0].Length != columnVector.Length)
                throw new DimensionMismatchException();
#endif
            var ab = rowVector.Dot(b);
            <#=c#> result = (<#=c#>)0;
            for (int i = 0; i < ab.Length; i++)
                result += (<#=c#>)((<#=c#>)ab[i] * (<#=c#>)columnVector[i]);
            return result;
        }

        /// <summary>
        ///   Computes the product <c>a*B*c</c> of a row vector <c>a</c>, 
        ///   a square matrix <c>B</c> and a column vector <c>c</c>.
        /// </summary>
        /// 
        /// <param name="rowVector">The left vector <c>a</c>.</param>
        /// <param name="b">The square matrix <c>B</c>.</param>
        /// <param name="columnVector">The column vector <c>c</c>.</param>
        ///
        /// <returns>The product <c>a*B*c</c> of the given vector <c>a</c>,
        ///   matrix <c>B</c> and vector <c>c</c>.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=c#> DotAndDot(this <#=a#>[] rowVector, <#=b#>[,] b, <#=c#>[] columnVector)
        {
#if DEBUG
            if (rowVector.Length != b.GetLength(0) || b.GetLength(1) != columnVector.Length)
                throw new DimensionMismatchException();
#endif
            var ab = rowVector.Dot(b);
            <#=c#> result = (<#=c#>)0;
            for (int i = 0; i < ab.Length; i++)
                result += (<#=c#>)((<#=c#>)ab[i] * (<#=c#>)columnVector[i]);
            return result;      
        }


<#
            }
        }
    }

    foreach (string a in types)
    {
        foreach (string b in new HashSet<string>() { a, "double", "int", "float" })
        {
            foreach (string r in new HashSet<string>() { a, b, "double", "int" })
            {
#>

#region dot

        /// <summary>
        ///   Computes the product <c>R = A*B</c> of two matrices <c>A</c>
        ///   and <c>B</c>, storing the result in matrix <c>R</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] Dot(this <#=a#>[,] a, <#=b#>[,] b, <#=r#>[,] result)
        {
#if DEBUG
            if (a.GetLength(1) != b.GetLength(0) || result.GetLength(0) > a.GetLength(0) || result.GetLength(1) > b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int N = result.GetLength(0);
            int K = a.GetLength(1);
            int M = result.GetLength(1);
            int stride = b.GetLength(1);

            var t = new <#=b#>[K];

            unsafe
            {
                fixed (<#=a#>* A = a)
                fixed (<#=b#>* B = b)
                fixed (<#=b#>* T = t)
                fixed (<#=r#>* R = result)
                {
                    for (int j = 0; j < M; j++)
                    {
                        <#=b#>* pb = B + j;
                        for (int k = 0; k < K; k++)
                        {
                            T[k] = *pb;
                            pb += stride;
                        }

                        <#=a#>* pa = A;
                        <#=r#>* pr = R + j;
                        for (int i = 0; i < N; i++)
                        {
                            <#=r#> s = (<#=r#>)0;
                            for (int k = 0; k < K; k++)
                                s += (<#=r#>)((<#=r#>)pa[k] * (<#=r#>)T[k]);
                            *pr = s;
                            pa += K;
                            pr += M;
                        }
                    }
                }
            }
#if DEBUG
            var C = new <#=r#>[N, M];
            for (int i = 0; i < N; i++)
                for (int j = 0; j < M; j++)
                    for (int k = 0; k < K; k++)
                        C[i, j] += (<#=r#>)((<#=r#>)a[i, k] * (<#=r#>)b[k, j]);
            if (!Matrix.IsEqual(C.To<double[,]>(), result.To<double[,]>(), 1e-4))
                throw new Exception();
#endif
            return result;
        }

        /// <summary>
        ///   Computes the product <c>R = A*B</c> of two matrices <c>A</c>
        ///   and <c>B</c>, storing the result in matrix <c>R</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product.</param>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] Dot(this <#=a#>[][] a, <#=b#>[][] b, <#=r#>[][] result)
        {
#if DEBUG
            if (a[0].Length != b.Length || result.Length > a.Length || result[0].Length > b[0].Length)
                throw new DimensionMismatchException();
#endif
            int N = result.Length;
            int K = a[0].Length;
            int M = result[0].Length;

            var t = new <#=b#>[K];

            for (int j = 0; j < M; j++)
            {
                for (int k = 0; k < b.Length; k++)
                    t[k] = b[k][j];

                for (int i = 0; i < a.Length; i++)
                {
                    <#=r#> s = (<#=r#>)0;
                    for (int k = 0; k < t.Length; k++)
                        s += (<#=r#>)((<#=r#>)a[i][k] * (<#=r#>)t[k]);
                    result[i][j] = s;
                }
            }
#if DEBUG
            var C = Dot(a.ToMatrix().To<double[,]>(), b.ToMatrix().To<double[,]>());
            if (!Matrix.IsEqual(C, result.ToMatrix().To<double[,]>(), 1e-4))
                throw new Exception();
#endif
            return result;
        }

        /// <summary>
        ///   Computes the product <c>R = A*B</c> of two matrices <c>A</c>
        ///   and <c>B</c>, storing the result in matrix <c>R</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product.</param>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] Dot(this <#=a#>[][] a, <#=b#>[,] b, <#=r#>[][] result)
        {
#if DEBUG
            if (a[0].Length != b.GetLength(0) || result.Length > a.Length || result[0].Length > b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int N = result.Length;
            int K = a[0].Length;
            int M = result[0].Length;
            int stride = b.GetLength(1);
            var t = new <#=b#>[K];

            unsafe
            {
                fixed (<#=b#>* B = b)
                fixed (<#=b#>* T = t)
                {
                    for (int j = 0; j < M; j++)
                    {
                        <#=b#>* pb = B + j;
                        for (int k = 0; k < K; k++)
                        {
                            T[k] = *pb;
                            pb += stride;
                        }

                        for (int i = 0; i < a.Length; i++)
                        {
                            <#=r#> s = (<#=r#>)0;
                            for (int k = 0; k < a[i].Length; k++)
                                s += (<#=r#>)((<#=r#>)a[i][k] * (<#=r#>)T[k]);
                            result[i][j] = s;
                        }
                    }
                }
            }
#if DEBUG
            var C = Dot(a.ToMatrix().To<double[,]>(), b.To<double[,]>());
            if (!Matrix.IsEqual(C, result.ToMatrix().To<double[,]>(), 1e-4))
                throw new Exception();
#endif
            return result;
        }

        /// <summary>
        ///   Computes the product <c>R = A*B</c> of two matrices <c>A</c>
        ///   and <c>B</c>, storing the result in matrix <c>R</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product.</param>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] Dot(this <#=a#>[,] a, <#=b#>[][] b, <#=r#>[][] result)
        {
#if DEBUG
            if (a.GetLength(1) != b[0].Length || result.Length > a.Length || result[0].Length > b[0].Length)
                throw new DimensionMismatchException();
#endif
            // TODO: Optimize
            int N = result.Length;
            int K = a.GetLength(0);
            int M = result[0].Length;

            var t = new <#=b#>[K];

            for (int j = 0; j < M; j++)
            {
                for (int k = 0; k < t.Length; k++)
                    t[k] = b[k][j];

                for (int i = 0; i < N; i++)
                {
                    <#=r#> s = (<#=r#>)0;
                    for (int k = 0; k < t.Length; k++)
                        s += (<#=r#>)((<#=r#>)a[i, k] * (<#=r#>)t[k]);
                    result[i][j] = s;
                }
            }
#if DEBUG
            var C = Dot(a.To<double[,]>(), b.ToMatrix().To<double[,]>());
            if (!Matrix.IsEqual(C, result.ToMatrix().To<double[,]>(), 1e-4))
                throw new Exception();
#endif
            return result;
        }

        /// <summary>
        ///   Multiplies a row vector <c>v</c> and a matrix <c>A</c>,
        ///   giving the product <c>v'*A</c>.
        /// </summary>
        /// 
        /// <param name="rowVector">The row vector <c>v</c>.</param>
        /// <param name="matrix">The matrix <c>A</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product.</param>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] Dot(this <#=a#>[] rowVector, <#=b#>[,] matrix, <#=r#>[] result)
        {
#if DEBUG
            if (rowVector.Length != matrix.GetLength(0) || result.Length > matrix.GetLength(1))
                throw new DimensionMismatchException();
#endif
            // TODO: optimize
            int cols = matrix.GetLength(1);
            for (int j = 0; j < cols; j++)
                for (int k = 0; k < rowVector.Length; k++)
                    result[j] += (<#=r#>)((<#=r#>)rowVector[k] * (<#=r#>)matrix[k, j]);
            return result;
        }

        /// <summary>
        ///   Multiplies a matrix <c>A</c> and a column vector <c>v</c>,
        ///   giving the product <c>A*v</c>
        /// </summary>
        /// 
        /// <param name="matrix">The matrix <c>A</c>.</param>
        /// <param name="columnVector">The column vector <c>v</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product.</param>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] Dot(this <#=a#>[][] matrix, <#=b#>[] columnVector, <#=r#>[] result)
        {
#if DEBUG
            if (matrix[0].Length != columnVector.Length || result.Length > matrix.Length)
                throw new DimensionMismatchException();
#endif

            for (int i = 0; i < matrix.Length; i++)
                for (int j = 0; j < columnVector.Length; j++)
                    result[i] += (<#=r#>)((<#=r#>)matrix[i][j] * (<#=r#>)columnVector[j]);
            return result;
        }

        /// <summary>
        ///   Multiplies a matrix <c>A</c> and a column vector <c>v</c>,
        ///   giving the product <c>A*v</c>
        /// </summary>
        /// 
        /// <param name="matrix">The matrix <c>A</c>.</param>
        /// <param name="columnVector">The column vector <c>v</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product.</param>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] Dot(this <#=a#>[,] matrix, <#=b#>[] columnVector, <#=r#>[] result)
        {
#if DEBUG
            if (matrix.GetLength(1) != columnVector.Length || result.Length > matrix.GetLength(0))
                throw new DimensionMismatchException();
#endif
            // TODO: Optimize
            for (int i = 0; i < result.Length; i++)
                for (int j = 0; j < columnVector.Length; j++)
                    result[i] += (<#=r#>)((<#=r#>)matrix[i, j] * (<#=r#>)columnVector[j]);
            return result;
        }

        /// <summary>
        ///   Computes the product <c>R = A*B</c> of two matrices <c>A</c>
        ///   and <c>B</c>, storing the result in matrix <c>R</c>.
        /// </summary>
        /// 
        /// <param name="rowVector">The left matrix <c>A</c>.</param>
        /// <param name="matrix">The right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product.</param>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] Dot(this <#=a#>[] rowVector, <#=b#>[][] matrix, <#=r#>[] result)
        {
#if DEBUG
            if (rowVector.Length != matrix.Length || result.Length > matrix[0].Length)
                throw new DimensionMismatchException();
#endif
            var t = new <#=b#>[rowVector.Length];

            for (int j = 0; j < result.Length; j++)
            {
                for (int k = 0; k < rowVector.Length; k++)
                    t[k] = matrix[k][j];

                <#=r#> s = (<#=r#>)0;
                for (int k = 0; k < t.Length; k++)
                    s += (<#=r#>)((<#=r#>)rowVector[k] * (<#=r#>)t[k]);
                result[j] = s;
            }

            return result;
        }

#endregion






#region dot with transposed

        /// <summary>
        ///   Computes the product <c>A*B'</c> of matrix <c>A</c> and
        ///   transpose of <c>B</c>, storing the result in matrix <c>R</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The transposed right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A*B'</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        ///    
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] DotWithTransposed(this <#=a#>[,] a, <#=b#>[,] b, <#=r#>[,] result)
        {
#if DEBUG
            if (a.GetLength(1) != b.GetLength(1) || result.GetLength(0) > a.GetLength(0) || result.GetLength(1) > b.GetLength(0))
                throw new DimensionMismatchException();
#endif
            int n = a.GetLength(1);
            int m = a.GetLength(0);
            int p = b.GetLength(0);

            unsafe
            {
                fixed (<#=a#>* A = a)
                fixed (<#=b#>* B = b)
                fixed (<#=r#>* R = result)
                {
                    <#=r#>* pr = R;
                    for (int i = 0; i < m; i++)
                    {
                        <#=b#>* pb = B;
                        for (int j = 0; j < p; j++, pr++)
                        {
                            <#=a#>* pa = A + n * i;

                            <#=r#> s = (<#=r#>)0;
                            for (int k = 0; k < n; k++)
                                s += (<#=r#>)((<#=r#>)(*pa++) * (<#=r#>)(*pb++));
                            *pr = s;
                        }
                    }
                }
            }
#if DEBUG
            var C = Dot(a.To<double[,]>(), b.Transpose().To<double[,]>());
            if (!Matrix.IsEqual(C, result.To<double[,]>(), 1e-4))
                throw new Exception();
#endif
            return result;
        }

        /// <summary>
        ///   Computes the product <c>A*B'</c> of matrix <c>A</c> and
        ///   transpose of <c>B</c>, storing the result in matrix <c>R</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The transposed right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A*B'</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        ///    
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] DotWithTransposed(this <#=a#>[][] a, <#=b#>[,] b, <#=r#>[][] result)
        {
            // TODO: Optimize this call
            return a.Dot(b.Transpose(), result);
        }

        /// <summary>
        ///   Computes the product <c>A*B'</c> of matrix <c>A</c> and
        ///   transpose of <c>B</c>, storing the result in matrix <c>R</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The transposed right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A*B'</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        ///   
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif 
        public static <#=r#>[][] DotWithTransposed(this <#=a#>[,] a, <#=b#>[][] b, <#=r#>[][] result)
        {
            // TODO: Optimize this call
            return a.Dot(b.Transpose(), result);
        }

        /// <summary>
        ///   Computes the product <c>A*B'</c> of matrix <c>A</c> and
        ///   transpose of <c>B</c>, storing the result in matrix <c>R</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="b">The transposed right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A*B'</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        ///    
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] DotWithTransposed(this <#=a#>[][] a, <#=b#>[][] b, <#=r#>[][] result)
        {
            // TODO: Optimize this call
            return a.Dot(b.Transpose(), result);
        }

        /// <summary>
        ///   Computes the product <c>A*B'</c> of matrix <c>A</c> and
        ///   transpose of <c>B</c>, storing the result in matrix <c>R</c>.
        /// </summary>
        /// 
        /// <param name="rowVector">The left matrix <c>A</c>.</param>
        /// <param name="b">The transposed right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A*B'</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        ///    
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] DotWithTransposed(this <#=a#>[] rowVector, <#=b#>[,] b, <#=r#>[] result)
        {
            // TODO: Optimize this call
            return rowVector.Dot(b.Transpose(), result);
        }

        /// <summary>
        ///   Computes the product <c>A*B'</c> of matrix <c>A</c> and
        ///   transpose of <c>B</c>, storing the result in matrix <c>R</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="columnVector">The transposed right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A*B'</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        ///    
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] DotWithTransposed(this <#=a#>[,] a, <#=b#>[] columnVector, <#=r#>[,] result)
        {
            // TODO: Optimize this call
            return a.Dot(columnVector.Transpose(), result);
        }

        /// <summary>
        ///   Computes the product <c>A*B'</c> of matrix <c>A</c> and
        ///   transpose of <c>B</c>, storing the result in matrix <c>R</c>.
        /// </summary>
        /// 
        /// <param name="rowVector">The left matrix <c>A</c>.</param>
        /// <param name="b">The transposed right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A*B'</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        ///    
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] DotWithTransposed(this <#=a#>[] rowVector, <#=b#>[][] b, <#=r#>[] result)
        {
            // TODO: Optimize this call
            return rowVector.Dot(b.Transpose(), result);
        }

        /// <summary>
        ///   Computes the product <c>A*B'</c> of matrix <c>A</c> and
        ///   transpose of <c>B</c>, storing the result in matrix <c>R</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="columnVector">The transposed right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A*B'</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        ///    
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] DotWithTransposed(this <#=a#>[][] a, <#=b#>[] columnVector, <#=r#>[][] result)
        {
            // TODO: Optimize this call
            <#=b#>[][] t;
            return a.Dot(columnVector.Transpose(out t), result);
        }

#endregion








#region transpose and dot


        /// <summary>
        ///   Computes the product <c>A'*B</c> of matrix <c>A</c> transposed and matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The transposed left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A'*B</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] TransposeAndDot(this <#=a#>[,] a, <#=b#>[,] b, <#=r#>[,] result)
        {
#if DEBUG
            if (a.GetLength(0) != b.GetLength(0) || result.GetLength(0) > a.GetLength(1) || result.GetLength(1) > b.GetLength(1))
                throw new DimensionMismatchException();
#endif
            int n = a.GetLength(0);
            int m = a.GetLength(1);
            int p = b.GetLength(1);

            var Bcolj = new <#=b#>[n];
            for (int i = 0; i < p; i++)
            {
                for (int k = 0; k < n; k++)
                    Bcolj[k] = b[k, i];

                for (int j = 0; j < m; j++)
                {
                    <#=r#> s = (<#=r#>)0;
                    for (int k = 0; k < n; k++)
                        s += (<#=r#>)((<#=r#>)a[k, j] * (<#=r#>)Bcolj[k]);
                    result[j, i] = s;
                }
            }
#if DEBUG
            var C = Dot(a.Transpose().To<double[,]>(), b.To<double[,]>());
            if (!Matrix.IsEqual(C, result.To<double[,]>(), 1e-4))
                throw new Exception();
#endif
            return result;
        }

        /// <summary>
        ///   Computes the product <c>A'*B</c> of matrix <c>A</c> transposed and matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The transposed left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A'*B</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] TransposeAndDot(this <#=a#>[][] a, <#=b#>[][] b, <#=r#>[][] result)
        {
#if DEBUG
            if (a.Length != b.Length || result.Length > a[0].Length || result[0].Length > b[0].Length)
                throw new DimensionMismatchException();
#endif
            int n = a.Length;
            int m = a[0].Length;
            int p = b[0].Length;

            var Bcolj = new <#=b#>[n];
            for (int i = 0; i < p; i++)
            {
                for (int k = 0; k < b.Length; k++)
                    Bcolj[k] = b[k][i];

                for (int j = 0; j < m; j++)
                {
                    <#=r#> s = (<#=r#>)0;
                    for (int k = 0; k < Bcolj.Length; k++)
                        s += (<#=r#>)((<#=r#>)a[k][j] * (<#=r#>)Bcolj[k]);
                    result[j][i] = s;
                }
            }
#if DEBUG
            var C = Dot(a.Transpose().To<double[,]>(), b.To<double[,]>());
            if (!Matrix.IsEqual(C, result.To<double[,]>(), 1e-4))
                throw new Exception();
#endif
            return result;
        }


       

        /// <summary>
        ///   Computes the product <c>A'*b</c> of matrix <c>A</c> transposed and column vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="matrix">The transposed left matrix <c>A</c>.</param>
        /// <param name="columnVector">The right column vector <c>b</c>.</param>
        /// <param name="result">The vector <c>r</c> to store the product <c>r = A'*b</c>
        ///   of the given matrix <c>A</c> and vector <c>b</c>.</param>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] TransposeAndDot(this <#=a#>[,] matrix, <#=b#>[] columnVector, <#=r#>[] result)
        {
#if DEBUG
            if (matrix.GetLength(0) != columnVector.Length || result.Length > matrix.GetLength(1))
                throw new DimensionMismatchException();
#endif
            // TODO: optimize
            int cols = matrix.GetLength(1);
            for (int j = 0; j < cols; j++)
            {
                <#=r#> s = (<#=r#>)0;
                for (int k = 0; k < columnVector.Length; k++)
                    s += (<#=r#>)((<#=r#>)matrix[k, j] * (<#=r#>)columnVector[k]);
                result[j] = s;
            }
#if DEBUG
            var C = Dot(matrix.Transpose().To<double[,]>(), columnVector.To<double[]>());
            if (!Matrix.IsEqual(C, result.To<double[]>(), 1e-4))
                throw new Exception();
#endif
            return result;
        }

        /// <summary>
        ///   Computes the product <c>A'*b</c> of matrix <c>A</c> transposed and column vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="matrix">The transposed left matrix <c>A</c>.</param>
        /// <param name="columnVector">The right column vector <c>b</c>.</param>
        /// <param name="result">The vector <c>r</c> to store the product <c>r = A'*b</c>
        ///   of the given matrix <c>A</c> and vector <c>b</c>.</param>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] TransposeAndDot(this <#=a#>[][] matrix, <#=b#>[] columnVector, <#=r#>[] result)
        {
#if DEBUG
            if (matrix.Length != columnVector.Length || result.Length > matrix[0].Length)
                throw new DimensionMismatchException();
#endif
            int cols = matrix[0].Length;
            for (int j = 0; j < cols; j++)
            {
                <#=r#> s = (<#=r#>)0;
                for (int k = 0; k < columnVector.Length; k++)
                    s += (<#=r#>)((<#=r#>)matrix[k][j] * (<#=r#>)columnVector[k]);
                result[j] = s;
            }
#if DEBUG
            var C = Dot(matrix.Transpose().To<double[,]>(), columnVector.To<double[]>());
            if (!Matrix.IsEqual(C, result.To<double[]>(), 1e-4))
                throw new Exception();
#endif
            return result;
        }

        /// <summary>
        ///   Computes the product <c>A'*B</c> of matrix <c>A</c> transposed and matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The transposed left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A'*B</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] TransposeAndDot(this <#=a#>[][] a, <#=b#>[,] b, <#=r#>[][] result)
        {
            // TODO: optimize
            return a.Transpose().Dot(b, result);
        }

        /// <summary>
        ///   Computes the product <c>A'*B</c> of matrix <c>A</c> transposed and matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The transposed left matrix <c>A</c>.</param>
        /// <param name="b">The right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A'*B</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] TransposeAndDot(this <#=a#>[,] a, <#=b#>[][] b, <#=r#>[][] result)
        {
            // TODO: optimize
            return a.Transpose().Dot(b, result);
        }


       

        /// <summary>
        ///   Computes the product <c>A'*b</c> of matrix <c>A</c> transposed and column vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="rowVector">The transposed left matrix <c>A</c>.</param>
        /// <param name="b">The right column vector <c>b</c>.</param>
        /// <param name="result">The vector <c>r</c> to store the product <c>r = A'*b</c>
        ///   of the given matrix <c>A</c> and vector <c>b</c>.</param>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] TransposeAndDot(this <#=a#>[] rowVector, <#=b#>[,] b, <#=r#>[,] result)
        {
            // TODO: optimize
            return rowVector.Transpose().Dot(b, result);
        }

        /// <summary>
        ///   Computes the product <c>A'*b</c> of matrix <c>A</c> transposed and column vector <c>b</c>.
        /// </summary>
        /// 
        /// <param name="rowVector">The transposed left matrix <c>A</c>.</param>
        /// <param name="b">The right column vector <c>b</c>.</param>
        /// <param name="result">The vector <c>r</c> to store the product <c>r = A'*b</c>
        ///   of the given matrix <c>A</c> and vector <c>b</c>.</param>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] TransposeAndDot(this <#=a#>[] rowVector, <#=b#>[][] b, <#=r#>[][] result)
        {
            // TODO: optimize
            <#=a#>[][] t;
            return rowVector.Transpose(out t).Dot(b, result);
        }

#endregion




#region diagonal

        /// <summary>
        ///   Computes the product A'*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="diagonal">The diagonal vector of right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] TransposeAndDotWithDiagonal(this <#=a#>[,] a, <#=b#>[] diagonal, <#=r#>[,] result)
        {
            int m = a.GetLength(1);
            for (int i = 0; i < diagonal.Length; i++)
                for (int j = 0; j < m; j++)
                    result[j, i] = (<#=r#>)((<#=r#>)a[i, j] * (<#=r#>)diagonal[i]);
#if DEBUG
            var C = Dot(a.Transpose().To<double[,]>(), Matrix.Diagonal(diagonal.To<double[]>()));
            if (!Matrix.IsEqual(C, result.To<double[,]>(), 1e-4))
                throw new Exception();
#endif
            return result;            
        }

        /// <summary>
        ///   Computes the product A'*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="diagonal">The diagonal vector of right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] TransposeAndDotWithDiagonal(this <#=a#>[][] a, <#=b#>[] diagonal, <#=r#>[][] result)
        {
            int m = a.GetLength(1);
            for (int i = 0; i < diagonal.Length; i++)
                for (int j = 0; j < m; j++)
                    result[j][i] = (<#=r#>)((<#=r#>)a[i][j] * (<#=r#>)diagonal[i]);
#if DEBUG
            var C = Dot(a.Transpose().To<double[,]>(), Matrix.Diagonal(diagonal.To<double[]>()));
            if (!Matrix.IsEqual(C, result.To<double[,]>(), 1e-4))
                throw new Exception();
#endif
            return result;
        }

        /// <summary>
        ///   Computes the product A*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="diagonal">The diagonal vector of right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] DotWithDiagonal(this <#=a#>[,] a, <#=b#>[] diagonal, <#=r#>[,] result)
        {
            int rows = a.GetLength(0);

            unsafe
            {
                fixed (<#=a#>* ptrA = a)
                fixed (<#=r#>* ptrR = result)
                {
                    <#=a#>* A = ptrA;
                    <#=r#>* R = ptrR;
                    for (int i = 0; i < rows; i++)
                        for (int j = 0; j < diagonal.Length; j++)
                            *R++ = (<#=r#>)((<#=r#>)(*A++) * (<#=r#>)diagonal[j]);
                }
            }
#if DEBUG
            var C = Dot(a.To<double[,]>(), Matrix.Diagonal(diagonal.To<double[]>()));
            if (!Matrix.IsEqual(C, result.To<double[,]>(), 1e-4))
                throw new Exception();
#endif
            return result;
        }

        /// <summary>
        ///   Computes the product A*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="diagonal">The diagonal vector of right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] DotWithDiagonal(this <#=a#>[][] a, <#=b#>[] diagonal, <#=r#>[][] result)
        {
            int rows = a.Length;
            for (int i = 0; i < rows; i++)
                for (int j = 0; j < diagonal.Length; j++)
                    result[i][j] = (<#=r#>)((<#=r#>)a[i][j] * (<#=r#>)diagonal[j]);
#if DEBUG
            var C = Dot(a.To<double[,]>(), Matrix.Diagonal(diagonal.To<double[]>()));
            if (!Matrix.IsEqual(C, result.To<double[,]>(), 1e-4))
                throw new Exception();
#endif
            return result;
        }

        /// <summary>
        ///   Computes the product A*inv(B) of matrix <c>A</c> and diagonal matrix <c>B</c>.
        /// </summary>
        /// 
        /// <param name="a">The left matrix <c>A</c>.</param>
        /// <param name="diagonal">The diagonal vector of inverse right matrix <c>B</c>.</param>
        /// <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
        ///   of the given matrices <c>A</c> and <c>B</c>.</param>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] DivideByDiagonal(this <#=a#>[,] a, <#=b#>[] diagonal, <#=r#>[,] result)
        {
            int rows = a.GetLength(0);

            unsafe
            {
                fixed (<#=a#>* ptrA = a)
                fixed (<#=r#>* ptrR = result)
                {
                    <#=a#>* A = ptrA;
                    <#=r#>* R = ptrR;
                    for (int i = 0; i < rows; i++)
                        for (int j = 0; j < diagonal.Length; j++)
                            (*R++) = (<#=r#>)((<#=r#>)(*A++) / (<#=r#>)diagonal[j]);
                }
            }

            return result;
        }

#endregion


     








        /// <summary>
        ///   Gets the outer product (matrix product) between two vectors (a*bT).
        /// </summary>
        /// 
        /// <remarks>
        ///   In linear algebra, the outer product typically refers to the tensor
        ///   product of two vectors. The result of applying the outer product to
        ///   a pair of vectors is a matrix. The name contrasts with the inner product,
        ///   which takes as input a pair of vectors and produces a scalar.
        /// </remarks>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] Outer(this <#=a#>[] a, <#=b#>[] b, <#=r#>[,] result)
        {
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < b.Length; j++)
                    result[i, j] += (<#=r#>)((<#=r#>)a[i] * (<#=r#>)b[j]);
            return result;
        }


        /// <summary>
        ///   Gets the outer product (matrix product) between two vectors (a*bT).
        /// </summary>
        /// 
        /// <remarks>
        ///   In linear algebra, the outer product typically refers to the tensor
        ///   product of two vectors. The result of applying the outer product to
        ///   a pair of vectors is a matrix. The name contrasts with the inner product,
        ///   which takes as input a pair of vectors and produces a scalar.
        /// </remarks>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] Outer(this <#=a#>[] a, <#=b#>[] b, <#=r#>[][] result)
        {
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < b.Length; j++)
                    result[i][j] += (<#=r#>)((<#=r#>)a[i] * (<#=r#>)b[j]);
            return result;
        }

        /// <summary>
        ///   Vector product.
        /// </summary>
        /// 
        /// <remarks>
        ///   The cross product, vector product or Gibbs vector product is a binary operation
        ///   on two vectors in three-dimensional space. It has a vector result, a vector which
        ///   is always perpendicular to both of the vectors being multiplied and the plane
        ///   containing them. It has many applications in mathematics, engineering and physics.
        /// </remarks>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] Cross(<#=a#>[] a, <#=b#>[] b, <#=r#>[] result)
        {
            return new <#=r#>[] 
            {
                (<#=r#>)((<#=r#>)a[1]*(<#=r#>)b[2] - (<#=r#>)a[2]*(<#=r#>)b[1]),
                (<#=r#>)((<#=r#>)a[2]*(<#=r#>)b[0] - (<#=r#>)a[0]*(<#=r#>)b[2]),
                (<#=r#>)((<#=r#>)a[0]*(<#=r#>)b[1] - (<#=r#>)a[1]*(<#=r#>)b[0])
            };
        }






#region Kronecker

        /// <summary>
        ///   Computes the Kronecker product between two matrices.
        /// </summary>
        /// 
        /// <param name="a">The left matrix a.</param>
        /// <param name="b">The right matrix b.</param>
        /// <param name="result">The matrix <c>R</c> to store the 
        ///   Kronecker product between matrices <c>A</c> and <c>B</c>.</param>
        /// 
        /// <returns>The Kronecker product of the two matrices.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[,] Kronecker(this <#=a#>[,] a, <#=b#>[,] b, <#=r#>[,] result)
        {
            int arows = a.GetLength(0);
            int acols = a.GetLength(1);

            int brows = b.GetLength(0);
            int bcols = b.GetLength(1);

            int crows = arows * brows;
            int ccols = acols * bcols;
            int block = brows * ccols;

            unsafe
            {
                fixed (<#=r#>* ptrR = result)
                fixed (<#=a#>* ptrA = a)
                fixed (<#=b#>* ptrB = b)
                {
                    <#=a#>* A = ptrA;
                    <#=r#>* Ri = ptrR;

                    for (int i = 0; i < arows; Ri += block, i++)
                    {
                        <#=r#>* Rj = Ri;

                        for (int j = 0; j < acols; j++, Rj += bcols, A++)
                        {
                            <#=r#>* R = Rj;
                            <#=b#>* B = ptrB;

                            for (int k = 0; k < brows; k++, R += ccols)
                            {
                                for (int l = 0; l < bcols; l++, B++)
                                    *(R + l) = (<#=r#>)((<#=r#>)(*A) * (<#=r#>)(*B));
                            }
                        }
                    }
                }
            }

            return result;
        }

        /// <summary>
        ///   Computes the Kronecker product between two matrices.
        /// </summary>
        /// 
        /// <param name="a">The left matrix a.</param>
        /// <param name="b">The right matrix b.</param>
        /// <param name="result">The matrix <c>R</c> to store the 
        ///   Kronecker product between matrices <c>A</c> and <c>B</c>.</param>
        /// 
        /// <returns>The Kronecker product of the two matrices.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] Kronecker(this <#=a#>[][] a, <#=b#>[][] b, <#=r#>[][] result)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        ///   Computes the Kronecker product between two matrices.
        /// </summary>
        /// 
        /// <param name="a">The left matrix a.</param>
        /// <param name="b">The right matrix b.</param>
        /// <param name="result">The matrix <c>R</c> to store the 
        ///   Kronecker product between matrices <c>A</c> and <c>B</c>.</param>
        /// 
        /// <returns>The Kronecker product of the two matrices.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] Kronecker(this <#=a#>[][] a, <#=b#>[,] b, <#=r#>[][] result)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        ///   Computes the Kronecker product between two matrices.
        /// </summary>
        /// 
        /// <param name="a">The left matrix a.</param>
        /// <param name="b">The right matrix b.</param>
        /// <param name="result">The matrix <c>R</c> to store the 
        ///   Kronecker product between matrices <c>A</c> and <c>B</c>.</param>
        /// 
        /// <returns>The Kronecker product of the two matrices.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[][] Kronecker(this <#=a#>[,] a, <#=b#>[][] b, <#=r#>[][] result)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        ///   Computes the Kronecker product between two vectors.
        /// </summary>
        /// 
        /// <param name="a">The left vector a.</param>
        /// <param name="b">The right vector b.</param>
        /// <param name="result">The matrix <c>R</c> to store the 
        ///   Kronecker product between matrices <c>A</c> and <c>B</c>.</param>
        /// 
        /// <returns>The Kronecker product of the two vectors.</returns>
        /// 
#if NET45
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static <#=r#>[] Kronecker(this <#=a#>[] a, <#=b#>[] b, <#=r#>[] result)
        {
            int k = 0;
            for (int i = 0; i < a.Length; i++)
                for (int j = 0; j < b.Length; j++)
                    result[k++] = (<#=r#>)((<#=r#>)a[i] * (<#=r#>)b[j]);
            return result;
        }

#endregion



<#
            }
        }
    }





    foreach (string a in types)
    {
        foreach (string b in types)
        {
            foreach (string c in types)
            {
                var resultTypes = new HashSet<string>() { a, b, "double", "int" };
                foreach (string r in resultTypes)
                {
#>
<#
                }
            }
        }
    }
#>
    }
}