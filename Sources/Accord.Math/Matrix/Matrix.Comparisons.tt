<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension="Generated.cs" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="System.Text" #>
<#@ include file="T4Toolbox.tt" #>
// Accord Math Library
// The Accord.NET Framework
// http://accord-framework.net
//
// Copyright © César Souza, 2009-2017
// cesarsouza at gmail.com
//
//    This library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    This library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with this library; if not, write to the Free Software
//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
//

// ======================================================================
// This code has been generated by a tool; do not edit manually. Instead,
// edit the T4 template Matrix.Comparisons.tt so this file can be regenerated. 
// ======================================================================

namespace Accord.Math
{
    using System;
    using System.CodeDom.Compiler;
    using Accord.Math;
    using System.Runtime.CompilerServices;

    // [GeneratedCode("Accord.NET T4 Templates", "3.6")]
    public static partial class Matrix
    {
<# 
    string[] types =
    { 
        "Int32", "Int16",
        "Single", "Double", 
        "Int64", "Decimal",
        "Byte", "sbyte", 
    };

    Action<StringBuilder, string, string, string, string> doubleTests = (sb, a, b, A, B) =>
    {
        if ((a == "Double" || a == "Single") && (b == "Double" || b == "Single"))
        {
            sb.AppendLine(String.Format("    if ({0}.IsNaN(A) && {1}.IsNaN(B))", a, b));
            sb.AppendLine("        continue;");
            sb.AppendLine(String.Format("    if ({0}.IsNaN(A) ^ {1}.IsNaN(B))", a, b));
            sb.AppendLine("        return false;");
            sb.AppendLine(String.Format("    if ({0}.IsPositiveInfinity(A) ^ {1}.IsPositiveInfinity(B))", a, b));
            sb.AppendLine("        return false;");
            sb.AppendLine(String.Format("    if ({0}.IsNegativeInfinity(A) ^ {1}.IsNegativeInfinity(B))", a, b));
            sb.AppendLine("        return false;");
        }
        else if (a == "Double" || a == "Single")
        {                   
            sb.AppendLine(String.Format("    if ({0}.IsNaN(A))", a));
            sb.AppendLine("        return false;");
            sb.AppendLine(String.Format("    if ({0}.IsInfinity(A))", a));
            sb.AppendLine("        return false;");
        }
        else if (b == "Double" || b == "Single")
        {                   
            sb.AppendLine(String.Format("    if ({0}.IsNaN(B))", b));
            sb.AppendLine("        return false;");
            sb.AppendLine(String.Format("    if ({0}.IsInfinity(B))", b));
            sb.AppendLine("        return false;");
        }
    };

    Func<string, string, string, string, string> atol = (a, b, A, B) =>
    {
        StringBuilder sb = new StringBuilder();
        sb.AppendLine("{");
        if (a == "Decimal" || b == "Decimal")
        {
            sb.AppendLine(String.Format("    var A = {0};", A));
            sb.AppendLine(String.Format("    var B = {0};", B));
            doubleTests(sb, a, b, A, B);
            sb.AppendLine(String.Format("    decimal C = (decimal)A;", A));
            sb.AppendLine(String.Format("    decimal D = (decimal)B;", B));
            sb.AppendLine("    if (C == D)");
            sb.AppendLine("        continue;");
        }
        else
        {
            sb.AppendLine(String.Format("    var A = {0};", A));
            sb.AppendLine(String.Format("    var B = {0};", B));
            sb.AppendLine("    if (A == B)");
            sb.AppendLine("        continue;");
            doubleTests(sb, a, b, A, B);
            sb.AppendLine(String.Format("    var C = A;", A));
            sb.AppendLine(String.Format("    var D = B;", B));
        }
        sb.AppendLine("    if (Math.Abs(C - D) <= atol)");
        sb.AppendLine("        continue;");
        sb.AppendLine("    return false;");
        sb.AppendLine("}");
        string indent = new String(' ', 4 * 0);
        return indent + sb.ToString().Replace("\n", "\n" + indent);
    };

    Func<string, string, string, string, string> rtol = (a, b, A, B) =>
    {
        StringBuilder sb = new StringBuilder();
        sb.AppendLine("{");
        if (a == "Decimal" || b == "Decimal")
        {
            sb.AppendLine(String.Format("    var A = {0};", A));
            sb.AppendLine(String.Format("    var B = {0};", B));
            doubleTests(sb, a, b, A, B);
            sb.AppendLine(String.Format("    decimal C = (decimal)A;", A));
            sb.AppendLine(String.Format("    decimal D = (decimal)B;", B));
            sb.AppendLine("    if (C == D)");
            sb.AppendLine("        continue;");
        }
        else
        {
            sb.AppendLine(String.Format("    var A = {0};", A));
            sb.AppendLine(String.Format("    var B = {0};", B));
            sb.AppendLine("    if (A == B)");
            sb.AppendLine("        continue;");
            doubleTests(sb, a, b, A, B);
            sb.AppendLine(String.Format("    var C = A;", A));
            sb.AppendLine(String.Format("    var D = B;", B));
        }
        sb.AppendLine("    var delta = Math.Abs(C - D);");
        sb.AppendLine("    if (C == 0)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (delta <= rtol)");
        sb.AppendLine("            continue;");
        sb.AppendLine("    }");
        sb.AppendLine("    else if (D == 0)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (delta <= rtol)");
        sb.AppendLine("            continue;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    if (delta <= Math.Abs(C) * rtol)");
        sb.AppendLine("        continue;");
        sb.AppendLine("    return false;");
        sb.AppendLine("}");
        string indent = new String(' ', 4 * 0);
        return indent + sb.ToString().Replace("\n", "\n" + indent);
    };

    Func<string, string, string, string, string> notol = (a, b, A, B) =>
    {
        StringBuilder sb = new StringBuilder();
        sb.AppendLine("{");
        if (a == "Decimal" || b == "Decimal")
        {
            sb.AppendLine(String.Format("    var A = (decimal){0};", A));
            sb.AppendLine(String.Format("    var B = (decimal){0};", B));
            sb.AppendLine("    if (A != B)");
            sb.AppendLine("        return false;");
        }
        else
        {
            sb.AppendLine(String.Format("    var A = {0};", A));
            sb.AppendLine(String.Format("    var B = {0};", B));
            doubleTests(sb, a, b, A, B);
            sb.AppendLine("    if (A != B)");
            sb.AppendLine("        return false;");
        }
        sb.AppendLine("}");
        string indent = new String(' ', 4 * 0);
        return indent + sb.ToString().Replace("\n", "\n" + indent);
    };

    Func<string, string, string, string, string> reference = (a, b, A, B) =>
    {
        StringBuilder sb = new StringBuilder();
        if (a + A == b + B)
        {
            sb.AppendLine("    if (a == b)");
            sb.AppendLine("        return true;");
        }

        if (!String.IsNullOrEmpty(A) && String.IsNullOrEmpty(B))
        {
            sb.AppendLine("    if (a == null)");
            sb.AppendLine("        return true;");
        }
        else if (String.IsNullOrEmpty(A) && !String.IsNullOrEmpty(B))
        {
            sb.AppendLine("    if (b == null)");
            sb.AppendLine("        return true;");
        }
        else 
        {
            sb.AppendLine("    if (a == null && b == null)");
            sb.AppendLine("        return true;");
            sb.AppendLine("    if (a == null ^ b == null)");
            sb.AppendLine("        return false;");
        }

		if (!String.IsNullOrEmpty(A) && !String.IsNullOrEmpty(B))
		{
			sb.AppendLine("    int[] la = a.GetLength(true);");
			sb.AppendLine("    int[] lb = b.GetLength(true);");
			sb.AppendLine("    if (la.Length != lb.Length)");
			sb.AppendLine("        return false;");
			sb.AppendLine("    for (int i = 0; i < la.Length; i++)");
			sb.AppendLine("        if (la[i] != lb[i])");
			sb.AppendLine("            return false;");
		}

        return sb.ToString();
    };

	Func<string, string, string> symmetric = (a, A) =>
    {
        StringBuilder sb = new StringBuilder();

		sb.AppendLine("    if (!a.IsSquare())");
		sb.AppendLine("        return false;");

        return sb.ToString();
    };

    foreach (string a in types)
    {
        foreach (string b in types)
        {
            string tr = "Double";
            string ta = null;
            if (a == "Decimal" || b == "Decimal")
            {
                ta = "Decimal";
                tr = "Decimal";
            }
            else if (a == "Double" || b == "Double")
                ta = "Double";
            else if (a == "Single" || b == "Single")
                ta = "Single";
            else if (a == "Int64" || b == "Int64")
                ta = "Int64";
            else if (a == "Int32" || b == "Int32")
                ta = "Int32";
            else if (a == "Int16" || b == "Int16")
                ta = "Int16";
            else if (a == "Byte" || b == "Byte")
                ta = "Byte";
            else if (a == "sbyte" || b == "sbyte")
                ta = "byte";

#>
        /// <summary>
        ///   Determines whether two vectors contain the same values.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static bool IsEqual(this <#=a#>[] a, <#=b#>[] b, <#=ta#> atol = 0, <#=tr#> rtol = 0)
        {
<#=reference(a, b, "[]", "[]")#>
            if (rtol > 0)
            {
                for (int i = 0; i < a.Length; i++)
<#=rtol(a, b, "a[i]", "b[i]")#>
            }
            else if (atol > 0)
            {
                for (int i = 0; i < a.Length; i++)
<#=atol(a, b, "a[i]", "b[i]")#>
            }
            else
            {
                for (int i = 0; i < a.Length; i++)
<#=notol(a, b, "a[i]", "b[i]")#>
            }

            return true;
        }

        /// <summary>
        ///   Determines whether two matrices contain the same values.
        /// </summary>
        ///
#if NET45 || NET46 || NET462 || NETSTANDARD
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static bool IsEqual(this <#=a#>[,] a, <#=b#>[,] b, <#=ta#> atol = 0, <#=tr#> rtol = 0)
        {
<#=reference(a, b, "[,]", "[,]")#>
            unsafe
            {
                fixed (<#=a#>* ptrA = a)
                fixed (<#=b#>* ptrB = b)
                {
                    if (rtol > 0)
                    {
                        for (int i = 0; i < a.Length; i++)
<#=rtol(a, b, "ptrA[i]", "ptrB[i]")#>
                    }
                    else if (atol > 0)
                    {
                        for (int i = 0; i < a.Length; i++)
<#=atol(a, b, "ptrA[i]", "ptrB[i]")#>
                    }
                    else
                    {
                        for (int i = 0; i < a.Length; i++)
<#=notol(a, b, "ptrA[i]", "ptrB[i]")#>
                    }
                }
            }

            return true;
        }

        /// <summary>
        ///   Determines whether two matrices contain the same values.
        /// </summary>
        ///
#if NET45 || NET46 || NET462 || NETSTANDARD
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static bool IsEqual(this <#=a#>[,] a, <#=b#>[][] b, <#=ta#> atol = 0, <#=tr#> rtol = 0)
        {
<#=reference(a, b, "[,]", "[][]")#>
            if (rtol > 0)
            {
                for (int i = 0; i < b.Length; i++)
                    for (int j = 0; j < b[i].Length; j++)
<#=rtol(a, b, "a[i, j]", "b[i][j]")#>
            }
            else if (atol > 0)
            {
                for (int i = 0; i < b.Length; i++)
                    for (int j = 0; j < b[i].Length; j++)
<#=atol(a, b, "a[i, j]", "b[i][j]")#>
            }
            else
            {
                for (int i = 0; i < b.Length; i++)
                    for (int j = 0; j < b[i].Length; j++)
<#=notol(a, b, "a[i, j]", "b[i][j]")#>
            }

            return true;
        }

        /// <summary>
        ///   Determines whether two matrices contain the same values.
        /// </summary>
        ///
#if NET45 || NET46 || NET462 || NETSTANDARD
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static bool IsEqual(this <#=a#>[][] a, <#=b#>[,] b, <#=ta#> atol = 0, <#=tr#> rtol = 0)
        {
<#=reference(a, b, "[][]", "[,]")#>
            if (rtol > 0)
            {
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
<#=rtol(a, b, "a[i][j]", "b[i, j]")#>
            }
            else if (atol > 0)
            {
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
<#=atol(a, b, "a[i][j]", "b[i, j]")#>
            }
            else
            {
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
<#=notol(a, b, "a[i][j]", "b[i, j]")#>
            }

            return true;
        }

        /// <summary>
        ///   Determines whether two matrices contain the same values.
        /// </summary>
        ///
#if NET45 || NET46 || NET462 || NETSTANDARD
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static bool IsEqual(this <#=a#>[][] a, <#=b#>[][] b, <#=ta#> atol = 0, <#=tr#> rtol = 0)
        {
<#=reference(a, b, "[][]", "[][]")#>
            if (rtol > 0)
            {
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
<#=rtol(a, b, "a[i][j]", "b[i][j]")#>
            }
            else if (atol > 0)
            {
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
<#=atol(a, b, "a[i][j]", "b[i][j]")#>
            }
            else
            {
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
<#=notol(a, b, "a[i][j]", "b[i][j]")#>
            }

            return true;
        }










        /// <summary>
        ///   Determines whether two vectors contain the same values.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static bool IsEqual(this <#=a#>[] a, <#=b#> b, <#=ta#> atol = 0, <#=tr#> rtol = 0)
        {
<#=reference(a, b, "[]", "")#>
            if (rtol > 0)
            {
                for (int i = 0; i < a.Length; i++)
<#=rtol(a, b, "a[i]", "b")#>
            }
            else if (atol > 0)
            {
                for (int i = 0; i < a.Length; i++)
<#=atol(a, b, "a[i]", "b")#>
            }
            else
            {
                for (int i = 0; i < a.Length; i++)
<#=notol(a, b, "a[i]", "b")#>
            }

            return true;
        }

        /// <summary>
        ///   Determines whether two matrices contain the same values.
        /// </summary>
        ///
#if NET45 || NET46 || NET462 || NETSTANDARD
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static bool IsEqual(this <#=a#>[,] a, <#=b#> b, <#=ta#> atol = 0, <#=tr#> rtol = 0)
        {
<#=reference(a, b, "[,]", "")#>
            unsafe
            {
                fixed (<#=a#>* ptrA = a)
                {
                    if (rtol > 0)
                    {
                        for (int i = 0; i < a.Length; i++)
<#=rtol(a, b, "ptrA[i]", "b")#>
                    }
                    else if (atol > 0)
                    {
                        for (int i = 0; i < a.Length; i++)
<#=atol(a, b, "ptrA[i]", "b")#>
                    }
                    else
                    {
                        for (int i = 0; i < a.Length; i++)
<#=notol(a, b, "ptrA[i]", "b")#>
                    }
                }
            }

            return true;
        }

        /// <summary>
        ///   Determines whether two matrices contain the same values.
        /// </summary>
        ///
#if NET45 || NET46 || NET462 || NETSTANDARD
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static bool IsEqual(this <#=a#>[][] a, <#=b#> b, <#=ta#> atol = 0, <#=tr#> rtol = 0)
        {
<#=reference(a, b, "[][]", "")#>
            if (rtol > 0)
            {
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
<#=rtol(a, b, "a[i][j]", "b")#>

            }
            else if (atol > 0)
            {
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
<#=atol(a, b, "a[i][j]", "b")#>
            }
            else
            {
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
<#=notol(a, b, "a[i][j]", "b")#>
            }

            return true;
        }



















        /// <summary>
        ///   Determines whether two vectors contain the same values.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static bool IsEqual(this <#=a#> a, <#=b#>[] b, <#=ta#> atol = 0, <#=tr#> rtol = 0)
        {
            return IsEqual(b, a, rtol, atol);
        }

        /// <summary>
        ///   Determines whether two matrices contain the same values.
        /// </summary>
        ///
#if NET45 || NET46 || NET462 || NETSTANDARD
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static bool IsEqual(this <#=a#> a, <#=b#>[,] b, <#=ta#> atol = 0, <#=tr#> rtol = 0)
        {
            return IsEqual(b, a, rtol, atol);
        }

        /// <summary>
        ///   Determines whether two matrices contain the same values.
        /// </summary>
        ///
#if NET45 || NET46 || NET462 || NETSTANDARD
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static bool IsEqual(this <#=a#> a, <#=b#>[][] b, <#=ta#> atol = 0, <#=tr#> rtol = 0)
        {
            return IsEqual(b, a, rtol, atol);
        }








       /// <summary>
        ///   Determines whether two vectors contain the same values.
        /// </summary>
        /// 
#if NET45 || NET46 || NET462 || NETSTANDARD
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static bool IsEqual(this <#=a#> a, <#=b#> b, <#=ta#> atol = 0, <#=tr#> rtol = 0)
        {
            if (rtol > 0)
            {
<#=rtol(a, b, "a", "b").Replace("continue;","return true;")#>
            }
            else if (atol > 0)
            {
<#=atol(a, b, "a", "b").Replace("continue;","return true;")#>
            }
            else
            {
<#=notol(a, b, "a", "b").Replace("continue;","return true;")#>
            }

            return true;
        }








<#
        }
    }

    foreach (string a in types)
    {
        string tr = "Double";
        string ta = null;
        if (a == "Decimal")
        {
            ta = "Decimal";
            tr = "Decimal";
        }
        else if (a == "Double")
            ta = "Double";
        else if (a == "Single")
            ta = "Single";
        else if (a == "Int64")
            ta = "Int64";
        else if (a == "Int32")
            ta = "Int32";
        else if (a == "Int16")
            ta = "Int16";
        else if (a == "Byte")
            ta = "Byte";
        else if (a == "sbyte")
            ta = "byte";
#>

		/// <summary>
        ///   Determines a matrix is symmetric.
        /// </summary>
        ///
#if NET45 || NET46 || NET462 || NETSTANDARD
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static bool IsSymmetric(this <#=a#>[][] a, <#=ta#> atol = 0, <#=tr#> rtol = 0)
        {
<#=symmetric(a, "[][]")#>
            if (rtol > 0)
            {
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
<#=rtol(a, a, "a[i][j]", "a[j][i]")#>
            }
            else if (atol > 0)
            {
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
<#=atol(a, a, "a[i][j]", "a[j][i]")#>
            }
            else
            {
                for (int i = 0; i < a.Length; i++)
                    for (int j = 0; j < a[i].Length; j++)
<#=notol(a, a, "a[i][j]", "a[j][i]")#>
            }

            return true;
        }

		/// <summary>
        ///   Determines a matrix is symmetric.
        /// </summary>
        ///
#if NET45 || NET46 || NET462 || NETSTANDARD
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public static bool IsSymmetric(this <#=a#>[,] a, <#=ta#> atol = 0, <#=tr#> rtol = 0)
        {
<#=symmetric(a, "[,]")#>
            if (rtol > 0)
            {
                for (int i = 0; i < a.Rows(); i++)
                    for (int j = 0; j < i; j++)
<#=rtol(a, a, "a[i, j]", "a[j, i]")#>
            }
            else if (atol > 0)
            {
                for (int i = 0; i < a.Rows(); i++)
                    for (int j = 0; j < i; j++)
<#=atol(a, a, "a[i, j]", "a[j, i]")#>
            }
            else
            {
                for (int i = 0; i < a.Rows(); i++)
                    for (int j = 0; j < i; j++)
<#=notol(a, a, "a[i, j]", "a[j, i]")#>
            }

            return true;
        }



<#
    }
#>
    }
}