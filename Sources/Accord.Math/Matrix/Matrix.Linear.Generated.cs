// Accord Math Library
// The Accord.NET Framework
// http://accord-framework.net
//
// Copyright © César Souza, 2009-2016
// cesarsouza at gmail.com
//
//    This library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    This library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with this library; if not, write to the Free Software
//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
//

// ======================================================================
// This code has been generated by a tool; do not edit manually. Instead,
// edit the T4 template Matrix.Elementwise.tt so this file can be regenerated. 
// ======================================================================

namespace Accord.Math
{
    using System;
    using System.CodeDom.Compiler;
    using Accord.Math;
    using System.Runtime.CompilerServices;
    using Accord.Math.Decompositions;

    //[GeneratedCode("Accord.NET T4 Templates", "3.1")]
    public static partial class Matrix
    {

        /// <summary>
        ///   Returns the solution matrix if the matrix is square or the least squares solution otherwise.
        /// </summary>
        /// 
        /// <param name="matrix">The matrix for the linear problem.</param>
        /// <param name="rightSide">The right side <c>b</c>.</param>
        /// <param name="leastSquares">True to produce a solution even if the 
        ///   <paramref name="matrix"/> is singular; false otherwise. Default is false.</param>
        /// 
        /// <remarks>
        ///   Please note that this does not check if the matrix is non-singular
        ///   before attempting to solve. If a least squares solution is desired
        ///   in case the matrix is singular, pass true to the <paramref name="leastSquares"/>
        ///   parameter when calling this function.
        /// </remarks>
        /// 
        /// <example>
        /// <code>
        /// // Create a matrix. Please note that this matrix
        /// // is singular (i.e. not invertible), so only a 
        /// // least squares solution would be feasible here.
        /// 
        /// double[,] matrix = 
        /// {
        ///     { 1, 2, 3 },
        ///     { 4, 5, 6 },
        ///     { 7, 8, 9 },
        /// };
        /// 
        /// // Define a right side matrix b:
        /// double[,] rightSide = { {1}, {2}, {3} };
        /// 
        /// // Solve the linear system Ax = b by finding x:
        /// double[,] x = Matrix.Solve(matrix, rightSide, leastSquares: true);
        /// 
        /// // The answer should be { {-1/18}, {2/18}, {5/18} }.
        /// </code>
        /// </example>
        /// 
        public static double[,] Solve(this double[,] matrix, double[,] rightSide, bool leastSquares = false)
        {
            int rows = matrix.GetLength(0);
            int cols = matrix.GetLength(1);

            if (rows != rightSide.GetLength(0))
                throw new DimensionMismatchException("rightSide",
                    "The number of rows in the right hand side matrix must be "
                    + "equal to the number of rows in the problem matrix.");

            if (leastSquares)
            {
                return new SingularValueDecomposition(matrix,
                       computeLeftSingularVectors: true,
                       computeRightSingularVectors: true,
                       autoTranspose: true).Solve(rightSide);
            }


            if (rows == cols)
            {
                // Solve by LU Decomposition if matrix is square.
                return new LuDecomposition(matrix).Solve(rightSide);
            }
            else
            {
                if (cols < rows)
                {
                    // Solve by QR Decomposition if not.
                    return new QrDecomposition(matrix).Solve(rightSide);
                }
                else
                {
                    return new SingularValueDecomposition(matrix,
                        computeLeftSingularVectors: true,
                        computeRightSingularVectors: true,
                        autoTranspose: true).Solve(rightSide);
                }
            }
        }

        /// <summary>
        ///   Returns the solution matrix if the matrix is square or the least squares solution otherwise.
        /// </summary>
        /// 
        /// <param name="matrix">The matrix for the linear problem.</param>
        /// <param name="rightSide">The right side <c>b</c>.</param>
        /// <param name="leastSquares">True to produce a solution even if the 
        ///   <paramref name="matrix"/> is singular; false otherwise. Default is false.</param>
        /// 
        /// <remarks>
        ///   Please note that this does not check if the matrix is non-singular
        ///   before attempting to solve. If a least squares solution is desired
        ///   in case the matrix is singular, pass true to the <paramref name="leastSquares"/>
        ///   parameter when calling this function.
        /// </remarks>
        /// 
        /// <example>
        /// <code>
        /// // Create a matrix. Please note that this matrix
        /// // is singular (i.e. not invertible), so only a 
        /// // least squares solution would be feasible here.
        /// 
        /// double[,] matrix = 
        /// {
        ///     { 1, 2, 3 },
        ///     { 4, 5, 6 },
        ///     { 7, 8, 9 },
        /// };
        /// 
        /// // Define a right side vector b:
        /// double[] rightSide = { 1, 2, 3 };
        /// 
        /// // Solve the linear system Ax = b by finding x:
        /// double[] x = Matrix.Solve(matrix, rightSide, leastSquares: true);
        /// 
        /// // The answer should be { -1/18, 2/18, 5/18 }.
        /// </code>
        /// </example>
        /// 
        public static double[] Solve(this double[,] matrix, double[] rightSide, bool leastSquares = false)
        {
            if (matrix == null)
                throw new ArgumentNullException("matrix");

            if (rightSide == null)
                throw new ArgumentNullException("rightSide");

            int rows = matrix.GetLength(0);
            int cols = matrix.GetLength(1);

            if (rows != rightSide.Length)
                throw new DimensionMismatchException("rightSide",
                    "The right hand side vector must have the same length"
                     + "as there are rows of the problem matrix.");

            if (leastSquares)
            {
                return new SingularValueDecomposition(matrix,
                      computeLeftSingularVectors: true,
                      computeRightSingularVectors: true,
                      autoTranspose: true).Solve(rightSide);
            }


            if (rows == cols)
            {
                // Solve by LU Decomposition if matrix is square.
                return new LuDecomposition(matrix).Solve(rightSide);
            }
            else
            {
                if (cols < rows)
                {
                    // Solve by QR Decomposition if not.
                    return new QrDecomposition(matrix).Solve(rightSide);
                }
                else
                {
                    return new SingularValueDecomposition(matrix,
                        computeLeftSingularVectors: true,
                        computeRightSingularVectors: true,
                        autoTranspose: true).Solve(rightSide);
                }
            }
        }

        /// <summary>
        ///   Computes the inverse of a matrix.
        /// </summary>
        /// 
        public static double[,] Inverse(this double[,] matrix)
        {
            return Inverse(matrix, false);
        }

        /// <summary>
        ///   Computes the inverse of a matrix.
        /// </summary>
        /// 
        public static double[,] Inverse(this double[,] matrix, bool inPlace)
        {
            int rows = matrix.GetLength(0);
            int cols = matrix.GetLength(1);

            if (rows != cols)
                throw new ArgumentException("Matrix must be square", "matrix");

            if (rows == 3)
            {
                // Special case for 3x3 matrices
                double a = matrix[0, 0], b = matrix[0, 1], c = matrix[0, 2];
                double d = matrix[1, 0], e = matrix[1, 1], f = matrix[1, 2];
                double g = matrix[2, 0], h = matrix[2, 1], i = matrix[2, 2];

                double den = a * (e * i - f * h) -
                             b * (d * i - f * g) +
                             c * (d * h - e * g);

                if (den == 0)
                    throw new SingularMatrixException();

                double m = 1 / den;

                var inv = (inPlace) ? matrix : new double[3, 3];
                inv[0, 0] = m * (e * i - f * h);
                inv[0, 1] = m * (c * h - b * i);
                inv[0, 2] = m * (b * f - c * e);
                inv[1, 0] = m * (f * g - d * i);
                inv[1, 1] = m * (a * i - c * g);
                inv[1, 2] = m * (c * d - a * f);
                inv[2, 0] = m * (d * h - e * g);
                inv[2, 1] = m * (b * g - a * h);
                inv[2, 2] = m * (a * e - b * d);

                return inv;
            }

            if (rows == 2)
            {
                // Special case for 2x2 matrices
                double a = matrix[0, 0], b = matrix[0, 1];
                double c = matrix[1, 0], d = matrix[1, 1];

                double den = a * d - b * c;

                if (den == 0)
                    throw new SingularMatrixException();

                double m = 1 / den;

                var inv = (inPlace) ? matrix : new double[2, 2];
                inv[0, 0] = +m * d;
                inv[0, 1] = -m * b;
                inv[1, 0] = -m * c;
                inv[1, 1] = +m * a;

                return inv;
            }

            return new LuDecomposition(matrix, false, inPlace).Inverse();
        }

        /// <summary>
        ///   Computes the pseudo-inverse of a matrix.
        /// </summary>
        /// 
        public static double[,] PseudoInverse(this double[,] matrix)
        {
            return new SingularValueDecomposition(matrix,
                computeLeftSingularVectors: true,
                computeRightSingularVectors: true,
                autoTranspose: true).Inverse();
        }


        /// <summary>
        ///   Returns the solution matrix if the matrix is square or the least squares solution otherwise.
        /// </summary>
        /// 
        /// <param name="matrix">The matrix for the linear problem.</param>
        /// <param name="rightSide">The right side <c>b</c>.</param>
        /// <param name="leastSquares">True to produce a solution even if the 
        ///   <paramref name="matrix"/> is singular; false otherwise. Default is false.</param>
        /// 
        /// <remarks>
        ///   Please note that this does not check if the matrix is non-singular
        ///   before attempting to solve. If a least squares solution is desired
        ///   in case the matrix is singular, pass true to the <paramref name="leastSquares"/>
        ///   parameter when calling this function.
        /// </remarks>
        /// 
        /// <example>
        /// <code>
        /// // Create a matrix. Please note that this matrix
        /// // is singular (i.e. not invertible), so only a 
        /// // least squares solution would be feasible here.
        /// 
        /// double[,] matrix = 
        /// {
        ///     { 1, 2, 3 },
        ///     { 4, 5, 6 },
        ///     { 7, 8, 9 },
        /// };
        /// 
        /// // Define a right side matrix b:
        /// double[,] rightSide = { {1}, {2}, {3} };
        /// 
        /// // Solve the linear system Ax = b by finding x:
        /// double[,] x = Matrix.Solve(matrix, rightSide, leastSquares: true);
        /// 
        /// // The answer should be { {-1/18}, {2/18}, {5/18} }.
        /// </code>
        /// </example>
        /// 
        public static double[][] Solve(this double[][] matrix, double[][] rightSide, bool leastSquares = false)
        {
            if (matrix.Length != rightSide[0].Length)
            {
                throw new DimensionMismatchException("rightSide",
                    "The number of rows in the right hand side matrix must be "
                    + "equal to the number of rows in the problem matrix.");
            }

            return matrix.Decompose(leastSquares).Solve(rightSide);
        }

        /// <summary>
        ///   Returns the solution matrix if the matrix is square or the least squares solution otherwise.
        /// </summary>
        /// 
        /// <param name="matrix">The matrix for the linear problem.</param>
        /// <param name="rightSide">The right side <c>b</c>.</param>
        /// <param name="leastSquares">True to produce a solution even if the 
        ///   <paramref name="matrix"/> is singular; false otherwise. Default is false.</param>
        /// 
        /// <remarks>
        ///   Please note that this does not check if the matrix is non-singular
        ///   before attempting to solve. If a least squares solution is desired
        ///   in case the matrix is singular, pass true to the <paramref name="leastSquares"/>
        ///   parameter when calling this function.
        /// </remarks>
        /// 
        /// <example>
        /// <code>
        /// // Create a matrix. Please note that this matrix
        /// // is singular (i.e. not invertible), so only a 
        /// // least squares solution would be feasible here.
        /// 
        /// double[,] matrix = 
        /// {
        ///     { 1, 2, 3 },
        ///     { 4, 5, 6 },
        ///     { 7, 8, 9 },
        /// };
        /// 
        /// // Define a right side vector b:
        /// double[] rightSide = { 1, 2, 3 };
        /// 
        /// // Solve the linear system Ax = b by finding x:
        /// double[] x = Matrix.Solve(matrix, rightSide, leastSquares: true);
        /// 
        /// // The answer should be { -1/18, 2/18, 5/18 }.
        /// </code>
        /// </example>
        /// 
        public static double[] Solve(this double[][] matrix, double[] rightSide, bool leastSquares = false)
        {
            if (matrix.Length != rightSide.Length)
            {
                throw new DimensionMismatchException("rightSide",
                    "The right hand side vector must have the same length"
                     + "as there are rows of the problem matrix.");
            }

            return matrix.Decompose(leastSquares).Solve(rightSide);
        }


        /// <summary>
        ///   Creates a matrix decomposition that be used to compute the solution matrix if the 
        ///   matrix is square or the least squares solution otherwise.
        /// </summary>
        /// 
        public static ISolverMatrixDecomposition<double> Decompose(this double[,] matrix, bool leastSquares = false)
        {
            int rows = matrix.Rows();
            int cols = matrix.Columns();

            if (leastSquares)
            {
                return new SingularValueDecomposition(matrix,
                       computeLeftSingularVectors: true,
                       computeRightSingularVectors: true,
                       autoTranspose: true);
            }

            if (rows == cols)
            {
                // Solve by LU Decomposition if matrix is square.
                return new LuDecomposition(matrix);
            }
            else
            {
                if (cols < rows)
                {
                    // Solve by QR Decomposition if not.
                    return new QrDecomposition(matrix);
                }
                else
                {
                    return new SingularValueDecomposition(matrix,
                        computeLeftSingularVectors: true,
                        computeRightSingularVectors: true,
                        autoTranspose: true);
                }
            }
        }

        /// <summary>
        ///   Creates a matrix decomposition that be used to compute the solution matrix if the 
        ///   matrix is square or the least squares solution otherwise.
        /// </summary>
        /// 
        public static ISolverArrayDecomposition<double> Decompose(this double[][] matrix, bool leastSquares = false)
        {
            int rows = matrix.Rows();
            int cols = matrix.Columns();

            if (leastSquares)
            {
                return new JaggedSingularValueDecomposition(matrix,
                      computeLeftSingularVectors: true,
                      computeRightSingularVectors: true,
                      autoTranspose: true);
            }

            if (rows == cols)
            {
                // Solve by LU Decomposition if matrix is square.
                return new JaggedLuDecomposition(matrix);
            }
            else
            {
                if (cols < rows)
                {
                    // Solve by QR Decomposition if not.
                    return new JaggedQrDecomposition(matrix);
                }
                else
                {
                    return new JaggedSingularValueDecomposition(matrix,
                        computeLeftSingularVectors: true,
                        computeRightSingularVectors: true,
                        autoTranspose: true);
                }
            }
        }

        /// <summary>
        ///   Computes the inverse of a matrix.
        /// </summary>
        /// 
        public static double[][] Inverse(this double[][] matrix)
        {
            return Inverse(matrix, false);
        }

        /// <summary>
        ///   Computes the inverse of a matrix.
        /// </summary>
        /// 
        public static double[][] Inverse(this double[][] matrix, bool inPlace)
        {
            int rows = matrix.Length;
            int cols = matrix[0].Length;

            if (rows != cols)
                throw new ArgumentException("Matrix must be square", "matrix");

            if (rows == 3)
            {
                // Special case for 3x3 matrices
                double a = matrix[0][0], b = matrix[0][1], c = matrix[0][2];
                double d = matrix[1][0], e = matrix[1][1], f = matrix[1][2];
                double g = matrix[2][0], h = matrix[2][1], i = matrix[2][2];

                double den = a * (e * i - f * h) -
                             b * (d * i - f * g) +
                             c * (d * h - e * g);

                if (den == 0)
                    throw new SingularMatrixException();

                double m = 1 / den;

                var inv = matrix;
                if (!inPlace)
                {
                    inv = new double[3][];
                    for (int j = 0; j < inv.Length; j++)
                        inv[j] = new double[3];
                }

                inv[0][0] = m * (e * i - f * h);
                inv[0][1] = m * (c * h - b * i);
                inv[0][2] = m * (b * f - c * e);
                inv[1][0] = m * (f * g - d * i);
                inv[1][1] = m * (a * i - c * g);
                inv[1][2] = m * (c * d - a * f);
                inv[2][0] = m * (d * h - e * g);
                inv[2][1] = m * (b * g - a * h);
                inv[2][2] = m * (a * e - b * d);

                return inv;
            }

            if (rows == 2)
            {
                // Special case for 2x2 matrices
                double a = matrix[0][0], b = matrix[0][1];
                double c = matrix[1][0], d = matrix[1][1];

                double den = a * d - b * c;

                if (den == 0)
                    throw new SingularMatrixException();

                double m = 1 / den;

                var inv = matrix;
                if (!inPlace)
                {
                    inv = new double[2][];
                    for (int j = 0; j < inv.Length; j++)
                        inv[j] = new double[2];
                }

                inv[0][0] = +m * d;
                inv[0][1] = -m * b;
                inv[1][0] = -m * c;
                inv[1][1] = +m * a;

                return inv;
            }

            return new JaggedLuDecomposition(matrix, false, inPlace).Inverse();
        }

        /// <summary>
        ///   Computes the pseudo-inverse of a matrix.
        /// </summary>
        /// 
        public static double[][] PseudoInverse(this double[][] matrix)
        {
            return new JaggedSingularValueDecomposition(matrix,
                computeLeftSingularVectors: true,
                computeRightSingularVectors: true,
                autoTranspose: true).Inverse();
        }

        /// <summary>
        ///   Divides two matrices by multiplying A by the inverse of B.
        /// </summary>
        /// 
        /// <param name="a">The first matrix.</param>
        /// <param name="b">The second matrix (which will be inverted).</param>
        /// <param name="leastSquares">True to produce a solution even if the 
        ///   <paramref name="b"/> is singular; false otherwise. Default is false.</param>
        /// 
        /// <returns>The result from the division <c>AB^-1</c> of the given matrices.</returns>
        /// 
        public static double[,] Divide(this double[,] a, double[,] b, bool leastSquares = false)
        {
            int rows = b.Rows();
            int cols = b.Columns();

            if (leastSquares)
            {
                return new SingularValueDecomposition(b.Transpose(),
                       computeLeftSingularVectors: true,
                       computeRightSingularVectors: true,
                       autoTranspose: true).Solve(a.Transpose()).Transpose();
            }


            if (rows == cols && cols == a.Rows())
            {
                // Solve by LU Decomposition if matrix is square.
                return new LuDecomposition(b, true).SolveTranspose(a);
            }
            else
            {
                if (rows <= cols)
                {
                    // Solve by QR Decomposition if not.
                    return new QrDecomposition(b, true).SolveTranspose(a);
                }
                else
                {
                    return new SingularValueDecomposition(b.Transpose(),
                        computeLeftSingularVectors: true,
                        computeRightSingularVectors: true,
                        autoTranspose: true).Solve(a.Transpose()).Transpose();
                }
            }
        }

        /// <summary>
        ///   Divides two matrices by multiplying A by the inverse of B.
        /// </summary>
        /// 
        /// <param name="a">The first matrix.</param>
        /// <param name="b">The second matrix (which will be inverted).</param>
        /// <param name="leastSquares">True to produce a solution even if the 
        ///   <paramref name="b"/> is singular; false otherwise. Default is false.</param>
        /// 
        /// <returns>The result from the division <c>AB^-1</c> of the given matrices.</returns>
        /// 
        public static double[][] Divide(this double[][] a, double[][] b, bool leastSquares = false)
        {
            int rows = b.Rows();
            int cols = b.Columns();

            if (leastSquares)
            {
                return new JaggedSingularValueDecomposition(b.Transpose(),
                       computeLeftSingularVectors: true,
                       computeRightSingularVectors: true,
                       autoTranspose: true).Solve(a.Transpose()).Transpose();
            }


            if (rows == cols && cols == a.Rows())
            {
                // Solve by LU Decomposition if matrix is square.
                return new JaggedLuDecomposition(b, true).SolveTranspose(a);
            }
            else
            {
                if (rows <= cols)
                {
                    // Solve by QR Decomposition if not.
                    return new JaggedQrDecomposition(b, true).SolveTranspose(a);
                }
                else
                {
                    return new JaggedSingularValueDecomposition(b.Transpose(),
                        computeLeftSingularVectors: true,
                        computeRightSingularVectors: true,
                        autoTranspose: true).Solve(a.Transpose()).Transpose();
                }
            }
        }

        /// <summary>
        ///   Returns the solution matrix if the matrix is square or the least squares solution otherwise.
        /// </summary>
        /// 
        /// <param name="matrix">The matrix for the linear problem.</param>
        /// <param name="rightSide">The right side <c>b</c>.</param>
        /// <param name="leastSquares">True to produce a solution even if the 
        ///   <paramref name="matrix"/> is singular; false otherwise. Default is false.</param>
        /// 
        /// <remarks>
        ///   Please note that this does not check if the matrix is non-singular
        ///   before attempting to solve. If a least squares solution is desired
        ///   in case the matrix is singular, pass true to the <paramref name="leastSquares"/>
        ///   parameter when calling this function.
        /// </remarks>
        /// 
        /// <example>
        /// <code>
        /// // Create a matrix. Please note that this matrix
        /// // is singular (i.e. not invertible), so only a 
        /// // least squares solution would be feasible here.
        /// 
        /// float[,] matrix = 
        /// {
        ///     { 1, 2, 3 },
        ///     { 4, 5, 6 },
        ///     { 7, 8, 9 },
        /// };
        /// 
        /// // Define a right side matrix b:
        /// float[,] rightSide = { {1}, {2}, {3} };
        /// 
        /// // Solve the linear system Ax = b by finding x:
        /// float[,] x = Matrix.Solve(matrix, rightSide, leastSquares: true);
        /// 
        /// // The answer should be { {-1/18}, {2/18}, {5/18} }.
        /// </code>
        /// </example>
        /// 
        public static float[,] Solve(this float[,] matrix, float[,] rightSide, bool leastSquares = false)
        {
            int rows = matrix.GetLength(0);
            int cols = matrix.GetLength(1);

            if (rows != rightSide.GetLength(0))
                throw new DimensionMismatchException("rightSide",
                    "The number of rows in the right hand side matrix must be "
                    + "equal to the number of rows in the problem matrix.");

            if (leastSquares)
            {
                return new SingularValueDecompositionF(matrix,
                       computeLeftSingularVectors: true,
                       computeRightSingularVectors: true,
                       autoTranspose: true).Solve(rightSide);
            }


            if (rows == cols)
            {
                // Solve by LU Decomposition if matrix is square.
                return new LuDecompositionF(matrix).Solve(rightSide);
            }
            else
            {
                if (cols < rows)
                {
                    // Solve by QR Decomposition if not.
                    return new QrDecompositionF(matrix).Solve(rightSide);
                }
                else
                {
                    return new SingularValueDecompositionF(matrix,
                        computeLeftSingularVectors: true,
                        computeRightSingularVectors: true,
                        autoTranspose: true).Solve(rightSide);
                }
            }
        }

        /// <summary>
        ///   Returns the solution matrix if the matrix is square or the least squares solution otherwise.
        /// </summary>
        /// 
        /// <param name="matrix">The matrix for the linear problem.</param>
        /// <param name="rightSide">The right side <c>b</c>.</param>
        /// <param name="leastSquares">True to produce a solution even if the 
        ///   <paramref name="matrix"/> is singular; false otherwise. Default is false.</param>
        /// 
        /// <remarks>
        ///   Please note that this does not check if the matrix is non-singular
        ///   before attempting to solve. If a least squares solution is desired
        ///   in case the matrix is singular, pass true to the <paramref name="leastSquares"/>
        ///   parameter when calling this function.
        /// </remarks>
        /// 
        /// <example>
        /// <code>
        /// // Create a matrix. Please note that this matrix
        /// // is singular (i.e. not invertible), so only a 
        /// // least squares solution would be feasible here.
        /// 
        /// float[,] matrix = 
        /// {
        ///     { 1, 2, 3 },
        ///     { 4, 5, 6 },
        ///     { 7, 8, 9 },
        /// };
        /// 
        /// // Define a right side vector b:
        /// float[] rightSide = { 1, 2, 3 };
        /// 
        /// // Solve the linear system Ax = b by finding x:
        /// float[] x = Matrix.Solve(matrix, rightSide, leastSquares: true);
        /// 
        /// // The answer should be { -1/18, 2/18, 5/18 }.
        /// </code>
        /// </example>
        /// 
        public static float[] Solve(this float[,] matrix, float[] rightSide, bool leastSquares = false)
        {
            if (matrix == null)
                throw new ArgumentNullException("matrix");

            if (rightSide == null)
                throw new ArgumentNullException("rightSide");

            int rows = matrix.GetLength(0);
            int cols = matrix.GetLength(1);

            if (rows != rightSide.Length)
                throw new DimensionMismatchException("rightSide",
                    "The right hand side vector must have the same length"
                     + "as there are rows of the problem matrix.");

            if (leastSquares)
            {
                return new SingularValueDecompositionF(matrix,
                      computeLeftSingularVectors: true,
                      computeRightSingularVectors: true,
                      autoTranspose: true).Solve(rightSide);
            }


            if (rows == cols)
            {
                // Solve by LU Decomposition if matrix is square.
                return new LuDecompositionF(matrix).Solve(rightSide);
            }
            else
            {
                if (cols < rows)
                {
                    // Solve by QR Decomposition if not.
                    return new QrDecompositionF(matrix).Solve(rightSide);
                }
                else
                {
                    return new SingularValueDecompositionF(matrix,
                        computeLeftSingularVectors: true,
                        computeRightSingularVectors: true,
                        autoTranspose: true).Solve(rightSide);
                }
            }
        }

        /// <summary>
        ///   Computes the inverse of a matrix.
        /// </summary>
        /// 
        public static float[,] Inverse(this float[,] matrix)
        {
            return Inverse(matrix, false);
        }

        /// <summary>
        ///   Computes the inverse of a matrix.
        /// </summary>
        /// 
        public static float[,] Inverse(this float[,] matrix, bool inPlace)
        {
            int rows = matrix.GetLength(0);
            int cols = matrix.GetLength(1);

            if (rows != cols)
                throw new ArgumentException("Matrix must be square", "matrix");

            if (rows == 3)
            {
                // Special case for 3x3 matrices
                float a = matrix[0, 0], b = matrix[0, 1], c = matrix[0, 2];
                float d = matrix[1, 0], e = matrix[1, 1], f = matrix[1, 2];
                float g = matrix[2, 0], h = matrix[2, 1], i = matrix[2, 2];

                float den = a * (e * i - f * h) -
                             b * (d * i - f * g) +
                             c * (d * h - e * g);

                if (den == 0)
                    throw new SingularMatrixException();

                float m = 1 / den;

                var inv = (inPlace) ? matrix : new float[3, 3];
                inv[0, 0] = m * (e * i - f * h);
                inv[0, 1] = m * (c * h - b * i);
                inv[0, 2] = m * (b * f - c * e);
                inv[1, 0] = m * (f * g - d * i);
                inv[1, 1] = m * (a * i - c * g);
                inv[1, 2] = m * (c * d - a * f);
                inv[2, 0] = m * (d * h - e * g);
                inv[2, 1] = m * (b * g - a * h);
                inv[2, 2] = m * (a * e - b * d);

                return inv;
            }

            if (rows == 2)
            {
                // Special case for 2x2 matrices
                float a = matrix[0, 0], b = matrix[0, 1];
                float c = matrix[1, 0], d = matrix[1, 1];

                float den = a * d - b * c;

                if (den == 0)
                    throw new SingularMatrixException();

                float m = 1 / den;

                var inv = (inPlace) ? matrix : new float[2, 2];
                inv[0, 0] = +m * d;
                inv[0, 1] = -m * b;
                inv[1, 0] = -m * c;
                inv[1, 1] = +m * a;

                return inv;
            }

            return new LuDecompositionF(matrix, false, inPlace).Inverse();
        }

        /// <summary>
        ///   Computes the pseudo-inverse of a matrix.
        /// </summary>
        /// 
        public static float[,] PseudoInverse(this float[,] matrix)
        {
            return new SingularValueDecompositionF(matrix,
                computeLeftSingularVectors: true,
                computeRightSingularVectors: true,
                autoTranspose: true).Inverse();
        }


        /// <summary>
        ///   Returns the solution matrix if the matrix is square or the least squares solution otherwise.
        /// </summary>
        /// 
        /// <param name="matrix">The matrix for the linear problem.</param>
        /// <param name="rightSide">The right side <c>b</c>.</param>
        /// <param name="leastSquares">True to produce a solution even if the 
        ///   <paramref name="matrix"/> is singular; false otherwise. Default is false.</param>
        /// 
        /// <remarks>
        ///   Please note that this does not check if the matrix is non-singular
        ///   before attempting to solve. If a least squares solution is desired
        ///   in case the matrix is singular, pass true to the <paramref name="leastSquares"/>
        ///   parameter when calling this function.
        /// </remarks>
        /// 
        /// <example>
        /// <code>
        /// // Create a matrix. Please note that this matrix
        /// // is singular (i.e. not invertible), so only a 
        /// // least squares solution would be feasible here.
        /// 
        /// float[,] matrix = 
        /// {
        ///     { 1, 2, 3 },
        ///     { 4, 5, 6 },
        ///     { 7, 8, 9 },
        /// };
        /// 
        /// // Define a right side matrix b:
        /// float[,] rightSide = { {1}, {2}, {3} };
        /// 
        /// // Solve the linear system Ax = b by finding x:
        /// float[,] x = Matrix.Solve(matrix, rightSide, leastSquares: true);
        /// 
        /// // The answer should be { {-1/18}, {2/18}, {5/18} }.
        /// </code>
        /// </example>
        /// 
        public static float[][] Solve(this float[][] matrix, float[][] rightSide, bool leastSquares = false)
        {
            if (matrix.Length != rightSide[0].Length)
            {
                throw new DimensionMismatchException("rightSide",
                    "The number of rows in the right hand side matrix must be "
                    + "equal to the number of rows in the problem matrix.");
            }

            return matrix.Decompose(leastSquares).Solve(rightSide);
        }

        /// <summary>
        ///   Returns the solution matrix if the matrix is square or the least squares solution otherwise.
        /// </summary>
        /// 
        /// <param name="matrix">The matrix for the linear problem.</param>
        /// <param name="rightSide">The right side <c>b</c>.</param>
        /// <param name="leastSquares">True to produce a solution even if the 
        ///   <paramref name="matrix"/> is singular; false otherwise. Default is false.</param>
        /// 
        /// <remarks>
        ///   Please note that this does not check if the matrix is non-singular
        ///   before attempting to solve. If a least squares solution is desired
        ///   in case the matrix is singular, pass true to the <paramref name="leastSquares"/>
        ///   parameter when calling this function.
        /// </remarks>
        /// 
        /// <example>
        /// <code>
        /// // Create a matrix. Please note that this matrix
        /// // is singular (i.e. not invertible), so only a 
        /// // least squares solution would be feasible here.
        /// 
        /// float[,] matrix = 
        /// {
        ///     { 1, 2, 3 },
        ///     { 4, 5, 6 },
        ///     { 7, 8, 9 },
        /// };
        /// 
        /// // Define a right side vector b:
        /// float[] rightSide = { 1, 2, 3 };
        /// 
        /// // Solve the linear system Ax = b by finding x:
        /// float[] x = Matrix.Solve(matrix, rightSide, leastSquares: true);
        /// 
        /// // The answer should be { -1/18, 2/18, 5/18 }.
        /// </code>
        /// </example>
        /// 
        public static float[] Solve(this float[][] matrix, float[] rightSide, bool leastSquares = false)
        {
            if (matrix.Length != rightSide.Length)
            {
                throw new DimensionMismatchException("rightSide",
                    "The right hand side vector must have the same length"
                     + "as there are rows of the problem matrix.");
            }

            return matrix.Decompose(leastSquares).Solve(rightSide);
        }


        /// <summary>
        ///   Creates a matrix decomposition that be used to compute the solution matrix if the 
        ///   matrix is square or the least squares solution otherwise.
        /// </summary>
        /// 
        public static ISolverMatrixDecomposition<float> Decompose(this float[,] matrix, bool leastSquares = false)
        {
            int rows = matrix.Rows();
            int cols = matrix.Columns();

            if (leastSquares)
            {
                return new SingularValueDecompositionF(matrix,
                       computeLeftSingularVectors: true,
                       computeRightSingularVectors: true,
                       autoTranspose: true);
            }

            if (rows == cols)
            {
                // Solve by LU Decomposition if matrix is square.
                return new LuDecompositionF(matrix);
            }
            else
            {
                if (cols < rows)
                {
                    // Solve by QR Decomposition if not.
                    return new QrDecompositionF(matrix);
                }
                else
                {
                    return new SingularValueDecompositionF(matrix,
                        computeLeftSingularVectors: true,
                        computeRightSingularVectors: true,
                        autoTranspose: true);
                }
            }
        }

        /// <summary>
        ///   Creates a matrix decomposition that be used to compute the solution matrix if the 
        ///   matrix is square or the least squares solution otherwise.
        /// </summary>
        /// 
        public static ISolverArrayDecomposition<float> Decompose(this float[][] matrix, bool leastSquares = false)
        {
            int rows = matrix.Rows();
            int cols = matrix.Columns();

            if (leastSquares)
            {
                return new JaggedSingularValueDecompositionF(matrix,
                      computeLeftSingularVectors: true,
                      computeRightSingularVectors: true,
                      autoTranspose: true);
            }

            if (rows == cols)
            {
                // Solve by LU Decomposition if matrix is square.
                return new JaggedLuDecompositionF(matrix);
            }
            else
            {
                if (cols < rows)
                {
                    // Solve by QR Decomposition if not.
                    return new JaggedQrDecompositionF(matrix);
                }
                else
                {
                    return new JaggedSingularValueDecompositionF(matrix,
                        computeLeftSingularVectors: true,
                        computeRightSingularVectors: true,
                        autoTranspose: true);
                }
            }
        }

        /// <summary>
        ///   Computes the inverse of a matrix.
        /// </summary>
        /// 
        public static float[][] Inverse(this float[][] matrix)
        {
            return Inverse(matrix, false);
        }

        /// <summary>
        ///   Computes the inverse of a matrix.
        /// </summary>
        /// 
        public static float[][] Inverse(this float[][] matrix, bool inPlace)
        {
            int rows = matrix.Length;
            int cols = matrix[0].Length;

            if (rows != cols)
                throw new ArgumentException("Matrix must be square", "matrix");

            if (rows == 3)
            {
                // Special case for 3x3 matrices
                float a = matrix[0][0], b = matrix[0][1], c = matrix[0][2];
                float d = matrix[1][0], e = matrix[1][1], f = matrix[1][2];
                float g = matrix[2][0], h = matrix[2][1], i = matrix[2][2];

                float den = a * (e * i - f * h) -
                             b * (d * i - f * g) +
                             c * (d * h - e * g);

                if (den == 0)
                    throw new SingularMatrixException();

                float m = 1 / den;

                var inv = matrix;
                if (!inPlace)
                {
                    inv = new float[3][];
                    for (int j = 0; j < inv.Length; j++)
                        inv[j] = new float[3];
                }

                inv[0][0] = m * (e * i - f * h);
                inv[0][1] = m * (c * h - b * i);
                inv[0][2] = m * (b * f - c * e);
                inv[1][0] = m * (f * g - d * i);
                inv[1][1] = m * (a * i - c * g);
                inv[1][2] = m * (c * d - a * f);
                inv[2][0] = m * (d * h - e * g);
                inv[2][1] = m * (b * g - a * h);
                inv[2][2] = m * (a * e - b * d);

                return inv;
            }

            if (rows == 2)
            {
                // Special case for 2x2 matrices
                float a = matrix[0][0], b = matrix[0][1];
                float c = matrix[1][0], d = matrix[1][1];

                float den = a * d - b * c;

                if (den == 0)
                    throw new SingularMatrixException();

                float m = 1 / den;

                var inv = matrix;
                if (!inPlace)
                {
                    inv = new float[2][];
                    for (int j = 0; j < inv.Length; j++)
                        inv[j] = new float[2];
                }

                inv[0][0] = +m * d;
                inv[0][1] = -m * b;
                inv[1][0] = -m * c;
                inv[1][1] = +m * a;

                return inv;
            }

            return new JaggedLuDecompositionF(matrix, false, inPlace).Inverse();
        }

        /// <summary>
        ///   Computes the pseudo-inverse of a matrix.
        /// </summary>
        /// 
        public static float[][] PseudoInverse(this float[][] matrix)
        {
            return new JaggedSingularValueDecompositionF(matrix,
                computeLeftSingularVectors: true,
                computeRightSingularVectors: true,
                autoTranspose: true).Inverse();
        }

        /// <summary>
        ///   Divides two matrices by multiplying A by the inverse of B.
        /// </summary>
        /// 
        /// <param name="a">The first matrix.</param>
        /// <param name="b">The second matrix (which will be inverted).</param>
        /// <param name="leastSquares">True to produce a solution even if the 
        ///   <paramref name="b"/> is singular; false otherwise. Default is false.</param>
        /// 
        /// <returns>The result from the division <c>AB^-1</c> of the given matrices.</returns>
        /// 
        public static float[,] Divide(this float[,] a, float[,] b, bool leastSquares = false)
        {
            int rows = b.Rows();
            int cols = b.Columns();

            if (leastSquares)
            {
                return new SingularValueDecompositionF(b.Transpose(),
                       computeLeftSingularVectors: true,
                       computeRightSingularVectors: true,
                       autoTranspose: true).Solve(a.Transpose()).Transpose();
            }


            if (rows == cols && cols == a.Rows())
            {
                // Solve by LU Decomposition if matrix is square.
                return new LuDecompositionF(b, true).SolveTranspose(a);
            }
            else
            {
                if (rows <= cols)
                {
                    // Solve by QR Decomposition if not.
                    return new QrDecompositionF(b, true).SolveTranspose(a);
                }
                else
                {
                    return new SingularValueDecompositionF(b.Transpose(),
                        computeLeftSingularVectors: true,
                        computeRightSingularVectors: true,
                        autoTranspose: true).Solve(a.Transpose()).Transpose();
                }
            }
        }

        /// <summary>
        ///   Divides two matrices by multiplying A by the inverse of B.
        /// </summary>
        /// 
        /// <param name="a">The first matrix.</param>
        /// <param name="b">The second matrix (which will be inverted).</param>
        /// <param name="leastSquares">True to produce a solution even if the 
        ///   <paramref name="b"/> is singular; false otherwise. Default is false.</param>
        /// 
        /// <returns>The result from the division <c>AB^-1</c> of the given matrices.</returns>
        /// 
        public static float[][] Divide(this float[][] a, float[][] b, bool leastSquares = false)
        {
            int rows = b.Rows();
            int cols = b.Columns();

            if (leastSquares)
            {
                return new JaggedSingularValueDecompositionF(b.Transpose(),
                       computeLeftSingularVectors: true,
                       computeRightSingularVectors: true,
                       autoTranspose: true).Solve(a.Transpose()).Transpose();
            }


            if (rows == cols && cols == a.Rows())
            {
                // Solve by LU Decomposition if matrix is square.
                return new JaggedLuDecompositionF(b, true).SolveTranspose(a);
            }
            else
            {
                if (rows <= cols)
                {
                    // Solve by QR Decomposition if not.
                    return new JaggedQrDecompositionF(b, true).SolveTranspose(a);
                }
                else
                {
                    return new JaggedSingularValueDecompositionF(b.Transpose(),
                        computeLeftSingularVectors: true,
                        computeRightSingularVectors: true,
                        autoTranspose: true).Solve(a.Transpose()).Transpose();
                }
            }
        }

        /// <summary>
        ///   Returns the solution matrix if the matrix is square or the least squares solution otherwise.
        /// </summary>
        /// 
        /// <param name="matrix">The matrix for the linear problem.</param>
        /// <param name="rightSide">The right side <c>b</c>.</param>
        /// <param name="leastSquares">True to produce a solution even if the 
        ///   <paramref name="matrix"/> is singular; false otherwise. Default is false.</param>
        /// 
        /// <remarks>
        ///   Please note that this does not check if the matrix is non-singular
        ///   before attempting to solve. If a least squares solution is desired
        ///   in case the matrix is singular, pass true to the <paramref name="leastSquares"/>
        ///   parameter when calling this function.
        /// </remarks>
        /// 
        /// <example>
        /// <code>
        /// // Create a matrix. Please note that this matrix
        /// // is singular (i.e. not invertible), so only a 
        /// // least squares solution would be feasible here.
        /// 
        /// decimal[,] matrix = 
        /// {
        ///     { 1, 2, 3 },
        ///     { 4, 5, 6 },
        ///     { 7, 8, 9 },
        /// };
        /// 
        /// // Define a right side matrix b:
        /// decimal[,] rightSide = { {1}, {2}, {3} };
        /// 
        /// // Solve the linear system Ax = b by finding x:
        /// decimal[,] x = Matrix.Solve(matrix, rightSide, leastSquares: true);
        /// 
        /// // The answer should be { {-1/18}, {2/18}, {5/18} }.
        /// </code>
        /// </example>
        /// 
        public static decimal[,] Solve(this decimal[,] matrix, decimal[,] rightSide, bool leastSquares = false)
        {
            int rows = matrix.GetLength(0);
            int cols = matrix.GetLength(1);

            if (rows != rightSide.GetLength(0))
                throw new DimensionMismatchException("rightSide",
                    "The number of rows in the right hand side matrix must be "
                    + "equal to the number of rows in the problem matrix.");

            if (leastSquares)
            {
                return new SingularValueDecompositionD(matrix,
                       computeLeftSingularVectors: true,
                       computeRightSingularVectors: true,
                       autoTranspose: true).Solve(rightSide);
            }


            if (rows == cols)
            {
                // Solve by LU Decomposition if matrix is square.
                return new LuDecompositionD(matrix).Solve(rightSide);
            }
            else
            {
                if (cols < rows)
                {
                    // Solve by QR Decomposition if not.
                    return new QrDecompositionD(matrix).Solve(rightSide);
                }
                else
                {
                    return new SingularValueDecompositionD(matrix,
                        computeLeftSingularVectors: true,
                        computeRightSingularVectors: true,
                        autoTranspose: true).Solve(rightSide);
                }
            }
        }

        /// <summary>
        ///   Returns the solution matrix if the matrix is square or the least squares solution otherwise.
        /// </summary>
        /// 
        /// <param name="matrix">The matrix for the linear problem.</param>
        /// <param name="rightSide">The right side <c>b</c>.</param>
        /// <param name="leastSquares">True to produce a solution even if the 
        ///   <paramref name="matrix"/> is singular; false otherwise. Default is false.</param>
        /// 
        /// <remarks>
        ///   Please note that this does not check if the matrix is non-singular
        ///   before attempting to solve. If a least squares solution is desired
        ///   in case the matrix is singular, pass true to the <paramref name="leastSquares"/>
        ///   parameter when calling this function.
        /// </remarks>
        /// 
        /// <example>
        /// <code>
        /// // Create a matrix. Please note that this matrix
        /// // is singular (i.e. not invertible), so only a 
        /// // least squares solution would be feasible here.
        /// 
        /// decimal[,] matrix = 
        /// {
        ///     { 1, 2, 3 },
        ///     { 4, 5, 6 },
        ///     { 7, 8, 9 },
        /// };
        /// 
        /// // Define a right side vector b:
        /// decimal[] rightSide = { 1, 2, 3 };
        /// 
        /// // Solve the linear system Ax = b by finding x:
        /// decimal[] x = Matrix.Solve(matrix, rightSide, leastSquares: true);
        /// 
        /// // The answer should be { -1/18, 2/18, 5/18 }.
        /// </code>
        /// </example>
        /// 
        public static decimal[] Solve(this decimal[,] matrix, decimal[] rightSide, bool leastSquares = false)
        {
            if (matrix == null)
                throw new ArgumentNullException("matrix");

            if (rightSide == null)
                throw new ArgumentNullException("rightSide");

            int rows = matrix.GetLength(0);
            int cols = matrix.GetLength(1);

            if (rows != rightSide.Length)
                throw new DimensionMismatchException("rightSide",
                    "The right hand side vector must have the same length"
                     + "as there are rows of the problem matrix.");

            if (leastSquares)
            {
                return new SingularValueDecompositionD(matrix,
                      computeLeftSingularVectors: true,
                      computeRightSingularVectors: true,
                      autoTranspose: true).Solve(rightSide);
            }


            if (rows == cols)
            {
                // Solve by LU Decomposition if matrix is square.
                return new LuDecompositionD(matrix).Solve(rightSide);
            }
            else
            {
                if (cols < rows)
                {
                    // Solve by QR Decomposition if not.
                    return new QrDecompositionD(matrix).Solve(rightSide);
                }
                else
                {
                    return new SingularValueDecompositionD(matrix,
                        computeLeftSingularVectors: true,
                        computeRightSingularVectors: true,
                        autoTranspose: true).Solve(rightSide);
                }
            }
        }

        /// <summary>
        ///   Computes the inverse of a matrix.
        /// </summary>
        /// 
        public static decimal[,] Inverse(this decimal[,] matrix)
        {
            return Inverse(matrix, false);
        }

        /// <summary>
        ///   Computes the inverse of a matrix.
        /// </summary>
        /// 
        public static decimal[,] Inverse(this decimal[,] matrix, bool inPlace)
        {
            int rows = matrix.GetLength(0);
            int cols = matrix.GetLength(1);

            if (rows != cols)
                throw new ArgumentException("Matrix must be square", "matrix");

            if (rows == 3)
            {
                // Special case for 3x3 matrices
                decimal a = matrix[0, 0], b = matrix[0, 1], c = matrix[0, 2];
                decimal d = matrix[1, 0], e = matrix[1, 1], f = matrix[1, 2];
                decimal g = matrix[2, 0], h = matrix[2, 1], i = matrix[2, 2];

                decimal den = a * (e * i - f * h) -
                             b * (d * i - f * g) +
                             c * (d * h - e * g);

                if (den == 0)
                    throw new SingularMatrixException();

                decimal m = 1 / den;

                var inv = (inPlace) ? matrix : new decimal[3, 3];
                inv[0, 0] = m * (e * i - f * h);
                inv[0, 1] = m * (c * h - b * i);
                inv[0, 2] = m * (b * f - c * e);
                inv[1, 0] = m * (f * g - d * i);
                inv[1, 1] = m * (a * i - c * g);
                inv[1, 2] = m * (c * d - a * f);
                inv[2, 0] = m * (d * h - e * g);
                inv[2, 1] = m * (b * g - a * h);
                inv[2, 2] = m * (a * e - b * d);

                return inv;
            }

            if (rows == 2)
            {
                // Special case for 2x2 matrices
                decimal a = matrix[0, 0], b = matrix[0, 1];
                decimal c = matrix[1, 0], d = matrix[1, 1];

                decimal den = a * d - b * c;

                if (den == 0)
                    throw new SingularMatrixException();

                decimal m = 1 / den;

                var inv = (inPlace) ? matrix : new decimal[2, 2];
                inv[0, 0] = +m * d;
                inv[0, 1] = -m * b;
                inv[1, 0] = -m * c;
                inv[1, 1] = +m * a;

                return inv;
            }

            return new LuDecompositionD(matrix, false, inPlace).Inverse();
        }

        /// <summary>
        ///   Computes the pseudo-inverse of a matrix.
        /// </summary>
        /// 
        public static decimal[,] PseudoInverse(this decimal[,] matrix)
        {
            return new SingularValueDecompositionD(matrix,
                computeLeftSingularVectors: true,
                computeRightSingularVectors: true,
                autoTranspose: true).Inverse();
        }


        /// <summary>
        ///   Returns the solution matrix if the matrix is square or the least squares solution otherwise.
        /// </summary>
        /// 
        /// <param name="matrix">The matrix for the linear problem.</param>
        /// <param name="rightSide">The right side <c>b</c>.</param>
        /// <param name="leastSquares">True to produce a solution even if the 
        ///   <paramref name="matrix"/> is singular; false otherwise. Default is false.</param>
        /// 
        /// <remarks>
        ///   Please note that this does not check if the matrix is non-singular
        ///   before attempting to solve. If a least squares solution is desired
        ///   in case the matrix is singular, pass true to the <paramref name="leastSquares"/>
        ///   parameter when calling this function.
        /// </remarks>
        /// 
        /// <example>
        /// <code>
        /// // Create a matrix. Please note that this matrix
        /// // is singular (i.e. not invertible), so only a 
        /// // least squares solution would be feasible here.
        /// 
        /// decimal[,] matrix = 
        /// {
        ///     { 1, 2, 3 },
        ///     { 4, 5, 6 },
        ///     { 7, 8, 9 },
        /// };
        /// 
        /// // Define a right side matrix b:
        /// decimal[,] rightSide = { {1}, {2}, {3} };
        /// 
        /// // Solve the linear system Ax = b by finding x:
        /// decimal[,] x = Matrix.Solve(matrix, rightSide, leastSquares: true);
        /// 
        /// // The answer should be { {-1/18}, {2/18}, {5/18} }.
        /// </code>
        /// </example>
        /// 
        public static decimal[][] Solve(this decimal[][] matrix, decimal[][] rightSide, bool leastSquares = false)
        {
            if (matrix.Length != rightSide[0].Length)
            {
                throw new DimensionMismatchException("rightSide",
                    "The number of rows in the right hand side matrix must be "
                    + "equal to the number of rows in the problem matrix.");
            }

            return matrix.Decompose(leastSquares).Solve(rightSide);
        }

        /// <summary>
        ///   Returns the solution matrix if the matrix is square or the least squares solution otherwise.
        /// </summary>
        /// 
        /// <param name="matrix">The matrix for the linear problem.</param>
        /// <param name="rightSide">The right side <c>b</c>.</param>
        /// <param name="leastSquares">True to produce a solution even if the 
        ///   <paramref name="matrix"/> is singular; false otherwise. Default is false.</param>
        /// 
        /// <remarks>
        ///   Please note that this does not check if the matrix is non-singular
        ///   before attempting to solve. If a least squares solution is desired
        ///   in case the matrix is singular, pass true to the <paramref name="leastSquares"/>
        ///   parameter when calling this function.
        /// </remarks>
        /// 
        /// <example>
        /// <code>
        /// // Create a matrix. Please note that this matrix
        /// // is singular (i.e. not invertible), so only a 
        /// // least squares solution would be feasible here.
        /// 
        /// decimal[,] matrix = 
        /// {
        ///     { 1, 2, 3 },
        ///     { 4, 5, 6 },
        ///     { 7, 8, 9 },
        /// };
        /// 
        /// // Define a right side vector b:
        /// decimal[] rightSide = { 1, 2, 3 };
        /// 
        /// // Solve the linear system Ax = b by finding x:
        /// decimal[] x = Matrix.Solve(matrix, rightSide, leastSquares: true);
        /// 
        /// // The answer should be { -1/18, 2/18, 5/18 }.
        /// </code>
        /// </example>
        /// 
        public static decimal[] Solve(this decimal[][] matrix, decimal[] rightSide, bool leastSquares = false)
        {
            if (matrix.Length != rightSide.Length)
            {
                throw new DimensionMismatchException("rightSide",
                    "The right hand side vector must have the same length"
                     + "as there are rows of the problem matrix.");
            }

            return matrix.Decompose(leastSquares).Solve(rightSide);
        }


        /// <summary>
        ///   Creates a matrix decomposition that be used to compute the solution matrix if the 
        ///   matrix is square or the least squares solution otherwise.
        /// </summary>
        /// 
        public static ISolverMatrixDecomposition<decimal> Decompose(this decimal[,] matrix, bool leastSquares = false)
        {
            int rows = matrix.Rows();
            int cols = matrix.Columns();

            if (leastSquares)
            {
                return new SingularValueDecompositionD(matrix,
                       computeLeftSingularVectors: true,
                       computeRightSingularVectors: true,
                       autoTranspose: true);
            }

            if (rows == cols)
            {
                // Solve by LU Decomposition if matrix is square.
                return new LuDecompositionD(matrix);
            }
            else
            {
                if (cols < rows)
                {
                    // Solve by QR Decomposition if not.
                    return new QrDecompositionD(matrix);
                }
                else
                {
                    return new SingularValueDecompositionD(matrix,
                        computeLeftSingularVectors: true,
                        computeRightSingularVectors: true,
                        autoTranspose: true);
                }
            }
        }

        /// <summary>
        ///   Creates a matrix decomposition that be used to compute the solution matrix if the 
        ///   matrix is square or the least squares solution otherwise.
        /// </summary>
        /// 
        public static ISolverArrayDecomposition<decimal> Decompose(this decimal[][] matrix, bool leastSquares = false)
        {
            int rows = matrix.Rows();
            int cols = matrix.Columns();

            if (leastSquares)
            {
                return new JaggedSingularValueDecompositionD(matrix,
                      computeLeftSingularVectors: true,
                      computeRightSingularVectors: true,
                      autoTranspose: true);
            }

            if (rows == cols)
            {
                // Solve by LU Decomposition if matrix is square.
                return new JaggedLuDecompositionD(matrix);
            }
            else
            {
                if (cols < rows)
                {
                    // Solve by QR Decomposition if not.
                    return new JaggedQrDecompositionD(matrix);
                }
                else
                {
                    return new JaggedSingularValueDecompositionD(matrix,
                        computeLeftSingularVectors: true,
                        computeRightSingularVectors: true,
                        autoTranspose: true);
                }
            }
        }

        /// <summary>
        ///   Computes the inverse of a matrix.
        /// </summary>
        /// 
        public static decimal[][] Inverse(this decimal[][] matrix)
        {
            return Inverse(matrix, false);
        }

        /// <summary>
        ///   Computes the inverse of a matrix.
        /// </summary>
        /// 
        public static decimal[][] Inverse(this decimal[][] matrix, bool inPlace)
        {
            int rows = matrix.Length;
            int cols = matrix[0].Length;

            if (rows != cols)
                throw new ArgumentException("Matrix must be square", "matrix");

            if (rows == 3)
            {
                // Special case for 3x3 matrices
                decimal a = matrix[0][0], b = matrix[0][1], c = matrix[0][2];
                decimal d = matrix[1][0], e = matrix[1][1], f = matrix[1][2];
                decimal g = matrix[2][0], h = matrix[2][1], i = matrix[2][2];

                decimal den = a * (e * i - f * h) -
                             b * (d * i - f * g) +
                             c * (d * h - e * g);

                if (den == 0)
                    throw new SingularMatrixException();

                decimal m = 1 / den;

                var inv = matrix;
                if (!inPlace)
                {
                    inv = new decimal[3][];
                    for (int j = 0; j < inv.Length; j++)
                        inv[j] = new decimal[3];
                }

                inv[0][0] = m * (e * i - f * h);
                inv[0][1] = m * (c * h - b * i);
                inv[0][2] = m * (b * f - c * e);
                inv[1][0] = m * (f * g - d * i);
                inv[1][1] = m * (a * i - c * g);
                inv[1][2] = m * (c * d - a * f);
                inv[2][0] = m * (d * h - e * g);
                inv[2][1] = m * (b * g - a * h);
                inv[2][2] = m * (a * e - b * d);

                return inv;
            }

            if (rows == 2)
            {
                // Special case for 2x2 matrices
                decimal a = matrix[0][0], b = matrix[0][1];
                decimal c = matrix[1][0], d = matrix[1][1];

                decimal den = a * d - b * c;

                if (den == 0)
                    throw new SingularMatrixException();

                decimal m = 1 / den;

                var inv = matrix;
                if (!inPlace)
                {
                    inv = new decimal[2][];
                    for (int j = 0; j < inv.Length; j++)
                        inv[j] = new decimal[2];
                }

                inv[0][0] = +m * d;
                inv[0][1] = -m * b;
                inv[1][0] = -m * c;
                inv[1][1] = +m * a;

                return inv;
            }

            return new JaggedLuDecompositionD(matrix, false, inPlace).Inverse();
        }

        /// <summary>
        ///   Computes the pseudo-inverse of a matrix.
        /// </summary>
        /// 
        public static decimal[][] PseudoInverse(this decimal[][] matrix)
        {
            return new JaggedSingularValueDecompositionD(matrix,
                computeLeftSingularVectors: true,
                computeRightSingularVectors: true,
                autoTranspose: true).Inverse();
        }

        /// <summary>
        ///   Divides two matrices by multiplying A by the inverse of B.
        /// </summary>
        /// 
        /// <param name="a">The first matrix.</param>
        /// <param name="b">The second matrix (which will be inverted).</param>
        /// <param name="leastSquares">True to produce a solution even if the 
        ///   <paramref name="b"/> is singular; false otherwise. Default is false.</param>
        /// 
        /// <returns>The result from the division <c>AB^-1</c> of the given matrices.</returns>
        /// 
        public static decimal[,] Divide(this decimal[,] a, decimal[,] b, bool leastSquares = false)
        {
            int rows = b.Rows();
            int cols = b.Columns();

            if (leastSquares)
            {
                return new SingularValueDecompositionD(b.Transpose(),
                       computeLeftSingularVectors: true,
                       computeRightSingularVectors: true,
                       autoTranspose: true).Solve(a.Transpose()).Transpose();
            }


            if (rows == cols && cols == a.Rows())
            {
                // Solve by LU Decomposition if matrix is square.
                return new LuDecompositionD(b, true).SolveTranspose(a);
            }
            else
            {
                if (rows <= cols)
                {
                    // Solve by QR Decomposition if not.
                    return new QrDecompositionD(b, true).SolveTranspose(a);
                }
                else
                {
                    return new SingularValueDecompositionD(b.Transpose(),
                        computeLeftSingularVectors: true,
                        computeRightSingularVectors: true,
                        autoTranspose: true).Solve(a.Transpose()).Transpose();
                }
            }
        }

        /// <summary>
        ///   Divides two matrices by multiplying A by the inverse of B.
        /// </summary>
        /// 
        /// <param name="a">The first matrix.</param>
        /// <param name="b">The second matrix (which will be inverted).</param>
        /// <param name="leastSquares">True to produce a solution even if the 
        ///   <paramref name="b"/> is singular; false otherwise. Default is false.</param>
        /// 
        /// <returns>The result from the division <c>AB^-1</c> of the given matrices.</returns>
        /// 
        public static decimal[][] Divide(this decimal[][] a, decimal[][] b, bool leastSquares = false)
        {
            int rows = b.Rows();
            int cols = b.Columns();

            if (leastSquares)
            {
                return new JaggedSingularValueDecompositionD(b.Transpose(),
                       computeLeftSingularVectors: true,
                       computeRightSingularVectors: true,
                       autoTranspose: true).Solve(a.Transpose()).Transpose();
            }


            if (rows == cols && cols == a.Rows())
            {
                // Solve by LU Decomposition if matrix is square.
                return new JaggedLuDecompositionD(b, true).SolveTranspose(a);
            }
            else
            {
                if (rows <= cols)
                {
                    // Solve by QR Decomposition if not.
                    return new JaggedQrDecompositionD(b, true).SolveTranspose(a);
                }
                else
                {
                    return new JaggedSingularValueDecompositionD(b.Transpose(),
                        computeLeftSingularVectors: true,
                        computeRightSingularVectors: true,
                        autoTranspose: true).Solve(a.Transpose()).Transpose();
                }
            }
        }
    }
}