// Accord Math Library
// The Accord.NET Framework
// http://accord-framework.net
//
// Copyright © César Souza, 2009-2017
// cesarsouza at gmail.com
//
//    This library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    This library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with this library; if not, write to the Free Software
//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
//

// ======================================================================
// This code has been generated by a tool; do not edit manually. Instead,
// edit the T4 template Vector.Range.tt so this file can be regenerated. 
// ======================================================================


namespace Accord.Math
{
    using System;
	using System.Collections.Generic;
    using Accord.Math;

    public static partial class Vector
    {

        /// <summary>
        ///   Creates a range vector.
        /// </summary>
        /// 
        public static int[] Range(int n)
        {
            int[] r = new int[(int)n]; 
            for (int i = 0; i < r.Length; i++)
                r[i] = (int)i;
            return r;
        }

        /// <summary>
        ///   Creates a range vector.
        /// </summary>
        /// 
        public static int[] Range(int a, int b)
        {
            if (a == b)
                return new [] { a };

            int[] r;

            if (b > a)
            {
                r = new int[(int)(b - a)];
                for (int i = 0; i < r.Length; i++)
                    r[i] = (int)(a++);
            }
            else
            {
                r = new int[(int)(a - b)];
                for (int i = 0; i < r.Length; i++)
                    r[i] = (int)(a-- - 1);
            }

            return r;
        }

        /// <summary>
        ///   Creates an interval vector.
        /// </summary>
        /// 
        public static int[] Range(int a, int b, double stepSize)
        {
            if (a == b)
                return new [] { a };

            int[] r;

            if (b > a)
            {
                int steps = (int)System.Math.Ceiling((b - a) / (double)stepSize);
                r = new int[steps];
                for (uint i = 0; i < r.Length; i++)
                    r[i] = (int)(a +  i * stepSize);
                r[steps - 1] = (int)(b);
            }
            else
            {
                int steps = (int)System.Math.Ceiling((a - b) / (double)stepSize);
                r = new int[steps];
                for (uint i = 0; i < r.Length; i++)
                    r[i] = (int)(a - i * stepSize);
                r[steps - 1] = (int)(b);
            }

            return r;
        }




		/// <summary>
        ///   Creates a range enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<int> EnumerableRange(int n)
        {
            for (int i = 0; i < n; i++)
                yield return (int)i;
        }

        /// <summary>
        ///   Creates a range enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<int> EnumerableRange(int a, int b)
        {
            if (a == b)
                yield return a;

            if (b > a)
            {
                int n = (int)(b - a);
                for (int i = 0; i < n; i++)
                    yield return (int)(a++);
            }
            else
            {
                int n = (int)(a - b);
                for (int i = 0; i < n; i++)
                    yield return (int)(a-- - 1);
            }
        }

        /// <summary>
        ///   Creates an interval enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<int> EnumerableRange(int a, int b, double stepSize)
        {
            if (a == b)
                yield return a;

            if (b > a)
            {
                int steps = (int)System.Math.Ceiling((b - a) / (double)stepSize);
                for (uint i = 0; i < steps; i++)
                    yield return (int)(a +  i * stepSize);
                yield return (int)(b);
            }
            else
            {
                int steps = (int)System.Math.Ceiling((a - b) / (double)stepSize);
                for (uint i = 0; i < steps; i++)
                    yield return (int)(a - i * stepSize);
                yield return (int)(b);
            }
        }

        /// <summary>
        ///   Creates a range vector.
        /// </summary>
        /// 
        public static float[] Range(float n)
        {
            float[] r = new float[(int)n]; 
            for (int i = 0; i < r.Length; i++)
                r[i] = (float)i;
            return r;
        }

        /// <summary>
        ///   Creates a range vector.
        /// </summary>
        /// 
        public static float[] Range(float a, float b)
        {
            if (a == b)
                return new [] { a };

            float[] r;

            if (b > a)
            {
                r = new float[(int)(b - a)];
                for (int i = 0; i < r.Length; i++)
                    r[i] = (float)(a++);
            }
            else
            {
                r = new float[(int)(a - b)];
                for (int i = 0; i < r.Length; i++)
                    r[i] = (float)(a-- - 1);
            }

            return r;
        }

        /// <summary>
        ///   Creates an interval vector.
        /// </summary>
        /// 
        public static float[] Range(float a, float b, float stepSize)
        {
            if (a == b)
                return new [] { a };

            float[] r;

            if (b > a)
            {
                int steps = (int)System.Math.Ceiling((b - a) / (double)stepSize);
                r = new float[steps];
                for (uint i = 0; i < r.Length; i++)
                    r[i] = (float)(a +  i * stepSize);
                r[steps - 1] = (float)(b);
            }
            else
            {
                int steps = (int)System.Math.Ceiling((a - b) / (double)stepSize);
                r = new float[steps];
                for (uint i = 0; i < r.Length; i++)
                    r[i] = (float)(a - i * stepSize);
                r[steps - 1] = (float)(b);
            }

            return r;
        }




		/// <summary>
        ///   Creates a range enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<float> EnumerableRange(float n)
        {
            for (float i = 0; i < n; i++)
                yield return (float)i;
        }

        /// <summary>
        ///   Creates a range enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<float> EnumerableRange(float a, float b)
        {
            if (a == b)
                yield return a;

            if (b > a)
            {
                int n = (int)(b - a);
                for (int i = 0; i < n; i++)
                    yield return (float)(a++);
            }
            else
            {
                int n = (int)(a - b);
                for (int i = 0; i < n; i++)
                    yield return (float)(a-- - 1);
            }
        }

        /// <summary>
        ///   Creates an interval enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<float> EnumerableRange(float a, float b, float stepSize)
        {
            if (a == b)
                yield return a;

            if (b > a)
            {
                int steps = (int)System.Math.Ceiling((b - a) / (double)stepSize);
                for (uint i = 0; i < steps; i++)
                    yield return (float)(a +  i * stepSize);
                yield return (float)(b);
            }
            else
            {
                int steps = (int)System.Math.Ceiling((a - b) / (double)stepSize);
                for (uint i = 0; i < steps; i++)
                    yield return (float)(a - i * stepSize);
                yield return (float)(b);
            }
        }

        /// <summary>
        ///   Creates a range vector.
        /// </summary>
        /// 
        public static double[] Range(double n)
        {
            double[] r = new double[(int)n]; 
            for (int i = 0; i < r.Length; i++)
                r[i] = (double)i;
            return r;
        }

        /// <summary>
        ///   Creates a range vector.
        /// </summary>
        /// 
        public static double[] Range(double a, double b)
        {
            if (a == b)
                return new [] { a };

            double[] r;

            if (b > a)
            {
                r = new double[(int)(b - a)];
                for (int i = 0; i < r.Length; i++)
                    r[i] = (double)(a++);
            }
            else
            {
                r = new double[(int)(a - b)];
                for (int i = 0; i < r.Length; i++)
                    r[i] = (double)(a-- - 1);
            }

            return r;
        }

        /// <summary>
        ///   Creates an interval vector.
        /// </summary>
        /// 
        public static double[] Range(double a, double b, double stepSize)
        {
            if (a == b)
                return new [] { a };

            double[] r;

            if (b > a)
            {
                int steps = (int)System.Math.Ceiling((b - a) / (double)stepSize);
                r = new double[steps];
                for (uint i = 0; i < r.Length; i++)
                    r[i] = (double)(a +  i * stepSize);
                r[steps - 1] = (double)(b);
            }
            else
            {
                int steps = (int)System.Math.Ceiling((a - b) / (double)stepSize);
                r = new double[steps];
                for (uint i = 0; i < r.Length; i++)
                    r[i] = (double)(a - i * stepSize);
                r[steps - 1] = (double)(b);
            }

            return r;
        }




		/// <summary>
        ///   Creates a range enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<double> EnumerableRange(double n)
        {
            for (double i = 0; i < n; i++)
                yield return (double)i;
        }

        /// <summary>
        ///   Creates a range enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<double> EnumerableRange(double a, double b)
        {
            if (a == b)
                yield return a;

            if (b > a)
            {
                int n = (int)(b - a);
                for (int i = 0; i < n; i++)
                    yield return (double)(a++);
            }
            else
            {
                int n = (int)(a - b);
                for (int i = 0; i < n; i++)
                    yield return (double)(a-- - 1);
            }
        }

        /// <summary>
        ///   Creates an interval enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<double> EnumerableRange(double a, double b, double stepSize)
        {
            if (a == b)
                yield return a;

            if (b > a)
            {
                int steps = (int)System.Math.Ceiling((b - a) / (double)stepSize);
                for (uint i = 0; i < steps; i++)
                    yield return (double)(a +  i * stepSize);
                yield return (double)(b);
            }
            else
            {
                int steps = (int)System.Math.Ceiling((a - b) / (double)stepSize);
                for (uint i = 0; i < steps; i++)
                    yield return (double)(a - i * stepSize);
                yield return (double)(b);
            }
        }

        /// <summary>
        ///   Creates a range vector.
        /// </summary>
        /// 
        public static short[] Range(short n)
        {
            short[] r = new short[(int)n]; 
            for (int i = 0; i < r.Length; i++)
                r[i] = (short)i;
            return r;
        }

        /// <summary>
        ///   Creates a range vector.
        /// </summary>
        /// 
        public static short[] Range(short a, short b)
        {
            if (a == b)
                return new [] { a };

            short[] r;

            if (b > a)
            {
                r = new short[(int)(b - a)];
                for (int i = 0; i < r.Length; i++)
                    r[i] = (short)(a++);
            }
            else
            {
                r = new short[(int)(a - b)];
                for (int i = 0; i < r.Length; i++)
                    r[i] = (short)(a-- - 1);
            }

            return r;
        }

        /// <summary>
        ///   Creates an interval vector.
        /// </summary>
        /// 
        public static short[] Range(short a, short b, short stepSize)
        {
            if (a == b)
                return new [] { a };

            short[] r;

            if (b > a)
            {
                int steps = (int)System.Math.Ceiling((b - a) / (double)stepSize);
                r = new short[steps];
                for (uint i = 0; i < r.Length; i++)
                    r[i] = (short)(a +  i * stepSize);
                r[steps - 1] = (short)(b);
            }
            else
            {
                int steps = (int)System.Math.Ceiling((a - b) / (double)stepSize);
                r = new short[steps];
                for (uint i = 0; i < r.Length; i++)
                    r[i] = (short)(a - i * stepSize);
                r[steps - 1] = (short)(b);
            }

            return r;
        }




		/// <summary>
        ///   Creates a range enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<short> EnumerableRange(short n)
        {
            for (short i = 0; i < n; i++)
                yield return (short)i;
        }

        /// <summary>
        ///   Creates a range enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<short> EnumerableRange(short a, short b)
        {
            if (a == b)
                yield return a;

            if (b > a)
            {
                int n = (int)(b - a);
                for (int i = 0; i < n; i++)
                    yield return (short)(a++);
            }
            else
            {
                int n = (int)(a - b);
                for (int i = 0; i < n; i++)
                    yield return (short)(a-- - 1);
            }
        }

        /// <summary>
        ///   Creates an interval enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<short> EnumerableRange(short a, short b, short stepSize)
        {
            if (a == b)
                yield return a;

            if (b > a)
            {
                int steps = (int)System.Math.Ceiling((b - a) / (double)stepSize);
                for (uint i = 0; i < steps; i++)
                    yield return (short)(a +  i * stepSize);
                yield return (short)(b);
            }
            else
            {
                int steps = (int)System.Math.Ceiling((a - b) / (double)stepSize);
                for (uint i = 0; i < steps; i++)
                    yield return (short)(a - i * stepSize);
                yield return (short)(b);
            }
        }

        /// <summary>
        ///   Creates a range vector.
        /// </summary>
        /// 
        public static byte[] Range(byte n)
        {
            byte[] r = new byte[(int)n]; 
            for (int i = 0; i < r.Length; i++)
                r[i] = (byte)i;
            return r;
        }

        /// <summary>
        ///   Creates a range vector.
        /// </summary>
        /// 
        public static byte[] Range(byte a, byte b)
        {
            if (a == b)
                return new [] { a };

            byte[] r;

            if (b > a)
            {
                r = new byte[(int)(b - a)];
                for (int i = 0; i < r.Length; i++)
                    r[i] = (byte)(a++);
            }
            else
            {
                r = new byte[(int)(a - b)];
                for (int i = 0; i < r.Length; i++)
                    r[i] = (byte)(a-- - 1);
            }

            return r;
        }

        /// <summary>
        ///   Creates an interval vector.
        /// </summary>
        /// 
        public static byte[] Range(byte a, byte b, byte stepSize)
        {
            if (a == b)
                return new [] { a };

            byte[] r;

            if (b > a)
            {
                int steps = (int)System.Math.Ceiling((b - a) / (double)stepSize);
                r = new byte[steps];
                for (uint i = 0; i < r.Length; i++)
                    r[i] = (byte)(a +  i * stepSize);
                r[steps - 1] = (byte)(b);
            }
            else
            {
                int steps = (int)System.Math.Ceiling((a - b) / (double)stepSize);
                r = new byte[steps];
                for (uint i = 0; i < r.Length; i++)
                    r[i] = (byte)(a - i * stepSize);
                r[steps - 1] = (byte)(b);
            }

            return r;
        }




		/// <summary>
        ///   Creates a range enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<byte> EnumerableRange(byte n)
        {
            for (byte i = 0; i < n; i++)
                yield return (byte)i;
        }

        /// <summary>
        ///   Creates a range enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<byte> EnumerableRange(byte a, byte b)
        {
            if (a == b)
                yield return a;

            if (b > a)
            {
                int n = (int)(b - a);
                for (int i = 0; i < n; i++)
                    yield return (byte)(a++);
            }
            else
            {
                int n = (int)(a - b);
                for (int i = 0; i < n; i++)
                    yield return (byte)(a-- - 1);
            }
        }

        /// <summary>
        ///   Creates an interval enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<byte> EnumerableRange(byte a, byte b, byte stepSize)
        {
            if (a == b)
                yield return a;

            if (b > a)
            {
                int steps = (int)System.Math.Ceiling((b - a) / (double)stepSize);
                for (uint i = 0; i < steps; i++)
                    yield return (byte)(a +  i * stepSize);
                yield return (byte)(b);
            }
            else
            {
                int steps = (int)System.Math.Ceiling((a - b) / (double)stepSize);
                for (uint i = 0; i < steps; i++)
                    yield return (byte)(a - i * stepSize);
                yield return (byte)(b);
            }
        }

        /// <summary>
        ///   Creates a range vector.
        /// </summary>
        /// 
        public static sbyte[] Range(sbyte n)
        {
            sbyte[] r = new sbyte[(int)n]; 
            for (int i = 0; i < r.Length; i++)
                r[i] = (sbyte)i;
            return r;
        }

        /// <summary>
        ///   Creates a range vector.
        /// </summary>
        /// 
        public static sbyte[] Range(sbyte a, sbyte b)
        {
            if (a == b)
                return new [] { a };

            sbyte[] r;

            if (b > a)
            {
                r = new sbyte[(int)(b - a)];
                for (int i = 0; i < r.Length; i++)
                    r[i] = (sbyte)(a++);
            }
            else
            {
                r = new sbyte[(int)(a - b)];
                for (int i = 0; i < r.Length; i++)
                    r[i] = (sbyte)(a-- - 1);
            }

            return r;
        }

        /// <summary>
        ///   Creates an interval vector.
        /// </summary>
        /// 
        public static sbyte[] Range(sbyte a, sbyte b, sbyte stepSize)
        {
            if (a == b)
                return new [] { a };

            sbyte[] r;

            if (b > a)
            {
                int steps = (int)System.Math.Ceiling((b - a) / (double)stepSize);
                r = new sbyte[steps];
                for (uint i = 0; i < r.Length; i++)
                    r[i] = (sbyte)(a +  i * stepSize);
                r[steps - 1] = (sbyte)(b);
            }
            else
            {
                int steps = (int)System.Math.Ceiling((a - b) / (double)stepSize);
                r = new sbyte[steps];
                for (uint i = 0; i < r.Length; i++)
                    r[i] = (sbyte)(a - i * stepSize);
                r[steps - 1] = (sbyte)(b);
            }

            return r;
        }




		/// <summary>
        ///   Creates a range enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<sbyte> EnumerableRange(sbyte n)
        {
            for (sbyte i = 0; i < n; i++)
                yield return (sbyte)i;
        }

        /// <summary>
        ///   Creates a range enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<sbyte> EnumerableRange(sbyte a, sbyte b)
        {
            if (a == b)
                yield return a;

            if (b > a)
            {
                int n = (int)(b - a);
                for (int i = 0; i < n; i++)
                    yield return (sbyte)(a++);
            }
            else
            {
                int n = (int)(a - b);
                for (int i = 0; i < n; i++)
                    yield return (sbyte)(a-- - 1);
            }
        }

        /// <summary>
        ///   Creates an interval enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<sbyte> EnumerableRange(sbyte a, sbyte b, sbyte stepSize)
        {
            if (a == b)
                yield return a;

            if (b > a)
            {
                int steps = (int)System.Math.Ceiling((b - a) / (double)stepSize);
                for (uint i = 0; i < steps; i++)
                    yield return (sbyte)(a +  i * stepSize);
                yield return (sbyte)(b);
            }
            else
            {
                int steps = (int)System.Math.Ceiling((a - b) / (double)stepSize);
                for (uint i = 0; i < steps; i++)
                    yield return (sbyte)(a - i * stepSize);
                yield return (sbyte)(b);
            }
        }

        /// <summary>
        ///   Creates a range vector.
        /// </summary>
        /// 
        public static long[] Range(long n)
        {
            long[] r = new long[(int)n]; 
            for (int i = 0; i < r.Length; i++)
                r[i] = (long)i;
            return r;
        }

        /// <summary>
        ///   Creates a range vector.
        /// </summary>
        /// 
        public static long[] Range(long a, long b)
        {
            if (a == b)
                return new [] { a };

            long[] r;

            if (b > a)
            {
                r = new long[(int)(b - a)];
                for (int i = 0; i < r.Length; i++)
                    r[i] = (long)(a++);
            }
            else
            {
                r = new long[(int)(a - b)];
                for (int i = 0; i < r.Length; i++)
                    r[i] = (long)(a-- - 1);
            }

            return r;
        }

        /// <summary>
        ///   Creates an interval vector.
        /// </summary>
        /// 
        public static long[] Range(long a, long b, long stepSize)
        {
            if (a == b)
                return new [] { a };

            long[] r;

            if (b > a)
            {
                int steps = (int)System.Math.Ceiling((b - a) / (double)stepSize);
                r = new long[steps];
                for (uint i = 0; i < r.Length; i++)
                    r[i] = (long)(a +  i * stepSize);
                r[steps - 1] = (long)(b);
            }
            else
            {
                int steps = (int)System.Math.Ceiling((a - b) / (double)stepSize);
                r = new long[steps];
                for (uint i = 0; i < r.Length; i++)
                    r[i] = (long)(a - i * stepSize);
                r[steps - 1] = (long)(b);
            }

            return r;
        }




		/// <summary>
        ///   Creates a range enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<long> EnumerableRange(long n)
        {
            for (long i = 0; i < n; i++)
                yield return (long)i;
        }

        /// <summary>
        ///   Creates a range enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<long> EnumerableRange(long a, long b)
        {
            if (a == b)
                yield return a;

            if (b > a)
            {
                int n = (int)(b - a);
                for (int i = 0; i < n; i++)
                    yield return (long)(a++);
            }
            else
            {
                int n = (int)(a - b);
                for (int i = 0; i < n; i++)
                    yield return (long)(a-- - 1);
            }
        }

        /// <summary>
        ///   Creates an interval enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<long> EnumerableRange(long a, long b, long stepSize)
        {
            if (a == b)
                yield return a;

            if (b > a)
            {
                int steps = (int)System.Math.Ceiling((b - a) / (double)stepSize);
                for (uint i = 0; i < steps; i++)
                    yield return (long)(a +  i * stepSize);
                yield return (long)(b);
            }
            else
            {
                int steps = (int)System.Math.Ceiling((a - b) / (double)stepSize);
                for (uint i = 0; i < steps; i++)
                    yield return (long)(a - i * stepSize);
                yield return (long)(b);
            }
        }

        /// <summary>
        ///   Creates a range vector.
        /// </summary>
        /// 
        public static decimal[] Range(decimal n)
        {
            decimal[] r = new decimal[(int)n]; 
            for (int i = 0; i < r.Length; i++)
                r[i] = (decimal)i;
            return r;
        }

        /// <summary>
        ///   Creates a range vector.
        /// </summary>
        /// 
        public static decimal[] Range(decimal a, decimal b)
        {
            if (a == b)
                return new [] { a };

            decimal[] r;

            if (b > a)
            {
                r = new decimal[(int)(b - a)];
                for (int i = 0; i < r.Length; i++)
                    r[i] = (decimal)(a++);
            }
            else
            {
                r = new decimal[(int)(a - b)];
                for (int i = 0; i < r.Length; i++)
                    r[i] = (decimal)(a-- - 1);
            }

            return r;
        }

        /// <summary>
        ///   Creates an interval vector.
        /// </summary>
        /// 
        public static decimal[] Range(decimal a, decimal b, decimal stepSize)
        {
            if (a == b)
                return new [] { a };

            decimal[] r;

            if (b > a)
            {
                int steps = (int)System.Math.Ceiling((b - a) / (decimal)stepSize);
                r = new decimal[steps];
                for (uint i = 0; i < r.Length; i++)
                    r[i] = (decimal)(a +  i * stepSize);
                r[steps - 1] = (decimal)(b);
            }
            else
            {
                int steps = (int)System.Math.Ceiling((a - b) / (decimal)stepSize);
                r = new decimal[steps];
                for (uint i = 0; i < r.Length; i++)
                    r[i] = (decimal)(a - i * stepSize);
                r[steps - 1] = (decimal)(b);
            }

            return r;
        }




		/// <summary>
        ///   Creates a range enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<decimal> EnumerableRange(decimal n)
        {
            for (decimal i = 0; i < n; i++)
                yield return (decimal)i;
        }

        /// <summary>
        ///   Creates a range enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<decimal> EnumerableRange(decimal a, decimal b)
        {
            if (a == b)
                yield return a;

            if (b > a)
            {
                int n = (int)(b - a);
                for (int i = 0; i < n; i++)
                    yield return (decimal)(a++);
            }
            else
            {
                int n = (int)(a - b);
                for (int i = 0; i < n; i++)
                    yield return (decimal)(a-- - 1);
            }
        }

        /// <summary>
        ///   Creates an interval enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<decimal> EnumerableRange(decimal a, decimal b, decimal stepSize)
        {
            if (a == b)
                yield return a;

            if (b > a)
            {
                int steps = (int)System.Math.Ceiling((b - a) / (decimal)stepSize);
                for (uint i = 0; i < steps; i++)
                    yield return (decimal)(a +  i * stepSize);
                yield return (decimal)(b);
            }
            else
            {
                int steps = (int)System.Math.Ceiling((a - b) / (decimal)stepSize);
                for (uint i = 0; i < steps; i++)
                    yield return (decimal)(a - i * stepSize);
                yield return (decimal)(b);
            }
        }

        /// <summary>
        ///   Creates a range vector.
        /// </summary>
        /// 
        public static ulong[] Range(ulong n)
        {
            ulong[] r = new ulong[(int)n]; 
            for (int i = 0; i < r.Length; i++)
                r[i] = (ulong)i;
            return r;
        }

        /// <summary>
        ///   Creates a range vector.
        /// </summary>
        /// 
        public static ulong[] Range(ulong a, ulong b)
        {
            if (a == b)
                return new [] { a };

            ulong[] r;

            if (b > a)
            {
                r = new ulong[(int)(b - a)];
                for (int i = 0; i < r.Length; i++)
                    r[i] = (ulong)(a++);
            }
            else
            {
                r = new ulong[(int)(a - b)];
                for (int i = 0; i < r.Length; i++)
                    r[i] = (ulong)(a-- - 1);
            }

            return r;
        }

        /// <summary>
        ///   Creates an interval vector.
        /// </summary>
        /// 
        public static ulong[] Range(ulong a, ulong b, ulong stepSize)
        {
            if (a == b)
                return new [] { a };

            ulong[] r;

            if (b > a)
            {
                int steps = (int)System.Math.Ceiling((b - a) / (double)stepSize);
                r = new ulong[steps];
                for (uint i = 0; i < r.Length; i++)
                    r[i] = (ulong)(a +  i * stepSize);
                r[steps - 1] = (ulong)(b);
            }
            else
            {
                int steps = (int)System.Math.Ceiling((a - b) / (double)stepSize);
                r = new ulong[steps];
                for (uint i = 0; i < r.Length; i++)
                    r[i] = (ulong)(a - i * stepSize);
                r[steps - 1] = (ulong)(b);
            }

            return r;
        }




		/// <summary>
        ///   Creates a range enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<ulong> EnumerableRange(ulong n)
        {
            for (ulong i = 0; i < n; i++)
                yield return (ulong)i;
        }

        /// <summary>
        ///   Creates a range enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<ulong> EnumerableRange(ulong a, ulong b)
        {
            if (a == b)
                yield return a;

            if (b > a)
            {
                int n = (int)(b - a);
                for (int i = 0; i < n; i++)
                    yield return (ulong)(a++);
            }
            else
            {
                int n = (int)(a - b);
                for (int i = 0; i < n; i++)
                    yield return (ulong)(a-- - 1);
            }
        }

        /// <summary>
        ///   Creates an interval enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<ulong> EnumerableRange(ulong a, ulong b, ulong stepSize)
        {
            if (a == b)
                yield return a;

            if (b > a)
            {
                int steps = (int)System.Math.Ceiling((b - a) / (double)stepSize);
                for (uint i = 0; i < steps; i++)
                    yield return (ulong)(a +  i * stepSize);
                yield return (ulong)(b);
            }
            else
            {
                int steps = (int)System.Math.Ceiling((a - b) / (double)stepSize);
                for (uint i = 0; i < steps; i++)
                    yield return (ulong)(a - i * stepSize);
                yield return (ulong)(b);
            }
        }

        /// <summary>
        ///   Creates a range vector.
        /// </summary>
        /// 
        public static ushort[] Range(ushort n)
        {
            ushort[] r = new ushort[(int)n]; 
            for (int i = 0; i < r.Length; i++)
                r[i] = (ushort)i;
            return r;
        }

        /// <summary>
        ///   Creates a range vector.
        /// </summary>
        /// 
        public static ushort[] Range(ushort a, ushort b)
        {
            if (a == b)
                return new [] { a };

            ushort[] r;

            if (b > a)
            {
                r = new ushort[(int)(b - a)];
                for (int i = 0; i < r.Length; i++)
                    r[i] = (ushort)(a++);
            }
            else
            {
                r = new ushort[(int)(a - b)];
                for (int i = 0; i < r.Length; i++)
                    r[i] = (ushort)(a-- - 1);
            }

            return r;
        }

        /// <summary>
        ///   Creates an interval vector.
        /// </summary>
        /// 
        public static ushort[] Range(ushort a, ushort b, ushort stepSize)
        {
            if (a == b)
                return new [] { a };

            ushort[] r;

            if (b > a)
            {
                int steps = (int)System.Math.Ceiling((b - a) / (double)stepSize);
                r = new ushort[steps];
                for (uint i = 0; i < r.Length; i++)
                    r[i] = (ushort)(a +  i * stepSize);
                r[steps - 1] = (ushort)(b);
            }
            else
            {
                int steps = (int)System.Math.Ceiling((a - b) / (double)stepSize);
                r = new ushort[steps];
                for (uint i = 0; i < r.Length; i++)
                    r[i] = (ushort)(a - i * stepSize);
                r[steps - 1] = (ushort)(b);
            }

            return r;
        }




		/// <summary>
        ///   Creates a range enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<ushort> EnumerableRange(ushort n)
        {
            for (ushort i = 0; i < n; i++)
                yield return (ushort)i;
        }

        /// <summary>
        ///   Creates a range enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<ushort> EnumerableRange(ushort a, ushort b)
        {
            if (a == b)
                yield return a;

            if (b > a)
            {
                int n = (int)(b - a);
                for (int i = 0; i < n; i++)
                    yield return (ushort)(a++);
            }
            else
            {
                int n = (int)(a - b);
                for (int i = 0; i < n; i++)
                    yield return (ushort)(a-- - 1);
            }
        }

        /// <summary>
        ///   Creates an interval enumeration (similar to NumPy's xrange).
        /// </summary>
        /// 
        public static IEnumerable<ushort> EnumerableRange(ushort a, ushort b, ushort stepSize)
        {
            if (a == b)
                yield return a;

            if (b > a)
            {
                int steps = (int)System.Math.Ceiling((b - a) / (double)stepSize);
                for (uint i = 0; i < steps; i++)
                    yield return (ushort)(a +  i * stepSize);
                yield return (ushort)(b);
            }
            else
            {
                int steps = (int)System.Math.Ceiling((a - b) / (double)stepSize);
                for (uint i = 0; i < steps; i++)
                    yield return (ushort)(a - i * stepSize);
                yield return (ushort)(b);
            }
        }

        /// <summary>
        ///   Creates an interval vector.
        /// </summary>
        /// 
        public static double[] Range(this DoubleRange range)
        {
            return Range(range.Min, range.Max);
        }

        /// <summary>
        ///   Creates an interval vector.
        /// </summary>
        /// 
        public static double[] Range(this DoubleRange range, double stepSize)
        {
            return Range(range.Min, range.Max, stepSize);
        }

        /// <summary>
        ///   Creates an interval vector.
        /// </summary>
        /// 
        public static float[] Range(this Range range)
        {
            return Range(range.Min, range.Max);
        }

        /// <summary>
        ///   Creates an interval vector.
        /// </summary>
        /// 
        public static float[] Range(this Range range, float stepSize)
        {
            return Range(range.Min, range.Max, stepSize);
        }

        /// <summary>
        ///   Creates an interval vector.
        /// </summary>
        /// 
        public static byte[] Range(this ByteRange range)
        {
            return Range(range.Min, range.Max);
        }

        /// <summary>
        ///   Creates an interval vector.
        /// </summary>
        /// 
        public static byte[] Range(this ByteRange range, byte stepSize)
        {
            return Range(range.Min, range.Max, stepSize);
        }

        /// <summary>
        ///   Creates an interval vector.
        /// </summary>
        /// 
        public static int[] Range(this IntRange range)
        {
            return Range(range.Min, range.Max);
        }

        /// <summary>
        ///   Creates an interval vector.
        /// </summary>
        /// 
        public static int[] Range(this IntRange range, double stepSize)
        {
            return Range(range.Min, range.Max, stepSize);
        }
    }
}