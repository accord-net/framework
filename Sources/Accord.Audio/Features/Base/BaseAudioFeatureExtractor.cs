// Accord Audio Library
// The Accord.NET Framework
// http://accord-framework.net
//
// Copyright © César Souza, 2009-2017
// cesarsouza at gmail.com
//
//    This library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    This library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with this library; if not, write to the Free Software
//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
//

namespace Accord.Audio
{
    using Accord.Compat;
    using Accord.MachineLearning;
    using System;
    using System.Collections.Generic;

    /// <summary>
    ///   Base class for signal feature extractors that implement the <see cref="IAudioFeatureExtractor{TPoint}"/> interface.
    /// </summary>
    /// 
    /// <typeparam name="TFeature">The type of the extracted features (e.g. <see cref="MelFrequencyCepstrumCoefficientDescriptor"/>.</typeparam>
    /// 
    /// <seealso cref="IAudioFeatureExtractor{TPoint}" />
    /// 
    [Serializable]
    public abstract class BaseAudioFeatureExtractor<TFeature> : IAudioFeatureExtractor<TFeature>, IDisposable, ICloneable
    {
        /// <summary>
        ///   Gets the list of signal sample formats that are supported by 
        ///   this extractor. The extractor will check whether the sample
        ///   format of any provided signals are in this list to determine
        ///   whether the signal can be processed or not.
        /// </summary>
        /// 
        public ISet<SampleFormat> SupportedFormats { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="BaseAudioFeatureExtractor{TPoint}"/> class.
        /// </summary>
        public BaseAudioFeatureExtractor()
        {
            this.SupportedFormats = new HashSet<SampleFormat>();
        }

        /// <summary>
        /// Returns -1.
        /// </summary>
        /// 
        public int NumberOfInputs
        {
            get { return -1; }
        }

        /// <summary>
        ///   Gets the dimensionality of the features generated by this extractor.
        /// </summary>
        /// 
        public int NumberOfOutputs
        {
            get;  protected set;
        }

        /// <summary>
        ///   Applies the transformation to an input, producing an associated output.
        /// </summary>
        /// 
        /// <param name="input">The input data to which the transformation should be applied.</param>
        /// 
        /// <returns>The output generated by applying this transformation to the given input.</returns>
        /// 
        public IEnumerable<TFeature> Transform(Signal input)
        {
            // check image format
            if (!SupportedFormats.Contains(input.SampleFormat))
                throw new UnsupportedSampleFormatException("Unsupported pixel format of the source image.");

            return InnerTransform(input);
        }

        /// <summary>
        ///   Applies the transformation to an input, producing an associated output.
        /// </summary>
        /// 
        /// <param name="input">The input data to which the transformation should be applied.</param>
        /// 
        /// <returns>The output generated by applying this transformation to the given input.</returns>
        /// 
        public IEnumerable<TFeature>[] Transform(Signal[] input)
        {
            return Transform(input, new IList<TFeature>[input.Length]);
        }

        /// <summary>
        ///   Applies the transformation to a set of input vectors,
        ///   producing an associated set of output vectors.
        /// </summary>
        /// 
        /// <param name="input">The input data to which
        ///   the transformation should be applied.</param>
        /// <param name="result">The location to where to store the
        ///   result of this transformation.</param>
        /// 
        /// <returns>The output generated by applying this
        ///   transformation to the given input.</returns>
        /// 
        public IEnumerable<TFeature>[] Transform(Signal[] input, IEnumerable<TFeature>[] result)
        {
            for (int i = 0; i < input.Length; i++)
                result[i] = Transform(input[i]);
            return result;
        }

        /// <summary>
        ///   This method should be implemented by inheriting classes to implement the 
        ///   actual feature extraction, transforming the input image into a list of features.
        /// </summary>
        /// 
        protected abstract IList<TFeature> InnerTransform(Signal input);


        /// <summary>
        /// Creates a new object that is a copy of the current instance.
        /// </summary>
        /// 
        public abstract object Clone();


        #region IDisposable Support
        private bool disposedValue = false; // To detect redundant calls

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources.
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (!disposedValue)
            {
                if (disposing)
                {
                    // TODO: dispose managed state (managed objects).
                }

                // TODO: free unmanaged resources (unmanaged objects) and override a finalizer below.
                // TODO: set large fields to null.

                disposedValue = true;
            }
        }

        // TODO: override a finalizer only if Dispose(bool disposing) above has code to free unmanaged resources.
        // ~BaseFeatureDetector() {
        //   // Do not change this code. Put cleanup code in Dispose(bool disposing) above.
        //   Dispose(false);
        // }

        // This code added to correctly implement the disposable pattern.

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            // Do not change this code. Put cleanup code in Dispose(bool disposing) above.
            Dispose(true);
            // TODO: uncomment the following line if the finalizer is overridden above.
            // GC.SuppressFinalize(this);
        }
        #endregion

        int ITransform.NumberOfInputs
        {
            get { return NumberOfInputs; }
            set { throw new InvalidOperationException("This property is read-only."); }
        }

        int ITransform.NumberOfOutputs
        {
            get { return NumberOfOutputs; }
            set { throw new InvalidOperationException("This property is read-only."); }
        }
    }
}